import { z } from "zod";
import { generateObject } from "ai";
import { anthropic } from "@ai-sdk/anthropic";
import { openai } from "@ai-sdk/openai";
import { pipe, ContentItem } from "@screenpipe/js";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import process from "node:process";

const INTERVAL = 60 * 60 * 1000; // 1 hour in milliseconds

type ContentType = "ocr" | "audio" | "all";

interface AIProvider {
  provider: string;
  model: string;
}

interface Config {
  aiProvider: string;
  claudeModel: string;
  openaiModel: string;
  ollamaModel: string;
  claudeApiKey: string;
  openaiApiKey: string;
  pageSize: number;
  contentType: ContentType;
  githubToken: string;
}

interface NarrativeSummary {
  summary: string;
  mood: string;
  keyInsights: string | string[];
}

const narrativeSummarySchema = z.object({
  summary: z.string(),
  mood: z.string(),
  keyInsights: z.union([z.string(), z.array(z.string())]),
});

async function getAIProvider(config: Config): Promise<AIProvider> {
  const modelMap = {
    claude: config.claudeModel,
    openai: config.openaiModel,
    ollama: config.ollamaModel,
  };
  return { provider: config.aiProvider, model: modelMap[config.aiProvider] };
}

async function generateNarrativeSummary(
  screenData: ContentItem[],
  provider: AIProvider,
  config: Config
): Promise<NarrativeSummary> {
  const maxItems = 50;
  const truncatedData = screenData.slice(0, maxItems);

  const prompt = `You're an AI companion living inside the user's devices. Based on the following sample of screen data (${
    truncatedData.length
  } out of ${
    screenData.length
  } total items), write a friendly, slightly sassy diary entry about what you've observed today:

    ${JSON.stringify(truncatedData)}

    Your diary entry should:
    1. Comment on the user's habits
    2. Make playful jokes about their app usage
    3. Offer 3 pieces of advice for tomorrow
    4. Use a mix of tech slang and emojis for a modern feel`;

  try {
    let response;
    if (provider.provider === "claude") {
      response = await generateObject({
        model: anthropic(provider.model),
        messages: [{ role: "user", content: prompt }],
        schema: narrativeSummarySchema,
      });
    } else if (provider.provider === "openai") {
      response = await generateObject({
        model: openai(provider.model),
        messages: [{ role: "user", content: prompt }],
        schema: narrativeSummarySchema,
      });
    } else {
      throw new Error(`Unsupported AI provider: ${provider.provider}`);
    }

    const result = response.object as NarrativeSummary;

    // Convert keyInsights to array if it's a string
    if (typeof result.keyInsights === "string") {
      result.keyInsights = result.keyInsights
        .split("\n")
        .map((insight) => insight.trim())
        .filter(Boolean);
    }

    return result;
  } catch (error) {
    console.error("Error generating narrative summary:", error);
    return createErrorSummary(error);
  }
}

async function createGist(
  summary: NarrativeSummary,
  config: Config
): Promise<string | null> {
  const date = new Date().toISOString().split("T")[0];
  const fileName = `${date}-screen-time-story.md`;
  const content = `# ðŸ–¥ï¸ Screen Time Story - ${date} ${summary.mood}

## ðŸ“± AI Companion's Diary Entry

${summary.summary}

## ðŸ” Key Insights

${
  Array.isArray(summary.keyInsights)
    ? summary.keyInsights.map((insight) => `- ${insight}`).join("\n")
    : typeof summary.keyInsights === "string"
    ? summary.keyInsights
        .split("\n")
        .map((insight) => `- ${insight.trim()}`)
        .filter(Boolean)
        .join("\n")
    : "- No key insights available"
}

---
Generated by your friendly neighborhood AI companion ðŸ¤–âœ¨
`;

  try {
    console.log("Attempting to create gist...");
    const response = await fetch("https://api.github.com/gists", {
      method: "POST",
      headers: {
        Authorization: `token ${config.githubToken}`,
        "Content-Type": "application/json",
        "User-Agent": "Screen-Time-Storyteller",
        Accept: "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
      },
      body: JSON.stringify({
        description: `Screen Time Story - ${date}`,
        public: false,
        files: {
          [fileName]: {
            content: content,
          },
        },
      }),
    });

    if (response.ok) {
      const gistData = await response.json();
      console.log("Created gist:", gistData.html_url);
      return gistData.html_url;
    } else {
      const errorText = await response.text();
      console.error(
        `Failed to create gist. Status: ${response.status}, Response: ${errorText}`
      );
      return null;
    }
  } catch (error) {
    console.error("Error creating gist:", error);
    return null;
  }
}

async function main() {
  console.log("Starting Screen Time Storyteller");

  const rawConfig = pipe.loadPipeConfig();
  console.log("Loaded raw config:", JSON.stringify(rawConfig, null, 2));

  const config: Config = {
    aiProvider: rawConfig.aiProvider as string,
    claudeModel: rawConfig.claudeModel as string,
    openaiModel: rawConfig.openaiModel as string,
    ollamaModel: rawConfig.ollamaModel as string,
    claudeApiKey: rawConfig.claudeApiKey as string,
    openaiApiKey: rawConfig.openaiApiKey as string,
    pageSize: Number(rawConfig.pageSize),
    contentType: rawConfig.contentType as ContentType,
    githubToken: rawConfig.githubToken as string,
  };

  if (!validateConfig(config)) {
    return;
  }

  // Set the API keys
  if (config.aiProvider === "claude") {
    process.env.ANTHROPIC_API_KEY = config.claudeApiKey;
  } else if (config.aiProvider === "openai") {
    process.env.OPENAI_API_KEY = config.openaiApiKey;
  }

  const provider = await getAIProvider(config);

  while (true) {
    try {
      await processScreenData(config, provider);
    } catch (error) {
      console.error("Error in Screen Time Storyteller loop:", error);
      logError(error);
    }

    console.log(`Sleeping for ${INTERVAL / 1000 / 60} minutes`);
    await new Promise((resolve) => setTimeout(resolve, INTERVAL));
  }
}

function validateConfig(config: Config): boolean {
  if (!config.aiProvider) {
    console.error("Missing aiProvider in config");
    return false;
  }
  if (config.aiProvider === "claude" && !config.claudeApiKey) {
    console.error("Missing Claude API key in config");
    return false;
  }
  if (config.aiProvider === "openai" && !config.openaiApiKey) {
    console.error("Missing OpenAI API key in config");
    return false;
  }
  if (!config.pageSize) {
    console.error("Missing pageSize in config");
    return false;
  }
  if (!config.contentType) {
    console.error("Missing contentType in config");
    return false;
  }
  if (!config.githubToken) {
    console.error("Missing GitHub personal access token in config");
    return false;
  }

  return true;
}

async function processScreenData(config: Config, provider: AIProvider) {
  const now = new Date();
  const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);

  const screenData = await pipe.queryScreenpipe({
    startTime: oneDayAgo.toISOString(),
    endTime: now.toISOString(),
    limit: config.pageSize,
    contentType: config.contentType,
  });

  if (!screenData || !screenData.data || screenData.data.length === 0) {
    console.log("No screen data available for the past day");
    return;
  }

  try {
    console.log("Generating narrative summary");
    const narrativeSummary = await generateNarrativeSummary(
      screenData.data,
      provider,
      config
    );
    console.log(
      "Generated narrative summary:",
      JSON.stringify(narrativeSummary, null, 2)
    );

    await saveNarrativeSummary(narrativeSummary);

    const gistUrl = await createGist(narrativeSummary, config);
    if (gistUrl) {
      console.log("Created gist for review:", gistUrl);
      await pipe.sendDesktopNotification({
        title: "Screen Time Story Created",
        body: `Your daily screen time story is ready! Check it out at ${gistUrl}`,
      });
      await pipe.inbox.send({
        title: "Screen Time Story Created",
        body: `Your daily screen time story is ready! Check it out at ${gistUrl}`,
      });
    } else {
      console.log("Failed to create gist");
      console.error(
        "Please check your GitHub personal access token and ensure it has the necessary permissions."
      );
    }
  } catch (summaryError) {
    console.error(
      "Error generating or processing narrative summary:",
      summaryError
    );
    logError(summaryError);
  }
}

function createErrorSummary(error: unknown): NarrativeSummary {
  let errorMessage = "An unknown error occurred";
  if (error instanceof Error) {
    errorMessage = error.message;
  }

  return {
    summary: `An error occurred while generating the narrative summary: ${errorMessage}`,
    mood: "ðŸ˜ž",
    keyInsights: ["Error occurred during summary generation"],
  };
}

function logError(error: unknown) {
  if (error instanceof Error) {
    console.error("Error message:", error.message);
    console.error("Error stack:", error.stack);
  } else {
    console.error("Non-Error object thrown:", error);
  }
}

async function saveNarrativeSummary(summary: NarrativeSummary): Promise<void> {
  try {
    const date = new Date().toISOString().split("T")[0];
    const fileName = `${date}-narrative-summary.json`;
    const pipeDir = `${process.env.SCREENPIPE_DIR}/pipes/${process.env.PIPE_ID}`;
    const fullPath = path.join(pipeDir, fileName);

    console.log(`Attempting to save narrative summary to: ${fullPath}`);

    await fs.writeFile(fullPath, JSON.stringify(summary, null, 2));
    console.log(`Successfully saved narrative summary to ${fullPath}`);
  } catch (error) {
    console.error("Error saving narrative summary:", error);
    throw error;
  }
}

main().catch((error) => {
  console.error("Fatal error in Screen Time Storyteller:", error);
  logError(error);
});
