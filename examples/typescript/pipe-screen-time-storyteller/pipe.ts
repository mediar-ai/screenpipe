import { z } from "zod";
import { generateText, generateObject } from "ai";
import { anthropic } from "@ai-sdk/anthropic";
import { openai } from "@ai-sdk/openai";
import { queryScreenpipe, loadPipeConfig, ContentItem, sendDesktopNotification } from "screenpipe";
import * as fs from "node:fs/promises";
import * as path from "node:path";

const INTERVAL = 60 * 60 * 1000; // 1 hour in milliseconds

type ContentType = "ocr" | "audio" | "all"; 

interface AIProvider {
    provider: string;
    model: string;
}

interface Config {
    aiProvider: string;
    claudeModel: string;
    openaiModel: string;
    ollamaModel: string;
    claudeApiKey: string;
    openaiApiKey: string;
    pageSize: number;
    contentType: ContentType;
    githubToken: string;
}

interface NarrativeSummary {
    summary: string;
    mood: string; 
    keyInsights: string | string[]; 
}

const narrativeSummarySchema = z.object({
    summary: z.string(),
    mood: z.string(),
    keyInsights: z.union([z.string(), z.array(z.string())])
});

async function getAIProvider(config: Config): Promise<AIProvider> {
    const modelMap = {
        claude: config.claudeModel,
        openai: config.openaiModel,
        ollama: config.ollamaModel
    };
    return { provider: config.aiProvider, model: modelMap[config.aiProvider] };
}

async function generateNarrativeSummary(screenData: ContentItem[], provider: AIProvider, config: Config): Promise<NarrativeSummary> {
    const maxItems = 50;
    const truncatedData = screenData.slice(0, maxItems);

    const prompt = `You're an AI companion living inside the user's devices. Based on the following sample of screen data (${truncatedData.length} out of ${screenData.length} total items), write a friendly, slightly sassy diary entry about what you've observed today:

    ${JSON.stringify(truncatedData)}

    Your diary entry should:
    1. Comment on the user's habits
    2. Make playful jokes about their app usage
    3. Offer 3 pieces of advice for tomorrow
    4. Use a mix of tech slang and emojis for a modern feel`;

    try {
        let response;
        if (provider.provider === 'claude') {
            response = await generateObject({
                model: anthropic(provider.model),
                messages: [{ role: "user", content: prompt }],
                schema: narrativeSummarySchema,
            });
        } else if (provider.provider === 'openai') {
            response = await generateObject({
                model: openai(provider.model),
                messages: [{ role: "user", content: prompt }],
                schema: narrativeSummarySchema,
            });
        } else {
            throw new Error(`Unsupported AI provider: ${provider.provider}`);
        }

        const result = response.object as NarrativeSummary;

        // Convert keyInsights to array if it's a string
        if (typeof result.keyInsights === 'string') {
            result.keyInsights = result.keyInsights.split('\n').map(insight => insight.trim()).filter(Boolean);
        }

        return result;
    } catch (error) {
        console.error("Error generating narrative summary:", error);
        return createErrorSummary(error);
    }
}

async function createGist(summary: NarrativeSummary, config: Config): Promise<string | null> {
    const date = new Date().toISOString().split('T')[0];
    const fileName = `${date}-screen-time-story.md`;
    const content = `# 🖥️ Screen Time Story - ${date} ${summary.mood}

## 📱 AI Companion's Diary Entry

${summary.summary}

## 🔍 Key Insights

${Array.isArray(summary.keyInsights) 
  ? summary.keyInsights.map(insight => `- ${insight}`).join('\n')
  : typeof summary.keyInsights === 'string'
    ? summary.keyInsights.split('\n').map(insight => `- ${insight.trim()}`).filter(Boolean).join('\n')
    : '- No key insights available'}

---
Generated by your friendly neighborhood AI companion 🤖✨
`;
    
    try {
        console.log("Attempting to create gist...");
        const response = await fetch('https://api.github.com/gists', {
            method: 'POST',
            headers: {
                'Authorization': `token ${config.githubToken}`,
                'Content-Type': 'application/json',
                'User-Agent': 'Screen-Time-Storyteller',
                'Accept': 'application/vnd.github+json',
                'X-GitHub-Api-Version': '2022-11-28'
            },
            body: JSON.stringify({
                description: `Screen Time Story - ${date}`,
                public: false,
                files: {
                    [fileName]: {
                        content: content
                    }
                }
            })
        });

        if (response.ok) {
            const gistData = await response.json();
            console.log("Created gist:", gistData.html_url);
            return gistData.html_url;
        } else {
            const errorText = await response.text();
            console.error(`Failed to create gist. Status: ${response.status}, Response: ${errorText}`);
            return null;
        }
    } catch (error) {
        console.error("Error creating gist:", error);
        return null;
    }
}

async function main() {
    console.log("Starting Screen Time Storyteller");
    
    const rawConfig = await loadPipeConfig();
    console.log("Loaded raw config:", JSON.stringify(rawConfig, null, 2));
    
    const config: Config = {
        aiProvider: rawConfig.aiProvider as string,
        claudeModel: rawConfig.claudeModel as string,
        openaiModel: rawConfig.openaiModel as string,
        ollamaModel: rawConfig.ollamaModel as string,
        claudeApiKey: rawConfig.claudeApiKey as string,
        openaiApiKey: rawConfig.openaiApiKey as string,
        pageSize: Number(rawConfig.pageSize),
        contentType: rawConfig.contentType as ContentType,
        githubToken: rawConfig.githubToken as string
    };
    
    if (!validateConfig(config)) {
        return;
    }

    // Set the API keys
    if (config.aiProvider === 'claude') {
        process.env.ANTHROPIC_API_KEY = config.claudeApiKey;
    } else if (config.aiProvider === 'openai') {
        process.env.OPENAI_API_KEY = config.openaiApiKey;
    }

    const provider = await getAIProvider(config);

    while (true) {
        try {
            await processScreenData(config, provider);
        } catch (error) {
            console.error("Error in Screen Time Storyteller loop:", error);
            logError(error);
        }

        console.log(`Sleeping for ${INTERVAL / 1000 / 60} minutes`);
        await new Promise(resolve => setTimeout(resolve, INTERVAL));
    }
}

function validateConfig(config: Config): boolean {
    if (!config.aiProvider) {
        console.error("Missing aiProvider in config");
        return false;
    }
    if (config.aiProvider === 'claude' && !config.claudeApiKey) {
        console.error("Missing Claude API key in config");
        return false;
    }
    if (config.aiProvider === 'openai' && !config.openaiApiKey) {
        console.error("Missing OpenAI API key in config");
        return false;
    }
    if (!config.pageSize) {
        console.error("Missing pageSize in config");
        return false;
    }
    if (!config.contentType) {
        console.error("Missing contentType in config");
        return false;
    }
    if (!config.githubToken) {
        console.error("Missing GitHub personal access token in config");
        return false;
    }
    
    return true;
}

async function processScreenData(config: Config, provider: AIProvider) {
    const now = new Date();
    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);

    const screenData = await queryScreenpipe({
        startTime: oneDayAgo.toISOString(),
        endTime: now.toISOString(),
        limit: config.pageSize,
        contentType: config.contentType,
    });

    if (!screenData || !screenData.data || screenData.data.length === 0) {
        console.log("No screen data available for the past day");
        return;
    }

    try {
        console.log("Generating narrative summary");
        const narrativeSummary = await generateNarrativeSummary(screenData.data, provider, config);
        console.log("Generated narrative summary:", JSON.stringify(narrativeSummary, null, 2));
        
        await saveNarrativeSummary(narrativeSummary);
        
        const gistUrl = await createGist(narrativeSummary, config);
        if (gistUrl) {
            console.log("Created gist for review:", gistUrl);
            await sendDesktopNotification({
                title: "Screen Time Story Created",
                body: `Your daily screen time story is ready! Check it out at ${gistUrl}`
            });
        } else {
            console.log("Failed to create gist");
            console.error("Please check your GitHub personal access token and ensure it has the necessary permissions.");
        }
    } catch (summaryError) {
        console.error("Error generating or processing narrative summary:", summaryError);
        logError(summaryError);
    }
}

function createErrorSummary(error: unknown): NarrativeSummary {
    let errorMessage = "An unknown error occurred";
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    
    return {
        summary: `An error occurred while generating the narrative summary: ${errorMessage}`,
        mood: "😞",
        keyInsights: ["Error occurred during summary generation"]
    };
}

function logError(error: unknown) {
    if (error instanceof Error) {
        console.error("Error message:", error.message);
        console.error("Error stack:", error.stack);
    } else {
        console.error("Non-Error object thrown:", error);
    }
}

async function saveNarrativeSummary(summary: NarrativeSummary): Promise<void> {
    try {
        const date = new Date().toISOString().split('T')[0];
        const fileName = `${date}-narrative-summary.json`;
        const pipeDir = `${process.env.SCREENPIPE_DIR}/pipes/${process.env.PIPE_ID}`;
        const fullPath = path.join(pipeDir, fileName);
        
        console.log(`Attempting to save narrative summary to: ${fullPath}`);
        
        await fs.writeFile(fullPath, JSON.stringify(summary, null, 2));
        console.log(`Successfully saved narrative summary to ${fullPath}`);
    } catch (error) {
        console.error("Error saving narrative summary:", error);
        throw error;
    }
}

main().catch(error => {
    console.error("Fatal error in Screen Time Storyteller:", error);
    logError(error);
});
