{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-health",
  "type": "registry:hook",
  "description": "check screenpipe's health",
  "dependencies": [
    "lodash",
    "@types/lodash"
  ],
  "files": [
    {
      "path": "./registry/hooks/use-health.ts",
      "content": "import { useState, useEffect, useCallback, useRef } from \"react\";\nimport { debounce } from \"lodash\";\n\ninterface HealthCheckResponse {\n  status: string;\n  status_code: number;\n  last_frame_timestamp: string | null;\n  last_audio_timestamp: string | null;\n  last_ui_timestamp: string | null;\n  frame_status: string;\n  audio_status: string;\n  ui_status: string;\n  message: string;\n}\n\nfunction isHealthChanged(\n  oldHealth: HealthCheckResponse | null,\n  newHealth: HealthCheckResponse\n): boolean {\n  if (!oldHealth) return true;\n  return (\n    oldHealth.status !== newHealth.status ||\n    oldHealth.status_code !== newHealth.status_code ||\n    oldHealth.last_frame_timestamp !== newHealth.last_frame_timestamp ||\n    oldHealth.last_audio_timestamp !== newHealth.last_audio_timestamp ||\n    oldHealth.last_ui_timestamp !== newHealth.last_ui_timestamp ||\n    oldHealth.frame_status !== newHealth.frame_status ||\n    oldHealth.audio_status !== newHealth.audio_status ||\n    oldHealth.ui_status !== newHealth.ui_status ||\n    oldHealth.message !== newHealth.message\n  );\n}\n\ninterface HealthCheckHook {\n  health: HealthCheckResponse | null;\n  isServerDown: boolean;\n  isLoading: boolean;\n  fetchHealth: () => Promise<void>;\n  debouncedFetchHealth: () => Promise<void>;\n}\n\nexport function useHealthCheck() {\n  const [health, setHealth] = useState<HealthCheckResponse | null>(null);\n  const [isServerDown, setIsServerDown] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const healthRef = useRef(health);\n\n  const fetchHealth = useCallback(async () => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n\n    abortControllerRef.current = new AbortController();\n\n    try {\n      setIsLoading(true);\n      const response = await fetch(\"http://localhost:3030/health\", {\n        cache: \"no-store\",\n        signal: abortControllerRef.current.signal,\n        headers: {\n          \"Cache-Control\": \"no-cache\",\n          Pragma: \"no-cache\",\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data: HealthCheckResponse = await response.json();\n\n      // if (data.status == \"unhealthy\") {\n      //   try {\n      //     await invoke(\"set_tray_unhealth_icon\");\n      //   } catch (error) {\n      //     console.error(\"set unhealthy icon:\", error);\n      //   }\n      // } else {\n      //   await invoke(\"set_tray_health_icon\");\n      //   console.log(\"set healthy icon:\");\n      // }\n\n      if (isHealthChanged(healthRef.current, data)) {\n        setHealth(data);\n        healthRef.current = data;\n      }\n\n      setIsServerDown(false);\n    } catch (error) {\n      if (error instanceof Error && error.name === \"AbortError\") {\n        return;\n      }\n\n      // console.error(\"Health check error:\", error);\n      if (!isServerDown) {\n        setIsServerDown(true);\n        // await invoke(\"set_tray_unhealth_icon\");\n        const errorHealth: HealthCheckResponse = {\n          last_frame_timestamp: null,\n          last_audio_timestamp: null,\n          last_ui_timestamp: null,\n          frame_status: \"error\",\n          audio_status: \"error\",\n          ui_status: \"error\",\n          status: \"error\",\n          status_code: 500,\n          message: \"Failed to fetch health status. Server might be down.\",\n        };\n        setHealth(errorHealth);\n        healthRef.current = errorHealth;\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  }, [isServerDown, setIsLoading]);\n\n  const debouncedFetchHealth = useCallback(debounce(fetchHealth, 1000), [\n    fetchHealth,\n  ]);\n\n  useEffect(() => {\n    fetchHealth();\n    const interval = setInterval(fetchHealth, 1000);\n\n    return () => {\n      clearInterval(interval);\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, [fetchHealth]);\n\n  return {\n    health,\n    isServerDown,\n    isLoading,\n    fetchHealth,\n    debouncedFetchHealth,\n  } as HealthCheckHook;\n}\n",
      "type": "registry:hook"
    }
  ]
}