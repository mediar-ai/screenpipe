#!/usr/bin/env bun
// @bun
import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/universalify/index.js
var require_universalify = __commonJS((exports) => {
  exports.fromCallback = function(fn) {
    return Object.defineProperty(function(...args) {
      if (typeof args[args.length - 1] === "function")
        fn.apply(this, args);
      else {
        return new Promise((resolve, reject) => {
          args.push((err, res) => err != null ? reject(err) : resolve(res));
          fn.apply(this, args);
        });
      }
    }, "name", { value: fn.name });
  };
  exports.fromPromise = function(fn) {
    return Object.defineProperty(function(...args) {
      const cb = args[args.length - 1];
      if (typeof cb !== "function")
        return fn.apply(this, args);
      else {
        args.pop();
        fn.apply(this, args).then((r) => cb(null, r), cb);
      }
    }, "name", { value: fn.name });
  };
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS((exports, module) => {
  var constants = __require("constants");
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(process.chdir, chdir);
  }
  var chdir;
  module.exports = patch;
  function patch(fs) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs);
    }
    if (!fs.lutimes) {
      patchLutimes(fs);
    }
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    if (fs.chmod && !fs.lchmod) {
      fs.lchmod = function(path, mode, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs.lchmodSync = function() {
      };
    }
    if (fs.chown && !fs.lchown) {
      fs.lchown = function(path, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs.lchownSync = function() {
      };
    }
    if (platform === "win32") {
      fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
              setTimeout(function() {
                fs.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(rename, fs$rename);
        return rename;
      }(fs.rename);
    }
    fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _2, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs.readSync);
    function patchLchmod(fs2) {
      fs2.lchmod = function(path, mode, callback) {
        fs2.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs2.fchmod(fd, mode, function(err2) {
            fs2.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      };
      fs2.lchmodSync = function(path, mode) {
        var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs2.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs2.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs2.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
        fs2.lutimes = function(path, at, mt, cb) {
          fs2.open(path, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs2.futimes(fd, at, mt, function(er2) {
              fs2.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        };
        fs2.lutimesSync = function(path, at, mt) {
          var fd = fs2.openSync(path, constants.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs2.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      } else if (fs2.futimes) {
        fs2.lutimes = function(_a, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream;
  module.exports = legacy;
  function legacy(fs) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path, options);
      Stream.call(this);
      var self2 = this;
      this.path = path;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== undefined) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.end === undefined) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path, options);
      Stream.call(this);
      this.path = path;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== undefined) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
        this.flush();
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone2 = __commonJS((exports, module) => {
  module.exports = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = { __proto__: getPrototypeOf(obj) };
    else
      var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS((exports, module) => {
  var fs = __require("fs");
  var polyfills = require_polyfills();
  var legacy = require_legacy_streams();
  var clone = require_clone2();
  var util = __require("util");
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {
  }
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug = noop;
  if (util.debuglog)
    debug = util.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug = function() {
      var m = util.format.apply(util, arguments);
      m = "GFS4: " + m.split(/\n/).join(`
GFS4: `);
      console.error(m);
    };
  if (!fs[gracefulQueue]) {
    queue = global[gracefulQueue] || [];
    publishQueue(fs, queue);
    fs.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs, fd, function(err) {
          if (!err) {
            resetQueue();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs.close);
    fs.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs, arguments);
        resetQueue();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug(fs[gracefulQueue]);
        __require("assert").equal(fs[gracefulQueue].length, 0);
      });
    }
  }
  var queue;
  if (!global[gracefulQueue]) {
    publishQueue(global, fs[gracefulQueue]);
  }
  module.exports = patch(clone(fs));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs);
    fs.__patched = true;
  }
  function patch(fs2) {
    polyfills(fs2);
    fs2.gracefulify = patch;
    fs2.createReadStream = createReadStream;
    fs2.createWriteStream = createWriteStream;
    var fs$readFile = fs2.readFile;
    fs2.readFile = readFile;
    function readFile(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path, options, cb);
      function go$readFile(path2, options2, cb2, startTime) {
        return fs$readFile(path2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$writeFile = fs2.writeFile;
    fs2.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path, data, options, cb);
      function go$writeFile(path2, data2, options2, cb2, startTime) {
        return fs$writeFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$appendFile = fs2.appendFile;
    if (fs$appendFile)
      fs2.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path, data, options, cb);
      function go$appendFile(path2, data2, options2, cb2, startTime) {
        return fs$appendFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$copyFile = fs2.copyFile;
    if (fs$copyFile)
      fs2.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src, dest, flags, cb);
      function go$copyFile(src2, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src2, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$readdir = fs2.readdir;
    fs2.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path2, options2, cb2, startTime) {
        return fs$readdir(path2, fs$readdirCallback(path2, options2, cb2, startTime));
      } : function go$readdir(path2, options2, cb2, startTime) {
        return fs$readdir(path2, options2, fs$readdirCallback(path2, options2, cb2, startTime));
      };
      return go$readdir(path, options, cb);
      function fs$readdirCallback(path2, options2, cb2, startTime) {
        return function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([
              go$readdir,
              [path2, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs2);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs2.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs2.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs2, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs2, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs2, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs2, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path, options) {
      return new fs2.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
      return new fs2.WriteStream(path, options);
    }
    var fs$open = fs2.open;
    fs2.open = open;
    function open(path, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path, flags, mode, cb);
      function go$open(path2, flags2, mode2, cb2, startTime) {
        return fs$open(path2, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    return fs2;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs[gracefulQueue].push(elem);
    retry();
  }
  var retryTimer;
  function resetQueue() {
    var now = Date.now();
    for (var i = 0;i < fs[gracefulQueue].length; ++i) {
      if (fs[gracefulQueue][i].length > 2) {
        fs[gracefulQueue][i][3] = now;
        fs[gracefulQueue][i][4] = now;
      }
    }
    retry();
  }
  function retry() {
    clearTimeout(retryTimer);
    retryTimer = undefined;
    if (fs[gracefulQueue].length === 0)
      return;
    var elem = fs[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    if (startTime === undefined) {
      debug("RETRY", fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
      debug("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime;
      var sinceStart = Math.max(lastTime - startTime, 1);
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        fs[gracefulQueue].push(elem);
      }
    }
    if (retryTimer === undefined) {
      retryTimer = setTimeout(retry, 0);
    }
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS((exports) => {
  var u = require_universalify().fromCallback;
  var fs = require_graceful_fs();
  var api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "cp",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "glob",
    "lchmod",
    "lchown",
    "lutimes",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "statfs",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs[key] === "function";
  });
  Object.assign(exports, fs);
  api.forEach((method) => {
    exports[method] = u(fs[method]);
  });
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs.exists(filename, callback);
    }
    return new Promise((resolve) => {
      return fs.exists(filename, resolve);
    });
  };
  exports.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve, reject) => {
      fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs.write(fd, buffer, ...args);
    }
    return new Promise((resolve, reject) => {
      fs.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  exports.readv = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs.readv(fd, buffers, ...args);
    }
    return new Promise((resolve, reject) => {
      fs.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
        if (err)
          return reject(err);
        resolve({ bytesRead, buffers: buffers2 });
      });
    });
  };
  exports.writev = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs.writev(fd, buffers, ...args);
    }
    return new Promise((resolve, reject) => {
      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
        if (err)
          return reject(err);
        resolve({ bytesWritten, buffers: buffers2 });
      });
    });
  };
  if (typeof fs.realpath.native === "function") {
    exports.realpath.native = u(fs.realpath.native);
  } else {
    process.emitWarning("fs.realpath.native is not a function. Is fs being monkey-patched?", "Warning", "fs-extra-WARN0003");
  }
});

// node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS((exports, module) => {
  var path = __require("path");
  exports.checkPath = function checkPath(pth) {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error = new Error(`Path contains invalid characters: ${pth}`);
        error.code = "EINVAL";
        throw error;
      }
    }
  };
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS((exports, module) => {
  var fs = require_fs();
  var { checkPath } = require_utils();
  var getMode = (options) => {
    const defaults = { mode: 511 };
    if (typeof options === "number")
      return options;
    return { ...defaults, ...options }.mode;
  };
  exports.makeDir = async (dir, options) => {
    checkPath(dir);
    return fs.mkdir(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
  exports.makeDirSync = (dir, options) => {
    checkPath(dir);
    return fs.mkdirSync(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var { makeDir: _makeDir, makeDirSync } = require_make_dir();
  var makeDir = u(_makeDir);
  module.exports = {
    mkdirs: makeDir,
    mkdirsSync: makeDirSync,
    mkdirp: makeDir,
    mkdirpSync: makeDirSync,
    ensureDir: makeDir,
    ensureDirSync: makeDirSync
  };
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var fs = require_fs();
  function pathExists(path) {
    return fs.access(path).then(() => true).catch(() => false);
  }
  module.exports = {
    pathExists: u(pathExists),
    pathExistsSync: fs.existsSync
  };
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS((exports, module) => {
  var fs = require_fs();
  var u = require_universalify().fromPromise;
  async function utimesMillis(path, atime, mtime) {
    const fd = await fs.open(path, "r+");
    let closeErr = null;
    try {
      await fs.futimes(fd, atime, mtime);
    } finally {
      try {
        await fs.close(fd);
      } catch (e) {
        closeErr = e;
      }
    }
    if (closeErr) {
      throw closeErr;
    }
  }
  function utimesMillisSync(path, atime, mtime) {
    const fd = fs.openSync(path, "r+");
    fs.futimesSync(fd, atime, mtime);
    return fs.closeSync(fd);
  }
  module.exports = {
    utimesMillis: u(utimesMillis),
    utimesMillisSync
  };
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS((exports, module) => {
  var fs = require_fs();
  var path = __require("path");
  var u = require_universalify().fromPromise;
  function getStats(src, dest, opts) {
    const statFunc = opts.dereference ? (file) => fs.stat(file, { bigint: true }) : (file) => fs.lstat(file, { bigint: true });
    return Promise.all([
      statFunc(src),
      statFunc(dest).catch((err) => {
        if (err.code === "ENOENT")
          return null;
        throw err;
      })
    ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
  }
  function getStatsSync(src, dest, opts) {
    let destStat;
    const statFunc = opts.dereference ? (file) => fs.statSync(file, { bigint: true }) : (file) => fs.lstatSync(file, { bigint: true });
    const srcStat = statFunc(src);
    try {
      destStat = statFunc(dest);
    } catch (err) {
      if (err.code === "ENOENT")
        return { srcStat, destStat: null };
      throw err;
    }
    return { srcStat, destStat };
  }
  async function checkPaths(src, dest, funcName, opts) {
    const { srcStat, destStat } = await getStats(src, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src);
        const destBaseName = path.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return { srcStat, destStat, isChangingCase: true };
        }
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return { srcStat, destStat };
  }
  function checkPathsSync(src, dest, funcName, opts) {
    const { srcStat, destStat } = getStatsSync(src, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src);
        const destBaseName = path.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return { srcStat, destStat, isChangingCase: true };
        }
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return { srcStat, destStat };
  }
  async function checkParentPaths(src, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root)
      return;
    let destStat;
    try {
      destStat = await fs.stat(destParent, { bigint: true });
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPaths(src, srcStat, destParent, funcName);
  }
  function checkParentPathsSync(src, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root)
      return;
    let destStat;
    try {
      destStat = fs.statSync(destParent, { bigint: true });
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPathsSync(src, srcStat, destParent, funcName);
  }
  function areIdentical(srcStat, destStat) {
    return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
  }
  function isSrcSubdir(src, dest) {
    const srcArr = path.resolve(src).split(path.sep).filter((i) => i);
    const destArr = path.resolve(dest).split(path.sep).filter((i) => i);
    return srcArr.every((cur, i) => destArr[i] === cur);
  }
  function errMsg(src, dest, funcName) {
    return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
  }
  module.exports = {
    checkPaths: u(checkPaths),
    checkPathsSync,
    checkParentPaths: u(checkParentPaths),
    checkParentPathsSync,
    isSrcSubdir,
    areIdentical
  };
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS((exports, module) => {
  var fs = require_fs();
  var path = __require("path");
  var { mkdirs } = require_mkdirs();
  var { pathExists } = require_path_exists();
  var { utimesMillis } = require_utimes();
  var stat = require_stat();
  async function copy(src, dest, opts = {}) {
    if (typeof opts === "function") {
      opts = { filter: opts };
    }
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning(`Using the preserveTimestamps option in 32-bit node is not recommended;

` + "\tsee https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0001");
    }
    const { srcStat, destStat } = await stat.checkPaths(src, dest, "copy", opts);
    await stat.checkParentPaths(src, srcStat, dest, "copy");
    const include = await runFilter(src, dest, opts);
    if (!include)
      return;
    const destParent = path.dirname(dest);
    const dirExists = await pathExists(destParent);
    if (!dirExists) {
      await mkdirs(destParent);
    }
    await getStatsAndPerformCopy(destStat, src, dest, opts);
  }
  async function runFilter(src, dest, opts) {
    if (!opts.filter)
      return true;
    return opts.filter(src, dest);
  }
  async function getStatsAndPerformCopy(destStat, src, dest, opts) {
    const statFn = opts.dereference ? fs.stat : fs.lstat;
    const srcStat = await statFn(src);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts);
    if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts);
    if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts);
    if (srcStat.isSocket())
      throw new Error(`Cannot copy a socket file: ${src}`);
    if (srcStat.isFIFO())
      throw new Error(`Cannot copy a FIFO pipe: ${src}`);
    throw new Error(`Unknown file: ${src}`);
  }
  async function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts);
    if (opts.overwrite) {
      await fs.unlink(dest);
      return copyFile(srcStat, src, dest, opts);
    }
    if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  async function copyFile(srcStat, src, dest, opts) {
    await fs.copyFile(src, dest);
    if (opts.preserveTimestamps) {
      if (fileIsNotWritable(srcStat.mode)) {
        await makeFileWritable(dest, srcStat.mode);
      }
      const updatedSrcStat = await fs.stat(src);
      await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    return fs.chmod(dest, srcStat.mode);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return fs.chmod(dest, srcMode | 128);
  }
  async function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat) {
      await fs.mkdir(dest);
    }
    const promises = [];
    for await (const item of await fs.opendir(src)) {
      const srcItem = path.join(src, item.name);
      const destItem = path.join(dest, item.name);
      promises.push(runFilter(srcItem, destItem, opts).then((include) => {
        if (include) {
          return stat.checkPaths(srcItem, destItem, "copy", opts).then(({ destStat: destStat2 }) => {
            return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
          });
        }
      }));
    }
    await Promise.all(promises);
    if (!destStat) {
      await fs.chmod(dest, srcStat.mode);
    }
  }
  async function onLink(destStat, src, dest, opts) {
    let resolvedSrc = await fs.readlink(src);
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs.symlink(resolvedSrc, dest);
    }
    let resolvedDest = null;
    try {
      resolvedDest = await fs.readlink(dest);
    } catch (e) {
      if (e.code === "EINVAL" || e.code === "UNKNOWN")
        return fs.symlink(resolvedSrc, dest);
      throw e;
    }
    if (opts.dereference) {
      resolvedDest = path.resolve(process.cwd(), resolvedDest);
    }
    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    await fs.unlink(dest);
    return fs.symlink(resolvedSrc, dest);
  }
  module.exports = copy;
});

// node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var path = __require("path");
  var mkdirsSync = require_mkdirs().mkdirsSync;
  var utimesMillisSync = require_utimes().utimesMillisSync;
  var stat = require_stat();
  function copySync(src, dest, opts) {
    if (typeof opts === "function") {
      opts = { filter: opts };
    }
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning(`Using the preserveTimestamps option in 32-bit node is not recommended;

` + "\tsee https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0002");
    }
    const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
    stat.checkParentPathsSync(src, srcStat, dest, "copy");
    if (opts.filter && !opts.filter(src, dest))
      return;
    const destParent = path.dirname(dest);
    if (!fs.existsSync(destParent))
      mkdirsSync(destParent);
    return getStats(destStat, src, dest, opts);
  }
  function getStats(destStat, src, dest, opts) {
    const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
    const srcStat = statSync(src);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts);
    else if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts);
    else if (srcStat.isSocket())
      throw new Error(`Cannot copy a socket file: ${src}`);
    else if (srcStat.isFIFO())
      throw new Error(`Cannot copy a FIFO pipe: ${src}`);
    throw new Error(`Unknown file: ${src}`);
  }
  function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts);
    return mayCopyFile(srcStat, src, dest, opts);
  }
  function mayCopyFile(srcStat, src, dest, opts) {
    if (opts.overwrite) {
      fs.unlinkSync(dest);
      return copyFile(srcStat, src, dest, opts);
    } else if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  function copyFile(srcStat, src, dest, opts) {
    fs.copyFileSync(src, dest);
    if (opts.preserveTimestamps)
      handleTimestamps(srcStat.mode, src, dest);
    return setDestMode(dest, srcStat.mode);
  }
  function handleTimestamps(srcMode, src, dest) {
    if (fileIsNotWritable(srcMode))
      makeFileWritable(dest, srcMode);
    return setDestTimestamps(src, dest);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return setDestMode(dest, srcMode | 128);
  }
  function setDestMode(dest, srcMode) {
    return fs.chmodSync(dest, srcMode);
  }
  function setDestTimestamps(src, dest) {
    const updatedSrcStat = fs.statSync(src);
    return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return mkDirAndCopy(srcStat.mode, src, dest, opts);
    return copyDir(src, dest, opts);
  }
  function mkDirAndCopy(srcMode, src, dest, opts) {
    fs.mkdirSync(dest);
    copyDir(src, dest, opts);
    return setDestMode(dest, srcMode);
  }
  function copyDir(src, dest, opts) {
    const dir = fs.opendirSync(src);
    try {
      let dirent;
      while ((dirent = dir.readSync()) !== null) {
        copyDirItem(dirent.name, src, dest, opts);
      }
    } finally {
      dir.closeSync();
    }
  }
  function copyDirItem(item, src, dest, opts) {
    const srcItem = path.join(src, item);
    const destItem = path.join(dest, item);
    if (opts.filter && !opts.filter(srcItem, destItem))
      return;
    const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
    return getStats(destStat, srcItem, destItem, opts);
  }
  function onLink(destStat, src, dest, opts) {
    let resolvedSrc = fs.readlinkSync(src);
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs.symlinkSync(resolvedSrc, dest);
    } else {
      let resolvedDest;
      try {
        resolvedDest = fs.readlinkSync(dest);
      } catch (err) {
        if (err.code === "EINVAL" || err.code === "UNKNOWN")
          return fs.symlinkSync(resolvedSrc, dest);
        throw err;
      }
      if (opts.dereference) {
        resolvedDest = path.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      return copyLink(resolvedSrc, dest);
    }
  }
  function copyLink(resolvedSrc, dest) {
    fs.unlinkSync(dest);
    return fs.symlinkSync(resolvedSrc, dest);
  }
  module.exports = copySync;
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  module.exports = {
    copy: u(require_copy()),
    copySync: require_copy_sync()
  };
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var u = require_universalify().fromCallback;
  function remove(path, callback) {
    fs.rm(path, { recursive: true, force: true }, callback);
  }
  function removeSync(path) {
    fs.rmSync(path, { recursive: true, force: true });
  }
  module.exports = {
    remove: u(remove),
    removeSync
  };
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var fs = require_fs();
  var path = __require("path");
  var mkdir = require_mkdirs();
  var remove = require_remove();
  var emptyDir = u(async function emptyDir(dir) {
    let items;
    try {
      items = await fs.readdir(dir);
    } catch {
      return mkdir.mkdirs(dir);
    }
    return Promise.all(items.map((item) => remove.remove(path.join(dir, item))));
  });
  function emptyDirSync(dir) {
    let items;
    try {
      items = fs.readdirSync(dir);
    } catch {
      return mkdir.mkdirsSync(dir);
    }
    items.forEach((item) => {
      item = path.join(dir, item);
      remove.removeSync(item);
    });
  }
  module.exports = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
  };
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var path = __require("path");
  var fs = require_fs();
  var mkdir = require_mkdirs();
  async function createFile(file) {
    let stats;
    try {
      stats = await fs.stat(file);
    } catch {
    }
    if (stats && stats.isFile())
      return;
    const dir = path.dirname(file);
    let dirStats = null;
    try {
      dirStats = await fs.stat(dir);
    } catch (err) {
      if (err.code === "ENOENT") {
        await mkdir.mkdirs(dir);
        await fs.writeFile(file, "");
        return;
      } else {
        throw err;
      }
    }
    if (dirStats.isDirectory()) {
      await fs.writeFile(file, "");
    } else {
      await fs.readdir(dir);
    }
  }
  function createFileSync(file) {
    let stats;
    try {
      stats = fs.statSync(file);
    } catch {
    }
    if (stats && stats.isFile())
      return;
    const dir = path.dirname(file);
    try {
      if (!fs.statSync(dir).isDirectory()) {
        fs.readdirSync(dir);
      }
    } catch (err) {
      if (err && err.code === "ENOENT")
        mkdir.mkdirsSync(dir);
      else
        throw err;
    }
    fs.writeFileSync(file, "");
  }
  module.exports = {
    createFile: u(createFile),
    createFileSync
  };
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var path = __require("path");
  var fs = require_fs();
  var mkdir = require_mkdirs();
  var { pathExists } = require_path_exists();
  var { areIdentical } = require_stat();
  async function createLink(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = await fs.lstat(dstpath);
    } catch {
    }
    let srcStat;
    try {
      srcStat = await fs.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    if (dstStat && areIdentical(srcStat, dstStat))
      return;
    const dir = path.dirname(dstpath);
    const dirExists = await pathExists(dir);
    if (!dirExists) {
      await mkdir.mkdirs(dir);
    }
    await fs.link(srcpath, dstpath);
  }
  function createLinkSync(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = fs.lstatSync(dstpath);
    } catch {
    }
    try {
      const srcStat = fs.lstatSync(srcpath);
      if (dstStat && areIdentical(srcStat, dstStat))
        return;
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    const dir = path.dirname(dstpath);
    const dirExists = fs.existsSync(dir);
    if (dirExists)
      return fs.linkSync(srcpath, dstpath);
    mkdir.mkdirsSync(dir);
    return fs.linkSync(srcpath, dstpath);
  }
  module.exports = {
    createLink: u(createLink),
    createLinkSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = require_fs();
  var { pathExists } = require_path_exists();
  var u = require_universalify().fromPromise;
  async function symlinkPaths(srcpath, dstpath) {
    if (path.isAbsolute(srcpath)) {
      try {
        await fs.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    }
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    const exists = await pathExists(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    }
    try {
      await fs.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureSymlink");
      throw err;
    }
    return {
      toCwd: srcpath,
      toDst: path.relative(dstdir, srcpath)
    };
  }
  function symlinkPathsSync(srcpath, dstpath) {
    if (path.isAbsolute(srcpath)) {
      const exists2 = fs.existsSync(srcpath);
      if (!exists2)
        throw new Error("absolute srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    }
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    const exists = fs.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    }
    const srcExists = fs.existsSync(srcpath);
    if (!srcExists)
      throw new Error("relative srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: path.relative(dstdir, srcpath)
    };
  }
  module.exports = {
    symlinkPaths: u(symlinkPaths),
    symlinkPathsSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS((exports, module) => {
  var fs = require_fs();
  var u = require_universalify().fromPromise;
  async function symlinkType(srcpath, type) {
    if (type)
      return type;
    let stats;
    try {
      stats = await fs.lstat(srcpath);
    } catch {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  function symlinkTypeSync(srcpath, type) {
    if (type)
      return type;
    let stats;
    try {
      stats = fs.lstatSync(srcpath);
    } catch {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  module.exports = {
    symlinkType: u(symlinkType),
    symlinkTypeSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var path = __require("path");
  var fs = require_fs();
  var { mkdirs, mkdirsSync } = require_mkdirs();
  var { symlinkPaths, symlinkPathsSync } = require_symlink_paths();
  var { symlinkType, symlinkTypeSync } = require_symlink_type();
  var { pathExists } = require_path_exists();
  var { areIdentical } = require_stat();
  async function createSymlink(srcpath, dstpath, type) {
    let stats;
    try {
      stats = await fs.lstat(dstpath);
    } catch {
    }
    if (stats && stats.isSymbolicLink()) {
      const [srcStat, dstStat] = await Promise.all([
        fs.stat(srcpath),
        fs.stat(dstpath)
      ]);
      if (areIdentical(srcStat, dstStat))
        return;
    }
    const relative = await symlinkPaths(srcpath, dstpath);
    srcpath = relative.toDst;
    const toType = await symlinkType(relative.toCwd, type);
    const dir = path.dirname(dstpath);
    if (!await pathExists(dir)) {
      await mkdirs(dir);
    }
    return fs.symlink(srcpath, dstpath, toType);
  }
  function createSymlinkSync(srcpath, dstpath, type) {
    let stats;
    try {
      stats = fs.lstatSync(dstpath);
    } catch {
    }
    if (stats && stats.isSymbolicLink()) {
      const srcStat = fs.statSync(srcpath);
      const dstStat = fs.statSync(dstpath);
      if (areIdentical(srcStat, dstStat))
        return;
    }
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type = symlinkTypeSync(relative.toCwd, type);
    const dir = path.dirname(dstpath);
    const exists = fs.existsSync(dir);
    if (exists)
      return fs.symlinkSync(srcpath, dstpath, type);
    mkdirsSync(dir);
    return fs.symlinkSync(srcpath, dstpath, type);
  }
  module.exports = {
    createSymlink: u(createSymlink),
    createSymlinkSync
  };
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS((exports, module) => {
  var { createFile, createFileSync } = require_file();
  var { createLink, createLinkSync } = require_link();
  var { createSymlink, createSymlinkSync } = require_symlink();
  module.exports = {
    createFile,
    createFileSync,
    ensureFile: createFile,
    ensureFileSync: createFileSync,
    createLink,
    createLinkSync,
    ensureLink: createLink,
    ensureLinkSync: createLinkSync,
    createSymlink,
    createSymlinkSync,
    ensureSymlink: createSymlink,
    ensureSymlinkSync: createSymlinkSync
  };
});

// node_modules/jsonfile/utils.js
var require_utils2 = __commonJS((exports, module) => {
  function stringify(obj, { EOL = `
`, finalEOL = true, replacer = null, spaces } = {}) {
    const EOF = finalEOL ? EOL : "";
    const str = JSON.stringify(obj, replacer, spaces);
    return str.replace(/\n/g, EOL) + EOF;
  }
  function stripBom(content) {
    if (Buffer.isBuffer(content))
      content = content.toString("utf8");
    return content.replace(/^\uFEFF/, "");
  }
  module.exports = { stringify, stripBom };
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS((exports, module) => {
  var _fs;
  try {
    _fs = require_graceful_fs();
  } catch (_2) {
    _fs = __require("fs");
  }
  var universalify = require_universalify();
  var { stringify, stripBom } = require_utils2();
  async function _readFile(file, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    let data = await universalify.fromCallback(fs.readFile)(file, options);
    data = stripBom(data);
    let obj;
    try {
      obj = JSON.parse(data, options ? options.reviver : null);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
    return obj;
  }
  var readFile = universalify.fromPromise(_readFile);
  function readFileSync(file, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    try {
      let content = fs.readFileSync(file, options);
      content = stripBom(content);
      return JSON.parse(content, options.reviver);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
  }
  async function _writeFile(file, obj, options = {}) {
    const fs = options.fs || _fs;
    const str = stringify(obj, options);
    await universalify.fromCallback(fs.writeFile)(file, str, options);
  }
  var writeFile = universalify.fromPromise(_writeFile);
  function writeFileSync(file, obj, options = {}) {
    const fs = options.fs || _fs;
    const str = stringify(obj, options);
    return fs.writeFileSync(file, str, options);
  }
  var jsonfile = {
    readFile,
    readFileSync,
    writeFile,
    writeFileSync
  };
  module.exports = jsonfile;
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS((exports, module) => {
  var jsonFile = require_jsonfile();
  module.exports = {
    readJson: jsonFile.readFile,
    readJsonSync: jsonFile.readFileSync,
    writeJson: jsonFile.writeFile,
    writeJsonSync: jsonFile.writeFileSync
  };
});

// node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var fs = require_fs();
  var path = __require("path");
  var mkdir = require_mkdirs();
  var pathExists = require_path_exists().pathExists;
  async function outputFile(file, data, encoding = "utf-8") {
    const dir = path.dirname(file);
    if (!await pathExists(dir)) {
      await mkdir.mkdirs(dir);
    }
    return fs.writeFile(file, data, encoding);
  }
  function outputFileSync(file, ...args) {
    const dir = path.dirname(file);
    if (!fs.existsSync(dir)) {
      mkdir.mkdirsSync(dir);
    }
    fs.writeFileSync(file, ...args);
  }
  module.exports = {
    outputFile: u(outputFile),
    outputFileSync
  };
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS((exports, module) => {
  var { stringify } = require_utils2();
  var { outputFile } = require_output_file();
  async function outputJson(file, data, options = {}) {
    const str = stringify(data, options);
    await outputFile(file, str, options);
  }
  module.exports = outputJson;
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS((exports, module) => {
  var { stringify } = require_utils2();
  var { outputFileSync } = require_output_file();
  function outputJsonSync(file, data, options) {
    const str = stringify(data, options);
    outputFileSync(file, str, options);
  }
  module.exports = outputJsonSync;
});

// node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var jsonFile = require_jsonfile2();
  jsonFile.outputJson = u(require_output_json());
  jsonFile.outputJsonSync = require_output_json_sync();
  jsonFile.outputJSON = jsonFile.outputJson;
  jsonFile.outputJSONSync = jsonFile.outputJsonSync;
  jsonFile.writeJSON = jsonFile.writeJson;
  jsonFile.writeJSONSync = jsonFile.writeJsonSync;
  jsonFile.readJSON = jsonFile.readJson;
  jsonFile.readJSONSync = jsonFile.readJsonSync;
  module.exports = jsonFile;
});

// node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS((exports, module) => {
  var fs = require_fs();
  var path = __require("path");
  var { copy } = require_copy2();
  var { remove } = require_remove();
  var { mkdirp } = require_mkdirs();
  var { pathExists } = require_path_exists();
  var stat = require_stat();
  async function move(src, dest, opts = {}) {
    const overwrite = opts.overwrite || opts.clobber || false;
    const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, "move", opts);
    await stat.checkParentPaths(src, srcStat, dest, "move");
    const destParent = path.dirname(dest);
    const parsedParentPath = path.parse(destParent);
    if (parsedParentPath.root !== destParent) {
      await mkdirp(destParent);
    }
    return doRename(src, dest, overwrite, isChangingCase);
  }
  async function doRename(src, dest, overwrite, isChangingCase) {
    if (!isChangingCase) {
      if (overwrite) {
        await remove(dest);
      } else if (await pathExists(dest)) {
        throw new Error("dest already exists.");
      }
    }
    try {
      await fs.rename(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV") {
        throw err;
      }
      await moveAcrossDevice(src, dest, overwrite);
    }
  }
  async function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true,
      preserveTimestamps: true
    };
    await copy(src, dest, opts);
    return remove(src);
  }
  module.exports = move;
});

// node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS((exports, module) => {
  var fs = require_graceful_fs();
  var path = __require("path");
  var copySync = require_copy2().copySync;
  var removeSync = require_remove().removeSync;
  var mkdirpSync = require_mkdirs().mkdirpSync;
  var stat = require_stat();
  function moveSync(src, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
    stat.checkParentPathsSync(src, srcStat, dest, "move");
    if (!isParentRoot(dest))
      mkdirpSync(path.dirname(dest));
    return doRename(src, dest, overwrite, isChangingCase);
  }
  function isParentRoot(dest) {
    const parent = path.dirname(dest);
    const parsedPath = path.parse(parent);
    return parsedPath.root === parent;
  }
  function doRename(src, dest, overwrite, isChangingCase) {
    if (isChangingCase)
      return rename(src, dest, overwrite);
    if (overwrite) {
      removeSync(dest);
      return rename(src, dest, overwrite);
    }
    if (fs.existsSync(dest))
      throw new Error("dest already exists.");
    return rename(src, dest, overwrite);
  }
  function rename(src, dest, overwrite) {
    try {
      fs.renameSync(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV")
        throw err;
      return moveAcrossDevice(src, dest, overwrite);
    }
  }
  function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true,
      preserveTimestamps: true
    };
    copySync(src, dest, opts);
    return removeSync(src);
  }
  module.exports = moveSync;
});

// node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  module.exports = {
    move: u(require_move()),
    moveSync: require_move_sync()
  };
});

// node_modules/fs-extra/lib/index.js
var require_lib = __commonJS((exports, module) => {
  module.exports = {
    ...require_fs(),
    ...require_copy2(),
    ...require_empty(),
    ...require_ensure(),
    ...require_json(),
    ...require_mkdirs(),
    ...require_move2(),
    ...require_output_file(),
    ...require_path_exists(),
    ...require_remove()
  };
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/key.js
var isUpKey = (key) => key.name === "up" || key.name === "k" || key.ctrl && key.name === "p", isDownKey = (key) => key.name === "down" || key.name === "j" || key.ctrl && key.name === "n", isSpaceKey = (key) => key.name === "space", isNumberKey = (key) => "123456789".includes(key.name), isEnterKey = (key) => key.name === "enter" || key.name === "return";

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/errors.js
var AbortPromptError, CancelPromptError, ExitPromptError, HookError, ValidationError;
var init_errors = __esm(() => {
  AbortPromptError = class AbortPromptError extends Error {
    name = "AbortPromptError";
    message = "Prompt was aborted";
    constructor(options) {
      super();
      this.cause = options?.cause;
    }
  };
  CancelPromptError = class CancelPromptError extends Error {
    name = "CancelPromptError";
    message = "Prompt was canceled";
  };
  ExitPromptError = class ExitPromptError extends Error {
    name = "ExitPromptError";
  };
  HookError = class HookError extends Error {
    name = "HookError";
  };
  ValidationError = class ValidationError extends Error {
    name = "ValidationError";
  };
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/hook-engine.js
import { AsyncLocalStorage, AsyncResource } from "node:async_hooks";
function createStore(rl) {
  const store = {
    rl,
    hooks: [],
    hooksCleanup: [],
    hooksEffect: [],
    index: 0,
    handleChange() {
    }
  };
  return store;
}
function withHooks(rl, cb) {
  const store = createStore(rl);
  return hookStorage.run(store, () => {
    function cycle(render) {
      store.handleChange = () => {
        store.index = 0;
        render();
      };
      store.handleChange();
    }
    return cb(cycle);
  });
}
function getStore() {
  const store = hookStorage.getStore();
  if (!store) {
    throw new HookError("[Inquirer] Hook functions can only be called from within a prompt");
  }
  return store;
}
function readline() {
  return getStore().rl;
}
function withUpdates(fn) {
  const wrapped = (...args) => {
    const store = getStore();
    let shouldUpdate = false;
    const oldHandleChange = store.handleChange;
    store.handleChange = () => {
      shouldUpdate = true;
    };
    const returnValue = fn(...args);
    if (shouldUpdate) {
      oldHandleChange();
    }
    store.handleChange = oldHandleChange;
    return returnValue;
  };
  return AsyncResource.bind(wrapped);
}
function withPointer(cb) {
  const store = getStore();
  const { index } = store;
  const pointer = {
    get() {
      return store.hooks[index];
    },
    set(value) {
      store.hooks[index] = value;
    },
    initialized: index in store.hooks
  };
  const returnValue = cb(pointer);
  store.index++;
  return returnValue;
}
function handleChange() {
  getStore().handleChange();
}
var hookStorage, effectScheduler;
var init_hook_engine = __esm(() => {
  init_errors();
  hookStorage = new AsyncLocalStorage;
  effectScheduler = {
    queue(cb) {
      const store = getStore();
      const { index } = store;
      store.hooksEffect.push(() => {
        store.hooksCleanup[index]?.();
        const cleanFn = cb(readline());
        if (cleanFn != null && typeof cleanFn !== "function") {
          throw new ValidationError("useEffect return value must be a cleanup function or nothing.");
        }
        store.hooksCleanup[index] = cleanFn;
      });
    },
    run() {
      const store = getStore();
      withUpdates(() => {
        store.hooksEffect.forEach((effect) => {
          effect();
        });
        store.hooksEffect.length = 0;
      })();
    },
    clearAll() {
      const store = getStore();
      store.hooksCleanup.forEach((cleanFn) => {
        cleanFn?.();
      });
      store.hooksEffect.length = 0;
      store.hooksCleanup.length = 0;
    }
  };
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/use-state.js
function useState(defaultValue) {
  return withPointer((pointer) => {
    const setFn = (newValue) => {
      if (pointer.get() !== newValue) {
        pointer.set(newValue);
        handleChange();
      }
    };
    if (pointer.initialized) {
      return [pointer.get(), setFn];
    }
    const value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
    pointer.set(value);
    return [value, setFn];
  });
}
var init_use_state = __esm(() => {
  init_hook_engine();
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/use-effect.js
function useEffect(cb, depArray) {
  withPointer((pointer) => {
    const oldDeps = pointer.get();
    const hasChanged = !Array.isArray(oldDeps) || depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    if (hasChanged) {
      effectScheduler.queue(cb);
    }
    pointer.set(depArray);
  });
}
var init_use_effect = __esm(() => {
  init_hook_engine();
});

// node_modules/yoctocolors-cjs/index.js
var require_yoctocolors_cjs = __commonJS((exports, module) => {
  var tty = __require("node:tty");
  var hasColors = tty?.WriteStream?.prototype?.hasColors?.() ?? false;
  var format = (open, close) => {
    if (!hasColors) {
      return (input) => input;
    }
    const openCode = `\x1B[${open}m`;
    const closeCode = `\x1B[${close}m`;
    return (input) => {
      const string2 = input + "";
      let index = string2.indexOf(closeCode);
      if (index === -1) {
        return openCode + string2 + closeCode;
      }
      let result = openCode;
      let lastIndex = 0;
      while (index !== -1) {
        result += string2.slice(lastIndex, index) + openCode;
        lastIndex = index + closeCode.length;
        index = string2.indexOf(closeCode, lastIndex);
      }
      result += string2.slice(lastIndex) + closeCode;
      return result;
    };
  };
  var colors = {};
  colors.reset = format(0, 0);
  colors.bold = format(1, 22);
  colors.dim = format(2, 22);
  colors.italic = format(3, 23);
  colors.underline = format(4, 24);
  colors.overline = format(53, 55);
  colors.inverse = format(7, 27);
  colors.hidden = format(8, 28);
  colors.strikethrough = format(9, 29);
  colors.black = format(30, 39);
  colors.red = format(31, 39);
  colors.green = format(32, 39);
  colors.yellow = format(33, 39);
  colors.blue = format(34, 39);
  colors.magenta = format(35, 39);
  colors.cyan = format(36, 39);
  colors.white = format(37, 39);
  colors.gray = format(90, 39);
  colors.bgBlack = format(40, 49);
  colors.bgRed = format(41, 49);
  colors.bgGreen = format(42, 49);
  colors.bgYellow = format(43, 49);
  colors.bgBlue = format(44, 49);
  colors.bgMagenta = format(45, 49);
  colors.bgCyan = format(46, 49);
  colors.bgWhite = format(47, 49);
  colors.bgGray = format(100, 49);
  colors.redBright = format(91, 39);
  colors.greenBright = format(92, 39);
  colors.yellowBright = format(93, 39);
  colors.blueBright = format(94, 39);
  colors.magentaBright = format(95, 39);
  colors.cyanBright = format(96, 39);
  colors.whiteBright = format(97, 39);
  colors.bgRedBright = format(101, 49);
  colors.bgGreenBright = format(102, 49);
  colors.bgYellowBright = format(103, 49);
  colors.bgBlueBright = format(104, 49);
  colors.bgMagentaBright = format(105, 49);
  colors.bgCyanBright = format(106, 49);
  colors.bgWhiteBright = format(107, 49);
  module.exports = colors;
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/figures/dist/esm/index.js
import process2 from "node:process";
function isUnicodeSupported() {
  if (process2.platform !== "win32") {
    return process2.env["TERM"] !== "linux";
  }
  return Boolean(process2.env["WT_SESSION"]) || Boolean(process2.env["TERMINUS_SUBLIME"]) || process2.env["ConEmuTask"] === "{cmd::Cmder}" || process2.env["TERM_PROGRAM"] === "Terminus-Sublime" || process2.env["TERM_PROGRAM"] === "vscode" || process2.env["TERM"] === "xterm-256color" || process2.env["TERM"] === "alacritty" || process2.env["TERMINAL_EMULATOR"] === "JetBrains-JediTerm";
}
var common, specialMainSymbols, specialFallbackSymbols, mainSymbols, fallbackSymbols, shouldUseMain, figures, esm_default, replacements;
var init_esm = __esm(() => {
  common = {
    circleQuestionMark: "(?)",
    questionMarkPrefix: "(?)",
    square: "",
    squareDarkShade: "",
    squareMediumShade: "",
    squareLightShade: "",
    squareTop: "",
    squareBottom: "",
    squareLeft: "",
    squareRight: "",
    squareCenter: "",
    bullet: "",
    dot: "",
    ellipsis: "",
    pointerSmall: "",
    triangleUp: "",
    triangleUpSmall: "",
    triangleDown: "",
    triangleDownSmall: "",
    triangleLeftSmall: "",
    triangleRightSmall: "",
    home: "",
    heart: "",
    musicNote: "",
    musicNoteBeamed: "",
    arrowUp: "",
    arrowDown: "",
    arrowLeft: "",
    arrowRight: "",
    arrowLeftRight: "",
    arrowUpDown: "",
    almostEqual: "",
    notEqual: "",
    lessOrEqual: "",
    greaterOrEqual: "",
    identical: "",
    infinity: "",
    subscriptZero: "",
    subscriptOne: "",
    subscriptTwo: "",
    subscriptThree: "",
    subscriptFour: "",
    subscriptFive: "",
    subscriptSix: "",
    subscriptSeven: "",
    subscriptEight: "",
    subscriptNine: "",
    oneHalf: "",
    oneThird: "",
    oneQuarter: "",
    oneFifth: "",
    oneSixth: "",
    oneEighth: "",
    twoThirds: "",
    twoFifths: "",
    threeQuarters: "",
    threeFifths: "",
    threeEighths: "",
    fourFifths: "",
    fiveSixths: "",
    fiveEighths: "",
    sevenEighths: "",
    line: "",
    lineBold: "",
    lineDouble: "",
    lineDashed0: "",
    lineDashed1: "",
    lineDashed2: "",
    lineDashed3: "",
    lineDashed4: "",
    lineDashed5: "",
    lineDashed6: "",
    lineDashed7: "",
    lineDashed8: "",
    lineDashed9: "",
    lineDashed10: "",
    lineDashed11: "",
    lineDashed12: "",
    lineDashed13: "",
    lineDashed14: "",
    lineDashed15: "",
    lineVertical: "",
    lineVerticalBold: "",
    lineVerticalDouble: "",
    lineVerticalDashed0: "",
    lineVerticalDashed1: "",
    lineVerticalDashed2: "",
    lineVerticalDashed3: "",
    lineVerticalDashed4: "",
    lineVerticalDashed5: "",
    lineVerticalDashed6: "",
    lineVerticalDashed7: "",
    lineVerticalDashed8: "",
    lineVerticalDashed9: "",
    lineVerticalDashed10: "",
    lineVerticalDashed11: "",
    lineDownLeft: "",
    lineDownLeftArc: "",
    lineDownBoldLeftBold: "",
    lineDownBoldLeft: "",
    lineDownLeftBold: "",
    lineDownDoubleLeftDouble: "",
    lineDownDoubleLeft: "",
    lineDownLeftDouble: "",
    lineDownRight: "",
    lineDownRightArc: "",
    lineDownBoldRightBold: "",
    lineDownBoldRight: "",
    lineDownRightBold: "",
    lineDownDoubleRightDouble: "",
    lineDownDoubleRight: "",
    lineDownRightDouble: "",
    lineUpLeft: "",
    lineUpLeftArc: "",
    lineUpBoldLeftBold: "",
    lineUpBoldLeft: "",
    lineUpLeftBold: "",
    lineUpDoubleLeftDouble: "",
    lineUpDoubleLeft: "",
    lineUpLeftDouble: "",
    lineUpRight: "",
    lineUpRightArc: "",
    lineUpBoldRightBold: "",
    lineUpBoldRight: "",
    lineUpRightBold: "",
    lineUpDoubleRightDouble: "",
    lineUpDoubleRight: "",
    lineUpRightDouble: "",
    lineUpDownLeft: "",
    lineUpBoldDownBoldLeftBold: "",
    lineUpBoldDownBoldLeft: "",
    lineUpDownLeftBold: "",
    lineUpBoldDownLeftBold: "",
    lineUpDownBoldLeftBold: "",
    lineUpDownBoldLeft: "",
    lineUpBoldDownLeft: "",
    lineUpDoubleDownDoubleLeftDouble: "",
    lineUpDoubleDownDoubleLeft: "",
    lineUpDownLeftDouble: "",
    lineUpDownRight: "",
    lineUpBoldDownBoldRightBold: "",
    lineUpBoldDownBoldRight: "",
    lineUpDownRightBold: "",
    lineUpBoldDownRightBold: "",
    lineUpDownBoldRightBold: "",
    lineUpDownBoldRight: "",
    lineUpBoldDownRight: "",
    lineUpDoubleDownDoubleRightDouble: "",
    lineUpDoubleDownDoubleRight: "",
    lineUpDownRightDouble: "",
    lineDownLeftRight: "",
    lineDownBoldLeftBoldRightBold: "",
    lineDownLeftBoldRightBold: "",
    lineDownBoldLeftRight: "",
    lineDownBoldLeftBoldRight: "",
    lineDownBoldLeftRightBold: "",
    lineDownLeftRightBold: "",
    lineDownLeftBoldRight: "",
    lineDownDoubleLeftDoubleRightDouble: "",
    lineDownDoubleLeftRight: "",
    lineDownLeftDoubleRightDouble: "",
    lineUpLeftRight: "",
    lineUpBoldLeftBoldRightBold: "",
    lineUpLeftBoldRightBold: "",
    lineUpBoldLeftRight: "",
    lineUpBoldLeftBoldRight: "",
    lineUpBoldLeftRightBold: "",
    lineUpLeftRightBold: "",
    lineUpLeftBoldRight: "",
    lineUpDoubleLeftDoubleRightDouble: "",
    lineUpDoubleLeftRight: "",
    lineUpLeftDoubleRightDouble: "",
    lineUpDownLeftRight: "",
    lineUpBoldDownBoldLeftBoldRightBold: "",
    lineUpDownBoldLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRightBold: "",
    lineUpBoldDownBoldLeftRightBold: "",
    lineUpBoldDownBoldLeftBoldRight: "",
    lineUpBoldDownLeftRight: "",
    lineUpDownBoldLeftRight: "",
    lineUpDownLeftBoldRight: "",
    lineUpDownLeftRightBold: "",
    lineUpBoldDownBoldLeftRight: "",
    lineUpDownLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRight: "",
    lineUpBoldDownLeftRightBold: "",
    lineUpDownBoldLeftBoldRight: "",
    lineUpDownBoldLeftRightBold: "",
    lineUpDoubleDownDoubleLeftDoubleRightDouble: "",
    lineUpDoubleDownDoubleLeftRight: "",
    lineUpDownLeftDoubleRightDouble: "",
    lineCross: "",
    lineBackslash: "",
    lineSlash: ""
  };
  specialMainSymbols = {
    tick: "",
    info: "",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "",
    circleFilled: "",
    circleDotted: "",
    circleDouble: "",
    circleCircle: "",
    circleCross: "",
    circlePipe: "",
    radioOn: "",
    radioOff: "",
    checkboxOn: "",
    checkboxOff: "",
    checkboxCircleOn: "",
    checkboxCircleOff: "",
    pointer: "",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "",
    oneNinth: "",
    oneTenth: ""
  };
  specialFallbackSymbols = {
    tick: "",
    info: "i",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "( )",
    circleFilled: "(*)",
    circleDotted: "( )",
    circleDouble: "( )",
    circleCircle: "()",
    circleCross: "()",
    circlePipe: "()",
    radioOn: "(*)",
    radioOff: "( )",
    checkboxOn: "[]",
    checkboxOff: "[ ]",
    checkboxCircleOn: "()",
    checkboxCircleOff: "( )",
    pointer: ">",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "1/7",
    oneNinth: "1/9",
    oneTenth: "1/10"
  };
  mainSymbols = { ...common, ...specialMainSymbols };
  fallbackSymbols = {
    ...common,
    ...specialFallbackSymbols
  };
  shouldUseMain = isUnicodeSupported();
  figures = shouldUseMain ? mainSymbols : fallbackSymbols;
  esm_default = figures;
  replacements = Object.entries(specialMainSymbols);
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/theme.js
var import_yoctocolors_cjs, defaultTheme;
var init_theme = __esm(() => {
  import_yoctocolors_cjs = __toESM(require_yoctocolors_cjs(), 1);
  init_esm();
  defaultTheme = {
    prefix: {
      idle: import_yoctocolors_cjs.default.blue("?"),
      done: import_yoctocolors_cjs.default.green(esm_default.tick)
    },
    spinner: {
      interval: 80,
      frames: ["", "", "", "", "", "", "", "", "", ""].map((frame) => import_yoctocolors_cjs.default.yellow(frame))
    },
    style: {
      answer: import_yoctocolors_cjs.default.cyan,
      message: import_yoctocolors_cjs.default.bold,
      error: (text) => import_yoctocolors_cjs.default.red(`> ${text}`),
      defaultAnswer: (text) => import_yoctocolors_cjs.default.dim(`(${text})`),
      help: import_yoctocolors_cjs.default.dim,
      highlight: import_yoctocolors_cjs.default.cyan,
      key: (text) => import_yoctocolors_cjs.default.cyan(import_yoctocolors_cjs.default.bold(`<${text}>`))
    }
  };
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/make-theme.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function deepMerge(...objects) {
  const output = {};
  for (const obj of objects) {
    for (const [key, value] of Object.entries(obj)) {
      const prevValue = output[key];
      output[key] = isPlainObject(prevValue) && isPlainObject(value) ? deepMerge(prevValue, value) : value;
    }
  }
  return output;
}
function makeTheme(...themes) {
  const themesToMerge = [
    defaultTheme,
    ...themes.filter((theme) => theme != null)
  ];
  return deepMerge(...themesToMerge);
}
var init_make_theme = __esm(() => {
  init_theme();
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/use-prefix.js
import { AsyncResource as AsyncResource2 } from "node:async_hooks";
function usePrefix({ status = "idle", theme }) {
  const [showLoader, setShowLoader] = useState(false);
  const [tick, setTick] = useState(0);
  const { prefix, spinner } = makeTheme(theme);
  useEffect(() => {
    if (status === "loading") {
      let tickInterval;
      let inc = -1;
      const delayTimeout = setTimeout(AsyncResource2.bind(() => {
        setShowLoader(true);
        tickInterval = setInterval(AsyncResource2.bind(() => {
          inc = inc + 1;
          setTick(inc % spinner.frames.length);
        }), spinner.interval);
      }), 300);
      return () => {
        clearTimeout(delayTimeout);
        clearInterval(tickInterval);
      };
    } else {
      setShowLoader(false);
    }
  }, [status]);
  if (showLoader) {
    return spinner.frames[tick];
  }
  const iconName = status === "loading" ? "idle" : status;
  return typeof prefix === "string" ? prefix : prefix[iconName] ?? prefix["idle"];
}
var init_use_prefix = __esm(() => {
  init_use_state();
  init_use_effect();
  init_make_theme();
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/use-memo.js
function useMemo(fn, dependencies) {
  return withPointer((pointer) => {
    const prev = pointer.get();
    if (!prev || prev.dependencies.length !== dependencies.length || prev.dependencies.some((dep, i) => dep !== dependencies[i])) {
      const value = fn();
      pointer.set({ value, dependencies });
      return value;
    }
    return prev.value;
  });
}
var init_use_memo = __esm(() => {
  init_hook_engine();
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/use-ref.js
function useRef(val) {
  return useState({ current: val })[0];
}
var init_use_ref = __esm(() => {
  init_use_state();
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/use-keypress.js
function useKeypress(userHandler) {
  const signal = useRef(userHandler);
  signal.current = userHandler;
  useEffect((rl) => {
    let ignore = false;
    const handler = withUpdates((_input, event) => {
      if (ignore)
        return;
      signal.current(event, rl);
    });
    rl.input.on("keypress", handler);
    return () => {
      ignore = true;
      rl.input.removeListener("keypress", handler);
    };
  }, []);
}
var init_use_keypress = __esm(() => {
  init_use_ref();
  init_use_effect();
  init_hook_engine();
});

// node_modules/cli-width/index.js
var require_cli_width = __commonJS((exports, module) => {
  module.exports = cliWidth;
  function normalizeOpts(options) {
    const defaultOpts = {
      defaultWidth: 0,
      output: process.stdout,
      tty: __require("tty")
    };
    if (!options) {
      return defaultOpts;
    }
    Object.keys(defaultOpts).forEach(function(key) {
      if (!options[key]) {
        options[key] = defaultOpts[key];
      }
    });
    return options;
  }
  function cliWidth(options) {
    const opts = normalizeOpts(options);
    if (opts.output.getWindowSize) {
      return opts.output.getWindowSize()[0] || opts.defaultWidth;
    }
    if (opts.tty.getWindowSize) {
      return opts.tty.getWindowSize()[1] || opts.defaultWidth;
    }
    if (opts.output.columns) {
      return opts.output.columns;
    }
    if (process.env.CLI_WIDTH) {
      const width = parseInt(process.env.CLI_WIDTH, 10);
      if (!isNaN(width) && width !== 0) {
        return width;
      }
    }
    return opts.defaultWidth;
  }
});

// node_modules/wrap-ansi/node_modules/strip-ansi/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/wrap-ansi/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex();
  module.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
});

// node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS((exports, module) => {
  var isFullwidthCodePoint = (codePoint) => {
    if (Number.isNaN(codePoint)) {
      return false;
    }
    if (codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141)) {
      return true;
    }
    return false;
  };
  module.exports = isFullwidthCodePoint;
  module.exports.default = isFullwidthCodePoint;
});

// node_modules/wrap-ansi/node_modules/string-width/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS((exports, module) => {
  module.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// node_modules/wrap-ansi/node_modules/string-width/index.js
var require_string_width = __commonJS((exports, module) => {
  var stripAnsi = require_strip_ansi();
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var emojiRegex = require_emoji_regex();
  var stringWidth = (string2) => {
    if (typeof string2 !== "string" || string2.length === 0) {
      return 0;
    }
    string2 = stripAnsi(string2);
    if (string2.length === 0) {
      return 0;
    }
    string2 = string2.replace(emojiRegex(), "  ");
    let width = 0;
    for (let i = 0;i < string2.length; i++) {
      const code = string2.codePointAt(i);
      if (code <= 31 || code >= 127 && code <= 159) {
        continue;
      }
      if (code >= 768 && code <= 879) {
        continue;
      }
      if (code > 65535) {
        i++;
      }
      width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
  };
  module.exports = stringWidth;
  module.exports.default = stringWidth;
});

// node_modules/color-name/index.js
var require_color_name = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports, module) => {
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  var convert = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  module.exports = convert;
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", { value: channels });
    Object.defineProperty(convert[model], "labels", { value: labels });
  }
  convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0;i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string2 = integer.toString(16).toUpperCase();
    return "000000".substring(string2.length) + string2;
  };
  convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string2 = integer.toString(16).toUpperCase();
    return "000000".substring(string2.length) + string2;
  };
  convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// node_modules/color-convert/route.js
var require_route = __commonJS((exports, module) => {
  var conversions = require_conversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0;i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0;i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  module.exports = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0;i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports, module) => {
  var conversions = require_conversions();
  var route = require_route();
  var convert = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0;i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert;
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS((exports, module) => {
  var wrapAnsi16 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `\x1B[${code + offset}m`;
  };
  var wrapAnsi256 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `\x1B[${38 + offset};5;${code}m`;
  };
  var wrapAnsi16m = (fn, offset) => (...args) => {
    const rgb = fn(...args);
    return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  var ansi2ansi = (n) => n;
  var rgb2rgb = (r, g, b) => [r, g, b];
  var setLazyProperty = (object, property, get) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  var colorConvert;
  var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    if (colorConvert === undefined) {
      colorConvert = require_color_convert();
    }
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
      const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles[name] = wrap(identity, offset);
      } else if (typeof suite === "object") {
        styles[name] = wrap(suite[targetSpace], offset);
      }
    }
    return styles;
  };
  function assembleStyles() {
    const codes = new Map;
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, "codes", {
      value: codes,
      enumerable: false
    });
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles;
  }
  Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// node_modules/wrap-ansi/index.js
var require_wrap_ansi = __commonJS((exports, module) => {
  var stringWidth = require_string_width();
  var stripAnsi = require_strip_ansi();
  var ansiStyles = require_ansi_styles();
  var ESCAPES = new Set([
    "\x1B",
    ""
  ]);
  var END_CODE = 39;
  var wrapAnsi = (code) => `${ESCAPES.values().next().value}[${code}m`;
  var wordLengths = (string2) => string2.split(" ").map((character) => stringWidth(character));
  var wrapWord = (rows, word, columns) => {
    const characters = [...word];
    let isInsideEscape = false;
    let visible = stringWidth(stripAnsi(rows[rows.length - 1]));
    for (const [index, character] of characters.entries()) {
      const characterLength = stringWidth(character);
      if (visible + characterLength <= columns) {
        rows[rows.length - 1] += character;
      } else {
        rows.push(character);
        visible = 0;
      }
      if (ESCAPES.has(character)) {
        isInsideEscape = true;
      } else if (isInsideEscape && character === "m") {
        isInsideEscape = false;
        continue;
      }
      if (isInsideEscape) {
        continue;
      }
      visible += characterLength;
      if (visible === columns && index < characters.length - 1) {
        rows.push("");
        visible = 0;
      }
    }
    if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
      rows[rows.length - 2] += rows.pop();
    }
  };
  var stringVisibleTrimSpacesRight = (str) => {
    const words = str.split(" ");
    let last = words.length;
    while (last > 0) {
      if (stringWidth(words[last - 1]) > 0) {
        break;
      }
      last--;
    }
    if (last === words.length) {
      return str;
    }
    return words.slice(0, last).join(" ") + words.slice(last).join("");
  };
  var exec = (string2, columns, options = {}) => {
    if (options.trim !== false && string2.trim() === "") {
      return "";
    }
    let pre = "";
    let ret = "";
    let escapeCode;
    const lengths = wordLengths(string2);
    let rows = [""];
    for (const [index, word] of string2.split(" ").entries()) {
      if (options.trim !== false) {
        rows[rows.length - 1] = rows[rows.length - 1].trimLeft();
      }
      let rowLength = stringWidth(rows[rows.length - 1]);
      if (index !== 0) {
        if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
          rows.push("");
          rowLength = 0;
        }
        if (rowLength > 0 || options.trim === false) {
          rows[rows.length - 1] += " ";
          rowLength++;
        }
      }
      if (options.hard && lengths[index] > columns) {
        const remainingColumns = columns - rowLength;
        const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
        const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
        if (breaksStartingNextLine < breaksStartingThisLine) {
          rows.push("");
        }
        wrapWord(rows, word, columns);
        continue;
      }
      if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
        if (options.wordWrap === false && rowLength < columns) {
          wrapWord(rows, word, columns);
          continue;
        }
        rows.push("");
      }
      if (rowLength + lengths[index] > columns && options.wordWrap === false) {
        wrapWord(rows, word, columns);
        continue;
      }
      rows[rows.length - 1] += word;
    }
    if (options.trim !== false) {
      rows = rows.map(stringVisibleTrimSpacesRight);
    }
    pre = rows.join(`
`);
    for (const [index, character] of [...pre].entries()) {
      ret += character;
      if (ESCAPES.has(character)) {
        const code2 = parseFloat(/\d[^m]*/.exec(pre.slice(index, index + 4)));
        escapeCode = code2 === END_CODE ? null : code2;
      }
      const code = ansiStyles.codes.get(Number(escapeCode));
      if (escapeCode && code) {
        if (pre[index + 1] === `
`) {
          ret += wrapAnsi(code);
        } else if (character === `
`) {
          ret += wrapAnsi(escapeCode);
        }
      }
    }
    return ret;
  };
  module.exports = (string2, columns, options) => {
    return String(string2).normalize().replace(/\r\n/g, `
`).split(`
`).map((line) => exec(line, columns, options)).join(`
`);
  };
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/utils.js
function breakLines(content, width) {
  return content.split(`
`).flatMap((line) => import_wrap_ansi.default(line, width, { trim: false, hard: true }).split(`
`).map((str) => str.trimEnd())).join(`
`);
}
function readlineWidth() {
  return import_cli_width.default({ defaultWidth: 80, output: readline().output });
}
var import_cli_width, import_wrap_ansi;
var init_utils = __esm(() => {
  import_cli_width = __toESM(require_cli_width(), 1);
  import_wrap_ansi = __toESM(require_wrap_ansi(), 1);
  init_hook_engine();
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/pagination/lines.js
function split(content, width) {
  return breakLines(content, width).split(`
`);
}
function rotate(count, items) {
  const max = items.length;
  const offset = (count % max + max) % max;
  return [...items.slice(offset), ...items.slice(0, offset)];
}
function lines({ items, width, renderItem, active, position: requested, pageSize }) {
  const layouts = items.map((item, index) => ({
    item,
    index,
    isActive: index === active
  }));
  const layoutsInPage = rotate(active - requested, layouts).slice(0, pageSize);
  const renderItemAt = (index) => layoutsInPage[index] == null ? [] : split(renderItem(layoutsInPage[index]), width);
  const pageBuffer = Array.from({ length: pageSize });
  const activeItem = renderItemAt(requested).slice(0, pageSize);
  const position = requested + activeItem.length <= pageSize ? requested : pageSize - activeItem.length;
  pageBuffer.splice(position, activeItem.length, ...activeItem);
  let bufferPointer = position + activeItem.length;
  let layoutPointer = requested + 1;
  while (bufferPointer < pageSize && layoutPointer < layoutsInPage.length) {
    for (const line of renderItemAt(layoutPointer)) {
      pageBuffer[bufferPointer++] = line;
      if (bufferPointer >= pageSize)
        break;
    }
    layoutPointer++;
  }
  bufferPointer = position - 1;
  layoutPointer = requested - 1;
  while (bufferPointer >= 0 && layoutPointer >= 0) {
    for (const line of renderItemAt(layoutPointer).reverse()) {
      pageBuffer[bufferPointer--] = line;
      if (bufferPointer < 0)
        break;
    }
    layoutPointer--;
  }
  return pageBuffer.filter((line) => typeof line === "string");
}
var init_lines = __esm(() => {
  init_utils();
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/pagination/position.js
function finite({ active, pageSize, total }) {
  const middle = Math.floor(pageSize / 2);
  if (total <= pageSize || active < middle)
    return active;
  if (active >= total - middle)
    return active + pageSize - total;
  return middle;
}
function infinite({ active, lastActive, total, pageSize, pointer }) {
  if (total <= pageSize)
    return active;
  if (lastActive < active && active - lastActive < pageSize) {
    return Math.min(Math.floor(pageSize / 2), pointer + active - lastActive);
  }
  return pointer;
}

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/pagination/use-pagination.js
function usePagination({ items, active, renderItem, pageSize, loop = true }) {
  const state = useRef({ position: 0, lastActive: 0 });
  const position = loop ? infinite({
    active,
    lastActive: state.current.lastActive,
    total: items.length,
    pageSize,
    pointer: state.current.position
  }) : finite({
    active,
    total: items.length,
    pageSize
  });
  state.current.position = position;
  state.current.lastActive = active;
  return lines({
    items,
    width: readlineWidth(),
    renderItem,
    active,
    position,
    pageSize
  }).join(`
`);
}
var init_use_pagination = __esm(() => {
  init_use_ref();
  init_utils();
  init_lines();
});

// node_modules/mute-stream/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var Stream = __require("stream");

  class MuteStream extends Stream {
    #isTTY = null;
    constructor(opts = {}) {
      super(opts);
      this.writable = this.readable = true;
      this.muted = false;
      this.on("pipe", this._onpipe);
      this.replace = opts.replace;
      this._prompt = opts.prompt || null;
      this._hadControl = false;
    }
    #destSrc(key, def) {
      if (this._dest) {
        return this._dest[key];
      }
      if (this._src) {
        return this._src[key];
      }
      return def;
    }
    #proxy(method, ...args) {
      if (typeof this._dest?.[method] === "function") {
        this._dest[method](...args);
      }
      if (typeof this._src?.[method] === "function") {
        this._src[method](...args);
      }
    }
    get isTTY() {
      if (this.#isTTY !== null) {
        return this.#isTTY;
      }
      return this.#destSrc("isTTY", false);
    }
    set isTTY(val) {
      this.#isTTY = val;
    }
    get rows() {
      return this.#destSrc("rows");
    }
    get columns() {
      return this.#destSrc("columns");
    }
    mute() {
      this.muted = true;
    }
    unmute() {
      this.muted = false;
    }
    _onpipe(src) {
      this._src = src;
    }
    pipe(dest, options) {
      this._dest = dest;
      return super.pipe(dest, options);
    }
    pause() {
      if (this._src) {
        return this._src.pause();
      }
    }
    resume() {
      if (this._src) {
        return this._src.resume();
      }
    }
    write(c) {
      if (this.muted) {
        if (!this.replace) {
          return true;
        }
        if (c.match(/^\u001b/)) {
          if (c.indexOf(this._prompt) === 0) {
            c = c.slice(this._prompt.length);
            c = c.replace(/./g, this.replace);
            c = this._prompt + c;
          }
          this._hadControl = true;
          return this.emit("data", c);
        } else {
          if (this._prompt && this._hadControl && c.indexOf(this._prompt) === 0) {
            this._hadControl = false;
            this.emit("data", this._prompt);
            c = c.slice(this._prompt.length);
          }
          c = c.toString().replace(/./g, this.replace);
        }
      }
      this.emit("data", c);
    }
    end(c) {
      if (this.muted) {
        if (c && this.replace) {
          c = c.toString().replace(/./g, this.replace);
        } else {
          c = null;
        }
      }
      if (c) {
        this.emit("data", c);
      }
      this.emit("end");
    }
    destroy(...args) {
      return this.#proxy("destroy", ...args);
    }
    destroySoon(...args) {
      return this.#proxy("destroySoon", ...args);
    }
    close(...args) {
      return this.#proxy("close", ...args);
    }
  }
  module.exports = MuteStream;
});

// node_modules/signal-exit/dist/mjs/signals.js
var signals;
var init_signals = __esm(() => {
  signals = [];
  signals.push("SIGHUP", "SIGINT", "SIGTERM");
  if (process.platform !== "win32") {
    signals.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
  }
  if (process.platform === "linux") {
    signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
  }
});

// node_modules/signal-exit/dist/mjs/index.js
class Emitter {
  emitted = {
    afterExit: false,
    exit: false
  };
  listeners = {
    afterExit: [],
    exit: []
  };
  count = 0;
  id = Math.random();
  constructor() {
    if (global2[kExitEmitter]) {
      return global2[kExitEmitter];
    }
    ObjectDefineProperty(global2, kExitEmitter, {
      value: this,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  on(ev, fn) {
    this.listeners[ev].push(fn);
  }
  removeListener(ev, fn) {
    const list = this.listeners[ev];
    const i = list.indexOf(fn);
    if (i === -1) {
      return;
    }
    if (i === 0 && list.length === 1) {
      list.length = 0;
    } else {
      list.splice(i, 1);
    }
  }
  emit(ev, code, signal) {
    if (this.emitted[ev]) {
      return false;
    }
    this.emitted[ev] = true;
    let ret = false;
    for (const fn of this.listeners[ev]) {
      ret = fn(code, signal) === true || ret;
    }
    if (ev === "exit") {
      ret = this.emit("afterExit", code, signal) || ret;
    }
    return ret;
  }
}

class SignalExitBase {
}
var processOk = (process3) => !!process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function", kExitEmitter, global2, ObjectDefineProperty, signalExitWrap = (handler) => {
  return {
    onExit(cb, opts) {
      return handler.onExit(cb, opts);
    },
    load() {
      return handler.load();
    },
    unload() {
      return handler.unload();
    }
  };
}, SignalExitFallback, SignalExit, process3, onExit, load, unload;
var init_mjs = __esm(() => {
  init_signals();
  kExitEmitter = Symbol.for("signal-exit emitter");
  global2 = globalThis;
  ObjectDefineProperty = Object.defineProperty.bind(Object);
  SignalExitFallback = class SignalExitFallback extends SignalExitBase {
    onExit() {
      return () => {
      };
    }
    load() {
    }
    unload() {
    }
  };
  SignalExit = class SignalExit extends SignalExitBase {
    #hupSig = process3.platform === "win32" ? "SIGINT" : "SIGHUP";
    #emitter = new Emitter;
    #process;
    #originalProcessEmit;
    #originalProcessReallyExit;
    #sigListeners = {};
    #loaded = false;
    constructor(process3) {
      super();
      this.#process = process3;
      this.#sigListeners = {};
      for (const sig of signals) {
        this.#sigListeners[sig] = () => {
          const listeners = this.#process.listeners(sig);
          let { count } = this.#emitter;
          const p = process3;
          if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
            count += p.__signal_exit_emitter__.count;
          }
          if (listeners.length === count) {
            this.unload();
            const ret = this.#emitter.emit("exit", null, sig);
            const s = sig === "SIGHUP" ? this.#hupSig : sig;
            if (!ret)
              process3.kill(process3.pid, s);
          }
        };
      }
      this.#originalProcessReallyExit = process3.reallyExit;
      this.#originalProcessEmit = process3.emit;
    }
    onExit(cb, opts) {
      if (!processOk(this.#process)) {
        return () => {
        };
      }
      if (this.#loaded === false) {
        this.load();
      }
      const ev = opts?.alwaysLast ? "afterExit" : "exit";
      this.#emitter.on(ev, cb);
      return () => {
        this.#emitter.removeListener(ev, cb);
        if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) {
          this.unload();
        }
      };
    }
    load() {
      if (this.#loaded) {
        return;
      }
      this.#loaded = true;
      this.#emitter.count += 1;
      for (const sig of signals) {
        try {
          const fn = this.#sigListeners[sig];
          if (fn)
            this.#process.on(sig, fn);
        } catch (_2) {
        }
      }
      this.#process.emit = (ev, ...a) => {
        return this.#processEmit(ev, ...a);
      };
      this.#process.reallyExit = (code) => {
        return this.#processReallyExit(code);
      };
    }
    unload() {
      if (!this.#loaded) {
        return;
      }
      this.#loaded = false;
      signals.forEach((sig) => {
        const listener = this.#sigListeners[sig];
        if (!listener) {
          throw new Error("Listener not defined for signal: " + sig);
        }
        try {
          this.#process.removeListener(sig, listener);
        } catch (_2) {
        }
      });
      this.#process.emit = this.#originalProcessEmit;
      this.#process.reallyExit = this.#originalProcessReallyExit;
      this.#emitter.count -= 1;
    }
    #processReallyExit(code) {
      if (!processOk(this.#process)) {
        return 0;
      }
      this.#process.exitCode = code || 0;
      this.#emitter.emit("exit", this.#process.exitCode, null);
      return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
    }
    #processEmit(ev, ...args) {
      const og = this.#originalProcessEmit;
      if (ev === "exit" && processOk(this.#process)) {
        if (typeof args[0] === "number") {
          this.#process.exitCode = args[0];
        }
        const ret = og.call(this.#process, ev, ...args);
        this.#emitter.emit("exit", this.#process.exitCode, null);
        return ret;
      } else {
        return og.call(this.#process, ev, ...args);
      }
    }
  };
  process3 = globalThis.process;
  ({
    onExit,
    load,
    unload
  } = signalExitWrap(processOk(process3) ? new SignalExit(process3) : new SignalExitFallback));
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/node_modules/strip-ansi/node_modules/ansi-regex/index.js
var require_ansi_regex2 = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/node_modules/strip-ansi/index.js
var require_strip_ansi2 = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex2();
  module.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
});

// node_modules/ansi-escapes/index.js
var require_ansi_escapes = __commonJS((exports, module) => {
  var ansiEscapes = exports;
  exports.default = ansiEscapes;
  var ESC = "\x1B[";
  var OSC = "\x1B]";
  var BEL = "\x07";
  var SEP = ";";
  var isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal";
  ansiEscapes.cursorTo = (x, y) => {
    if (typeof x !== "number") {
      throw new TypeError("The `x` argument is required");
    }
    if (typeof y !== "number") {
      return ESC + (x + 1) + "G";
    }
    return ESC + (y + 1) + ";" + (x + 1) + "H";
  };
  ansiEscapes.cursorMove = (x, y) => {
    if (typeof x !== "number") {
      throw new TypeError("The `x` argument is required");
    }
    let ret = "";
    if (x < 0) {
      ret += ESC + -x + "D";
    } else if (x > 0) {
      ret += ESC + x + "C";
    }
    if (y < 0) {
      ret += ESC + -y + "A";
    } else if (y > 0) {
      ret += ESC + y + "B";
    }
    return ret;
  };
  ansiEscapes.cursorUp = (count = 1) => ESC + count + "A";
  ansiEscapes.cursorDown = (count = 1) => ESC + count + "B";
  ansiEscapes.cursorForward = (count = 1) => ESC + count + "C";
  ansiEscapes.cursorBackward = (count = 1) => ESC + count + "D";
  ansiEscapes.cursorLeft = ESC + "G";
  ansiEscapes.cursorSavePosition = isTerminalApp ? "\x1B7" : ESC + "s";
  ansiEscapes.cursorRestorePosition = isTerminalApp ? "\x1B8" : ESC + "u";
  ansiEscapes.cursorGetPosition = ESC + "6n";
  ansiEscapes.cursorNextLine = ESC + "E";
  ansiEscapes.cursorPrevLine = ESC + "F";
  ansiEscapes.cursorHide = ESC + "?25l";
  ansiEscapes.cursorShow = ESC + "?25h";
  ansiEscapes.eraseLines = (count) => {
    let clear = "";
    for (let i = 0;i < count; i++) {
      clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : "");
    }
    if (count) {
      clear += ansiEscapes.cursorLeft;
    }
    return clear;
  };
  ansiEscapes.eraseEndLine = ESC + "K";
  ansiEscapes.eraseStartLine = ESC + "1K";
  ansiEscapes.eraseLine = ESC + "2K";
  ansiEscapes.eraseDown = ESC + "J";
  ansiEscapes.eraseUp = ESC + "1J";
  ansiEscapes.eraseScreen = ESC + "2J";
  ansiEscapes.scrollUp = ESC + "S";
  ansiEscapes.scrollDown = ESC + "T";
  ansiEscapes.clearScreen = "\x1Bc";
  ansiEscapes.clearTerminal = process.platform === "win32" ? `${ansiEscapes.eraseScreen}${ESC}0f` : `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;
  ansiEscapes.beep = BEL;
  ansiEscapes.link = (text, url) => {
    return [
      OSC,
      "8",
      SEP,
      SEP,
      url,
      BEL,
      text,
      OSC,
      "8",
      SEP,
      SEP,
      BEL
    ].join("");
  };
  ansiEscapes.image = (buffer, options = {}) => {
    let ret = `${OSC}1337;File=inline=1`;
    if (options.width) {
      ret += `;width=${options.width}`;
    }
    if (options.height) {
      ret += `;height=${options.height}`;
    }
    if (options.preserveAspectRatio === false) {
      ret += ";preserveAspectRatio=0";
    }
    return ret + ":" + buffer.toString("base64") + BEL;
  };
  ansiEscapes.iTerm = {
    setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
    annotation: (message, options = {}) => {
      let ret = `${OSC}1337;`;
      const hasX = typeof options.x !== "undefined";
      const hasY = typeof options.y !== "undefined";
      if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== "undefined")) {
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      }
      message = message.replace(/\|/g, "");
      ret += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
      if (options.length > 0) {
        ret += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|");
      } else {
        ret += message;
      }
      return ret + BEL;
    }
  };
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/screen-manager.js
function cursorDown(n) {
  return n > 0 ? import_ansi_escapes.default.cursorDown(n) : "";
}

class ScreenManager {
  rl;
  height = 0;
  extraLinesUnderPrompt = 0;
  cursorPos;
  constructor(rl) {
    this.rl = rl;
    this.rl = rl;
    this.cursorPos = rl.getCursorPos();
  }
  write(content) {
    this.rl.output.unmute();
    this.rl.output.write(content);
    this.rl.output.mute();
  }
  render(content, bottomContent = "") {
    const promptLine = lastLine(content);
    const rawPromptLine = import_strip_ansi.default(promptLine);
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }
    this.rl.setPrompt(prompt);
    this.cursorPos = this.rl.getCursorPos();
    const width = readlineWidth();
    content = breakLines(content, width);
    bottomContent = breakLines(bottomContent, width);
    if (rawPromptLine.length % width === 0) {
      content += `
`;
    }
    let output = content + (bottomContent ? `
` + bottomContent : "");
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - this.cursorPos.rows;
    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);
    if (bottomContentHeight > 0)
      output += import_ansi_escapes.default.cursorUp(bottomContentHeight);
    output += import_ansi_escapes.default.cursorTo(this.cursorPos.cols);
    this.write(cursorDown(this.extraLinesUnderPrompt) + import_ansi_escapes.default.eraseLines(this.height) + output);
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height(output);
  }
  checkCursorPos() {
    const cursorPos = this.rl.getCursorPos();
    if (cursorPos.cols !== this.cursorPos.cols) {
      this.write(import_ansi_escapes.default.cursorTo(cursorPos.cols));
      this.cursorPos = cursorPos;
    }
  }
  done({ clearContent }) {
    this.rl.setPrompt("");
    let output = cursorDown(this.extraLinesUnderPrompt);
    output += clearContent ? import_ansi_escapes.default.eraseLines(this.height) : `
`;
    output += import_ansi_escapes.default.cursorShow;
    this.write(output);
    this.rl.close();
  }
}
var import_strip_ansi, import_ansi_escapes, height = (content) => content.split(`
`).length, lastLine = (content) => content.split(`
`).pop() ?? "";
var init_screen_manager = __esm(() => {
  import_strip_ansi = __toESM(require_strip_ansi2(), 1);
  import_ansi_escapes = __toESM(require_ansi_escapes(), 1);
  init_utils();
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/promise-polyfill.js
var PromisePolyfill;
var init_promise_polyfill = __esm(() => {
  PromisePolyfill = class PromisePolyfill extends Promise {
    static withResolver() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return { promise, resolve, reject };
    }
  };
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/create-prompt.js
import * as readline2 from "node:readline";
import { AsyncResource as AsyncResource3 } from "node:async_hooks";
function getCallSites() {
  const _prepareStackTrace = Error.prepareStackTrace;
  try {
    let result = [];
    Error.prepareStackTrace = (_2, callSites) => {
      const callSitesWithoutCurrent = callSites.slice(1);
      result = callSitesWithoutCurrent;
      return callSitesWithoutCurrent;
    };
    new Error().stack;
    return result;
  } finally {
    Error.prepareStackTrace = _prepareStackTrace;
  }
}
function createPrompt(view) {
  const callSites = getCallSites();
  const callerFilename = callSites[1]?.getFileName?.();
  const prompt = (config, context = {}) => {
    const { input = process.stdin, signal } = context;
    const cleanups = new Set;
    const output = new import_mute_stream.default;
    output.pipe(context.output ?? process.stdout);
    const rl = readline2.createInterface({
      terminal: true,
      input,
      output
    });
    const screen = new ScreenManager(rl);
    const { promise, resolve, reject } = PromisePolyfill.withResolver();
    const cancel = () => reject(new CancelPromptError);
    if (signal) {
      const abort = () => reject(new AbortPromptError({ cause: signal.reason }));
      if (signal.aborted) {
        abort();
        return Object.assign(promise, { cancel });
      }
      signal.addEventListener("abort", abort);
      cleanups.add(() => signal.removeEventListener("abort", abort));
    }
    cleanups.add(onExit((code, signal2) => {
      reject(new ExitPromptError(`User force closed the prompt with ${code} ${signal2}`));
    }));
    const checkCursorPos = () => screen.checkCursorPos();
    rl.input.on("keypress", checkCursorPos);
    cleanups.add(() => rl.input.removeListener("keypress", checkCursorPos));
    return withHooks(rl, (cycle) => {
      const hooksCleanup = AsyncResource3.bind(() => effectScheduler.clearAll());
      rl.on("close", hooksCleanup);
      cleanups.add(() => rl.removeListener("close", hooksCleanup));
      cycle(() => {
        try {
          const nextView = view(config, (value) => {
            setImmediate(() => resolve(value));
          });
          if (nextView === undefined) {
            throw new Error(`Prompt functions must return a string.
    at ${callerFilename}`);
          }
          const [content, bottomContent] = typeof nextView === "string" ? [nextView] : nextView;
          screen.render(content, bottomContent);
          effectScheduler.run();
        } catch (error) {
          reject(error);
        }
      });
      return Object.assign(promise.then((answer) => {
        effectScheduler.clearAll();
        return answer;
      }, (error) => {
        effectScheduler.clearAll();
        throw error;
      }).finally(() => {
        cleanups.forEach((cleanup) => cleanup());
        screen.done({ clearContent: Boolean(context.clearPromptOnDone) });
        output.end();
      }).then(() => promise), { cancel });
    });
  };
  return prompt;
}
var import_mute_stream;
var init_create_prompt = __esm(() => {
  import_mute_stream = __toESM(require_lib2(), 1);
  init_mjs();
  init_screen_manager();
  init_promise_polyfill();
  init_hook_engine();
  init_errors();
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/lib/Separator.js
class Separator {
  separator = import_yoctocolors_cjs2.default.dim(Array.from({ length: 15 }).join(esm_default.line));
  type = "separator";
  constructor(separator) {
    if (separator) {
      this.separator = separator;
    }
  }
  static isSeparator(choice) {
    return Boolean(choice && typeof choice === "object" && "type" in choice && choice.type === "separator");
  }
}
var import_yoctocolors_cjs2;
var init_Separator = __esm(() => {
  import_yoctocolors_cjs2 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm();
});

// node_modules/@inquirer/checkbox/node_modules/@inquirer/core/dist/esm/index.js
var init_esm2 = __esm(() => {
  init_errors();
  init_use_prefix();
  init_use_state();
  init_use_memo();
  init_use_ref();
  init_use_keypress();
  init_make_theme();
  init_use_pagination();
  init_create_prompt();
  init_Separator();
});

// node_modules/@inquirer/checkbox/dist/esm/index.js
function isSelectable(item) {
  return !Separator.isSeparator(item) && !item.disabled;
}
function isChecked(item) {
  return isSelectable(item) && Boolean(item.checked);
}
function toggle(item) {
  return isSelectable(item) ? { ...item, checked: !item.checked } : item;
}
function check(checked) {
  return function(item) {
    return isSelectable(item) ? { ...item, checked } : item;
  };
}
function normalizeChoices(choices) {
  return choices.map((choice) => {
    if (Separator.isSeparator(choice))
      return choice;
    if (typeof choice === "string") {
      return {
        value: choice,
        name: choice,
        short: choice,
        disabled: false,
        checked: false
      };
    }
    const name = choice.name ?? String(choice.value);
    return {
      value: choice.value,
      name,
      short: choice.short ?? name,
      description: choice.description,
      disabled: choice.disabled ?? false,
      checked: choice.checked ?? false
    };
  });
}
var import_yoctocolors_cjs3, import_ansi_escapes2, checkboxTheme, esm_default2;
var init_esm3 = __esm(() => {
  init_esm2();
  import_yoctocolors_cjs3 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm();
  import_ansi_escapes2 = __toESM(require_ansi_escapes(), 1);
  init_esm2();
  checkboxTheme = {
    icon: {
      checked: import_yoctocolors_cjs3.default.green(esm_default.circleFilled),
      unchecked: esm_default.circle,
      cursor: esm_default.pointer
    },
    style: {
      disabledChoice: (text) => import_yoctocolors_cjs3.default.dim(`- ${text}`),
      renderSelectedChoices: (selectedChoices) => selectedChoices.map((choice) => choice.short).join(", "),
      description: (text) => import_yoctocolors_cjs3.default.cyan(text)
    },
    helpMode: "auto"
  };
  esm_default2 = createPrompt((config, done) => {
    const { instructions, pageSize = 7, loop = true, required, validate = () => true } = config;
    const theme = makeTheme(checkboxTheme, config.theme);
    const firstRender = useRef(true);
    const [status, setStatus] = useState("idle");
    const prefix = usePrefix({ status, theme });
    const [items, setItems] = useState(normalizeChoices(config.choices));
    const bounds = useMemo(() => {
      const first = items.findIndex(isSelectable);
      const last = items.findLastIndex(isSelectable);
      if (first === -1) {
        throw new ValidationError("[checkbox prompt] No selectable choices. All choices are disabled.");
      }
      return { first, last };
    }, [items]);
    const [active, setActive] = useState(bounds.first);
    const [showHelpTip, setShowHelpTip] = useState(true);
    const [errorMsg, setError] = useState();
    useKeypress(async (key2) => {
      if (isEnterKey(key2)) {
        const selection = items.filter(isChecked);
        const isValid = await validate([...selection]);
        if (required && !items.some(isChecked)) {
          setError("At least one choice must be selected");
        } else if (isValid === true) {
          setStatus("done");
          done(selection.map((choice) => choice.value));
        } else {
          setError(isValid || "You must select a valid value");
        }
      } else if (isUpKey(key2) || isDownKey(key2)) {
        if (loop || isUpKey(key2) && active !== bounds.first || isDownKey(key2) && active !== bounds.last) {
          const offset = isUpKey(key2) ? -1 : 1;
          let next = active;
          do {
            next = (next + offset + items.length) % items.length;
          } while (!isSelectable(items[next]));
          setActive(next);
        }
      } else if (isSpaceKey(key2)) {
        setError(undefined);
        setShowHelpTip(false);
        setItems(items.map((choice, i) => i === active ? toggle(choice) : choice));
      } else if (key2.name === "a") {
        const selectAll = items.some((choice) => isSelectable(choice) && !choice.checked);
        setItems(items.map(check(selectAll)));
      } else if (key2.name === "i") {
        setItems(items.map(toggle));
      } else if (isNumberKey(key2)) {
        const position = Number(key2.name) - 1;
        const item = items[position];
        if (item != null && isSelectable(item)) {
          setActive(position);
          setItems(items.map((choice, i) => i === position ? toggle(choice) : choice));
        }
      }
    });
    const message = theme.style.message(config.message, status);
    let description;
    const page = usePagination({
      items,
      active,
      renderItem({ item, isActive }) {
        if (Separator.isSeparator(item)) {
          return ` ${item.separator}`;
        }
        if (item.disabled) {
          const disabledLabel = typeof item.disabled === "string" ? item.disabled : "(disabled)";
          return theme.style.disabledChoice(`${item.name} ${disabledLabel}`);
        }
        if (isActive) {
          description = item.description;
        }
        const checkbox = item.checked ? theme.icon.checked : theme.icon.unchecked;
        const color = isActive ? theme.style.highlight : (x) => x;
        const cursor = isActive ? theme.icon.cursor : " ";
        return color(`${cursor}${checkbox} ${item.name}`);
      },
      pageSize,
      loop
    });
    if (status === "done") {
      const selection = items.filter(isChecked);
      const answer = theme.style.answer(theme.style.renderSelectedChoices(selection, items));
      return `${prefix} ${message} ${answer}`;
    }
    let helpTipTop = "";
    let helpTipBottom = "";
    if (theme.helpMode === "always" || theme.helpMode === "auto" && showHelpTip && (instructions === undefined || instructions)) {
      if (typeof instructions === "string") {
        helpTipTop = instructions;
      } else {
        const keys = [
          `${theme.style.key("space")} to select`,
          `${theme.style.key("a")} to toggle all`,
          `${theme.style.key("i")} to invert selection`,
          `and ${theme.style.key("enter")} to proceed`
        ];
        helpTipTop = ` (Press ${keys.join(", ")})`;
      }
      if (items.length > pageSize && (theme.helpMode === "always" || theme.helpMode === "auto" && firstRender.current)) {
        helpTipBottom = `
${theme.style.help("(Use arrow keys to reveal more choices)")}`;
        firstRender.current = false;
      }
    }
    const choiceDescription = description ? `
${theme.style.description(description)}` : ``;
    let error = "";
    if (errorMsg) {
      error = `
${theme.style.error(errorMsg)}`;
    }
    return `${prefix} ${message}${helpTipTop}
${page}${helpTipBottom}${choiceDescription}${error}${import_ansi_escapes2.default.cursorHide}`;
  });
});

// node_modules/chardet/match.js
var require_match = __commonJS((exports, module) => {
  module.exports = function(det, rec, confidence, name, lang) {
    this.confidence = confidence;
    this.name = name || rec.name(det);
    this.lang = lang;
  };
});

// node_modules/chardet/encoding/utf8.js
var require_utf8 = __commonJS((exports, module) => {
  var Match = require_match();
  module.exports = function() {
    this.name = function() {
      return "UTF-8";
    };
    this.match = function(det) {
      var hasBOM = false, numValid = 0, numInvalid = 0, input = det.fRawInput, trailBytes = 0, confidence;
      if (det.fRawLength >= 3 && (input[0] & 255) == 239 && (input[1] & 255) == 187 && (input[2] & 255) == 191) {
        hasBOM = true;
      }
      for (var i = 0;i < det.fRawLength; i++) {
        var b = input[i];
        if ((b & 128) == 0)
          continue;
        if ((b & 224) == 192) {
          trailBytes = 1;
        } else if ((b & 240) == 224) {
          trailBytes = 2;
        } else if ((b & 248) == 240) {
          trailBytes = 3;
        } else {
          numInvalid++;
          if (numInvalid > 5)
            break;
          trailBytes = 0;
        }
        for (;; ) {
          i++;
          if (i >= det.fRawLength)
            break;
          if ((input[i] & 192) != 128) {
            numInvalid++;
            break;
          }
          if (--trailBytes == 0) {
            numValid++;
            break;
          }
        }
      }
      confidence = 0;
      if (hasBOM && numInvalid == 0)
        confidence = 100;
      else if (hasBOM && numValid > numInvalid * 10)
        confidence = 80;
      else if (numValid > 3 && numInvalid == 0)
        confidence = 100;
      else if (numValid > 0 && numInvalid == 0)
        confidence = 80;
      else if (numValid == 0 && numInvalid == 0)
        confidence = 10;
      else if (numValid > numInvalid * 10)
        confidence = 25;
      else
        return null;
      return new Match(det, this, confidence);
    };
  };
});

// node_modules/chardet/encoding/unicode.js
var require_unicode = __commonJS((exports, module) => {
  var util = __require("util");
  var Match = require_match();
  exports.UTF_16BE = function() {
    this.name = function() {
      return "UTF-16BE";
    };
    this.match = function(det) {
      var input = det.fRawInput;
      if (input.length >= 2 && ((input[0] & 255) == 254 && (input[1] & 255) == 255)) {
        return new Match(det, this, 100);
      }
      return null;
    };
  };
  exports.UTF_16LE = function() {
    this.name = function() {
      return "UTF-16LE";
    };
    this.match = function(det) {
      var input = det.fRawInput;
      if (input.length >= 2 && ((input[0] & 255) == 255 && (input[1] & 255) == 254)) {
        if (input.length >= 4 && input[2] == 0 && input[3] == 0) {
          return null;
        }
        return new Match(det, this, 100);
      }
      return null;
    };
  };
  function UTF_32() {
  }
  UTF_32.prototype.match = function(det) {
    var input = det.fRawInput, limit = det.fRawLength / 4 * 4, numValid = 0, numInvalid = 0, hasBOM = false, confidence = 0;
    if (limit == 0) {
      return null;
    }
    if (this.getChar(input, 0) == 65279) {
      hasBOM = true;
    }
    for (var i = 0;i < limit; i += 4) {
      var ch = this.getChar(input, i);
      if (ch < 0 || ch >= 1114111 || ch >= 55296 && ch <= 57343) {
        numInvalid += 1;
      } else {
        numValid += 1;
      }
    }
    if (hasBOM && numInvalid == 0) {
      confidence = 100;
    } else if (hasBOM && numValid > numInvalid * 10) {
      confidence = 80;
    } else if (numValid > 3 && numInvalid == 0) {
      confidence = 100;
    } else if (numValid > 0 && numInvalid == 0) {
      confidence = 80;
    } else if (numValid > numInvalid * 10) {
      confidence = 25;
    }
    return confidence == 0 ? null : new Match(det, this, confidence);
  };
  exports.UTF_32BE = function() {
    this.name = function() {
      return "UTF-32BE";
    };
    this.getChar = function(input, index) {
      return (input[index + 0] & 255) << 24 | (input[index + 1] & 255) << 16 | (input[index + 2] & 255) << 8 | input[index + 3] & 255;
    };
  };
  util.inherits(exports.UTF_32BE, UTF_32);
  exports.UTF_32LE = function() {
    this.name = function() {
      return "UTF-32LE";
    };
    this.getChar = function(input, index) {
      return (input[index + 3] & 255) << 24 | (input[index + 2] & 255) << 16 | (input[index + 1] & 255) << 8 | input[index + 0] & 255;
    };
  };
  util.inherits(exports.UTF_32LE, UTF_32);
});

// node_modules/chardet/encoding/mbcs.js
var require_mbcs = __commonJS((exports, module) => {
  var util = __require("util");
  var Match = require_match();
  function binarySearch(arr, searchValue) {
    function find(arr2, searchValue2, left, right) {
      if (right < left)
        return -1;
      var mid = Math.floor(left + right >>> 1);
      if (searchValue2 > arr2[mid])
        return find(arr2, searchValue2, mid + 1, right);
      if (searchValue2 < arr2[mid])
        return find(arr2, searchValue2, left, mid - 1);
      return mid;
    }
    return find(arr, searchValue, 0, arr.length - 1);
  }
  function IteratedChar() {
    this.charValue = 0;
    this.index = 0;
    this.nextIndex = 0;
    this.error = false;
    this.done = false;
    this.reset = function() {
      this.charValue = 0;
      this.index = -1;
      this.nextIndex = 0;
      this.error = false;
      this.done = false;
    };
    this.nextByte = function(det) {
      if (this.nextIndex >= det.fRawLength) {
        this.done = true;
        return -1;
      }
      var byteValue = det.fRawInput[this.nextIndex++] & 255;
      return byteValue;
    };
  }
  function mbcs() {
  }
  mbcs.prototype.match = function(det) {
    var singleByteCharCount = 0, doubleByteCharCount = 0, commonCharCount = 0, badCharCount = 0, totalCharCount = 0, confidence = 0;
    var iter = new IteratedChar;
    detectBlock: {
      for (iter.reset();this.nextChar(iter, det); ) {
        totalCharCount++;
        if (iter.error) {
          badCharCount++;
        } else {
          var cv = iter.charValue & 4294967295;
          if (cv <= 255) {
            singleByteCharCount++;
          } else {
            doubleByteCharCount++;
            if (this.commonChars != null) {
              if (binarySearch(this.commonChars, cv) >= 0) {
                commonCharCount++;
              }
            }
          }
        }
        if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {
          break detectBlock;
        }
      }
      if (doubleByteCharCount <= 10 && badCharCount == 0) {
        if (doubleByteCharCount == 0 && totalCharCount < 10) {
          confidence = 0;
        } else {
          confidence = 10;
        }
        break detectBlock;
      }
      if (doubleByteCharCount < 20 * badCharCount) {
        confidence = 0;
        break detectBlock;
      }
      if (this.commonChars == null) {
        confidence = 30 + doubleByteCharCount - 20 * badCharCount;
        if (confidence > 100) {
          confidence = 100;
        }
      } else {
        var maxVal = Math.log(parseFloat(doubleByteCharCount) / 4);
        var scaleFactor = 90 / maxVal;
        confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10);
        confidence = Math.min(confidence, 100);
      }
    }
    return confidence == 0 ? null : new Match(det, this, confidence);
  };
  mbcs.prototype.nextChar = function(iter, det) {
  };
  exports.sjis = function() {
    this.name = function() {
      return "Shift-JIS";
    };
    this.language = function() {
      return "ja";
    };
    this.commonChars = [
      33088,
      33089,
      33090,
      33093,
      33115,
      33129,
      33130,
      33141,
      33142,
      33440,
      33442,
      33444,
      33449,
      33450,
      33451,
      33453,
      33455,
      33457,
      33459,
      33461,
      33463,
      33469,
      33470,
      33473,
      33476,
      33477,
      33478,
      33480,
      33481,
      33484,
      33485,
      33500,
      33504,
      33511,
      33512,
      33513,
      33514,
      33520,
      33521,
      33601,
      33603,
      33614,
      33615,
      33624,
      33630,
      33634,
      33639,
      33653,
      33654,
      33673,
      33674,
      33675,
      33677,
      33683,
      36502,
      37882,
      38314
    ];
    this.nextChar = function(iter, det) {
      iter.index = iter.nextIndex;
      iter.error = false;
      var firstByte;
      firstByte = iter.charValue = iter.nextByte(det);
      if (firstByte < 0)
        return false;
      if (firstByte <= 127 || firstByte > 160 && firstByte <= 223)
        return true;
      var secondByte = iter.nextByte(det);
      if (secondByte < 0)
        return false;
      iter.charValue = firstByte << 8 | secondByte;
      if (!(secondByte >= 64 && secondByte <= 127 || secondByte >= 128 && secondByte <= 255)) {
        iter.error = true;
      }
      return true;
    };
  };
  util.inherits(exports.sjis, mbcs);
  exports.big5 = function() {
    this.name = function() {
      return "Big5";
    };
    this.language = function() {
      return "zh";
    };
    this.commonChars = [
      41280,
      41281,
      41282,
      41283,
      41287,
      41289,
      41333,
      41334,
      42048,
      42054,
      42055,
      42056,
      42065,
      42068,
      42071,
      42084,
      42090,
      42092,
      42103,
      42147,
      42148,
      42151,
      42177,
      42190,
      42193,
      42207,
      42216,
      42237,
      42304,
      42312,
      42328,
      42345,
      42445,
      42471,
      42583,
      42593,
      42594,
      42600,
      42608,
      42664,
      42675,
      42681,
      42707,
      42715,
      42726,
      42738,
      42816,
      42833,
      42841,
      42970,
      43171,
      43173,
      43181,
      43217,
      43219,
      43236,
      43260,
      43456,
      43474,
      43507,
      43627,
      43706,
      43710,
      43724,
      43772,
      44103,
      44111,
      44208,
      44242,
      44377,
      44745,
      45024,
      45290,
      45423,
      45747,
      45764,
      45935,
      46156,
      46158,
      46412,
      46501,
      46525,
      46544,
      46552,
      46705,
      47085,
      47207,
      47428,
      47832,
      47940,
      48033,
      48593,
      49860,
      50105,
      50240,
      50271
    ];
    this.nextChar = function(iter, det) {
      iter.index = iter.nextIndex;
      iter.error = false;
      var firstByte = iter.charValue = iter.nextByte(det);
      if (firstByte < 0)
        return false;
      if (firstByte <= 127 || firstByte == 255)
        return true;
      var secondByte = iter.nextByte(det);
      if (secondByte < 0)
        return false;
      iter.charValue = iter.charValue << 8 | secondByte;
      if (secondByte < 64 || secondByte == 127 || secondByte == 255)
        iter.error = true;
      return true;
    };
  };
  util.inherits(exports.big5, mbcs);
  function eucNextChar(iter, det) {
    iter.index = iter.nextIndex;
    iter.error = false;
    var firstByte = 0;
    var secondByte = 0;
    var thirdByte = 0;
    buildChar: {
      firstByte = iter.charValue = iter.nextByte(det);
      if (firstByte < 0) {
        iter.done = true;
        break buildChar;
      }
      if (firstByte <= 141) {
        break buildChar;
      }
      secondByte = iter.nextByte(det);
      iter.charValue = iter.charValue << 8 | secondByte;
      if (firstByte >= 161 && firstByte <= 254) {
        if (secondByte < 161) {
          iter.error = true;
        }
        break buildChar;
      }
      if (firstByte == 142) {
        if (secondByte < 161) {
          iter.error = true;
        }
        break buildChar;
      }
      if (firstByte == 143) {
        thirdByte = iter.nextByte(det);
        iter.charValue = iter.charValue << 8 | thirdByte;
        if (thirdByte < 161) {
          iter.error = true;
        }
      }
    }
    return iter.done == false;
  }
  exports.euc_jp = function() {
    this.name = function() {
      return "EUC-JP";
    };
    this.language = function() {
      return "ja";
    };
    this.commonChars = [
      41377,
      41378,
      41379,
      41382,
      41404,
      41418,
      41419,
      41430,
      41431,
      42146,
      42148,
      42150,
      42152,
      42154,
      42155,
      42156,
      42157,
      42159,
      42161,
      42163,
      42165,
      42167,
      42169,
      42171,
      42173,
      42175,
      42176,
      42177,
      42179,
      42180,
      42182,
      42183,
      42184,
      42185,
      42186,
      42187,
      42190,
      42191,
      42192,
      42206,
      42207,
      42209,
      42210,
      42212,
      42216,
      42217,
      42218,
      42219,
      42220,
      42223,
      42226,
      42227,
      42402,
      42403,
      42404,
      42406,
      42407,
      42410,
      42413,
      42415,
      42416,
      42419,
      42421,
      42423,
      42424,
      42425,
      42431,
      42435,
      42438,
      42439,
      42440,
      42441,
      42443,
      42448,
      42453,
      42454,
      42455,
      42462,
      42464,
      42465,
      42469,
      42473,
      42474,
      42475,
      42476,
      42477,
      42483,
      47273,
      47572,
      47854,
      48072,
      48880,
      49079,
      50410,
      50940,
      51133,
      51896,
      51955,
      52188,
      52689
    ];
    this.nextChar = eucNextChar;
  };
  util.inherits(exports.euc_jp, mbcs);
  exports.euc_kr = function() {
    this.name = function() {
      return "EUC-KR";
    };
    this.language = function() {
      return "ko";
    };
    this.commonChars = [
      45217,
      45235,
      45253,
      45261,
      45268,
      45286,
      45293,
      45304,
      45306,
      45308,
      45496,
      45497,
      45511,
      45527,
      45538,
      45994,
      46011,
      46274,
      46287,
      46297,
      46315,
      46501,
      46517,
      46527,
      46535,
      46569,
      46835,
      47023,
      47042,
      47054,
      47270,
      47278,
      47286,
      47288,
      47291,
      47337,
      47531,
      47534,
      47564,
      47566,
      47613,
      47800,
      47822,
      47824,
      47857,
      48103,
      48115,
      48125,
      48301,
      48314,
      48338,
      48374,
      48570,
      48576,
      48579,
      48581,
      48838,
      48840,
      48863,
      48878,
      48888,
      48890,
      49057,
      49065,
      49088,
      49124,
      49131,
      49132,
      49144,
      49319,
      49327,
      49336,
      49338,
      49339,
      49341,
      49351,
      49356,
      49358,
      49359,
      49366,
      49370,
      49381,
      49403,
      49404,
      49572,
      49574,
      49590,
      49622,
      49631,
      49654,
      49656,
      50337,
      50637,
      50862,
      51151,
      51153,
      51154,
      51160,
      51173,
      51373
    ];
    this.nextChar = eucNextChar;
  };
  util.inherits(exports.euc_kr, mbcs);
  exports.gb_18030 = function() {
    this.name = function() {
      return "GB18030";
    };
    this.language = function() {
      return "zh";
    };
    this.nextChar = function(iter, det) {
      iter.index = iter.nextIndex;
      iter.error = false;
      var firstByte = 0;
      var secondByte = 0;
      var thirdByte = 0;
      var fourthByte = 0;
      buildChar: {
        firstByte = iter.charValue = iter.nextByte(det);
        if (firstByte < 0) {
          iter.done = true;
          break buildChar;
        }
        if (firstByte <= 128) {
          break buildChar;
        }
        secondByte = iter.nextByte(det);
        iter.charValue = iter.charValue << 8 | secondByte;
        if (firstByte >= 129 && firstByte <= 254) {
          if (secondByte >= 64 && secondByte <= 126 || secondByte >= 80 && secondByte <= 254) {
            break buildChar;
          }
          if (secondByte >= 48 && secondByte <= 57) {
            thirdByte = iter.nextByte(det);
            if (thirdByte >= 129 && thirdByte <= 254) {
              fourthByte = iter.nextByte(det);
              if (fourthByte >= 48 && fourthByte <= 57) {
                iter.charValue = iter.charValue << 16 | thirdByte << 8 | fourthByte;
                break buildChar;
              }
            }
          }
          iter.error = true;
          break buildChar;
        }
      }
      return iter.done == false;
    };
    this.commonChars = [
      41377,
      41378,
      41379,
      41380,
      41392,
      41393,
      41457,
      41459,
      41889,
      41900,
      41914,
      45480,
      45496,
      45502,
      45755,
      46025,
      46070,
      46323,
      46525,
      46532,
      46563,
      46767,
      46804,
      46816,
      47010,
      47016,
      47037,
      47062,
      47069,
      47284,
      47327,
      47350,
      47531,
      47561,
      47576,
      47610,
      47613,
      47821,
      48039,
      48086,
      48097,
      48122,
      48316,
      48347,
      48382,
      48588,
      48845,
      48861,
      49076,
      49094,
      49097,
      49332,
      49389,
      49611,
      49883,
      50119,
      50396,
      50410,
      50636,
      50935,
      51192,
      51371,
      51403,
      51413,
      51431,
      51663,
      51706,
      51889,
      51893,
      51911,
      51920,
      51926,
      51957,
      51965,
      52460,
      52728,
      52906,
      52932,
      52946,
      52965,
      53173,
      53186,
      53206,
      53442,
      53445,
      53456,
      53460,
      53671,
      53930,
      53938,
      53941,
      53947,
      53972,
      54211,
      54224,
      54269,
      54466,
      54490,
      54754,
      54992
    ];
  };
  util.inherits(exports.gb_18030, mbcs);
});

// node_modules/chardet/encoding/sbcs.js
var require_sbcs = __commonJS((exports, module) => {
  var util = __require("util");
  var Match = require_match();
  function NGramParser(theNgramList, theByteMap) {
    var N_GRAM_MASK = 16777215;
    this.byteIndex = 0;
    this.ngram = 0;
    this.ngramList = theNgramList;
    this.byteMap = theByteMap;
    this.ngramCount = 0;
    this.hitCount = 0;
    this.spaceChar;
    this.search = function(table, value) {
      var index = 0;
      if (table[index + 32] <= value)
        index += 32;
      if (table[index + 16] <= value)
        index += 16;
      if (table[index + 8] <= value)
        index += 8;
      if (table[index + 4] <= value)
        index += 4;
      if (table[index + 2] <= value)
        index += 2;
      if (table[index + 1] <= value)
        index += 1;
      if (table[index] > value)
        index -= 1;
      if (index < 0 || table[index] != value)
        return -1;
      return index;
    };
    this.lookup = function(thisNgram) {
      this.ngramCount += 1;
      if (this.search(this.ngramList, thisNgram) >= 0) {
        this.hitCount += 1;
      }
    };
    this.addByte = function(b) {
      this.ngram = (this.ngram << 8) + (b & 255) & N_GRAM_MASK;
      this.lookup(this.ngram);
    };
    this.nextByte = function(det) {
      if (this.byteIndex >= det.fInputLen)
        return -1;
      return det.fInputBytes[this.byteIndex++] & 255;
    };
    this.parse = function(det, spaceCh) {
      var b, ignoreSpace = false;
      this.spaceChar = spaceCh;
      while ((b = this.nextByte(det)) >= 0) {
        var mb = this.byteMap[b];
        if (mb != 0) {
          if (!(mb == this.spaceChar && ignoreSpace)) {
            this.addByte(mb);
          }
          ignoreSpace = mb == this.spaceChar;
        }
      }
      this.addByte(this.spaceChar);
      var rawPercent = this.hitCount / this.ngramCount;
      if (rawPercent > 0.33)
        return 98;
      return Math.floor(rawPercent * 300);
    };
  }
  function NGramsPlusLang(la, ng) {
    this.fLang = la;
    this.fNGrams = ng;
  }
  function sbcs() {
  }
  sbcs.prototype.spaceChar = 32;
  sbcs.prototype.ngrams = function() {
  };
  sbcs.prototype.byteMap = function() {
  };
  sbcs.prototype.match = function(det) {
    var ngrams = this.ngrams();
    var multiple = Array.isArray(ngrams) && ngrams[0] instanceof NGramsPlusLang;
    if (!multiple) {
      var parser = new NGramParser(ngrams, this.byteMap());
      var confidence = parser.parse(det, this.spaceChar);
      return confidence <= 0 ? null : new Match(det, this, confidence);
    }
    var bestConfidenceSoFar = -1;
    var lang = null;
    for (var i = ngrams.length - 1;i >= 0; i--) {
      var ngl = ngrams[i];
      var parser = new NGramParser(ngl.fNGrams, this.byteMap());
      var confidence = parser.parse(det, this.spaceChar);
      if (confidence > bestConfidenceSoFar) {
        bestConfidenceSoFar = confidence;
        lang = ngl.fLang;
      }
    }
    var name = this.name(det);
    return bestConfidenceSoFar <= 0 ? null : new Match(det, this, bestConfidenceSoFar, name, lang);
  };
  exports.ISO_8859_1 = function() {
    this.byteMap = function() {
      return [
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        0,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        170,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        181,
        32,
        32,
        32,
        32,
        186,
        32,
        32,
        32,
        32,
        32,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        32,
        248,
        249,
        250,
        251,
        252,
        253,
        254,
        223,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        32,
        248,
        249,
        250,
        251,
        252,
        253,
        254,
        255
      ];
    };
    this.ngrams = function() {
      return [
        new NGramsPlusLang("da", [
          2122086,
          2122100,
          2122853,
          2123118,
          2123122,
          2123375,
          2123873,
          2124064,
          2125157,
          2125671,
          2126053,
          2126697,
          2126708,
          2126953,
          2127465,
          6383136,
          6385184,
          6385252,
          6386208,
          6386720,
          6579488,
          6579566,
          6579570,
          6579572,
          6627443,
          6644768,
          6644837,
          6647328,
          6647396,
          6648352,
          6648421,
          6648608,
          6648864,
          6713202,
          6776096,
          6776174,
          6776178,
          6907749,
          6908960,
          6909543,
          7038240,
          7039845,
          7103858,
          7104871,
          7105637,
          7169380,
          7234661,
          7234848,
          7235360,
          7235429,
          7300896,
          7302432,
          7303712,
          7398688,
          7479396,
          7479397,
          7479411,
          7496992,
          7566437,
          7610483,
          7628064,
          7628146,
          7629164,
          7759218
        ]),
        new NGramsPlusLang("de", [
          2122094,
          2122101,
          2122341,
          2122849,
          2122853,
          2122857,
          2123113,
          2123621,
          2123873,
          2124142,
          2125161,
          2126691,
          2126693,
          2127214,
          2127461,
          2127471,
          2127717,
          2128501,
          6448498,
          6514720,
          6514789,
          6514804,
          6578547,
          6579566,
          6579570,
          6580581,
          6627428,
          6627443,
          6646126,
          6646132,
          6647328,
          6648352,
          6648608,
          6776174,
          6841710,
          6845472,
          6906728,
          6907168,
          6909472,
          6909541,
          6911008,
          7104867,
          7105637,
          7217249,
          7217252,
          7217267,
          7234592,
          7234661,
          7234848,
          7235360,
          7235429,
          7238757,
          7479396,
          7496805,
          7497065,
          7562088,
          7566437,
          7610468,
          7628064,
          7628142,
          7628146,
          7695972,
          7695975,
          7759218
        ]),
        new NGramsPlusLang("en", [
          2122016,
          2122094,
          2122341,
          2122607,
          2123375,
          2123873,
          2123877,
          2124142,
          2125153,
          2125670,
          2125938,
          2126437,
          2126689,
          2126708,
          2126952,
          2126959,
          2127720,
          6383972,
          6384672,
          6385184,
          6385252,
          6386464,
          6386720,
          6386789,
          6386793,
          6561889,
          6561908,
          6627425,
          6627443,
          6627444,
          6644768,
          6647412,
          6648352,
          6648608,
          6713202,
          6840692,
          6841632,
          6841714,
          6906912,
          6909472,
          6909543,
          6909806,
          6910752,
          7217249,
          7217268,
          7234592,
          7235360,
          7238688,
          7300640,
          7302688,
          7303712,
          7496992,
          7500576,
          7544929,
          7544948,
          7561577,
          7566368,
          7610484,
          7628146,
          7628897,
          7628901,
          7629167,
          7630624,
          7631648
        ]),
        new NGramsPlusLang("es", [
          2122016,
          2122593,
          2122607,
          2122853,
          2123116,
          2123118,
          2123123,
          2124142,
          2124897,
          2124911,
          2125921,
          2125935,
          2125938,
          2126197,
          2126437,
          2126693,
          2127214,
          2128160,
          6365283,
          6365284,
          6365285,
          6365292,
          6365296,
          6382441,
          6382703,
          6384672,
          6386208,
          6386464,
          6515187,
          6516590,
          6579488,
          6579564,
          6582048,
          6627428,
          6627429,
          6627436,
          6646816,
          6647328,
          6647412,
          6648608,
          6648692,
          6907246,
          6943598,
          7102752,
          7106419,
          7217253,
          7238757,
          7282788,
          7282789,
          7302688,
          7303712,
          7303968,
          7364978,
          7435621,
          7495968,
          7497075,
          7544932,
          7544933,
          7544944,
          7562528,
          7628064,
          7630624,
          7693600,
          15953440
        ]),
        new NGramsPlusLang("fr", [
          2122101,
          2122607,
          2122849,
          2122853,
          2122869,
          2123118,
          2123124,
          2124897,
          2124901,
          2125921,
          2125935,
          2125938,
          2126197,
          2126693,
          2126703,
          2127214,
          2154528,
          6385268,
          6386793,
          6513952,
          6516590,
          6579488,
          6579571,
          6583584,
          6627425,
          6627427,
          6627428,
          6627429,
          6627436,
          6627440,
          6627443,
          6647328,
          6647412,
          6648352,
          6648608,
          6648864,
          6649202,
          6909806,
          6910752,
          6911008,
          7102752,
          7103776,
          7103859,
          7169390,
          7217252,
          7234848,
          7238432,
          7238688,
          7302688,
          7302772,
          7304562,
          7435621,
          7479404,
          7496992,
          7544929,
          7544932,
          7544933,
          7544940,
          7544944,
          7610468,
          7628064,
          7629167,
          7693600,
          7696928
        ]),
        new NGramsPlusLang("it", [
          2122092,
          2122600,
          2122607,
          2122853,
          2122857,
          2123040,
          2124140,
          2124142,
          2124897,
          2125925,
          2125938,
          2127214,
          6365283,
          6365284,
          6365296,
          6365299,
          6386799,
          6514789,
          6516590,
          6579564,
          6580512,
          6627425,
          6627427,
          6627428,
          6627433,
          6627436,
          6627440,
          6627443,
          6646816,
          6646892,
          6647412,
          6648352,
          6841632,
          6889569,
          6889571,
          6889572,
          6889587,
          6906144,
          6908960,
          6909472,
          6909806,
          7102752,
          7103776,
          7104800,
          7105633,
          7234848,
          7235872,
          7237408,
          7238757,
          7282785,
          7282788,
          7282793,
          7282803,
          7302688,
          7302757,
          7366002,
          7495968,
          7496992,
          7563552,
          7627040,
          7628064,
          7629088,
          7630624,
          8022383
        ]),
        new NGramsPlusLang("nl", [
          2122092,
          2122341,
          2122849,
          2122853,
          2122857,
          2123109,
          2123118,
          2123621,
          2123877,
          2124142,
          2125153,
          2125157,
          2125680,
          2126949,
          2127457,
          2127461,
          2127471,
          2127717,
          2128489,
          6381934,
          6381938,
          6385184,
          6385252,
          6386208,
          6386720,
          6514804,
          6579488,
          6579566,
          6579570,
          6627426,
          6627446,
          6645102,
          6645106,
          6647328,
          6648352,
          6648435,
          6648864,
          6776174,
          6841716,
          6907168,
          6909472,
          6909543,
          6910752,
          7217250,
          7217252,
          7217253,
          7217256,
          7217263,
          7217270,
          7234661,
          7235360,
          7302756,
          7303026,
          7303200,
          7303712,
          7562088,
          7566437,
          7610468,
          7628064,
          7628142,
          7628146,
          7758190,
          7759218,
          7761775
        ]),
        new NGramsPlusLang("no", [
          2122100,
          2122102,
          2122853,
          2123118,
          2123122,
          2123375,
          2123873,
          2124064,
          2125157,
          2125671,
          2126053,
          2126693,
          2126699,
          2126703,
          2126708,
          2126953,
          2127465,
          2155808,
          6385252,
          6386208,
          6386720,
          6579488,
          6579566,
          6579572,
          6627443,
          6644768,
          6647328,
          6647397,
          6648352,
          6648421,
          6648864,
          6648948,
          6713202,
          6776174,
          6908779,
          6908960,
          6909543,
          7038240,
          7039845,
          7103776,
          7105637,
          7169380,
          7169390,
          7217267,
          7234848,
          7235360,
          7235429,
          7237221,
          7300896,
          7302432,
          7303712,
          7398688,
          7479411,
          7496992,
          7565165,
          7566437,
          7610483,
          7628064,
          7628142,
          7628146,
          7629164,
          7631904,
          7631973,
          7759218
        ]),
        new NGramsPlusLang("pt", [
          2122016,
          2122607,
          2122849,
          2122853,
          2122863,
          2123040,
          2123123,
          2125153,
          2125423,
          2125600,
          2125921,
          2125935,
          2125938,
          2126197,
          2126437,
          2126693,
          2127213,
          6365281,
          6365283,
          6365284,
          6365296,
          6382693,
          6382703,
          6384672,
          6386208,
          6386273,
          6386464,
          6516589,
          6516590,
          6578464,
          6579488,
          6582048,
          6582131,
          6627425,
          6627428,
          6647072,
          6647412,
          6648608,
          6648692,
          6906144,
          6906721,
          7169390,
          7238757,
          7238767,
          7282785,
          7282787,
          7282788,
          7282789,
          7282800,
          7303968,
          7364978,
          7435621,
          7495968,
          7497075,
          7544929,
          7544932,
          7544933,
          7544944,
          7566433,
          7628064,
          7630624,
          7693600,
          14905120,
          15197039
        ]),
        new NGramsPlusLang("sv", [
          2122100,
          2122102,
          2122853,
          2123118,
          2123510,
          2123873,
          2124064,
          2124142,
          2124655,
          2125157,
          2125667,
          2126053,
          2126699,
          2126703,
          2126708,
          2126953,
          2127457,
          2127465,
          2155634,
          6382693,
          6385184,
          6385252,
          6386208,
          6386804,
          6514720,
          6579488,
          6579566,
          6579570,
          6579572,
          6644768,
          6647328,
          6648352,
          6648864,
          6747762,
          6776174,
          6909036,
          6909543,
          7037216,
          7105568,
          7169380,
          7217267,
          7233824,
          7234661,
          7235360,
          7235429,
          7235950,
          7299944,
          7302432,
          7302688,
          7398688,
          7479393,
          7479411,
          7495968,
          7564129,
          7565165,
          7610483,
          7627040,
          7628064,
          7628146,
          7629164,
          7631904,
          7758194,
          14971424,
          16151072
        ])
      ];
    };
    this.name = function(det) {
      return det && det.fC1Bytes ? "windows-1252" : "ISO-8859-1";
    };
  };
  util.inherits(exports.ISO_8859_1, sbcs);
  exports.ISO_8859_2 = function() {
    this.byteMap = function() {
      return [
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        0,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        177,
        32,
        179,
        32,
        181,
        182,
        32,
        32,
        185,
        186,
        187,
        188,
        32,
        190,
        191,
        32,
        177,
        32,
        179,
        32,
        181,
        182,
        183,
        32,
        185,
        186,
        187,
        188,
        32,
        190,
        191,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        32,
        248,
        249,
        250,
        251,
        252,
        253,
        254,
        223,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        32,
        248,
        249,
        250,
        251,
        252,
        253,
        254,
        32
      ];
    };
    this.ngrams = function() {
      return [
        new NGramsPlusLang("cs", [
          2122016,
          2122361,
          2122863,
          2124389,
          2125409,
          2125413,
          2125600,
          2125668,
          2125935,
          2125938,
          2126072,
          2126447,
          2126693,
          2126703,
          2126708,
          2126959,
          2127392,
          2127481,
          2128481,
          6365296,
          6513952,
          6514720,
          6627440,
          6627443,
          6627446,
          6647072,
          6647533,
          6844192,
          6844260,
          6910836,
          6972704,
          7042149,
          7103776,
          7104800,
          7233824,
          7268640,
          7269408,
          7269664,
          7282800,
          7300206,
          7301737,
          7304052,
          7304480,
          7304801,
          7368548,
          7368554,
          7369327,
          7403621,
          7562528,
          7565173,
          7566433,
          7566441,
          7566446,
          7628146,
          7630573,
          7630624,
          7676016,
          12477728,
          14773997,
          15296623,
          15540336,
          15540339,
          15559968,
          16278884
        ]),
        new NGramsPlusLang("hu", [
          2122016,
          2122106,
          2122341,
          2123111,
          2123116,
          2123365,
          2123873,
          2123887,
          2124147,
          2124645,
          2124649,
          2124790,
          2124901,
          2125153,
          2125157,
          2125161,
          2125413,
          2126714,
          2126949,
          2156915,
          6365281,
          6365291,
          6365293,
          6365299,
          6384416,
          6385184,
          6388256,
          6447470,
          6448494,
          6645625,
          6646560,
          6646816,
          6646885,
          6647072,
          6647328,
          6648421,
          6648864,
          6648933,
          6648948,
          6781216,
          6844263,
          6909556,
          6910752,
          7020641,
          7075450,
          7169383,
          7170414,
          7217249,
          7233899,
          7234923,
          7234925,
          7238688,
          7300985,
          7544929,
          7567973,
          7567988,
          7568097,
          7596391,
          7610465,
          7631904,
          7659891,
          8021362,
          14773792,
          15299360
        ]),
        new NGramsPlusLang("pl", [
          2122618,
          2122863,
          2124064,
          2124389,
          2124655,
          2125153,
          2125161,
          2125409,
          2125417,
          2125668,
          2125935,
          2125938,
          2126697,
          2127648,
          2127721,
          2127737,
          2128416,
          2128481,
          6365296,
          6365303,
          6385257,
          6514720,
          6519397,
          6519417,
          6582048,
          6584937,
          6627440,
          6627443,
          6627447,
          6627450,
          6645615,
          6646304,
          6647072,
          6647401,
          6778656,
          6906144,
          6907168,
          6907242,
          7037216,
          7039264,
          7039333,
          7170405,
          7233824,
          7235937,
          7235941,
          7282800,
          7305057,
          7305065,
          7368556,
          7369313,
          7369327,
          7369338,
          7502437,
          7502457,
          7563754,
          7564137,
          7566433,
          7825765,
          7955304,
          7957792,
          8021280,
          8022373,
          8026400,
          15955744
        ]),
        new NGramsPlusLang("ro", [
          2122016,
          2122083,
          2122593,
          2122597,
          2122607,
          2122613,
          2122853,
          2122857,
          2124897,
          2125153,
          2125925,
          2125938,
          2126693,
          2126819,
          2127214,
          2144873,
          2158190,
          6365283,
          6365284,
          6386277,
          6386720,
          6386789,
          6386976,
          6513010,
          6516590,
          6518048,
          6546208,
          6579488,
          6627425,
          6627427,
          6627428,
          6627440,
          6627443,
          6644000,
          6646048,
          6646885,
          6647412,
          6648692,
          6889569,
          6889571,
          6889572,
          6889584,
          6907168,
          6908192,
          6909472,
          7102752,
          7103776,
          7106418,
          7107945,
          7234848,
          7238770,
          7303712,
          7365998,
          7496992,
          7497057,
          7501088,
          7594784,
          7628064,
          7631477,
          7660320,
          7694624,
          7695392,
          12216608,
          15625760
        ])
      ];
    };
    this.name = function(det) {
      return det && det.fC1Bytes ? "windows-1250" : "ISO-8859-2";
    };
  };
  util.inherits(exports.ISO_8859_2, sbcs);
  exports.ISO_8859_5 = function() {
    this.byteMap = function() {
      return [
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        0,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250,
        251,
        252,
        32,
        254,
        255,
        208,
        209,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        219,
        220,
        221,
        222,
        223,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        208,
        209,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        219,
        220,
        221,
        222,
        223,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        32,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250,
        251,
        252,
        32,
        254,
        255
      ];
    };
    this.ngrams = function() {
      return [
        2150944,
        2151134,
        2151646,
        2152400,
        2152480,
        2153168,
        2153182,
        2153936,
        2153941,
        2154193,
        2154462,
        2154464,
        2154704,
        2154974,
        2154978,
        2155230,
        2156514,
        2158050,
        13688280,
        13689580,
        13884960,
        14015468,
        14015960,
        14016994,
        14017056,
        14164191,
        14210336,
        14211104,
        14216992,
        14407133,
        14407712,
        14413021,
        14536736,
        14538016,
        14538965,
        14538991,
        14540320,
        14540498,
        14557394,
        14557407,
        14557409,
        14602784,
        14602960,
        14603230,
        14604576,
        14605292,
        14605344,
        14606818,
        14671579,
        14672085,
        14672088,
        14672094,
        14733522,
        14734804,
        14803664,
        14803666,
        14803672,
        14806816,
        14865883,
        14868000,
        14868192,
        14871584,
        15196894,
        15459616
      ];
    };
    this.name = function(det) {
      return "ISO-8859-5";
    };
    this.language = function() {
      return "ru";
    };
  };
  util.inherits(exports.ISO_8859_5, sbcs);
  exports.ISO_8859_6 = function() {
    this.byteMap = function() {
      return [
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        0,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        193,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        32,
        32,
        32,
        32,
        32,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32
      ];
    };
    this.ngrams = function() {
      return [
        2148324,
        2148326,
        2148551,
        2152932,
        2154986,
        2155748,
        2156006,
        2156743,
        13050055,
        13091104,
        13093408,
        13095200,
        13100064,
        13100227,
        13100231,
        13100232,
        13100234,
        13100236,
        13100237,
        13100239,
        13100243,
        13100249,
        13100258,
        13100261,
        13100264,
        13100266,
        13100320,
        13100576,
        13100746,
        13115591,
        13181127,
        13181153,
        13181156,
        13181157,
        13181160,
        13246663,
        13574343,
        13617440,
        13705415,
        13748512,
        13836487,
        14229703,
        14279913,
        14805536,
        14950599,
        14993696,
        15001888,
        15002144,
        15016135,
        15058720,
        15059232,
        15066656,
        15081671,
        15147207,
        15189792,
        15255524,
        15263264,
        15278279,
        15343815,
        15343845,
        15343848,
        15386912,
        15388960,
        15394336
      ];
    };
    this.name = function(det) {
      return "ISO-8859-6";
    };
    this.language = function() {
      return "ar";
    };
  };
  util.inherits(exports.ISO_8859_6, sbcs);
  exports.ISO_8859_7 = function() {
    this.byteMap = function() {
      return [
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        0,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        161,
        162,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        220,
        32,
        221,
        222,
        223,
        32,
        252,
        32,
        253,
        254,
        192,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        32,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250,
        251,
        220,
        221,
        222,
        223,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250,
        251,
        252,
        253,
        254,
        32
      ];
    };
    this.ngrams = function() {
      return [
        2154989,
        2154992,
        2155497,
        2155753,
        2156016,
        2156320,
        2157281,
        2157797,
        2158049,
        2158368,
        2158817,
        2158831,
        2158833,
        2159604,
        2159605,
        2159847,
        2159855,
        14672160,
        14754017,
        14754036,
        14805280,
        14806304,
        14807292,
        14807584,
        14936545,
        15067424,
        15069728,
        15147252,
        15199520,
        15200800,
        15278324,
        15327520,
        15330014,
        15331872,
        15393257,
        15393268,
        15525152,
        15540449,
        15540453,
        15540464,
        15589664,
        15725088,
        15725856,
        15790069,
        15790575,
        15793184,
        15868129,
        15868133,
        15868138,
        15868144,
        15868148,
        15983904,
        15984416,
        15987951,
        16048416,
        16048617,
        16050157,
        16050162,
        16050666,
        16052000,
        16052213,
        16054765,
        16379168,
        16706848
      ];
    };
    this.name = function(det) {
      return det && det.fC1Bytes ? "windows-1253" : "ISO-8859-7";
    };
    this.language = function() {
      return "el";
    };
  };
  util.inherits(exports.ISO_8859_7, sbcs);
  exports.ISO_8859_8 = function() {
    this.byteMap = function() {
      return [
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        0,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        181,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250,
        32,
        32,
        32,
        32,
        32
      ];
    };
    this.ngrams = function() {
      return [
        new NGramsPlusLang("he", [
          2154725,
          2154727,
          2154729,
          2154746,
          2154985,
          2154990,
          2155744,
          2155749,
          2155753,
          2155758,
          2155762,
          2155769,
          2155770,
          2157792,
          2157796,
          2158304,
          2159340,
          2161132,
          14744096,
          14950624,
          14950625,
          14950628,
          14950636,
          14950638,
          14950649,
          15001056,
          15065120,
          15068448,
          15068960,
          15071264,
          15071776,
          15278308,
          15328288,
          15328762,
          15329773,
          15330592,
          15331104,
          15333408,
          15333920,
          15474912,
          15474916,
          15523872,
          15524896,
          15540448,
          15540449,
          15540452,
          15540460,
          15540462,
          15540473,
          15655968,
          15671524,
          15787040,
          15788320,
          15788525,
          15920160,
          16261348,
          16312813,
          16378912,
          16392416,
          16392417,
          16392420,
          16392428,
          16392430,
          16392441
        ]),
        new NGramsPlusLang("he", [
          2154725,
          2154732,
          2155753,
          2155756,
          2155758,
          2155760,
          2157040,
          2157810,
          2157817,
          2158053,
          2158057,
          2158565,
          2158569,
          2160869,
          2160873,
          2161376,
          2161381,
          2161385,
          14688484,
          14688492,
          14688493,
          14688506,
          14738464,
          14738916,
          14740512,
          14741024,
          14754020,
          14754029,
          14754042,
          14950628,
          14950633,
          14950636,
          14950637,
          14950639,
          14950648,
          14950650,
          15002656,
          15065120,
          15066144,
          15196192,
          15327264,
          15327520,
          15328288,
          15474916,
          15474925,
          15474938,
          15528480,
          15530272,
          15591913,
          15591920,
          15591928,
          15605988,
          15605997,
          15606010,
          15655200,
          15655968,
          15918112,
          16326884,
          16326893,
          16326906,
          16376864,
          16441376,
          16442400,
          16442857
        ])
      ];
    };
    this.name = function(det) {
      return det && det.fC1Bytes ? "windows-1255" : "ISO-8859-8";
    };
    this.language = function() {
      return "he";
    };
  };
  util.inherits(exports.ISO_8859_8, sbcs);
  exports.ISO_8859_9 = function() {
    this.byteMap = function() {
      return [
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        0,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        170,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        181,
        32,
        32,
        32,
        32,
        186,
        32,
        32,
        32,
        32,
        32,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        32,
        248,
        249,
        250,
        251,
        252,
        105,
        254,
        223,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        32,
        248,
        249,
        250,
        251,
        252,
        253,
        254,
        255
      ];
    };
    this.ngrams = function() {
      return [
        2122337,
        2122345,
        2122357,
        2122849,
        2122853,
        2123621,
        2123873,
        2124140,
        2124641,
        2124655,
        2125153,
        2125676,
        2126689,
        2126945,
        2127461,
        2128225,
        6365282,
        6384416,
        6384737,
        6384993,
        6385184,
        6385405,
        6386208,
        6386273,
        6386429,
        6386685,
        6388065,
        6449522,
        6578464,
        6579488,
        6580512,
        6627426,
        6627435,
        6644841,
        6647328,
        6648352,
        6648425,
        6648681,
        6909029,
        6909472,
        6909545,
        6910496,
        7102830,
        7102834,
        7103776,
        7103858,
        7217249,
        7217250,
        7217259,
        7234657,
        7234661,
        7234848,
        7235872,
        7235950,
        7273760,
        7498094,
        7535982,
        7759136,
        7954720,
        7958386,
        16608800,
        16608868,
        16609021,
        16642301
      ];
    };
    this.name = function(det) {
      return det && det.fC1Bytes ? "windows-1254" : "ISO-8859-9";
    };
    this.language = function() {
      return "tr";
    };
  };
  util.inherits(exports.ISO_8859_9, sbcs);
  exports.windows_1251 = function() {
    this.byteMap = function() {
      return [
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        0,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        144,
        131,
        32,
        131,
        32,
        32,
        32,
        32,
        32,
        32,
        154,
        32,
        156,
        157,
        158,
        159,
        144,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        154,
        32,
        156,
        157,
        158,
        159,
        32,
        162,
        162,
        188,
        32,
        180,
        32,
        32,
        184,
        32,
        186,
        32,
        32,
        32,
        32,
        191,
        32,
        32,
        179,
        179,
        180,
        181,
        32,
        32,
        184,
        32,
        186,
        32,
        188,
        190,
        190,
        191,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250,
        251,
        252,
        253,
        254,
        255,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250,
        251,
        252,
        253,
        254,
        255
      ];
    };
    this.ngrams = function() {
      return [
        2155040,
        2155246,
        2155758,
        2156512,
        2156576,
        2157280,
        2157294,
        2158048,
        2158053,
        2158305,
        2158574,
        2158576,
        2158816,
        2159086,
        2159090,
        2159342,
        2160626,
        2162162,
        14740968,
        14742268,
        14937632,
        15068156,
        15068648,
        15069682,
        15069728,
        15212783,
        15263008,
        15263776,
        15269664,
        15459821,
        15460384,
        15465709,
        15589408,
        15590688,
        15591653,
        15591679,
        15592992,
        15593186,
        15605986,
        15605999,
        15606001,
        15655456,
        15655648,
        15655918,
        15657248,
        15657980,
        15658016,
        15659506,
        15724267,
        15724773,
        15724776,
        15724782,
        15786210,
        15787492,
        15856352,
        15856354,
        15856360,
        15859488,
        15918571,
        15920672,
        15920880,
        15924256,
        16249582,
        16512288
      ];
    };
    this.name = function(det) {
      return "windows-1251";
    };
    this.language = function() {
      return "ru";
    };
  };
  util.inherits(exports.windows_1251, sbcs);
  exports.windows_1256 = function() {
    this.byteMap = function() {
      return [
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        0,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        129,
        32,
        131,
        32,
        32,
        32,
        32,
        136,
        32,
        138,
        32,
        156,
        141,
        142,
        143,
        144,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        152,
        32,
        154,
        32,
        156,
        32,
        32,
        159,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        170,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        181,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        192,
        193,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        210,
        211,
        212,
        213,
        214,
        32,
        216,
        217,
        218,
        219,
        220,
        221,
        222,
        223,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        32,
        32,
        32,
        32,
        244,
        32,
        32,
        32,
        32,
        249,
        32,
        251,
        252,
        32,
        32,
        255
      ];
    };
    this.ngrams = function() {
      return [
        2148321,
        2148324,
        2148551,
        2153185,
        2153965,
        2154977,
        2155492,
        2156231,
        13050055,
        13091104,
        13093408,
        13095200,
        13099296,
        13099459,
        13099463,
        13099464,
        13099466,
        13099468,
        13099469,
        13099471,
        13099475,
        13099482,
        13099486,
        13099491,
        13099494,
        13099501,
        13099808,
        13100064,
        13100234,
        13115591,
        13181127,
        13181149,
        13181153,
        13181155,
        13181158,
        13246663,
        13574343,
        13617440,
        13705415,
        13748512,
        13836487,
        14295239,
        14344684,
        14544160,
        14753991,
        14797088,
        14806048,
        14806304,
        14885063,
        14927648,
        14928160,
        14935072,
        14950599,
        15016135,
        15058720,
        15124449,
        15131680,
        15474887,
        15540423,
        15540451,
        15540454,
        15583520,
        15585568,
        15590432
      ];
    };
    this.name = function(det) {
      return "windows-1256";
    };
    this.language = function() {
      return "ar";
    };
  };
  util.inherits(exports.windows_1256, sbcs);
  exports.KOI8_R = function() {
    this.byteMap = function() {
      return [
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        0,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        163,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        163,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        32,
        192,
        193,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        219,
        220,
        221,
        222,
        223,
        192,
        193,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        219,
        220,
        221,
        222,
        223
      ];
    };
    this.ngrams = function() {
      return [
        2147535,
        2148640,
        2149313,
        2149327,
        2150081,
        2150085,
        2150338,
        2150607,
        2150610,
        2151105,
        2151375,
        2151380,
        2151631,
        2152224,
        2152399,
        2153153,
        2153684,
        2154196,
        12701385,
        12702936,
        12963032,
        12963529,
        12964820,
        12964896,
        13094688,
        13181136,
        13223200,
        13224224,
        13226272,
        13419982,
        13420832,
        13424846,
        13549856,
        13550880,
        13552069,
        13552081,
        13553440,
        13553623,
        13574352,
        13574355,
        13574359,
        13617103,
        13617696,
        13618392,
        13618464,
        13620180,
        13621024,
        13621185,
        13684684,
        13685445,
        13685449,
        13685455,
        13812183,
        13813188,
        13881632,
        13882561,
        13882569,
        13882583,
        13944268,
        13946656,
        13946834,
        13948960,
        14272544,
        14603471
      ];
    };
    this.name = function(det) {
      return "KOI8-R";
    };
    this.language = function() {
      return "ru";
    };
  };
  util.inherits(exports.KOI8_R, sbcs);
});

// node_modules/chardet/encoding/iso2022.js
var require_iso2022 = __commonJS((exports, module) => {
  var util = __require("util");
  var Match = require_match();
  function ISO_2022() {
  }
  ISO_2022.prototype.match = function(det) {
    var i, j;
    var escN;
    var hits = 0;
    var misses = 0;
    var shifts = 0;
    var quality;
    var text = det.fInputBytes;
    var textLen = det.fInputLen;
    scanInput:
      for (i = 0;i < textLen; i++) {
        if (text[i] == 27) {
          checkEscapes:
            for (escN = 0;escN < this.escapeSequences.length; escN++) {
              var seq = this.escapeSequences[escN];
              if (textLen - i < seq.length)
                continue checkEscapes;
              for (j = 1;j < seq.length; j++)
                if (seq[j] != text[i + j])
                  continue checkEscapes;
              hits++;
              i += seq.length - 1;
              continue scanInput;
            }
          misses++;
        }
        if (text[i] == 14 || text[i] == 15)
          shifts++;
      }
    if (hits == 0)
      return null;
    quality = (100 * hits - 100 * misses) / (hits + misses);
    if (hits + shifts < 5)
      quality -= (5 - (hits + shifts)) * 10;
    return quality <= 0 ? null : new Match(det, this, quality);
  };
  exports.ISO_2022_JP = function() {
    this.name = function() {
      return "ISO-2022-JP";
    };
    this.escapeSequences = [
      [27, 36, 40, 67],
      [27, 36, 40, 68],
      [27, 36, 64],
      [27, 36, 65],
      [27, 36, 66],
      [27, 38, 64],
      [27, 40, 66],
      [27, 40, 72],
      [27, 40, 73],
      [27, 40, 74],
      [27, 46, 65],
      [27, 46, 70]
    ];
  };
  util.inherits(exports.ISO_2022_JP, ISO_2022);
  exports.ISO_2022_KR = function() {
    this.name = function() {
      return "ISO-2022-KR";
    };
    this.escapeSequences = [
      [27, 36, 41, 67]
    ];
  };
  util.inherits(exports.ISO_2022_KR, ISO_2022);
  exports.ISO_2022_CN = function() {
    this.name = function() {
      return "ISO-2022-CN";
    };
    this.escapeSequences = [
      [27, 36, 41, 65],
      [27, 36, 41, 71],
      [27, 36, 42, 72],
      [27, 36, 41, 69],
      [27, 36, 43, 73],
      [27, 36, 43, 74],
      [27, 36, 43, 75],
      [27, 36, 43, 76],
      [27, 36, 43, 77],
      [27, 78],
      [27, 79]
    ];
  };
  util.inherits(exports.ISO_2022_CN, ISO_2022);
});

// node_modules/chardet/index.js
var require_chardet = __commonJS((exports, module) => {
  var fs = __require("fs");
  var utf8 = require_utf8();
  var unicode = require_unicode();
  var mbcs = require_mbcs();
  var sbcs = require_sbcs();
  var iso2022 = require_iso2022();
  var self2 = exports;
  var recognisers = [
    new utf8,
    new unicode.UTF_16BE,
    new unicode.UTF_16LE,
    new unicode.UTF_32BE,
    new unicode.UTF_32LE,
    new mbcs.sjis,
    new mbcs.big5,
    new mbcs.euc_jp,
    new mbcs.euc_kr,
    new mbcs.gb_18030,
    new iso2022.ISO_2022_JP,
    new iso2022.ISO_2022_KR,
    new iso2022.ISO_2022_CN,
    new sbcs.ISO_8859_1,
    new sbcs.ISO_8859_2,
    new sbcs.ISO_8859_5,
    new sbcs.ISO_8859_6,
    new sbcs.ISO_8859_7,
    new sbcs.ISO_8859_8,
    new sbcs.ISO_8859_9,
    new sbcs.windows_1251,
    new sbcs.windows_1256,
    new sbcs.KOI8_R
  ];
  module.exports.detect = function(buffer, opts) {
    var fByteStats = [];
    for (var i = 0;i < 256; i++)
      fByteStats[i] = 0;
    for (var i = buffer.length - 1;i >= 0; i--)
      fByteStats[buffer[i] & 255]++;
    var fC1Bytes = false;
    for (var i = 128;i <= 159; i += 1) {
      if (fByteStats[i] != 0) {
        fC1Bytes = true;
        break;
      }
    }
    var context = {
      fByteStats,
      fC1Bytes,
      fRawInput: buffer,
      fRawLength: buffer.length,
      fInputBytes: buffer,
      fInputLen: buffer.length
    };
    var matches = recognisers.map(function(rec) {
      return rec.match(context);
    }).filter(function(match) {
      return !!match;
    }).sort(function(a, b) {
      return b.confidence - a.confidence;
    });
    if (opts && opts.returnAllMatches === true) {
      return matches;
    } else {
      return matches.length > 0 ? matches[0].name : null;
    }
  };
  module.exports.detectFile = function(filepath, opts, cb) {
    if (typeof opts === "function") {
      cb = opts;
      opts = undefined;
    }
    var fd;
    var handler = function(err, buffer) {
      if (fd) {
        fs.closeSync(fd);
      }
      if (err)
        return cb(err, null);
      cb(null, self2.detect(buffer, opts));
    };
    if (opts && opts.sampleSize) {
      fd = fs.openSync(filepath, "r"), sample = Buffer.allocUnsafe(opts.sampleSize);
      fs.read(fd, sample, 0, opts.sampleSize, null, function(err) {
        handler(err, sample);
      });
      return;
    }
    fs.readFile(filepath, handler);
  };
  module.exports.detectFileSync = function(filepath, opts) {
    if (opts && opts.sampleSize) {
      var fd = fs.openSync(filepath, "r"), sample2 = Buffer.allocUnsafe(opts.sampleSize);
      fs.readSync(fd, sample2, 0, opts.sampleSize);
      fs.closeSync(fd);
      return self2.detect(sample2, opts);
    }
    return self2.detect(fs.readFileSync(filepath), opts);
  };
  module.exports.detectAll = function(buffer, opts) {
    if (typeof opts !== "object") {
      opts = {};
    }
    opts.returnAllMatches = true;
    return self2.detect(buffer, opts);
  };
  module.exports.detectFileAll = function(filepath, opts, cb) {
    if (typeof opts === "function") {
      cb = opts;
      opts = undefined;
    }
    if (typeof opts !== "object") {
      opts = {};
    }
    opts.returnAllMatches = true;
    self2.detectFile(filepath, opts, cb);
  };
  module.exports.detectFileAllSync = function(filepath, opts) {
    if (typeof opts !== "object") {
      opts = {};
    }
    opts.returnAllMatches = true;
    return self2.detectFileSync(filepath, opts);
  };
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS((exports, module) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key2;
  for (key2 in buffer) {
    if (!buffer.hasOwnProperty(key2))
      continue;
    if (key2 === "SlowBuffer" || key2 === "Buffer")
      continue;
    safer[key2] = buffer[key2];
  }
  var Safer = safer.Buffer = {};
  for (key2 in Buffer2) {
    if (!Buffer2.hasOwnProperty(key2))
      continue;
    if (key2 === "allocUnsafe" || key2 === "allocUnsafeSlow")
      continue;
    Safer[key2] = Buffer2[key2];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  module.exports = safer;
});

// node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS((exports) => {
  var BOMChar = "\uFEFF";
  exports.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  exports.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
});

// node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  module.exports = {
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "\uD83D\uDCA9") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = __require("string_decoder").StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder.prototype;
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0;i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0;i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
});

// node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0;i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (;i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
  };
  exports.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var res = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res + trail : res;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2) {
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
        for (var i = 0;i < _len; i += 2) {
          if (buf[i] === 0 && buf[i + 1] !== 0)
            asciiCharsBE++;
          if (buf[i] !== 0 && buf[i + 1] === 0)
            asciiCharsLE++;
        }
        if (asciiCharsBE > asciiCharsLE)
          enc = "utf-16be";
        else if (asciiCharsBE < asciiCharsLE)
          enc = "utf-16le";
      }
    }
    return enc;
  }
});

// node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports.utf7 = Utf7Codec;
  exports.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (i = 0;i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var i;
  var plusChar = 43;
  var minusChar = 45;
  var andChar = 38;
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString();
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  exports.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0;i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[44] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
});

// node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0;i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0;i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0;i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0;i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
});

// node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS((exports, module) => {
  module.exports = {
    "10029": "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: ""
    },
    "808": "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: ""
    },
    mik: {
      type: "_sbcs",
      chars: ""
    },
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    "20866": "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    "21866": "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  };
});

// node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS((exports, module) => {
  module.exports = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    windows874: {
      type: "_sbcs",
      chars: ""
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: ""
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: ""
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: ""
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: ""
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: ""
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: ""
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: ""
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: ""
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: ""
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: ""
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: ""
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: ""
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: ""
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: ""
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: ""
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: ""
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: ""
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: ""
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: ""
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: ""
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: ""
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: ""
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: ""
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: ""
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: ""
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: ""
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: ""
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: ""
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: ""
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: ""
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: ""
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: ""
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: ""
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: ""
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: ""
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: ""
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: ""
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b\t
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: ""
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: ""
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: ""
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: ""
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: ""
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: ""
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: ""
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: ""
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: ""
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: ""
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: ""
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: ""
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: ""
    },
    maccyrillic: {
      type: "_sbcs",
      chars: ""
    },
    macgreek: {
      type: "_sbcs",
      chars: ""
    },
    maciceland: {
      type: "_sbcs",
      chars: ""
    },
    macroman: {
      type: "_sbcs",
      chars: ""
    },
    macromania: {
      type: "_sbcs",
      chars: ""
    },
    macthai: {
      type: "_sbcs",
      chars: "\uFEFF"
    },
    macturkish: {
      type: "_sbcs",
      chars: ""
    },
    macukraine: {
      type: "_sbcs",
      chars: ""
    },
    koi8r: {
      type: "_sbcs",
      chars: ""
    },
    koi8u: {
      type: "_sbcs",
      chars: ""
    },
    koi8ru: {
      type: "_sbcs",
      chars: ""
    },
    koi8t: {
      type: "_sbcs",
      chars: ""
    },
    armscii8: {
      type: "_sbcs",
      chars: ")(.,-"
    },
    rk1048: {
      type: "_sbcs",
      chars: ""
    },
    tcvn: {
      type: "_sbcs",
      chars: `\x00\x03\x07\b\t
\v\f\r\x0E\x0F\x10\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    georgianacademy: {
      type: "_sbcs",
      chars: ""
    },
    georgianps: {
      type: "_sbcs",
      chars: ""
    },
    pt154: {
      type: "_sbcs",
      chars: ""
    },
    viscii: {
      type: "_sbcs",
      chars: `\x00\x01\x03\x04\x07\b\t
\v\f\r\x0E\x0F\x10\x11\x12\x13\x15\x16\x17\x18\x1A\x1B\x1C\x1D\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    iso646cn: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b\t
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    iso646jp: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b\t
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    hproman8: {
      type: "_sbcs",
      chars: ""
    },
    macintosh: {
      type: "_sbcs",
      chars: ""
    },
    ascii: {
      type: "_sbcs",
      chars: ""
    },
    tis620: {
      type: "_sbcs",
      chars: ""
    }
  };
});

// node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._dbcs = DBCSCodec;
  var UNASSIGNED = -1;
  var GB18030_CODE = -2;
  var SEQ_START = -10;
  var NODE_START = -1000;
  var UNASSIGNED_NODE = new Array(256);
  var DEF_CHAR = -1;
  for (i = 0;i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  var i;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0;i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0;i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from;j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = 63;
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i2 = 129;i2 <= 254; i2++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j = 48;j <= 57; j++)
          secondByteNode[j] = NODE_START - thirdByteNodeIdx;
      }
      for (var i2 = 129;i2 <= 254; i2++)
        thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
      for (var i2 = 48;i2 <= 57; i2++)
        fourthByteNode[i2] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (;addr > 0; addr >>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node = this.decodeTables[0];
    for (var i2 = bytes.length - 1;i2 > 0; i2--) {
      var val = node[bytes[i2]];
      if (val == UNASSIGNED) {
        node[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1;k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0;l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m = 0;m < len; m++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0;l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === undefined)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED)
        node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j = 1;j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== undefined)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i2 = 0;i2 < 256; i2++) {
      var uCode = node[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0)
        this._setEncodeChar(uCode, mbCode);
      else if (uCode <= NODE_START)
        this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
      else if (uCode <= SEQ_START)
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length)
          break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== undefined && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == undefined) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== undefined) {
            dbcsCode = resCode;
            nextChar = uCode;
          } else {
          }
        }
        seqObj = undefined;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== undefined)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== undefined) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      } else {
      }
      this.seqObj = undefined;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBuf = Buffer2.alloc(0);
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    if (prevBufOffset > 0)
      prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
    for (var i2 = 0, j = 0;i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) {
      } else if (uCode === UNASSIGNED) {
        i2 = seqStart;
        uCode = this.defaultCharUnicode.charCodeAt(0);
      } else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
        var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0;k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 + uCode % 1024;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBuf.length > 0) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0);
      this.nodeIdx = 0;
      if (buf.length > 0)
        ret += this.write(buf);
    }
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + Math.floor((r - l + 1) / 2);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
});

// node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 128],
    ["a1", "", 62],
    ["8140", "", 9, ""],
    ["8180", ""],
    ["81b8", ""],
    ["81c8", ""],
    ["81da", ""],
    ["81f0", ""],
    ["81fc", ""],
    ["824f", "", 9],
    ["8260", "", 25],
    ["8281", "", 25],
    ["829f", "", 82],
    ["8340", "", 62],
    ["8380", "", 22],
    ["839f", "", 16, "", 6],
    ["83bf", "", 16, "", 6],
    ["8440", "", 5, "", 25],
    ["8470", "", 5, "", 7],
    ["8480", "", 17],
    ["849f", ""],
    ["8740", "", 19, "", 9],
    ["875f", ""],
    ["877e", ""],
    ["8780", "", 4, ""],
    ["889f", ""],
    ["8940", ""],
    ["8980", ""],
    ["8a40", ""],
    ["8a80", ""],
    ["8b40", ""],
    ["8b80", ""],
    ["8c40", ""],
    ["8c80", ""],
    ["8d40", ""],
    ["8d80", ""],
    ["8e40", ""],
    ["8e80", ""],
    ["8f40", ""],
    ["8f80", ""],
    ["9040", ""],
    ["9080", ""],
    ["9140", ""],
    ["9180", ""],
    ["9240", ""],
    ["9280", ""],
    ["9340", ""],
    ["9380", ""],
    ["9440", ""],
    ["9480", ""],
    ["9540", ""],
    ["9580", ""],
    ["9640", ""],
    ["9680", ""],
    ["9740", ""],
    ["9780", ""],
    ["9840", ""],
    ["989f", ""],
    ["9940", ""],
    ["9980", ""],
    ["9a40", ""],
    ["9a80", ""],
    ["9b40", ""],
    ["9b80", ""],
    ["9c40", ""],
    ["9c80", ""],
    ["9d40", ""],
    ["9d80", ""],
    ["9e40", ""],
    ["9e80", ""],
    ["9f40", ""],
    ["9f80", ""],
    ["e040", ""],
    ["e080", ""],
    ["e140", ""],
    ["e180", ""],
    ["e240", ""],
    ["e280", ""],
    ["e340", ""],
    ["e380", ""],
    ["e440", ""],
    ["e480", ""],
    ["e540", ""],
    ["e580", ""],
    ["e640", ""],
    ["e680", ""],
    ["e740", ""],
    ["e780", ""],
    ["e840", ""],
    ["e880", ""],
    ["e940", ""],
    ["e980", ""],
    ["ea40", ""],
    ["ea80", ""],
    ["ed40", ""],
    ["ed80", ""],
    ["ee40", ""],
    ["ee80", ""],
    ["eeef", "", 9, ""],
    ["f040", "", 62],
    ["f080", "", 124],
    ["f140", "", 62],
    ["f180", "", 124],
    ["f240", "", 62],
    ["f280", "", 124],
    ["f340", "", 62],
    ["f380", "", 124],
    ["f440", "", 62],
    ["f480", "", 124],
    ["f540", "", 62],
    ["f580", "", 124],
    ["f640", "", 62],
    ["f680", "", 124],
    ["f740", "", 62],
    ["f780", "", 124],
    ["f840", "", 62],
    ["f880", "", 124],
    ["f940", ""],
    ["fa40", "", 9, "", 9, ""],
    ["fa80", ""],
    ["fb40", ""],
    ["fb80", ""],
    ["fc40", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["8ea1", "", 62],
    ["a1a1", "", 9, ""],
    ["a2a1", ""],
    ["a2ba", ""],
    ["a2ca", ""],
    ["a2dc", ""],
    ["a2f2", ""],
    ["a2fe", ""],
    ["a3b0", "", 9],
    ["a3c1", "", 25],
    ["a3e1", "", 25],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a8a1", ""],
    ["ada1", "", 19, "", 9],
    ["adc0", ""],
    ["addf", "", 4, ""],
    ["b0a1", ""],
    ["b1a1", ""],
    ["b2a1", ""],
    ["b3a1", ""],
    ["b4a1", ""],
    ["b5a1", ""],
    ["b6a1", ""],
    ["b7a1", ""],
    ["b8a1", ""],
    ["b9a1", ""],
    ["baa1", ""],
    ["bba1", ""],
    ["bca1", ""],
    ["bda1", ""],
    ["bea1", ""],
    ["bfa1", ""],
    ["c0a1", ""],
    ["c1a1", ""],
    ["c2a1", ""],
    ["c3a1", ""],
    ["c4a1", ""],
    ["c5a1", ""],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["c9a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", ""],
    ["d2a1", ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fcf1", "", 9, ""],
    ["8fa2af", ""],
    ["8fa2c2", ""],
    ["8fa2eb", ""],
    ["8fa6e1", ""],
    ["8fa6e7", ""],
    ["8fa6e9", ""],
    ["8fa6ec", ""],
    ["8fa6f1", ""],
    ["8fa7c2", "", 10, ""],
    ["8fa7f2", "", 10, ""],
    ["8fa9a1", ""],
    ["8fa9a4", ""],
    ["8fa9a6", ""],
    ["8fa9a8", ""],
    ["8fa9ab", ""],
    ["8fa9af", ""],
    ["8fa9c1", ""],
    ["8faaa1", ""],
    ["8faaba", ""],
    ["8faba1", ""],
    ["8fabbd", ""],
    ["8fabc5", ""],
    ["8fb0a1", ""],
    ["8fb1a1", ""],
    ["8fb2a1", "", 4, ""],
    ["8fb3a1", ""],
    ["8fb4a1", ""],
    ["8fb5a1", ""],
    ["8fb6a1", "", 5, "", 4, ""],
    ["8fb7a1", "", 4, ""],
    ["8fb8a1", ""],
    ["8fb9a1", ""],
    ["8fbaa1", "", 4, ""],
    ["8fbba1", ""],
    ["8fbca1", "", 4, ""],
    ["8fbda1", "", 4, ""],
    ["8fbea1", "", 4, ""],
    ["8fbfa1", ""],
    ["8fc0a1", ""],
    ["8fc1a1", ""],
    ["8fc2a1", ""],
    ["8fc3a1", "", 4, ""],
    ["8fc4a1", ""],
    ["8fc5a1", ""],
    ["8fc6a1", ""],
    ["8fc7a1", ""],
    ["8fc8a1", ""],
    ["8fc9a1", "", 4, "", 4, ""],
    ["8fcaa1", ""],
    ["8fcba1", ""],
    ["8fcca1", "", 9, ""],
    ["8fcda1", "", 5, ""],
    ["8fcea1", "", 6, ""],
    ["8fcfa1", ""],
    ["8fd0a1", ""],
    ["8fd1a1", ""],
    ["8fd2a1", "", 5],
    ["8fd3a1", ""],
    ["8fd4a1", "", 4, ""],
    ["8fd5a1", ""],
    ["8fd6a1", ""],
    ["8fd7a1", ""],
    ["8fd8a1", ""],
    ["8fd9a1", "", 4, "", 6, ""],
    ["8fdaa1", "", 4, ""],
    ["8fdba1", "", 6, ""],
    ["8fdca1", "", 4, ""],
    ["8fdda1", "", 4, ""],
    ["8fdea1", "", 4, ""],
    ["8fdfa1", ""],
    ["8fe0a1", ""],
    ["8fe1a1", "", 4, ""],
    ["8fe2a1", ""],
    ["8fe3a1", "", 5, "", 4, ""],
    ["8fe4a1", "", 4, ""],
    ["8fe5a1", "", 4, ""],
    ["8fe6a1", ""],
    ["8fe7a1", ""],
    ["8fe8a1", "", 4, ""],
    ["8fe9a1", "", 4],
    ["8feaa1", "", 4, ""],
    ["8feba1", "", 4, ""],
    ["8feca1", ""],
    ["8feda1", "", 4, "", 4, ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127, ""],
    ["8140", "", 5, "", 9, "", 6, ""],
    ["8180", "", 6, "", 4, "", 4, "", 5, ""],
    ["8240", "", 4, "", 8, "", 4, "", 11],
    ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""],
    ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""],
    ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5],
    ["8440", "", 5, "", 5, ""],
    ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""],
    ["8540", "", 9, ""],
    ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""],
    ["8640", "", 4, "", 5, "", 4, "", 5, ""],
    ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""],
    ["8740", "", 7, "", 11, "", 4, "", 4],
    ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6],
    ["8840", "", 9, "", 4, "", 4, ""],
    ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7],
    ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""],
    ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""],
    ["8a40", "", 4, "", 12, ""],
    ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5],
    ["8b40", "", 8, "", 17, "", 6, "", 13, ""],
    ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6],
    ["8c40", "", 7, ""],
    ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4],
    ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4],
    ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""],
    ["8e40", "", 21, "", 12, "", 6, "", 12, ""],
    ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6],
    ["8f40", "", 5, "", 11, "", 8, ""],
    ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""],
    ["9040", "", 4, "", 4, "", 6, ""],
    ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6],
    ["9140", "", 6, "", 6, "", 18, "", 4, ""],
    ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""],
    ["9240", "", 6, "", 5, ""],
    ["9280", "", 5, "", 7, "", 6, ""],
    ["9340", "", 6, "", 4, "", 4, "", 5, ""],
    ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""],
    ["9440", "", 24, "", 7, "", 7, "", 4, "", 8],
    ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""],
    ["9540", "", 4, "", 4, "", 6, ""],
    ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""],
    ["9640", "", 5, "", 4, ""],
    ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5],
    ["9740", "", 7, "", 8, "", 7, "", 9, ""],
    ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""],
    ["9840", "", 4, "", 5, "", 9, ""],
    ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""],
    ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5],
    ["9980", "", 114, "", 6],
    ["9a40", "", 11, "", 7, "", 13, ""],
    ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""],
    ["9b40", "", 4, ""],
    ["9b80", "", 5, "", 4, "", 4, "", 5, ""],
    ["9c40", "", 7, ""],
    ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5],
    ["9d40", "", 7, "", 4, "", 9, "", 6, ""],
    ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""],
    ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6],
    ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""],
    ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""],
    ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4],
    ["a040", "", 9, "", 5, "", 9, "", 11, "", 19],
    ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""],
    ["a1a1", "", 7, ""],
    ["a2a1", "", 9],
    ["a2b1", "", 19, "", 19, "", 9],
    ["a2e5", "", 9],
    ["a2f1", "", 11],
    ["a3a1", "", 88, ""],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a6e0", ""],
    ["a6ee", ""],
    ["a6f4", ""],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a840", "", 35, "", 6],
    ["a880", "", 7, ""],
    ["a8a1", ""],
    ["a8bd", ""],
    ["a8c0", ""],
    ["a8c5", "", 36],
    ["a940", "", 8, ""],
    ["a959", ""],
    ["a95c", ""],
    ["a960", "", 9, "", 8],
    ["a980", "", 4, ""],
    ["a996", ""],
    ["a9a4", "", 75],
    ["aa40", "", 5, "", 5, "", 8],
    ["aa80", "", 7, "", 10, ""],
    ["ab40", "", 11, "", 4, "", 5, "", 4],
    ["ab80", "", 6, "", 4],
    ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11],
    ["ac80", "", 6, "", 12, "", 4, ""],
    ["ad40", "", 10, "", 7, "", 15, "", 12],
    ["ad80", "", 9, "", 8, "", 6, ""],
    ["ae40", "", 6, "", 7, "", 4, ""],
    ["ae80", "", 7, "", 6, "", 4, ""],
    ["af40", "", 4, ""],
    ["af80", ""],
    ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""],
    ["b080", "", 7, "", 8, "", 9, ""],
    ["b140", "", 4, "", 7, "", 10, ""],
    ["b180", "", 4, "", 7, "", 7, ""],
    ["b240", "", 11, "", 5, "", 11, "", 4],
    ["b280", "", 12, "", 8, "", 4, ""],
    ["b340", "", 5, ""],
    ["b380", "", 11, "", 7, "", 6, ""],
    ["b440", "", 7, "", 9],
    ["b480", "", 4, "", 5, "", 6, ""],
    ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""],
    ["b580", "", 6, "", 4, ""],
    ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""],
    ["b680", "", 6, "", 4, ""],
    ["b740", "", 14, "", 5, "", 9, "", 4, "", 16],
    ["b780", "", 6, ""],
    ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""],
    ["b880", "", 4, ""],
    ["b940", "", 5, "", 10, "", 6, ""],
    ["b980", "", 7, ""],
    ["ba40", "", 4, "", 4, "", 7, "", 5, ""],
    ["ba80", "", 4, "", 5, "", 12, "", 5, ""],
    ["bb40", "", 9, "", 36, "", 5, "", 9],
    ["bb80", "", 6, "", 4, ""],
    ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5],
    ["bc80", "", 14, "", 6, ""],
    ["bd40", "", 54, "", 7],
    ["bd80", "", 32, ""],
    ["be40", "", 12, "", 6, "", 42],
    ["be80", "", 32, ""],
    ["bf40", "", 62],
    ["bf80", "", 4, "", 4, "", 21, ""],
    ["c040", "", 35, "", 23, ""],
    ["c080", "", 6, "", 9, ""],
    ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""],
    ["c180", "", 4, "", 4, "", 5, ""],
    ["c240", "", 6, "", 5, ""],
    ["c280", "", 13, "", 5, "", 11, ""],
    ["c340", "", 5, "", 4, "", 6, ""],
    ["c380", "", 12, "", 4, ""],
    ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""],
    ["c480", "", 7, "", 5, "", 6, ""],
    ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""],
    ["c580", "", 7, "", 7, ""],
    ["c640", ""],
    ["c680", "", 4, "", 9, ""],
    ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""],
    ["c780", ""],
    ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""],
    ["c880", "", 6, "", 4, "", 4, ""],
    ["c940", "", 4, "", 7, "", 12, ""],
    ["c980", "", 4, "", 4, "", 10, ""],
    ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10],
    ["ca80", "", 4, "", 8, ""],
    ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""],
    ["cb80", "", 5, "", 6, "", 14, ""],
    ["cc40", "", 4, "", 10, "", 15, "", 13, ""],
    ["cc80", "", 11, "", 4, "", 7, ""],
    ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""],
    ["cd80", ""],
    ["ce40", "", 6, "", 5, "", 7, ""],
    ["ce80", "", 4, "", 6, "", 4, ""],
    ["cf40", "", 4, "", 4, "", 6, "", 9],
    ["cf80", "", 5, "", 7, "", 4, ""],
    ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""],
    ["d080", "", 4, "", 4, "", 5, ""],
    ["d140", "", 4, "", 4, "", 6, "", 5],
    ["d180", "", 4, "", 4, "", 4, ""],
    ["d240", "", 8, "", 24, "", 5, "", 19, ""],
    ["d280", "", 26, ""],
    ["d340", "", 30, "", 6],
    ["d380", "", 4, "", 5, "", 21, ""],
    ["d440", "", 31, "", 8, "", 21],
    ["d480", "", 25, "", 6, ""],
    ["d540", "", 7, "", 7, "", 46],
    ["d580", "", 32, ""],
    ["d640", "", 34, "", 27],
    ["d680", "", 30, ""],
    ["d740", "", 31, "", 4, "", 25],
    ["d780", "", 24, ""],
    ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""],
    ["d880", "", 6, "", 20, ""],
    ["d940", "", 62],
    ["d980", "", 32, ""],
    ["da40", "", 14, "", 8, "", 4, "", 9, ""],
    ["da80", "", 12, ""],
    ["db40", "", 6, "", 7, "", 4, ""],
    ["db80", "", 4, "", 5, "", 11, ""],
    ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7],
    ["dc80", "", 10, "", 21, ""],
    ["dd40", "", 62],
    ["dd80", "", 32, ""],
    ["de40", "", 32, ""],
    ["de80", "", 4, ""],
    ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""],
    ["df80", "", 4, ""],
    ["e040", "", 19, ""],
    ["e080", "", 10, "", 6, "", 8, ""],
    ["e140", "", 4, "", 6, "", 5, "", 5, ""],
    ["e180", "", 10, "", 9, "", 8, ""],
    ["e240", "", 62],
    ["e280", "", 32, "", 5, ""],
    ["e340", "", 45, "", 16],
    ["e380", "", 7, "", 24, ""],
    ["e440", "", 5, "", 24, "", 31],
    ["e480", "", 32, ""],
    ["e540", "", 51, "", 10],
    ["e580", "", 31, ""],
    ["e640", "", 34, "", 27],
    ["e680", "", 29, ""],
    ["e740", "", 7, "", 54],
    ["e780", "", 32, "", 6, "", 4, ""],
    ["e840", "", 14, "", 43, ""],
    ["e880", "", 20, ""],
    ["e940", "", 7, "", 42],
    ["e980", "", 32, ""],
    ["ea40", "", 27, "", 6, ""],
    ["ea80", "", 4, "", 12, ""],
    ["eb40", "", 9, "", 7, "", 9, "", 6, ""],
    ["eb80", "", 4, ""],
    ["ec40", "", 8, "", 4, "", 18, "", 7],
    ["ec80", "", 4, "", 7, "", 4, "", 4, ""],
    ["ed40", "", 6, "", 46],
    ["ed80", "", 4, "", 23, ""],
    ["ee40", "", 62],
    ["ee80", "", 32, "", 4, "", 6, ""],
    ["ef40", "", 5, "", 37, "", 4],
    ["ef80", "", 30, "", 4, "", 8, ""],
    ["f040", "", 4, "", 28, "", 26],
    ["f080", "", 9, "", 12, "", 4, "", 6, ""],
    ["f140", "", 10, "", 47],
    ["f180", "", 32, ""],
    ["f240", "", 62],
    ["f280", "", 32, ""],
    ["f340", "", 17, "", 6, "", 4, ""],
    ["f380", "", 8, "", 6, ""],
    ["f440", "", 5, "", 10, "", 10, "", 7, "", 5],
    ["f480", "", 32, ""],
    ["f540", "", 62],
    ["f580", "", 32, ""],
    ["f640", "", 62],
    ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""],
    ["f740", "", 62],
    ["f780", "", 4, "", 4, ""],
    ["f840", "", 62],
    ["f880", "", 32],
    ["f940", "", 62],
    ["f980", "", 32],
    ["fa40", "", 62],
    ["fa80", "", 32],
    ["fb40", "", 27, "", 9, ""],
    ["fb80", "", 5, "", 8, "", 5, ""],
    ["fc40", "", 8, "", 4, "", 8, "", 6],
    ["fc80", "", 4, "", 5, "", 8, ""],
    ["fd40", "", 4, "", 4, "", 10, "", 38],
    ["fd80", "", 5, "", 11, "", 4, ""],
    ["fe40", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS((exports, module) => {
  module.exports = [
    ["a140", "", 62],
    ["a180", "", 32],
    ["a240", "", 62],
    ["a280", "", 32],
    ["a2ab", "", 5],
    ["a2e3", ""],
    ["a2ef", ""],
    ["a2fd", ""],
    ["a340", "", 62],
    ["a380", "", 31, ""],
    ["a440", "", 62],
    ["a480", "", 32],
    ["a4f4", "", 10],
    ["a540", "", 62],
    ["a580", "", 32],
    ["a5f7", "", 7],
    ["a640", "", 62],
    ["a680", "", 32],
    ["a6b9", "", 7],
    ["a6d9", "", 6],
    ["a6ec", ""],
    ["a6f3", ""],
    ["a6f6", "", 8],
    ["a740", "", 62],
    ["a780", "", 32],
    ["a7c2", "", 14],
    ["a7f2", "", 12],
    ["a896", "", 10],
    ["a8bc", ""],
    ["a8bf", ""],
    ["a8c1", ""],
    ["a8ea", "", 20],
    ["a958", ""],
    ["a95b", ""],
    ["a95d", ""],
    ["a989", "", 11],
    ["a997", "", 12],
    ["a9f0", "", 14],
    ["aaa1", "", 93],
    ["aba1", "", 93],
    ["aca1", "", 93],
    ["ada1", "", 93],
    ["aea1", "", 93],
    ["afa1", "", 93],
    ["d7fa", "", 4],
    ["f8a1", "", 93],
    ["f9a1", "", 93],
    ["faa1", "", 93],
    ["fba1", "", 93],
    ["fca1", "", 93],
    ["fda1", "", 93],
    ["fe50", ""],
    ["fe80", "", 6, "", 93]
  ];
});

// node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS((exports, module) => {
  module.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189000] };
});

// node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["8141", "", 4, "", 6, ""],
    ["8161", "", 9, "", 5, ""],
    ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""],
    ["8241", "", 7, "", 5],
    ["8261", "", 6, "", 5, ""],
    ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18],
    ["8341", "", 5, "", 5, "", 7],
    ["8361", "", 18, ""],
    ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8],
    ["8441", "", 5, "", 8],
    ["8461", "", 18],
    ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""],
    ["8541", "", 5, "", 4, "", 6, "", 4],
    ["8561", "", 5, "", 5, "", 6, ""],
    ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""],
    ["8641", "", 6, "", 5, ""],
    ["8661", "", 6, "", 10],
    ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""],
    ["8741", "", 9, "", 15],
    ["8761", "", 18, ""],
    ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4],
    ["8841", "", 4, "", 5, "", 6, "", 4],
    ["8861", "", 4, ""],
    ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""],
    ["8941", "", 6, "", 5, ""],
    ["8961", "", 10, "", 5, ""],
    ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15],
    ["8a41", "", 10, "", 6, ""],
    ["8a61", "", 4, "", 18, ""],
    ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""],
    ["8b41", "", 5, "", 4, "", 6, ""],
    ["8b61", "", 6, "", 8],
    ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18],
    ["8c41", "", 15, "", 4],
    ["8c61", "", 6, "", 5, "", 6, "", 5],
    ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16],
    ["8d41", "", 16, "", 8],
    ["8d61", "", 17, ""],
    ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""],
    ["8e41", "", 6, "", 5, "", 8],
    ["8e61", "", 4, "", 19],
    ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7],
    ["8f41", "", 7, "", 17],
    ["8f61", "", 7, "", 6, "", 4],
    ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5],
    ["9041", "", 6, "", 5, ""],
    ["9061", "", 5, "", 15],
    ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""],
    ["9141", "", 6, "", 5],
    ["9161", "", 9, "", 5],
    ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6],
    ["9241", "", 7, "", 4, ""],
    ["9261", "", 7, "", 7, "", 4],
    ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""],
    ["9341", "", 4, ""],
    ["9361", "", 6, "", 8],
    ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""],
    ["9441", "", 5, "", 5, "", 8],
    ["9461", "", 5, "", 6, "", 12],
    ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24],
    ["9541", "", 11, "", 5, ""],
    ["9561", "", 6, "", 5, ""],
    ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14],
    ["9641", "", 23, ""],
    ["9661", "", 6, "", 5, "", 8],
    ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44],
    ["9741", "", 16, "", 8],
    ["9761", "", 17, "", 7],
    ["9781", "", 11, "", 5, "", 6, "", 89, ""],
    ["9841", "", 16, "", 5, ""],
    ["9861", "", 6, "", 15],
    ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""],
    ["9941", "", 6, "", 5, ""],
    ["9961", "", 6, "", 5, ""],
    ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""],
    ["9a41", "", 16],
    ["9a61", "", 6, "", 6, ""],
    ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""],
    ["9b41", "", 6, "", 8],
    ["9b61", "", 17, "", 7],
    ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""],
    ["9c41", "", 4, "", 5, "", 5],
    ["9c61", "", 8, "", 6, "", 9],
    ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12],
    ["9d41", "", 13, "", 8],
    ["9d61", "", 25],
    ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""],
    ["9e41", "", 7, "", 9, ""],
    ["9e61", "", 4, "", 6, ""],
    ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""],
    ["9f41", "", 5, "", 4, "", 5, ""],
    ["9f61", "", 6, "", 5, ""],
    ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""],
    ["a041", "", 5, "", 6, ""],
    ["a061", "", 5, "", 13],
    ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""],
    ["a141", "", 18, ""],
    ["a161", "", 6, "", 5, ""],
    ["a181", "", 14, "", 5, "", 4, "", 9, ""],
    ["a241", "", 5, "", 18],
    ["a261", "", 6, "", 18],
    ["a281", "", 7, "", 6, "", 7, ""],
    ["a341", "", 6, "", 10, ""],
    ["a361", "", 6, "", 16],
    ["a381", "", 16, "", 4, "", 58, "", 32, ""],
    ["a441", "", 5, ""],
    ["a461", "", 5, "", 12],
    ["a481", "", 28, "", 93],
    ["a541", "", 4, "", 6, "", 5, ""],
    ["a561", "", 17, "", 5, ""],
    ["a581", "", 16, "", 14, "", 9],
    ["a5b0", "", 9],
    ["a5c1", "", 16, "", 6],
    ["a5e1", "", 16, "", 6],
    ["a641", "", 19, ""],
    ["a661", "", 5, "", 5, "", 6],
    ["a681", "", 6, "", 18, "", 7],
    ["a741", "", 4, "", 6, "", 7],
    ["a761", "", 22, ""],
    ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""],
    ["a841", "", 10, "", 14],
    ["a861", "", 18, "", 6],
    ["a881", "", 19, "", 11, ""],
    ["a8a6", ""],
    ["a8a8", ""],
    ["a8b1", "", 27, "", 25, "", 14, ""],
    ["a941", "", 14, "", 10],
    ["a961", "", 18],
    ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""],
    ["aa41", "", 6, "", 4, ""],
    ["aa61", "", 4, "", 5, "", 6, ""],
    ["aa81", "", 29, "", 82],
    ["ab41", "", 6, "", 5, ""],
    ["ab61", "", 6, "", 5, "", 5],
    ["ab81", "", 8, "", 6, "", 12, "", 85],
    ["ac41", "", 5, "", 6, ""],
    ["ac61", "", 11, "", 4],
    ["ac81", "", 28, "", 5, "", 25],
    ["acd1", "", 5, "", 25],
    ["ad41", "", 6, "", 5, "", 7],
    ["ad61", "", 6, "", 10, ""],
    ["ad81", "", 5, "", 18, ""],
    ["ae41", "", 5, "", 16],
    ["ae61", "", 5, "", 6, "", 4],
    ["ae81", "", 6, "", 5, ""],
    ["af41", "", 19],
    ["af61", "", 13, "", 5, ""],
    ["af81", "", 5, "", 6, "", 5, ""],
    ["b041", "", 5, "", 5, "", 12],
    ["b061", "", 5, "", 19],
    ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""],
    ["b141", "", 6, "", 5, ""],
    ["b161", "", 6, "", 5, "", 11],
    ["b181", "", 14, "", 6, ""],
    ["b241", "", 6, "", 5, ""],
    ["b261", "", 18, "", 5, ""],
    ["b281", "", 5, "", 18, "", 6, ""],
    ["b341", "", 19, ""],
    ["b361", "", 5, "", 5, "", 5],
    ["b381", "", 5, "", 5, "", 19, "", 4, ""],
    ["b441", "", 5, "", 6, "", 5],
    ["b461", "", 6, "", 10, ""],
    ["b481", "", 6, "", 18, "", 4, "", 4, ""],
    ["b541", "", 14, "", 5],
    ["b561", "", 5, "", 5, "", 4],
    ["b581", "", 6, "", 5, "", 11, ""],
    ["b641", "", 7, "", 17],
    ["b661", "", 15, ""],
    ["b681", "", 5, "", 6, "", 5, ""],
    ["b741", "", 13, "", 6, ""],
    ["b761", "", 20, ""],
    ["b781", "", 6, "", 14, ""],
    ["b841", "", 7, "", 17],
    ["b861", "", 8, "", 13],
    ["b881", "", 5, "", 24, "", 4, ""],
    ["b941", "", 6, "", 5, ""],
    ["b961", "", 14, "", 6, ""],
    ["b981", "", 22, "", 4, "", 4, ""],
    ["ba41", "", 5, "", 6, ""],
    ["ba61", "", 5, "", 4, "", 5],
    ["ba81", "", 6, "", 9, ""],
    ["bb41", "", 4, "", 5, "", 4, ""],
    ["bb61", "", 6, "", 5, ""],
    ["bb81", "", 31, ""],
    ["bc41", "", 17, ""],
    ["bc61", "", 5, "", 6, ""],
    ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""],
    ["bd41", "", 7, "", 7, ""],
    ["bd61", "", 5, "", 13],
    ["bd81", "", 5, "", 25, ""],
    ["be41", "", 7, "", 14],
    ["be61", "", 7, "", 7, ""],
    ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""],
    ["bf41", "", 10, "", 14],
    ["bf61", "", 18, ""],
    ["bf81", "", 5, "", 7, "", 6, "", 5, ""],
    ["c041", "", 5, "", 6, "", 5],
    ["c061", "", 25],
    ["c081", "", 6, "", 5, "", 7, ""],
    ["c141", "", 5, "", 6, ""],
    ["c161", "", 19, ""],
    ["c181", "", 31, ""],
    ["c241", "", 4, "", 5, ""],
    ["c261", "", 4, "", 5, "", 6, ""],
    ["c281", "", 5, "", 7, "", 9, ""],
    ["c341", "", 4],
    ["c361", "", 4, "", 5, "", 11],
    ["c381", "", 5, "", 7, "", 5, ""],
    ["c441", "", 7, "", 7, ""],
    ["c461", "", 5, "", 4],
    ["c481", "", 5, "", 11, ""],
    ["c541", "", 6, "", 5, ""],
    ["c561", "", 6, "", 5, "", 4],
    ["c581", "", 6, "", 5, ""],
    ["c641", "", 6, "", 5],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", "", 5, "", 4, ""],
    ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f5a1", ""],
    ["f6a1", ""],
    ["f7a1", ""],
    ["f8a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fda1", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["a140", ""],
    ["a1a1", "", 4, ""],
    ["a240", "", 7, ""],
    ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21],
    ["a340", "", 16, "", 6, "", 16, "", 6, "", 10],
    ["a3a1", "", 25, ""],
    ["a3e1", ""],
    ["a440", ""],
    ["a4a1", ""],
    ["a540", ""],
    ["a5a1", ""],
    ["a640", ""],
    ["a6a1", ""],
    ["a740", ""],
    ["a7a1", ""],
    ["a840", ""],
    ["a8a1", ""],
    ["a940", ""],
    ["a9a1", ""],
    ["aa40", ""],
    ["aaa1", ""],
    ["ab40", ""],
    ["aba1", ""],
    ["ac40", ""],
    ["aca1", ""],
    ["ad40", ""],
    ["ada1", ""],
    ["ae40", ""],
    ["aea1", ""],
    ["af40", ""],
    ["afa1", ""],
    ["b040", ""],
    ["b0a1", ""],
    ["b140", ""],
    ["b1a1", ""],
    ["b240", ""],
    ["b2a1", ""],
    ["b340", ""],
    ["b3a1", ""],
    ["b440", ""],
    ["b4a1", ""],
    ["b540", ""],
    ["b5a1", ""],
    ["b640", ""],
    ["b6a1", ""],
    ["b740", ""],
    ["b7a1", ""],
    ["b840", ""],
    ["b8a1", ""],
    ["b940", ""],
    ["b9a1", ""],
    ["ba40", ""],
    ["baa1", ""],
    ["bb40", ""],
    ["bba1", ""],
    ["bc40", ""],
    ["bca1", ""],
    ["bd40", ""],
    ["bda1", ""],
    ["be40", ""],
    ["bea1", ""],
    ["bf40", ""],
    ["bfa1", ""],
    ["c040", ""],
    ["c0a1", ""],
    ["c140", ""],
    ["c1a1", ""],
    ["c240", ""],
    ["c2a1", ""],
    ["c340", ""],
    ["c3a1", ""],
    ["c440", ""],
    ["c4a1", ""],
    ["c540", ""],
    ["c5a1", ""],
    ["c640", ""],
    ["c940", ""],
    ["c9a1", ""],
    ["ca40", ""],
    ["caa1", ""],
    ["cb40", ""],
    ["cba1", ""],
    ["cc40", ""],
    ["cca1", ""],
    ["cd40", ""],
    ["cda1", ""],
    ["ce40", ""],
    ["cea1", ""],
    ["cf40", ""],
    ["cfa1", ""],
    ["d040", ""],
    ["d0a1", ""],
    ["d140", ""],
    ["d1a1", ""],
    ["d240", ""],
    ["d2a1", ""],
    ["d340", ""],
    ["d3a1", ""],
    ["d440", ""],
    ["d4a1", ""],
    ["d540", ""],
    ["d5a1", ""],
    ["d640", ""],
    ["d6a1", ""],
    ["d740", ""],
    ["d7a1", ""],
    ["d840", ""],
    ["d8a1", ""],
    ["d940", ""],
    ["d9a1", ""],
    ["da40", ""],
    ["daa1", ""],
    ["db40", ""],
    ["dba1", ""],
    ["dc40", ""],
    ["dca1", ""],
    ["dd40", ""],
    ["dda1", ""],
    ["de40", ""],
    ["dea1", ""],
    ["df40", ""],
    ["dfa1", ""],
    ["e040", ""],
    ["e0a1", ""],
    ["e140", ""],
    ["e1a1", ""],
    ["e240", ""],
    ["e2a1", ""],
    ["e340", ""],
    ["e3a1", ""],
    ["e440", ""],
    ["e4a1", ""],
    ["e540", ""],
    ["e5a1", ""],
    ["e640", ""],
    ["e6a1", ""],
    ["e740", ""],
    ["e7a1", ""],
    ["e840", ""],
    ["e8a1", ""],
    ["e940", ""],
    ["e9a1", ""],
    ["ea40", ""],
    ["eaa1", ""],
    ["eb40", ""],
    ["eba1", ""],
    ["ec40", ""],
    ["eca1", ""],
    ["ed40", ""],
    ["eda1", ""],
    ["ee40", ""],
    ["eea1", ""],
    ["ef40", ""],
    ["efa1", ""],
    ["f040", ""],
    ["f0a1", ""],
    ["f140", ""],
    ["f1a1", ""],
    ["f240", ""],
    ["f2a1", ""],
    ["f340", ""],
    ["f3a1", ""],
    ["f440", ""],
    ["f4a1", ""],
    ["f540", ""],
    ["f5a1", ""],
    ["f640", ""],
    ["f6a1", ""],
    ["f740", ""],
    ["f7a1", ""],
    ["f840", ""],
    ["f8a1", ""],
    ["f940", ""],
    ["f9a1", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS((exports, module) => {
  module.exports = [
    ["8740", "\uD85C\uDE67\uD85F\uDCB1\uD85F\uDCC5\uD850\uDEBF\uD84D\uDE17\uD85C\uDF52\uD85B\uDE8B\uD85C\uDCD2\uD868\uDF51\uD85F\uDC6C\uD85A\uDF23\uD856\uDE54\uD846\uDE63\uD84F\uDE06\uD84F\uDF61"],
    ["8767", "\uD862\uDFB9\uD85E\uDFEF\uD847\uDD5E\uD867\uDEB0\uD866\uDD45\uD847\uDD53\uD84D\uDE9E\uD858\uDC21"],
    ["87a1", "\uD856\uDCDE\uD850\uDD61\uD862\uDD0D\uD84C\uDDEA\uD842\uDE8A\uD84C\uDE5E\uD857\uDDB9\uD84D\uDE8E\uD85E\uDF65\uD85B\uDE88\uD857\uDD99\uD849\uDCBC\uD849\uDCC1\uD849\uDCC9\uD849\uDCCC\uD84D\uDDBB\uD86B\uDDFF"],
    ["8840", "", 4, "\uD840\uDD0C\uD840\uDCD1\uD840\uDCCD\uD840\uDCCB\uD847\uDFE8\uD840\uDCCA\uD840\uDD0E"],
    ["88a1", ""],
    ["8940", "\uD868\uDFA9\uD844\uDD45"],
    ["8943", ""],
    ["8946", ""],
    ["894c", "\uD85D\uDF35"],
    ["89a1", ""],
    ["89ab", ""],
    ["89b0", "\uD842\uDDE7"],
    ["89b5", "\uD867\uDDF6\uD85C\uDC0E\uD868\uDD33"],
    ["89c1", ""],
    ["89c5", "\uD861\uDC6C\uD847\uDDCA\uD841\uDDD0\uD84A\uDEE6"],
    ["8a40", "\uD85F\uDD84"],
    ["8a43", "\uD843\uDC42\uD843\uDD15\uD854\uDD2B\uD84B\uDCC6\uD840\uDF41\uD853\uDDB8\uD865\uDCE5\uD860\uDCBE\uD84B\uDC38\uD860\uDD5D\uD85A\uDDF2\uD853\uDDEA\uD843\uDD7C\uD843\uDFB4\uD843\uDCD5\uD844\uDCF4\uD843\uDE96\uD843\uDC0B\uD843\uDF64\uD84B\uDCA9\uD860\uDE56\uD851\uDCD3"],
    ["8a64", "\uD843\uDD46\uD866\uDE4D\uD860\uDCE9\uD853\uDEA7\uD84B\uDCC2\uD865\uDDF4\uD854\uDEC7\uD865\uDFD4\uD85E\uDCC8\uD84B\uDD44"],
    ["8a76", "\uD858\uDCA5\uD84B\uDD4C\uD84A\uDFCA\uD844\uDC77\uD844\uDC6F"],
    ["8aa1", "\uD859\uDEDA\uD859\uDF16\uD85E\uDDA0\uD854\uDC52\uD843\uDC43\uD848\uDDA1\uD862\uDF4C\uD841\uDF31"],
    ["8aac", "\uD840\uDDA9\uD84B\uDD8D"],
    ["8ab2", "\uD851\uDDC8\uD841\uDCFC\uD858\uDC97\uD843\uDF4C\uD843\uDD96"],
    ["8abb", "\uD84A\uDE66\uD844\uDC9D\uD843\uDD9C\uD849\uDF75"],
    ["8ac9", "\uD869\uDE01\uD843\uDE09\uD84A\uDECF\uD84B\uDCC9"],
    ["8ace", "\uD844\uDCC8\uD84E\uDDC2\uD860\uDE9B\uD857\uDE49\uD848\uDCC7\uD843\uDF31\uD84B\uDCB2\uD865\uDF20\uD853\uDE3B"],
    ["8adf", "\uD85D\uDD74\uD84B\uDE8B\uD848\uDE08\uD869\uDE5B\uD863\uDCCD\uD843\uDE7A\uD843\uDC34\uD85A\uDC1C\uD844\uDCCF\uD84A\uDC03\uD84A\uDD39\uD854\uDDE3\uD843\uDE8C\uD843\uDF8D\uD843\uDEAA\uD843\uDF30\uD843\uDD47\uD844\uDD4F\uD843\uDE4C"],
    ["8af6", "\uD843\uDEAB\uD842\uDFA9\uD843\uDD48\uD844\uDCC0\uD844\uDD3D\uD849\uDE96\uD843\uDFAD"],
    ["8b40", "\uD84C\uDFF4\uD85D\uDE39\uD84A\uDFCE\uD843\uDD7E\uD843\uDD7F\uD84B\uDC51\uD84B\uDC55\uD843\uDE98\uD844\uDCC7\uD843\uDF2E\uD869\uDE32\uD85A\uDF50\uD863\uDCD2\uD863\uDD99\uD863\uDCCA"],
    ["8b55", "\uD867\uDEC3\uD85D\uDF5E\uD84B\uDDEE\uD859\uDD72\uD860\uDCBD\uD843\uDEFA\uD843\uDE0F\uD843\uDE77\uD843\uDEFB\uD853\uDDEB\uD843\uDCD6\uD849\uDFB5\uD844\uDCC9\uD843\uDE10\uD843\uDE78\uD844\uDC78\uD844\uDD48\uD860\uDE07\uD845\uDC55\uD843\uDE79\uD853\uDE50\uD84B\uDDA4\uD844\uDC1D\uD844\uDC1E\uD844\uDCF5\uD844\uDCF6\uD843\uDE11"],
    ["8ba1", "\uD85D\uDE94\uD860\uDECD\uD843\uDFB5\uD843\uDE7B\uD854\uDD7E\uD843\uDFB6\uD844\uDD80\uD854\uDED8\uD868\uDEBD\uD852\uDDDA\uD846\uDC3A\uD850\uDD77\uD860\uDE7C\uD855\uDF3D\uD856\uDF74\uD84C\uDD3D\uD846\uDFC1\uD87E\uDC78\uD840\uDC86\uD852\uDCE9\uD858\uDE6A"],
    ["8bde", "\uD858\uDF4B\uD859\uDE12\uD85A\uDD51\uD85E\uDCB2\uD863\uDE0F\uD866\uDC10\uD840\uDC87"],
    ["8c40", "\uD867\uDC73\uD850\uDD4E\uD854\uDDCD\uD857\uDD30\uD862\uDE32\uD84C\uDE81\uD868\uDD07\uD846\uDD80\uD861\uDF0F\uD868\uDEBA\uD842\uDE6F\uD866\uDD47\uD862\uDEEA\uD848\uDC7E\uD862\uDDE3\uD847\uDDB6\uD849\uDF12"],
    ["8ca1", "\uD84C\uDFF9\uD84F\uDC63"],
    ["8ca7", "\uD851\uDD05\uD852\uDE13\uD857\uDCA4\uD855\uDE95\uD863\uDDB9\uD845\uDC3F"],
    ["8cc9", ""],
    ["8cce", "\uD852\uDD7B\uD85C\uDD0D\uD85B\uDD74\uD85A\uDF15\uD85B\uDFBE\uD84C\uDE56\uD849\uDF96"],
    ["8ce6", "\uD84E\uDF1A\uD84D\uDD51\uD850\uDCEC\uD847\uDE23\uD840\uDDA4\uD85B\uDC41\uD840\uDE39\uD866\uDCFA"],
    ["8d40", "\uD842\uDF9F"],
    ["8d42", "\uD848\uDDC1\uD862\uDD6D\uD864\uDC79\uD868\uDDB5\uD85B\uDC46\uD861\uDEB2\uD85C\uDFFF\uD855\uDC9A\uD852\uDF0F"],
    ["8da1", "\uD862\uDDC0\uD84F\uDF41\uD840\uDF25\uD843\uDED8"],
    ["8e40", "\uD84F\uDED7\uD85B\uDED3\uD855\uDFE0\uD862\uDFE9\uD856\uDCE1\uD865\uDCD9\uD856\uDDAC\uD859\uDC8D\uD857\uDC01\uD854\uDF0E\uD857\uDCFE\uD856\uDFB4\uD85B\uDC7F\uD857\uDD20\uD857\uDC65\uD857\uDCC1\uD852\uDC82\uD851\uDD78"],
    ["8ea1", "\uD85B\uDE44\uD85B\uDED6\uD850\uDC57\uD858\uDC29\uD845\uDFF9\uD860\uDF6D\uD858\uDD21\uD858\uDD5A\uD858\uDED0\uD858\uDF51\uD845\uDE61\uD840\uDC68\uD84D\uDF66\uD860\uDF3A\uD859\uDC89\uD868\uDC87\uD85B\uDCC3\uD849\uDF14\uD859\uDE26\uD84F\uDDE3\uD859\uDEE8\uD862\uDE48\uD849\uDEF6\uD859\uDC98\uD853\uDFB8\uD845\uDC8A\uD846\uDC5E\uD852\uDE65\uD852\uDE95\uD842\uDF0D\uD85A\uDE52\uD84F\uDD7E\uD845\uDCFD\uD85A\uDF0A\uD852\uDDA7\uD84D\uDD30\uD845\uDF73\uD84F\uDDF8\uD87E\uDD94"],
    ["8f40", "\uD843\uDE16\uD845\uDFB4\uD84C\uDD7D\uD84D\uDD5A\uD84F\uDE8B\uD85B\uDDA3\uD85A\uDF05\uD85A\uDF97\uD84D\uDDCE\uD85B\uDDA5\uD85B\uDED4\uD85B\uDE42\uD84B\uDEEF\uD856\uDFE4\uD84F\uDCB5\uD85A\uDF96\uD85B\uDE77\uD85B\uDE43\uD857\uDC91\uD857\uDCC0\uD85B\uDE99"],
    ["8fa1", "\uD861\uDE25\uD861\uDE3B\uD85C\uDC88\uD845\uDD82\uD85C\uDCCD\uD87E\uDDB2\uD846\uDCA2\uD85C\uDF9A\uD868\uDCF8\uD84B\uDC27\uD85D\uDDE0\uD84F\uDDB9\uD85D\uDDE4\uD85D\uDF0F\uD862\uDE25\uD85E\uDD24\uD85E\uDEBD\uD85E\uDE59\uD85E\uDF3A\uD84F\uDF8F\uD85E\uDF38\uD855\uDC30\uD855\uDD65\uD852\uDE7A\uD845\uDEDF\uD85F\uDD54\uD85F\uDD8F\uD87E\uDDD4\uD85F\uDD53\uD85F\uDD98\uD85F\uDDBD\uD846\uDD10\uD853\uDCC9"],
    ["9040", "\uD860\uDC02\uD844\uDC14\uD852\uDD8A\uD860\uDDBC\uD85C\uDD0C\uD860\uDF65\uD861\uDC12\uD868\uDE9F\uD842\uDE50\uD862\uDDDE\uD861\uDD3D\uD84F\uDDBB\uD84C\uDE62\uD868\uDC14\uD861\uDEBC\uD861\uDD01\uD848\uDF25\uD85B\uDED7\uD861\uDD3C\uD85E\uDEBE\uD861\uDD6C\uD861\uDE0B\uD861\uDF13\uD861\uDEE6\uD862\uDD33\uD847\uDE89\uD855\uDDB9\uD862\uDEC6\uD84F\uDC9B\uD862\uDF0C\uD855\uDDDB"],
    ["90a1", "\uD843\uDD31\uD862\uDEE1\uD862\uDFEB\uD862\uDEE2\uD862\uDEE5\uD862\uDFEC\uD863\uDC39\uD862\uDFFF\uD849\uDE7A\uD861\uDED8\uD844\uDE7C\uD84F\uDE2E\uD85B\uDED5\uD862\uDEE0\uD85B\uDCB8\uD840\uDE74\uD859\uDC10\uD864\uDCAF\uD864\uDCE5\uD852\uDED1\uD846\uDD15\uD84C\uDF0A\uD852\uDEE9\uD864\uDDD5\uD864\uDDEB\uD84C\uDCB7\uD84C\uDCBC\uD855\uDC6C\uD865\uDC33\uD865\uDC1D\uD85E\uDD7A\uD85C\uDD75\uD841\uDE30\uD850\uDD5C"],
    ["9140", "\uD855\uDF06\uD85B\uDD27\uD845\uDED3\uD852\uDE29\uD866\uDC57\uD866\uDD05\uD855\uDF25\uD864\uDCB1\uD866\uDFD5\uD866\uDF05\uD861\uDE00\uD85A\uDDA8\uD84C\uDC7D\uD867\uDD3E\uD846\uDC63\uD850\uDE4B\uD867\uDE68\uD867\uDFB7\uD868\uDD92\uD868\uDDAB\uD868\uDCE1\uD868\uDD23\uD868\uDDDF\uD868\uDD34"],
    ["91a1", "\uD848\uDD5B\uD868\uDD93\uD868\uDE20\uD846\uDD3B\uD868\uDE33\uD868\uDCB9\uD868\uDEB4\uD850\uDF64\uD863\uDC2B\uD85B\uDDA2\uD864\uDC8B\uD852\uDD75\uD852\uDDBB\uD852\uDDF8\uD850\uDF48\uD852\uDE51\uD862\uDFDA\uD846\uDCFA\uD862\uDD7E\uD863\uDE36\uD862\uDE44\uD862\uDD6C\uD851\uDCB9\uD851\uDC73\uD850\uDFF8\uD845\uDFEF\uD846\uDCBE\uD84D\uDD99\uD846\uDC85\uD855\uDC2F\uD845\uDFF8\uD845\uDEFB\uD846\uDC39\uD845\uDF74\uD846\uDCD1\uD857\uDF4B\uD845\uDEC0\uD852\uDE25\uD844\uDFFE\uD844\uDEA8"],
    ["9240", "\uD844\uDFC6\uD845\uDCB6\uD84D\uDEA6\uD852\uDD94\uD85C\uDD65\uD84F\uDE31\uD855\uDD5C\uD84F\uDEFB\uD85C\uDC52\uD84D\uDEEE\uD866\uDD9D\uD85B\uDF26\uD846\uDD22\uD84D\uDF3F\uD850\uDCE1\uD850\uDC8B\uD850\uDD0F\uD85B\uDC21\uD859\uDEB1\uD843\uDFDF\uD842\uDFA8\uD843\uDE0D\uD862\uDF13\uD851\uDC36\uD841\uDC65\uD840\uDF7F\uD855\uDE51\uD840\uDDAB\uD840\uDFCB\uD840\uDF0A\uD841\uDC14\uD840\uDEC0\uD863\uDEB3\uD840\uDE75\uD840\uDE0C"],
    ["92a1", "\uD852\uDE0E\uD84F\uDE8A\uD84D\uDD95\uD84F\uDE39\uD84F\uDEBF\uD846\uDC84\uD84F\uDE89\uD841\uDDE0\uD841\uDCA3\uD841\uDC92\uD841\uDC91\uD862\uDE9C\uD841\uDF0E\uD842\uDC73\uD850\uDF8C\uD843\uDC20\uD852\uDDAC\uD844\uDCE4\uD843\uDE1D\uD852\uDEBC\uD850\uDC8D\uD850\uDCC9\uD840\uDF45\uD842\uDFC6\uD862\uDE46\uD845\uDEFA\uD845\uDF6F\uD845\uDF10\uD856\uDD46\uD846\uDDF3\uD846\uDC61\uD850\uDE95\uD857\uDE83"],
    ["9340", "\uD862\uDFD7\uD841\uDC13\uD844\uDF03\uD862\uDDFB\uD846\uDD96\uD846\uDD7C\uD84E\uDEEE\uD846\uDD03\uD846\uDD04\uD846\uDCA0\uD845\uDEFE\uD862\uDE47\uD847\uDDBA\uD84D\uDC72\uD862\uDDA8\uD846\uDD27\uD845\uDFAB\uD845\uDF3B\uD85D\uDDFD\uD84A\uDC60\uD849\uDE2B\uD849\uDDAF\uD849\uDDBE\uD864\uDC88\uD85B\uDF73\uD840\uDC3E\uD840\uDC46\uD849\uDE1B\uD84B\uDC9B\uD84B\uDD07\uD851\uDED4\uD864\uDD4D"],
    ["93a1", "\uD851\uDE65\uD84A\uDF6A\uD84A\uDF22\uD84D\uDC50\uD866\uDCEA\uD84B\uDE78\uD869\uDC5B\uD852\uDDE3\uD84B\uDD67\uD84B\uDCA1\uD84C\uDC8E\uD84C\uDEAD\uD852\uDD89\uD84C\uDEAB\uD84C\uDEE0\uD846\uDCD9\uD865\uDC3F\uD84C\uDE89\uD84C\uDDB3\uD855\uDD84\uD862\uDF22\uD855\uDD8F\uD845\uDEFC\uD855\uDD5B\uD855\uDC25\uD84C\uDD03\uD846\uDC2A\uD84C\uDE34\uD84C\uDE0F\uD84C\uDD82\uD850\uDEC9\uD85B\uDD24\uD85E\uDC70\uD847\uDDEB\uD84C\uDED2\uD84C\uDEE1\uD856\uDC72\uD84E\uDC3A\uD84D\uDFBC\uD84D\uDFA2\uD84C\uDFFE\uD851\uDE2A\uD84D\uDFD5\uD851\uDC87\uD846\uDD12\uD84F\uDFC0\uD84F\uDC9A\uD862\uDFEA\uD862\uDECB"],
    ["9440", "\uD860\uDC1E\uD862\uDDDC\uD852\uDDEC\uD84F\uDF7F\uD850\uDC3C\uD850\uDF1A\uD850\uDE76\uD851\uDF8F\uD851\uDF25\uD852\uDEA4\uD841\uDDEB\uD84F\uDEF8\uD84D\uDE5F\uD852\uDE4A\uD852\uDD17\uD857\uDFE1\uD852\uDEDF\uD863\uDC23\uD84F\uDF35\uD85B\uDDEA\uD853\uDCD9\uD853\uDD06\uD869\uDDC6\uD862\uDECC\uD852\uDDAB\uD852\uDD8E"],
    ["94a1", "\uD852\uDE4E\uD852\uDDC5\uD852\uDCF3\uD862\uDEE3\uD846\uDC64\uD854\uDE21\uD854\uDDE7\uD84C\uDE32\uD851\uDE97\uD84D\uDF81\uD852\uDCF0\uD852\uDEBA\uD852\uDEC7\uD852\uDE96\uD858\uDDAE\uD855\uDD81\uD85D\uDF41\uD855\uDEE3\uD84F\uDEFA\uD845\uDEE6\uD843\uDD4C\uD852\uDD8C\uD840\uDE99\uD84F\uDDBA\uD845\uDF6E\uD840\uDDD4\uD843\uDC0D\uD849\uDEF5\uD856\uDEAF\uD856\uDE9C\uD840\uDE5B\uD856\uDFC6\uD856\uDFB3\uD857\uDEBC\uD857\uDEA6\uD852\uDDF9\uD845\uDFB0\uD858\uDE61"],
    ["9540", "\uD858\uDD5C\uD85E\uDF48\uD857\uDE82\uD85A\uDF75\uD842\uDD16\uD840\uDC4E\uD84D\uDDCF\uD859\uDC12\uD858\uDFF8\uD852\uDD62\uD842\uDC2C\uD856\uDEE9\uD857\uDD43\uD857\uDE0E\uD84D\uDC3F\uD852\uDDF7\uD859\uDDAD\uD859\uDDA0\uD85C\uDD27\uD85B\uDCD1\uD859\uDFB4\uD85A\uDE42\uD85A\uDE51\uD85B\uDDA7\uD85C\uDE1B\uD846\uDC40\uD846\uDCA1\uD846\uDCD8\uD87E\uDDBC\uD84F\uDD8F\uD85D\uDC22"],
    ["95a1", "\uD855\uDE83\uD85D\uDF85\uD85D\uDF84\uD862\uDFF5\uD862\uDFD9\uD862\uDF9C\uD862\uDDF9\uD865\uDC48\uD850\uDE84\uD846\uDC45\uD85F\uDDDC\uD853\uDC09\uD848\uDF21\uD845\uDFDA\uD852\uDD2F\uD862\uDE4B\uD862\uDEFC\uD863\uDC1D\uD863\uDC3B\uD863\uDD34\uD852\uDCFF\uD852\uDE42\uD850\uDFEA\uD84C\uDE25\uD863\uDEE7\uD863\uDE66\uD863\uDE65\uD852\uDDED\uD852\uDE78\uD84F\uDFEE\uD864\uDCB0"],
    ["9640", "\uD864\uDC93\uD855\uDFDF\uD862\uDD89\uD863\uDC26\uD862\uDF2F\uD858\uDFBE\uD850\uDE1B\uD843\uDF26\uD862\uDFC5\uD852\uDEB2\uD865\uDCDA\uD865\uDDD7\uD862\uDF50\uD852\uDE67\uD862\uDF64\uD862\uDE45\uD85E\uDF06\uD862\uDF65\uD856\uDCC8\uD866\uDCF1\uD866\uDD48\uD844\uDF02\uD852\uDDB8"],
    ["96a1", "\uD845\uDCE8\uD849\uDF1F\uD84F\uDDB8\uD849\uDF81\uD84A\uDD6B\uD867\uDE2D\uD868\uDDF5\uD868\uDCFE\uD850\uDD04\uD868\uDDB4\uD868\uDCED\uD868\uDCF3\uD866\uDD2F\uD85B\uDE12\uD85B\uDFDF\uD85A\uDF82\uD85B\uDDA4\uD85B\uDE84\uD85B\uDDF0\uD85B\uDE00\uD84D\uDFD7\uD858\uDC64\uD84D\uDD9C\uD84D\uDE40\uD852\uDDDE\uD840\uDEBF\uD855\uDD5D\uD845\uDF57\uD84C\uDDC9\uD852\uDD41\uD850\uDDB5\uD850\uDDAC\uD85B\uDC40\uD853\uDF97\uD845\uDFB5\uD862\uDE49"],
    ["9740", "\uD851\uDC88\uD862\uDDFC\uD846\uDCD6\uD843\uDF1D\uD85B\uDCC0\uD845\uDC13\uD850\uDEFA\uD84B\uDC26\uD850\uDFC1\uD84F\uDDB7\uD859\uDF41\uD858\uDD5B\uD858\uDCA4\uD852\uDDB9\uD852\uDD8B\uD862\uDDFA\uD862\uDF63\uD846\uDC9F\uD852\uDEB3\uD852\uDE3E\uD852\uDE94\uD845\uDFD9\uD852\uDE66\uD840\uDFA7\uD845\uDC24\uD852\uDDE5\uD852\uDD16\uD852\uDD76\uD841\uDCFE\uD862\uDECE\uD862\uDE16\uD862\uDFE7\uD855\uDDD5\uD862\uDE82"],
    ["97a1", "\uD852\uDD43\uD843\uDCFF\uD841\uDE1A\uD842\uDFEB\uD843\uDCB8\uD845\uDFFA\uD845\uDEC2\uD852\uDE50\uD846\uDC52\uD862\uDEC0\uD852\uDDAD\uD846\uDCBF\uD846\uDC83\uD85D\uDC84\uD84F\uDD5B\uD862\uDE81\uD846\uDC62\uD842\uDEB4\uD844\uDF9C\uD860\uDE18\uD864\uDCE4\uD85F\uDE4F\uD84F\uDFED\uD84F\uDE2D\uD840\uDFF5\uD863\uDC1C\uD85A\uDFC0\uD845\uDC52\uD850\uDF62\uD852\uDE71\uD84B\uDFE3\uD844\uDEB0\uD848\uDFBD\uD844\uDF98\uD84D\uDCE5\uD85E\uDFF4\uD84D\uDEDF\uD862\uDE83\uD84D\uDFD6\uD84C\uDFFA\uD853\uDC9F\uD84D\uDEAD\uD85B\uDCB7"],
    ["9840", "\uD85B\uDD26\uD85B\uDD51\uD85B\uDC82\uD85B\uDFDE\uD85C\uDD09\uD845\uDF3A\uD85B\uDC80\uD85C\uDC53\uD845\uDFDB\uD845\uDFB3\uD846\uDD05\uD850\uDDFC\uD845\uDF3C\uD850\uDEA5\uD850\uDE93\uD84F\uDEF9\uD85D\uDF36\uD851\uDC5B\uD850\uDECA\uD850\uDE59\uD862\uDDE1\uD85B\uDD28\uD851\uDCCE\uD85F\uDE4D\uD850\uDFBD\uD850\uDE56\uD844\uDF04\uD850\uDFE9\uD87E\uDC25\uD852\uDE4F\uD852\uDE5D\uD845\uDFDF"],
    ["98a1", "\uD84E\uDEFA\uD84C\uDF00\uD840\uDE14\uD842\uDCD5\uD841\uDE19\uD847\uDF9E\uD868\uDEB6\uD864\uDD5B\uD862\uDE59\uD865\uDC20\uD85E\uDEF4\uD855\uDEF6\uD85E\uDF18\uD852\uDCF2\uD853\uDF5C\uD855\uDD35"],
    ["9940", "\uD843\uDCCF"],
    ["99a1", "\uD85E\uDD67"],
    ["9a40", "\uD846\uDFC2"],
    ["9aa1", "\uD840\uDC94\uD840\uDEB7\uD840\uDFA0\uD841\uDCD7\uD841\uDDD5\uD841\uDE15\uD841\uDE76\uD845\uDEBA\uD842\uDEC2\uD842\uDECD\uD842\uDFBF\uD87E\uDC3B\uD842\uDFCB\uD842\uDFFB\uD843\uDC3B\uD843\uDC53\uD843\uDC65\uD843\uDC7C\uD843\uDC8D\uD843\uDCB5\uD843\uDCDD\uD843\uDCED\uD843\uDD6F\uD843\uDDB2\uD843\uDDC8\uD843\uDE04\uD843\uDE0E\uD843\uDED7\uD843\uDF90\uD843\uDF2D\uD843\uDE73\uD843\uDFBC\uD844\uDC5C\uD844\uDC4F\uD844\uDC76\uD844\uDC7B\uD844\uDC88\uD844\uDC96\uD844\uDCBF\uD844\uDCD3\uD844\uDD2F\uD844\uDD3B\uD844\uDEE3\uD844\uDF75\uD844\uDF36\uD845\uDD77\uD845\uDE19\uD845\uDFC3\uD845\uDFC7\uD846\uDC2D\uD846\uDD6A"],
    ["9b40", "\uD846\uDE2D\uD846\uDE45\uD847\uDC2A\uD847\uDC70\uD847\uDCAC\uD847\uDEC8\uD847\uDED5\uD847\uDF15\uD848\uDC45\uD848\uDE7C\uD848\uDFD7\uD848\uDFFA\uD849\uDF2A\uD84A\uDC71\uD84A\uDD4F\uD84A\uDD67\uD84A\uDD93\uD84A\uDED5\uD84A\uDEE8\uD84A\uDF0E\uD84A\uDF3F\uD84B\uDC4C"],
    ["9b62", "\uD84B\uDC88\uD84B\uDCB7\uD856\uDFE8\uD84B\uDD08\uD84B\uDD12\uD84B\uDDB7\uD84B\uDD95\uD84B\uDE42\uD84B\uDF74\uD84B\uDFCC\uD84C\uDC33\uD84C\uDC66\uD84C\uDF1F\uD84C\uDFDE\uD85E\uDE79\uD84D\uDD67\uD84D\uDDF3\uD852\uDDBA\uD84D\uDE1A\uD84D\uDF16\uD840\uDF46"],
    ["9ba1", "\uD84E\uDEA7\uD85D\uDE57\uD857\uDFE2\uD84F\uDE11\uD84F\uDEB9\uD85D\uDDFE\uD848\uDC9A\uD850\uDD19\uD862\uDE9A\uD850\uDEEE\uD850\uDF0D\uD850\uDC3B\uD850\uDF34\uD850\uDF96\uD852\uDE45\uD841\uDDCA\uD841\uDE11\uD847\uDEA8\uD84F\uDCFF\uD851\uDC04\uD851\uDCD6\uD851\uDE74\uD851\uDF2F\uD861\uDDE8\uD866\uDDC9\uD848\uDDC3\uD862\uDF4E\uD852\uDC12\uD852\uDCFB\uD852\uDE15\uD852\uDEC0\uD843\uDC78\uD853\uDEA5\uD853\uDF86\uD841\uDF79\uD854\uDC2C\uD854\uDE99\uD855\uDC19\uD84F\uDF4A\uD852\uDEA7\uD855\uDC46\uD855\uDC6E\uD85A\uDF52\uD855\uDD3F\uD85D\uDE32\uD855\uDD5E\uD855\uDD62\uD855\uDD66\uD855\uDFC7\uD852\uDD3F\uD856\uDC5D\uD84C\uDFCC\uD856\uDD03\uD862\uDD48\uD856\uDEAE\uD856\uDF89\uD857\uDC06\uD847\uDD90\uD858\uDD02\uD85F\uDC12\uD858\uDDB2\uD853\uDF9A\uD859\uDC02\uD859\uDC4A"],
    ["9c40", "\uD85A\uDFF7\uD859\uDC84\uD846\uDD1C\uD852\uDDF6\uD859\uDC88\uD84F\uDFEF\uD859\uDD12\uD859\uDDBF\uD859\uDEB5\uD849\uDF1B\uD855\uDFE1\uD87E\uDCCD\uD851\uDD21\uD859\uDEFC\uD852\uDD34\uD85B\uDCBD\uD859\uDF99\uD85A\uDC6E\uD859\uDC11\uD85A\uDC5E\uD85A\uDCC7\uD864\uDCC0\uD842\uDE11\uD85A\uDD26\uD85A\uDD39\uD85A\uDDFA\uD85A\uDE2D\uD859\uDC69\uD840\uDC21\uD85A\uDE34\uD85A\uDF5B\uD84D\uDD19\uD85A\uDF9D\uD85B\uDCA4\uD85B\uDDAE"],
    ["9ca1", "\uD849\uDD8D\uD85C\uDC4B\uD85C\uDDCD\uD85C\uDE80\uD85C\uDE85\uD848\uDD7A\uD85C\uDE8B\uD85C\uDEE6\uD852\uDDD0\uD85D\uDC50\uD843\uDEF8\uD84A\uDD26\uD861\uDC73\uD845\uDFB1\uD852\uDE2A\uD846\uDC20\uD867\uDCAD\uD866\uDCA4\uD85D\uDFCC\uD85E\uDC58\uD845\uDE0A\uD84D\uDF2F\uD860\uDCE8\uD844\uDFC5\uD85E\uDDDD\uD864\uDDA8\uD85C\uDCAF\uD862\uDDAB\uD85E\uDDFD\uD85E\uDE0A\uD85E\uDF0B\uD85F\uDD66\uD850\uDD7A\uD860\uDC09\uD868\uDEDF\uD860\uDF18\uD85B\uDE07\uD860\uDD6F\uD860\uDC23\uD85A\uDDB5\uD844\uDFED\uD84C\uDE2F\uD860\uDC48\uD863\uDC30\uD860\uDC83\uD862\uDD49\uD852\uDD88\uD852\uDEA5\uD84F\uDF81\uD860\uDC90\uD860\uDCF4\uD860\uDD2E\uD847\uDFA1\uD860\uDD4F"],
    ["9d40", "\uD860\uDD89\uD860\uDDAF\uD860\uDE1A\uD860\uDF06\uD860\uDF2F\uD860\uDF8A\uD861\uDC68\uD861\uDEAA\uD862\uDD56\uD862\uDDB8\uD862\uDDE7\uD862\uDDE8\uD862\uDF46\uD862\uDFD4\uD863\uDC09\uD863\uDFC5\uD864\uDCEC\uD864\uDD10\uD864\uDD3C\uD864\uDD5E\uD852\uDECA\uD865\uDCE7\uD865\uDDE9\uD865\uDDB0\uD865\uDDB8\uD865\uDF32\uD866\uDCD1\uD866\uDD49\uD866\uDD6A\uD866\uDDC3\uD866\uDE28\uD866\uDF0E\uD867\uDD5A\uD867\uDD9B\uD867\uDEF8\uD867\uDF23\uD868\uDE93\uD868\uDEFF\uD869\uDDCB\uD843\uDC9C"],
    ["9da1", "\uD849\uDCB0\uD852\uDE93\uD862\uDF2C\uD85E\uDC9D\uD845\uDFF5\uD860\uDC24\uD862\uDF6C\uD862\uDF99\uD85E\uDE3E\uD859\uDEAF\uD85D\uDE55\uD84F\uDCB7\uD855\uDE35\uD856\uDD56\uD857\uDE81\uD858\uDE58\uD843\uDE6D\uD84F\uDE88\uD853\uDC9E\uD845\uDFF6\uD846\uDC7B\uD857\uDC4A\uD854\uDF11\uD867\uDD98\uD857\uDED8\uD84F\uDD40\uD843\uDFEA\uD843\uDD49\uD84D\uDEBA\uD843\uDE9D\uD860\uDEE2\uD843\uDC41\uD843\uDC96\uD854\uDD48\uD843\uDE76\uD84B\uDC62"],
    ["9e40", "\uD843\uDEA2\uD844\uDC75\uD84A\uDF43\uD84B\uDEB3\uD843\uDDA7\uD85A\uDC8A\uD844\uDCC1\uD851\uDF06\uD85A\uDC93\uD849\uDEF4\uD85F\uDD2F\uD850\uDDA3\uD85F\uDD73\uD85B\uDED0\uD85C\uDEB6\uD844\uDDD9\uD84F\uDCFC\uD869\uDEA9\uD843\uDEAC\uD843\uDEF9\uD847\uDCA2\uD853\uDFC2\uD85F\uDFF9\uD843\uDFEB"],
    ["9ea1", "\uD84B\uDDA0\uD851\uDFE0\uD867\uDD7C\uD843\uDFEC\uD843\uDE0A\uD85D\uDDA3\uD843\uDFED"],
    ["9ead", "\uD858\uDC48\uD844\uDD87\uD851\uDE18\uD852\uDF6E\uD856\uDE95\uD842\uDD79"],
    ["9ec5", "\uD849\uDC65\uD867\uDEAC\uD84F\uDCFE\uD867\uDF30\uD853\uDFA9\uD865\uDD9E\uD867\uDFDE\uD84F\uDDB6\uD85C\uDEB2\uD859\uDFB3\uD84D\uDF20\uD84F\uDEF7\uD84F\uDE2C\uD841\uDC8E\uD843\uDEB6\uD85F\uDF2E\uD869\uDC34\uD84C\uDCDA\uD850\uDFF2"],
    ["9ef5", "\uD844\uDEA9\uD852\uDD63\uD867\uDE06\uD85C\uDCAE"],
    ["9f40", "\uD845\uDF6C\uD865\uDCD0\uD858\uDF35\uD85C\uDD64\uD843\uDD28\uD85B\uDD22\uD852\uDEE2\uD843\uDD71"],
    ["9f4f", "\uD847\uDF0F\uD847\uDDD1\uD852\uDD3E"],
    ["9fa1", "\uD845\uDF6D"],
    ["9fae", ""],
    ["9fb2", "\uD863\uDE97\uD85B\uDD23\uD840\uDFFC\uD857\uDC21\uD84F\uDCFD"],
    ["9fc1", "\uD852\uDD19\uD843\uDCD4"],
    ["9fc9", "\uD840\uDDF2"],
    ["9fdb", ""],
    ["9fe7", ""],
    ["9feb", "\uD869\uDE4A"],
    ["9ff0", "\uD860\uDF7D\uD852\uDE77"],
    ["a040", "\uD862\uDE5A\uD868\uDEB2\uD87E\uDC40\uD852\uDEBB"],
    ["a055", "\uD846\uDC3B\uD85B\uDE05"],
    ["a058", "\uD849\uDD1B"],
    ["a05b", ""],
    ["a063", "\uD858\uDD59"],
    ["a073", "\uD84C\uDFF5"],
    ["a0a1", "\uD862\uDFC2\uD863\uDE39"],
    ["a0a6", "\uD847\uDD46\uD843\uDF3B"],
    ["a0ae", ""],
    ["a0b0", "\uD857\uDF1A\uD85D\uDC86\uD859\uDFCC\uD85B\uDED1"],
    ["a0d4", "\uD850\uDC11"],
    ["a0e2", "\uD862\uDF2D\uD84F\uDCC7\uD857\uDED7\uD85D\uDE56\uD855\uDD31\uD846\uDD44\uD844\uDEFE\uD866\uDD03\uD85B\uDDDC\uD85C\uDCAD\uD858\uDDAD\uD862\uDE0F\uD84D\uDE77\uD840\uDCEE\uD85A\uDC46\uD853\uDF0E\uD858\uDF4C\uD858\uDE6B"],
    ["a3c0", "", 31, ""],
    ["c6a1", "", 9, "", 9, "", 9, "", 23],
    ["c740", "", 58, ""],
    ["c7a1", "", 81, "", 5, "", 4],
    ["c840", "", 26, "", 25, "\uD840\uDCCC\uD840\uDC8A"],
    ["c8a1", "\uD85D\uDE07"],
    ["c8cd", ""],
    ["c8f5", ""],
    ["f9fe", ""],
    ["fa40", "\uD841\uDD47\uD841\uDDDF\uD84F\uDFC5\uD852\uDD42\uD862\uDDE4\uD846\uDDDB\uD84F\uDCC8\uD852\uDD33\uD862\uDDAA\uD840\uDEA0\uD85A\uDFB3\uD844\uDF05\uD849\uDCED\uD85B\uDD29\uD85E\uDE84\uD84D\uDE00\uD852\uDEB1\uD849\uDD13\uD840\uDF7E\uD840\uDF80\uD840\uDF47\uD841\uDC1F\uD852\uDDA4\uD841\uDC87\uD84C\uDFB4\uD842\uDFFF\uD848\uDCFC\uD840\uDEE5\uD849\uDD30\uD841\uDD8E\uD84C\uDE33\uD846\uDD83\uD841\uDDB3\uD84F\uDC99"],
    ["faa1", "\uD852\uDEA6\uD84D\uDF2D\uD85A\uDF13\uD862\uDEDE\uD84F\uDF80\uD842\uDD54\uD84F\uDFEC\uD842\uDFE2\uD845\uDF26\uD845\uDEE8\uD861\uDEAB\uD845\uDD96\uD845\uDE13\uD862\uDE9B\uD855\uDF72\uD842\uDF8F\uD84F\uDFEB\uD84B\uDDA3\uD843\uDC77\uD85A\uDF53\uD843\uDD74\uD845\uDF0D\uD843\uDEDD\uD843\uDD4D"],
    ["fb40", "\uD862\uDDBC\uD849\uDE98\uD846\uDCD7\uD850\uDC3A\uD851\uDC35\uD844\uDCB4\uD84C\uDE8A\uD862\uDF66\uD844\uDE4F\uD850\uDDA5\uD85B\uDC7E\uD845\uDC16\uD845\uDC54\uD850\uDF63\uD852\uDFF5\uD844\uDE3C\uD868\uDD50\uD850\uDE78"],
    ["fba1", "\uD845\uDE3E\uD845\uDE92\uD843\uDD4E\uD85B\uDC81\uD85B\uDD2A\uD845\uDFDC\uD845\uDFFB\uD845\uDFB2\uD85B\uDDA6\uD846\uDC28\uD845\uDED5\uD85B\uDE45\uD852\uDDA9\uD85B\uDFA1\uD849\uDD54\uD846\uDD11\uD845\uDEB8\uD85E\uDE0E\uD840\uDE04\uD846\uDE34\uD856\uDDCC\uD841\uDDA5\uD846\uDF44\uD847\uDCA5\uD85A\uDF28\uD847\uDDF9\uD847\uDE37\uD847\uDEA4\uD852\uDD01\uD848\uDC49\uD848\uDD73\uD851\uDCBC\uD843\uDCD3\uD845\uDF71\uD861\uDC82"],
    ["fc40", "\uD840\uDDC1\uD87E\uDC94\uD844\uDF3A\uD85A\uDC88\uD848\uDFD0\uD849\uDC71\uD85B\uDE6E\uD862\uDE36\uD854\uDE50\uD847\uDF6A\uD85C\uDCF8\uD849\uDE68\uD840\uDE9E\uD862\uDE29\uD846\uDC77\uD849\uDFB4\uD852\uDD82\uD852\uDD8F\uD85E\uDE53\uD87E\uDCA6\uD85B\uDED2\uD841\uDE56\uD84F\uDFB7"],
    ["fca1", "\uD84A\uDC5F\uD862\uDF9D\uD866\uDD5D\uD84A\uDD80\uD84A\uDCC1\uD840\uDD18\uD845\uDF70\uD84B\uDE0D\uD852\uDDDF\uD844\uDF8E\uD845\uDFFC\uD84B\uDE36\uD850\uDC8C\uD855\uDF1D\uD852\uDE28\uD852\uDE23\uD84C\uDC7E\uD852\uDD40\uD846\uDC29\uD84D\uDC00\uD84C\uDDF7\uD84C\uDDF8\uD84C\uDDA4\uD84C\uDDA5\uD843\uDE75\uD854\uDDE6\uD847\uDE3D\uD84C\uDE31\uD861\uDDF4\uD84C\uDDC8\uD854\uDF13\uD84A\uDCF7\uD850\uDF9C\uD852\uDE21\uD84D\uDFC2\uD850\uDDCD\uD864\uDCED\uD84C\uDFE6\uD85B\uDDA0"],
    ["fd40", "\uD84D\uDC6F\uD862\uDEDF\uD84D\uDDCD\uD84D\uDE3C\uD862\uDE4A\uD840\uDFC9\uD84D\uDE59\uD848\uDD2A\uD84D\uDF03\uD864\uDD9C\uD842\uDD23\uD849\uDFCD\uD84E\uDEDB\uD840\uDFB5\uD846\uDD58\uD84E\uDF5A\uD84F\uDEFC\uD849\uDC8B\uD852\uDCF1\uD85A\uDF51\uD84F\uDDBC\uD84F\uDDBD\uD850\uDDA4\uD852\uDD0C\uD852\uDD00"],
    ["fda1", "\uD84F\uDCC9\uD843\uDD32\uD84C\uDDF9\uD849\uDC91\uD85B\uDD25\uD85B\uDDA1\uD85B\uDDEB\uD852\uDD7F\uD850\uDC85\uD85B\uDE72\uD85B\uDF74\uD862\uDF21\uD84F\uDE2F\uD84F\uDF82\uD84C\uDC4B\uD84F\uDE30\uD845\uDC97\uD850\uDC3D\uD864\uDD70\uD850\uDD44\uD850\uDC91\uD850\uDD55\uD850\uDC39\uD84F\uDFF0\uD84F\uDFB4\uD850\uDD3F\uD850\uDD56\uD850\uDD57\uD850\uDD40\uD858\uDDDD\uD850\uDE77\uD850\uDF65\uD850\uDEC1\uD851\uDC5A\uD852\uDE27\uD852\uDE22\uD862\uDFE8"],
    ["fe40", "\uD855\uDE05\uD852\uDD74\uD84C\uDC44\uD852\uDC23\uD862\uDC2B\uD862\uDC04\uD843\uDC3A\uD85A\uDE2E\uD850\uDDE2\uD845\uDEE7\uD852\uDE24\uD852\uDDB7\uD852\uDD8D\uD852\uDDFB\uD852\uDE26\uD841\uDDC3\uD84A\uDCAD\uD863\uDEB2\uD852\uDE8C"],
    ["fea1", "\uD850\uDD5F\uD852\uDE79\uD862\uDF8F\uD863\uDC03\uD846\uDC9E\uD846\uDD88\uD863\uDED9\uD846\uDE4B\uD863\uDEAC\uD853\uDF82\uD853\uDD13\uD858\uDFF5\uD85A\uDD11\uD85A\uDD0E\uD85B\uDF9F\uD854\uDC9D\uD854\uDD7D\uD847\uDE1C\uD854\uDE20\uD84C\uDEAC\uD862\uDD64\uD862\uDD68\uD845\uDEC1\uD844\uDF76\uD852\uDE12\uD855\uDDE0\uD85D\uDE0C\uD862\uDF2B\uD858\uDC83\uD849\uDE1C\uD856\uDC57\uD85E\uDF39\uD85C\uDD26\uD864\uDD0D"]
  ];
});

// node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS((exports, module) => {
  module.exports = {
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require_shiftjis();
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    "932": "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require_eucjp();
      },
      encodeAdd: { "": 92, "": 126 }
    },
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    windows936: "cp936",
    ms936: "cp936",
    "936": "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require_cp936();
      }
    },
    gbk: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      },
      gb18030: function() {
        return require_gb18030_ranges();
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    chinese: "gb18030",
    windows949: "cp949",
    ms949: "cp949",
    "949": "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require_cp949();
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    windows950: "cp950",
    ms950: "cp950",
    "950": "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require_cp950();
      }
    },
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require_cp950().concat(require_big5_added());
      },
      encodeSkipVals: [41676]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  };
});

// node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS((exports, module) => {
  var modules = [
    require_internal(),
    require_utf16(),
    require_utf7(),
    require_sbcs_codec(),
    require_sbcs_data(),
    require_sbcs_data_generated(),
    require_dbcs_codec(),
    require_dbcs_data()
  ];
  for (i = 0;i < modules.length; i++) {
    module = modules[i];
    for (enc in module)
      if (Object.prototype.hasOwnProperty.call(module, enc))
        exports[enc] = module[enc];
  }
  var module;
  var enc;
  var i;
});

// node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS((exports, module) => {
  var Buffer2 = __require("buffer").Buffer;
  var Transform = __require("stream").Transform;
  module.exports = function(iconv) {
    iconv.encodeStream = function encodeStream(encoding, options) {
      return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding, options) {
      return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };
    iconv.supportsStreams = true;
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
  };
  function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false;
    Transform.call(this, options);
  }
  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
  });
  IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
    if (typeof chunk != "string")
      return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length)
        this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length)
        this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on("error", cb);
    this.on("data", function(chunk) {
      chunks.push(chunk);
    });
    this.on("end", function() {
      cb(null, Buffer2.concat(chunks));
    });
    return this;
  };
  function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = "utf8";
    Transform.call(this, options);
  }
  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
  });
  IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
    if (!Buffer2.isBuffer(chunk))
      return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length)
        this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length)
        this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = "";
    this.on("error", cb);
    this.on("data", function(chunk) {
      res += chunk;
    });
    this.on("end", function() {
      cb(null, res);
    });
    return this;
  };
});

// node_modules/iconv-lite/lib/extend-node.js
var require_extend_node = __commonJS((exports, module) => {
  var Buffer2 = __require("buffer").Buffer;
  module.exports = function(iconv) {
    var original = undefined;
    iconv.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array);
    iconv.extendNodeEncodings = function extendNodeEncodings() {
      if (original)
        return;
      original = {};
      if (!iconv.supportsNodeEncodingsExtension) {
        console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
        console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
        return;
      }
      var nodeNativeEncodings = {
        hex: true,
        utf8: true,
        "utf-8": true,
        ascii: true,
        binary: true,
        base64: true,
        ucs2: true,
        "ucs-2": true,
        utf16le: true,
        "utf-16le": true
      };
      Buffer2.isNativeEncoding = function(enc) {
        return enc && nodeNativeEncodings[enc.toLowerCase()];
      };
      var SlowBuffer = __require("buffer").SlowBuffer;
      original.SlowBufferToString = SlowBuffer.prototype.toString;
      SlowBuffer.prototype.toString = function(encoding, start, end) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.SlowBufferToString.call(this, encoding, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding);
      };
      original.SlowBufferWrite = SlowBuffer.prototype.write;
      SlowBuffer.prototype.write = function(string2, offset, length, encoding) {
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding = length;
            length = undefined;
          }
        } else {
          var swap = encoding;
          encoding = offset;
          offset = length;
          length = swap;
        }
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.SlowBufferWrite.call(this, string2, offset, length, encoding);
        if (string2.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string2, encoding);
        if (buf.length < length)
          length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      original.BufferIsEncoding = Buffer2.isEncoding;
      Buffer2.isEncoding = function(encoding) {
        return Buffer2.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
      };
      original.BufferByteLength = Buffer2.byteLength;
      Buffer2.byteLength = SlowBuffer.byteLength = function(str, encoding) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferByteLength.call(this, str, encoding);
        return iconv.encode(str, encoding).length;
      };
      original.BufferToString = Buffer2.prototype.toString;
      Buffer2.prototype.toString = function(encoding, start, end) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferToString.call(this, encoding, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding);
      };
      original.BufferWrite = Buffer2.prototype.write;
      Buffer2.prototype.write = function(string2, offset, length, encoding) {
        var _offset = offset, _length = length, _encoding = encoding;
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding = length;
            length = undefined;
          }
        } else {
          var swap = encoding;
          encoding = offset;
          offset = length;
          length = swap;
        }
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferWrite.call(this, string2, _offset, _length, _encoding);
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        if (string2.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string2, encoding);
        if (buf.length < length)
          length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      if (iconv.supportsStreams) {
        var Readable = __require("stream").Readable;
        original.ReadableSetEncoding = Readable.prototype.setEncoding;
        Readable.prototype.setEncoding = function setEncoding(enc, options) {
          this._readableState.decoder = iconv.getDecoder(enc, options);
          this._readableState.encoding = enc;
        };
        Readable.prototype.collect = iconv._collect;
      }
    };
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
      if (!iconv.supportsNodeEncodingsExtension)
        return;
      if (!original)
        throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
      delete Buffer2.isNativeEncoding;
      var SlowBuffer = __require("buffer").SlowBuffer;
      SlowBuffer.prototype.toString = original.SlowBufferToString;
      SlowBuffer.prototype.write = original.SlowBufferWrite;
      Buffer2.isEncoding = original.BufferIsEncoding;
      Buffer2.byteLength = original.BufferByteLength;
      Buffer2.prototype.toString = original.BufferToString;
      Buffer2.prototype.write = original.BufferWrite;
      if (iconv.supportsStreams) {
        var Readable = __require("stream").Readable;
        Readable.prototype.setEncoding = original.ReadableSetEncoding;
        delete Readable.prototype.collect;
      }
      original = undefined;
    };
  };
});

// node_modules/iconv-lite/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  var bomHandling = require_bom_handling();
  var iconv = exports;
  iconv.encodings = null;
  iconv.defaultCharUnicode = "";
  iconv.defaultCharSingleByte = "?";
  iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || "");
    var encoder = iconv.getEncoder(encoding, options);
    var res = encoder.write(str);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === "string") {
      if (!iconv.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder = iconv.getDecoder(encoding, options);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv.encodingExists = function encodingExists(enc) {
    try {
      iconv.getCodec(enc);
      return true;
    } catch (e) {
      return false;
    }
  };
  iconv.toEncoding = iconv.encode;
  iconv.fromEncoding = iconv.decode;
  iconv._codecDataCache = {};
  iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
      iconv.encodings = require_encodings();
    var enc = iconv._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv._codecDataCache[enc];
      if (codec)
        return codec;
      var codecDef = iconv.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key2 in codecDef)
            codecOptions[key2] = codecDef[key2];
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv);
          iconv._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM)
      encoder = new bomHandling.PrependBOM(encoder, options);
    return encoder;
  };
  iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false))
      decoder = new bomHandling.StripBOM(decoder, options);
    return decoder;
  };
  var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
  if (nodeVer) {
    nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
      require_streams()(iconv);
    }
    require_extend_node()(iconv);
  }
  var nodeVerArr;
  if (false) {
  }
});

// node_modules/os-tmpdir/index.js
var require_os_tmpdir = __commonJS((exports, module) => {
  var isWindows = process.platform === "win32";
  var trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;
  module.exports = function() {
    var path;
    if (isWindows) {
      path = process.env.TEMP || process.env.TMP || (process.env.SystemRoot || process.env.windir) + "\\temp";
    } else {
      path = process.env.TMPDIR || process.env.TMP || process.env.TEMP || "/tmp";
    }
    if (trailingSlashRe.test(path)) {
      path = path.slice(0, -1);
    }
    return path;
  };
});

// node_modules/tmp/lib/tmp.js
var require_tmp = __commonJS((exports, module) => {
  /*!
   * Tmp
   *
   * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
   *
   * MIT Licensed
   */
  var fs = __require("fs");
  var path = __require("path");
  var crypto = __require("crypto");
  var osTmpDir = require_os_tmpdir();
  var _c = process.binding("constants");
  var tmpDir = osTmpDir();
  var RANDOM_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  var TEMPLATE_PATTERN = /XXXXXX/;
  var DEFAULT_TRIES = 3;
  var CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR);
  var EBADF = _c.EBADF || _c.os.errno.EBADF;
  var ENOENT = _c.ENOENT || _c.os.errno.ENOENT;
  var DIR_MODE = 448;
  var FILE_MODE = 384;
  var _removeObjects = [];
  var _gracefulCleanup = false;
  var _uncaughtException = false;
  function _randomChars(howMany) {
    var value = [], rnd = null;
    try {
      rnd = crypto.randomBytes(howMany);
    } catch (e) {
      rnd = crypto.pseudoRandomBytes(howMany);
    }
    for (var i = 0;i < howMany; i++) {
      value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
    }
    return value.join("");
  }
  function _isUndefined(obj) {
    return typeof obj === "undefined";
  }
  function _parseArguments(options, callback) {
    if (typeof options == "function") {
      return [callback || {}, options];
    }
    if (_isUndefined(options)) {
      return [{}, callback];
    }
    return [options, callback];
  }
  function _generateTmpName(opts) {
    if (opts.name) {
      return path.join(opts.dir || tmpDir, opts.name);
    }
    if (opts.template) {
      return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));
    }
    const name = [
      opts.prefix || "tmp-",
      process.pid,
      _randomChars(12),
      opts.postfix || ""
    ].join("");
    return path.join(opts.dir || tmpDir, name);
  }
  function tmpName(options, callback) {
    var args = _parseArguments(options, callback), opts = args[0], cb = args[1], tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;
    if (isNaN(tries) || tries < 0)
      return cb(new Error("Invalid tries"));
    if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
      return cb(new Error("Invalid template provided"));
    (function _getUniqueName() {
      const name = _generateTmpName(opts);
      fs.stat(name, function(err) {
        if (!err) {
          if (tries-- > 0)
            return _getUniqueName();
          return cb(new Error("Could not get a unique tmp filename, max tries reached " + name));
        }
        cb(null, name);
      });
    })();
  }
  function tmpNameSync(options) {
    var args = _parseArguments(options), opts = args[0], tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;
    if (isNaN(tries) || tries < 0)
      throw new Error("Invalid tries");
    if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
      throw new Error("Invalid template provided");
    do {
      const name = _generateTmpName(opts);
      try {
        fs.statSync(name);
      } catch (e) {
        return name;
      }
    } while (tries-- > 0);
    throw new Error("Could not get a unique tmp filename, max tries reached");
  }
  function file(options, callback) {
    var args = _parseArguments(options, callback), opts = args[0], cb = args[1];
    opts.postfix = _isUndefined(opts.postfix) ? ".tmp" : opts.postfix;
    tmpName(opts, function _tmpNameCreated(err, name) {
      if (err)
        return cb(err);
      fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err2, fd) {
        if (err2)
          return cb(err2);
        if (opts.discardDescriptor) {
          return fs.close(fd, function _discardCallback(err3) {
            if (err3) {
              try {
                fs.unlinkSync(name);
              } catch (e) {
                if (!isENOENT(e)) {
                  err3 = e;
                }
              }
              return cb(err3);
            }
            cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));
          });
        }
        if (opts.detachDescriptor) {
          return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));
        }
        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));
      });
    });
  }
  function fileSync(options) {
    var args = _parseArguments(options), opts = args[0];
    opts.postfix = opts.postfix || ".tmp";
    const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
    const name = tmpNameSync(opts);
    var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
    if (opts.discardDescriptor) {
      fs.closeSync(fd);
      fd = undefined;
    }
    return {
      name,
      fd,
      removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)
    };
  }
  function _rmdirRecursiveSync(root) {
    const dirs = [root];
    do {
      var dir2 = dirs.pop(), deferred = false, files = fs.readdirSync(dir2);
      for (var i = 0, length = files.length;i < length; i++) {
        var file2 = path.join(dir2, files[i]), stat = fs.lstatSync(file2);
        if (stat.isDirectory()) {
          if (!deferred) {
            deferred = true;
            dirs.push(dir2);
          }
          dirs.push(file2);
        } else {
          fs.unlinkSync(file2);
        }
      }
      if (!deferred) {
        fs.rmdirSync(dir2);
      }
    } while (dirs.length !== 0);
  }
  function dir(options, callback) {
    var args = _parseArguments(options, callback), opts = args[0], cb = args[1];
    tmpName(opts, function _tmpNameCreated(err, name) {
      if (err)
        return cb(err);
      fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err2) {
        if (err2)
          return cb(err2);
        cb(null, name, _prepareTmpDirRemoveCallback(name, opts));
      });
    });
  }
  function dirSync(options) {
    var args = _parseArguments(options), opts = args[0];
    const name = tmpNameSync(opts);
    fs.mkdirSync(name, opts.mode || DIR_MODE);
    return {
      name,
      removeCallback: _prepareTmpDirRemoveCallback(name, opts)
    };
  }
  function _prepareTmpFileRemoveCallback(name, fd, opts) {
    const removeCallback = _prepareRemoveCallback(function _removeCallback(fdPath) {
      try {
        if (0 <= fdPath[0]) {
          fs.closeSync(fdPath[0]);
        }
      } catch (e) {
        if (!isEBADF(e) && !isENOENT(e)) {
          throw e;
        }
      }
      try {
        fs.unlinkSync(fdPath[1]);
      } catch (e) {
        if (!isENOENT(e)) {
          throw e;
        }
      }
    }, [fd, name]);
    if (!opts.keep) {
      _removeObjects.unshift(removeCallback);
    }
    return removeCallback;
  }
  function _prepareTmpDirRemoveCallback(name, opts) {
    const removeFunction = opts.unsafeCleanup ? _rmdirRecursiveSync : fs.rmdirSync.bind(fs);
    const removeCallback = _prepareRemoveCallback(removeFunction, name);
    if (!opts.keep) {
      _removeObjects.unshift(removeCallback);
    }
    return removeCallback;
  }
  function _prepareRemoveCallback(removeFunction, arg) {
    var called = false;
    return function _cleanupCallback(next) {
      if (!called) {
        const index = _removeObjects.indexOf(_cleanupCallback);
        if (index >= 0) {
          _removeObjects.splice(index, 1);
        }
        called = true;
        removeFunction(arg);
      }
      if (next)
        next(null);
    };
  }
  function _garbageCollector() {
    if (_uncaughtException && !_gracefulCleanup) {
      return;
    }
    while (_removeObjects.length) {
      try {
        _removeObjects[0].call(null);
      } catch (e) {
      }
    }
  }
  function isEBADF(error) {
    return isExpectedError(error, -EBADF, "EBADF");
  }
  function isENOENT(error) {
    return isExpectedError(error, -ENOENT, "ENOENT");
  }
  function isExpectedError(error, code, errno) {
    return error.code == code || error.code == errno;
  }
  function setGracefulCleanup() {
    _gracefulCleanup = true;
  }
  var version = process.versions.node.split(".").map(function(value) {
    return parseInt(value, 10);
  });
  if (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {
    process.addListener("uncaughtException", function _uncaughtExceptionThrown(err) {
      _uncaughtException = true;
      _garbageCollector();
      throw err;
    });
  }
  process.addListener("exit", function _exit(code) {
    if (code)
      _uncaughtException = true;
    _garbageCollector();
  });
  exports.tmpdir = tmpDir;
  exports.dir = dir;
  exports.dirSync = dirSync;
  exports.file = file;
  exports.fileSync = fileSync;
  exports.tmpName = tmpName;
  exports.tmpNameSync = tmpNameSync;
  exports.setGracefulCleanup = setGracefulCleanup;
});

// node_modules/external-editor/main/errors/CreateFileError.js
var require_CreateFileError = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var CreateFileError = function(_super) {
    __extends(CreateFileError2, _super);
    function CreateFileError2(originalError) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, "Failed to create temporary file for editor") || this;
      _this.originalError = originalError;
      var proto = _newTarget.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(_this, proto);
      } else {
        _this.__proto__ = _newTarget.prototype;
      }
      return _this;
    }
    return CreateFileError2;
  }(Error);
  exports.CreateFileError = CreateFileError;
});

// node_modules/external-editor/main/errors/LaunchEditorError.js
var require_LaunchEditorError = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var LaunchEditorError = function(_super) {
    __extends(LaunchEditorError2, _super);
    function LaunchEditorError2(originalError) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, "Failed launch editor") || this;
      _this.originalError = originalError;
      var proto = _newTarget.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(_this, proto);
      } else {
        _this.__proto__ = _newTarget.prototype;
      }
      return _this;
    }
    return LaunchEditorError2;
  }(Error);
  exports.LaunchEditorError = LaunchEditorError;
});

// node_modules/external-editor/main/errors/ReadFileError.js
var require_ReadFileError = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var ReadFileError = function(_super) {
    __extends(ReadFileError2, _super);
    function ReadFileError2(originalError) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, "Failed to read temporary file") || this;
      _this.originalError = originalError;
      var proto = _newTarget.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(_this, proto);
      } else {
        _this.__proto__ = _newTarget.prototype;
      }
      return _this;
    }
    return ReadFileError2;
  }(Error);
  exports.ReadFileError = ReadFileError;
});

// node_modules/external-editor/main/errors/RemoveFileError.js
var require_RemoveFileError = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var RemoveFileError = function(_super) {
    __extends(RemoveFileError2, _super);
    function RemoveFileError2(originalError) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, "Failed to cleanup temporary file") || this;
      _this.originalError = originalError;
      var proto = _newTarget.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(_this, proto);
      } else {
        _this.__proto__ = _newTarget.prototype;
      }
      return _this;
    }
    return RemoveFileError2;
  }(Error);
  exports.RemoveFileError = RemoveFileError;
});

// node_modules/external-editor/main/index.js
var require_main = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var chardet_1 = require_chardet();
  var child_process_1 = __require("child_process");
  var fs_1 = __require("fs");
  var iconv_lite_1 = require_lib3();
  var tmp_1 = require_tmp();
  var CreateFileError_1 = require_CreateFileError();
  exports.CreateFileError = CreateFileError_1.CreateFileError;
  var LaunchEditorError_1 = require_LaunchEditorError();
  exports.LaunchEditorError = LaunchEditorError_1.LaunchEditorError;
  var ReadFileError_1 = require_ReadFileError();
  exports.ReadFileError = ReadFileError_1.ReadFileError;
  var RemoveFileError_1 = require_RemoveFileError();
  exports.RemoveFileError = RemoveFileError_1.RemoveFileError;
  function edit(text, fileOptions) {
    if (text === undefined) {
      text = "";
    }
    var editor = new ExternalEditor(text, fileOptions);
    editor.run();
    editor.cleanup();
    return editor.text;
  }
  exports.edit = edit;
  function editAsync(text, callback, fileOptions) {
    if (text === undefined) {
      text = "";
    }
    var editor = new ExternalEditor(text, fileOptions);
    editor.runAsync(function(err, result) {
      if (err) {
        setImmediate(callback, err, null);
      } else {
        try {
          editor.cleanup();
          setImmediate(callback, null, result);
        } catch (cleanupError) {
          setImmediate(callback, cleanupError, null);
        }
      }
    });
  }
  exports.editAsync = editAsync;
  var ExternalEditor = function() {
    function ExternalEditor2(text, fileOptions) {
      if (text === undefined) {
        text = "";
      }
      this.text = "";
      this.fileOptions = {};
      this.text = text;
      if (fileOptions) {
        this.fileOptions = fileOptions;
      }
      this.determineEditor();
      this.createTemporaryFile();
    }
    ExternalEditor2.splitStringBySpace = function(str) {
      var pieces = [];
      var currentString = "";
      for (var strIndex = 0;strIndex < str.length; strIndex++) {
        var currentLetter = str[strIndex];
        if (strIndex > 0 && currentLetter === " " && str[strIndex - 1] !== "\\" && currentString.length > 0) {
          pieces.push(currentString);
          currentString = "";
        } else {
          currentString += currentLetter;
        }
      }
      if (currentString.length > 0) {
        pieces.push(currentString);
      }
      return pieces;
    };
    Object.defineProperty(ExternalEditor2.prototype, "temp_file", {
      get: function() {
        console.log("DEPRECATED: temp_file. Use tempFile moving forward.");
        return this.tempFile;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ExternalEditor2.prototype, "last_exit_status", {
      get: function() {
        console.log("DEPRECATED: last_exit_status. Use lastExitStatus moving forward.");
        return this.lastExitStatus;
      },
      enumerable: true,
      configurable: true
    });
    ExternalEditor2.prototype.run = function() {
      this.launchEditor();
      this.readTemporaryFile();
      return this.text;
    };
    ExternalEditor2.prototype.runAsync = function(callback) {
      var _this = this;
      try {
        this.launchEditorAsync(function() {
          try {
            _this.readTemporaryFile();
            setImmediate(callback, null, _this.text);
          } catch (readError) {
            setImmediate(callback, readError, null);
          }
        });
      } catch (launchError) {
        setImmediate(callback, launchError, null);
      }
    };
    ExternalEditor2.prototype.cleanup = function() {
      this.removeTemporaryFile();
    };
    ExternalEditor2.prototype.determineEditor = function() {
      var editor = process.env.VISUAL ? process.env.VISUAL : process.env.EDITOR ? process.env.EDITOR : /^win/.test(process.platform) ? "notepad" : "vim";
      var editorOpts = ExternalEditor2.splitStringBySpace(editor).map(function(piece) {
        return piece.replace("\\ ", " ");
      });
      var bin = editorOpts.shift();
      this.editor = { args: editorOpts, bin };
    };
    ExternalEditor2.prototype.createTemporaryFile = function() {
      try {
        this.tempFile = tmp_1.tmpNameSync(this.fileOptions);
        var opt = { encoding: "utf8" };
        if (this.fileOptions.hasOwnProperty("mode")) {
          opt.mode = this.fileOptions.mode;
        }
        fs_1.writeFileSync(this.tempFile, this.text, opt);
      } catch (createFileError) {
        throw new CreateFileError_1.CreateFileError(createFileError);
      }
    };
    ExternalEditor2.prototype.readTemporaryFile = function() {
      try {
        var tempFileBuffer = fs_1.readFileSync(this.tempFile);
        if (tempFileBuffer.length === 0) {
          this.text = "";
        } else {
          var encoding = chardet_1.detect(tempFileBuffer).toString();
          if (!iconv_lite_1.encodingExists(encoding)) {
            encoding = "utf8";
          }
          this.text = iconv_lite_1.decode(tempFileBuffer, encoding);
        }
      } catch (readFileError) {
        throw new ReadFileError_1.ReadFileError(readFileError);
      }
    };
    ExternalEditor2.prototype.removeTemporaryFile = function() {
      try {
        fs_1.unlinkSync(this.tempFile);
      } catch (removeFileError) {
        throw new RemoveFileError_1.RemoveFileError(removeFileError);
      }
    };
    ExternalEditor2.prototype.launchEditor = function() {
      try {
        var editorProcess = child_process_1.spawnSync(this.editor.bin, this.editor.args.concat([this.tempFile]), { stdio: "inherit" });
        this.lastExitStatus = editorProcess.status;
      } catch (launchError) {
        throw new LaunchEditorError_1.LaunchEditorError(launchError);
      }
    };
    ExternalEditor2.prototype.launchEditorAsync = function(callback) {
      var _this = this;
      try {
        var editorProcess = child_process_1.spawn(this.editor.bin, this.editor.args.concat([this.tempFile]), { stdio: "inherit" });
        editorProcess.on("exit", function(code) {
          _this.lastExitStatus = code;
          setImmediate(callback);
        });
      } catch (launchError) {
        throw new LaunchEditorError_1.LaunchEditorError(launchError);
      }
    };
    return ExternalEditor2;
  }();
  exports.ExternalEditor = ExternalEditor;
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/key.js
var isEnterKey2 = (key2) => key2.name === "enter" || key2.name === "return";

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/errors.js
var AbortPromptError2, CancelPromptError2, ExitPromptError2, HookError2, ValidationError2;
var init_errors2 = __esm(() => {
  AbortPromptError2 = class AbortPromptError2 extends Error {
    name = "AbortPromptError";
    message = "Prompt was aborted";
    constructor(options) {
      super();
      this.cause = options?.cause;
    }
  };
  CancelPromptError2 = class CancelPromptError2 extends Error {
    name = "CancelPromptError";
    message = "Prompt was canceled";
  };
  ExitPromptError2 = class ExitPromptError2 extends Error {
    name = "ExitPromptError";
  };
  HookError2 = class HookError2 extends Error {
    name = "HookError";
  };
  ValidationError2 = class ValidationError2 extends Error {
    name = "ValidationError";
  };
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/hook-engine.js
import { AsyncLocalStorage as AsyncLocalStorage2, AsyncResource as AsyncResource4 } from "node:async_hooks";
function createStore2(rl) {
  const store = {
    rl,
    hooks: [],
    hooksCleanup: [],
    hooksEffect: [],
    index: 0,
    handleChange() {
    }
  };
  return store;
}
function withHooks2(rl, cb) {
  const store = createStore2(rl);
  return hookStorage2.run(store, () => {
    function cycle(render) {
      store.handleChange = () => {
        store.index = 0;
        render();
      };
      store.handleChange();
    }
    return cb(cycle);
  });
}
function getStore2() {
  const store = hookStorage2.getStore();
  if (!store) {
    throw new HookError2("[Inquirer] Hook functions can only be called from within a prompt");
  }
  return store;
}
function readline3() {
  return getStore2().rl;
}
function withUpdates2(fn) {
  const wrapped = (...args) => {
    const store = getStore2();
    let shouldUpdate = false;
    const oldHandleChange = store.handleChange;
    store.handleChange = () => {
      shouldUpdate = true;
    };
    const returnValue = fn(...args);
    if (shouldUpdate) {
      oldHandleChange();
    }
    store.handleChange = oldHandleChange;
    return returnValue;
  };
  return AsyncResource4.bind(wrapped);
}
function withPointer2(cb) {
  const store = getStore2();
  const { index } = store;
  const pointer = {
    get() {
      return store.hooks[index];
    },
    set(value) {
      store.hooks[index] = value;
    },
    initialized: index in store.hooks
  };
  const returnValue = cb(pointer);
  store.index++;
  return returnValue;
}
function handleChange2() {
  getStore2().handleChange();
}
var hookStorage2, effectScheduler2;
var init_hook_engine2 = __esm(() => {
  init_errors2();
  hookStorage2 = new AsyncLocalStorage2;
  effectScheduler2 = {
    queue(cb) {
      const store = getStore2();
      const { index } = store;
      store.hooksEffect.push(() => {
        store.hooksCleanup[index]?.();
        const cleanFn = cb(readline3());
        if (cleanFn != null && typeof cleanFn !== "function") {
          throw new ValidationError2("useEffect return value must be a cleanup function or nothing.");
        }
        store.hooksCleanup[index] = cleanFn;
      });
    },
    run() {
      const store = getStore2();
      withUpdates2(() => {
        store.hooksEffect.forEach((effect) => {
          effect();
        });
        store.hooksEffect.length = 0;
      })();
    },
    clearAll() {
      const store = getStore2();
      store.hooksCleanup.forEach((cleanFn) => {
        cleanFn?.();
      });
      store.hooksEffect.length = 0;
      store.hooksCleanup.length = 0;
    }
  };
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/use-state.js
function useState2(defaultValue) {
  return withPointer2((pointer) => {
    const setFn = (newValue) => {
      if (pointer.get() !== newValue) {
        pointer.set(newValue);
        handleChange2();
      }
    };
    if (pointer.initialized) {
      return [pointer.get(), setFn];
    }
    const value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
    pointer.set(value);
    return [value, setFn];
  });
}
var init_use_state2 = __esm(() => {
  init_hook_engine2();
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/use-effect.js
function useEffect2(cb, depArray) {
  withPointer2((pointer) => {
    const oldDeps = pointer.get();
    const hasChanged = !Array.isArray(oldDeps) || depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    if (hasChanged) {
      effectScheduler2.queue(cb);
    }
    pointer.set(depArray);
  });
}
var init_use_effect2 = __esm(() => {
  init_hook_engine2();
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/node_modules/@inquirer/figures/dist/esm/index.js
import process4 from "node:process";
function isUnicodeSupported2() {
  if (process4.platform !== "win32") {
    return process4.env["TERM"] !== "linux";
  }
  return Boolean(process4.env["WT_SESSION"]) || Boolean(process4.env["TERMINUS_SUBLIME"]) || process4.env["ConEmuTask"] === "{cmd::Cmder}" || process4.env["TERM_PROGRAM"] === "Terminus-Sublime" || process4.env["TERM_PROGRAM"] === "vscode" || process4.env["TERM"] === "xterm-256color" || process4.env["TERM"] === "alacritty" || process4.env["TERMINAL_EMULATOR"] === "JetBrains-JediTerm";
}
var common2, specialMainSymbols2, specialFallbackSymbols2, mainSymbols2, fallbackSymbols2, shouldUseMain2, figures2, esm_default3, replacements2;
var init_esm4 = __esm(() => {
  common2 = {
    circleQuestionMark: "(?)",
    questionMarkPrefix: "(?)",
    square: "",
    squareDarkShade: "",
    squareMediumShade: "",
    squareLightShade: "",
    squareTop: "",
    squareBottom: "",
    squareLeft: "",
    squareRight: "",
    squareCenter: "",
    bullet: "",
    dot: "",
    ellipsis: "",
    pointerSmall: "",
    triangleUp: "",
    triangleUpSmall: "",
    triangleDown: "",
    triangleDownSmall: "",
    triangleLeftSmall: "",
    triangleRightSmall: "",
    home: "",
    heart: "",
    musicNote: "",
    musicNoteBeamed: "",
    arrowUp: "",
    arrowDown: "",
    arrowLeft: "",
    arrowRight: "",
    arrowLeftRight: "",
    arrowUpDown: "",
    almostEqual: "",
    notEqual: "",
    lessOrEqual: "",
    greaterOrEqual: "",
    identical: "",
    infinity: "",
    subscriptZero: "",
    subscriptOne: "",
    subscriptTwo: "",
    subscriptThree: "",
    subscriptFour: "",
    subscriptFive: "",
    subscriptSix: "",
    subscriptSeven: "",
    subscriptEight: "",
    subscriptNine: "",
    oneHalf: "",
    oneThird: "",
    oneQuarter: "",
    oneFifth: "",
    oneSixth: "",
    oneEighth: "",
    twoThirds: "",
    twoFifths: "",
    threeQuarters: "",
    threeFifths: "",
    threeEighths: "",
    fourFifths: "",
    fiveSixths: "",
    fiveEighths: "",
    sevenEighths: "",
    line: "",
    lineBold: "",
    lineDouble: "",
    lineDashed0: "",
    lineDashed1: "",
    lineDashed2: "",
    lineDashed3: "",
    lineDashed4: "",
    lineDashed5: "",
    lineDashed6: "",
    lineDashed7: "",
    lineDashed8: "",
    lineDashed9: "",
    lineDashed10: "",
    lineDashed11: "",
    lineDashed12: "",
    lineDashed13: "",
    lineDashed14: "",
    lineDashed15: "",
    lineVertical: "",
    lineVerticalBold: "",
    lineVerticalDouble: "",
    lineVerticalDashed0: "",
    lineVerticalDashed1: "",
    lineVerticalDashed2: "",
    lineVerticalDashed3: "",
    lineVerticalDashed4: "",
    lineVerticalDashed5: "",
    lineVerticalDashed6: "",
    lineVerticalDashed7: "",
    lineVerticalDashed8: "",
    lineVerticalDashed9: "",
    lineVerticalDashed10: "",
    lineVerticalDashed11: "",
    lineDownLeft: "",
    lineDownLeftArc: "",
    lineDownBoldLeftBold: "",
    lineDownBoldLeft: "",
    lineDownLeftBold: "",
    lineDownDoubleLeftDouble: "",
    lineDownDoubleLeft: "",
    lineDownLeftDouble: "",
    lineDownRight: "",
    lineDownRightArc: "",
    lineDownBoldRightBold: "",
    lineDownBoldRight: "",
    lineDownRightBold: "",
    lineDownDoubleRightDouble: "",
    lineDownDoubleRight: "",
    lineDownRightDouble: "",
    lineUpLeft: "",
    lineUpLeftArc: "",
    lineUpBoldLeftBold: "",
    lineUpBoldLeft: "",
    lineUpLeftBold: "",
    lineUpDoubleLeftDouble: "",
    lineUpDoubleLeft: "",
    lineUpLeftDouble: "",
    lineUpRight: "",
    lineUpRightArc: "",
    lineUpBoldRightBold: "",
    lineUpBoldRight: "",
    lineUpRightBold: "",
    lineUpDoubleRightDouble: "",
    lineUpDoubleRight: "",
    lineUpRightDouble: "",
    lineUpDownLeft: "",
    lineUpBoldDownBoldLeftBold: "",
    lineUpBoldDownBoldLeft: "",
    lineUpDownLeftBold: "",
    lineUpBoldDownLeftBold: "",
    lineUpDownBoldLeftBold: "",
    lineUpDownBoldLeft: "",
    lineUpBoldDownLeft: "",
    lineUpDoubleDownDoubleLeftDouble: "",
    lineUpDoubleDownDoubleLeft: "",
    lineUpDownLeftDouble: "",
    lineUpDownRight: "",
    lineUpBoldDownBoldRightBold: "",
    lineUpBoldDownBoldRight: "",
    lineUpDownRightBold: "",
    lineUpBoldDownRightBold: "",
    lineUpDownBoldRightBold: "",
    lineUpDownBoldRight: "",
    lineUpBoldDownRight: "",
    lineUpDoubleDownDoubleRightDouble: "",
    lineUpDoubleDownDoubleRight: "",
    lineUpDownRightDouble: "",
    lineDownLeftRight: "",
    lineDownBoldLeftBoldRightBold: "",
    lineDownLeftBoldRightBold: "",
    lineDownBoldLeftRight: "",
    lineDownBoldLeftBoldRight: "",
    lineDownBoldLeftRightBold: "",
    lineDownLeftRightBold: "",
    lineDownLeftBoldRight: "",
    lineDownDoubleLeftDoubleRightDouble: "",
    lineDownDoubleLeftRight: "",
    lineDownLeftDoubleRightDouble: "",
    lineUpLeftRight: "",
    lineUpBoldLeftBoldRightBold: "",
    lineUpLeftBoldRightBold: "",
    lineUpBoldLeftRight: "",
    lineUpBoldLeftBoldRight: "",
    lineUpBoldLeftRightBold: "",
    lineUpLeftRightBold: "",
    lineUpLeftBoldRight: "",
    lineUpDoubleLeftDoubleRightDouble: "",
    lineUpDoubleLeftRight: "",
    lineUpLeftDoubleRightDouble: "",
    lineUpDownLeftRight: "",
    lineUpBoldDownBoldLeftBoldRightBold: "",
    lineUpDownBoldLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRightBold: "",
    lineUpBoldDownBoldLeftRightBold: "",
    lineUpBoldDownBoldLeftBoldRight: "",
    lineUpBoldDownLeftRight: "",
    lineUpDownBoldLeftRight: "",
    lineUpDownLeftBoldRight: "",
    lineUpDownLeftRightBold: "",
    lineUpBoldDownBoldLeftRight: "",
    lineUpDownLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRight: "",
    lineUpBoldDownLeftRightBold: "",
    lineUpDownBoldLeftBoldRight: "",
    lineUpDownBoldLeftRightBold: "",
    lineUpDoubleDownDoubleLeftDoubleRightDouble: "",
    lineUpDoubleDownDoubleLeftRight: "",
    lineUpDownLeftDoubleRightDouble: "",
    lineCross: "",
    lineBackslash: "",
    lineSlash: ""
  };
  specialMainSymbols2 = {
    tick: "",
    info: "",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "",
    circleFilled: "",
    circleDotted: "",
    circleDouble: "",
    circleCircle: "",
    circleCross: "",
    circlePipe: "",
    radioOn: "",
    radioOff: "",
    checkboxOn: "",
    checkboxOff: "",
    checkboxCircleOn: "",
    checkboxCircleOff: "",
    pointer: "",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "",
    oneNinth: "",
    oneTenth: ""
  };
  specialFallbackSymbols2 = {
    tick: "",
    info: "i",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "( )",
    circleFilled: "(*)",
    circleDotted: "( )",
    circleDouble: "( )",
    circleCircle: "()",
    circleCross: "()",
    circlePipe: "()",
    radioOn: "(*)",
    radioOff: "( )",
    checkboxOn: "[]",
    checkboxOff: "[ ]",
    checkboxCircleOn: "()",
    checkboxCircleOff: "( )",
    pointer: ">",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "1/7",
    oneNinth: "1/9",
    oneTenth: "1/10"
  };
  mainSymbols2 = { ...common2, ...specialMainSymbols2 };
  fallbackSymbols2 = {
    ...common2,
    ...specialFallbackSymbols2
  };
  shouldUseMain2 = isUnicodeSupported2();
  figures2 = shouldUseMain2 ? mainSymbols2 : fallbackSymbols2;
  esm_default3 = figures2;
  replacements2 = Object.entries(specialMainSymbols2);
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/theme.js
var import_yoctocolors_cjs4, defaultTheme2;
var init_theme2 = __esm(() => {
  import_yoctocolors_cjs4 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm4();
  defaultTheme2 = {
    prefix: {
      idle: import_yoctocolors_cjs4.default.blue("?"),
      done: import_yoctocolors_cjs4.default.green(esm_default3.tick)
    },
    spinner: {
      interval: 80,
      frames: ["", "", "", "", "", "", "", "", "", ""].map((frame) => import_yoctocolors_cjs4.default.yellow(frame))
    },
    style: {
      answer: import_yoctocolors_cjs4.default.cyan,
      message: import_yoctocolors_cjs4.default.bold,
      error: (text) => import_yoctocolors_cjs4.default.red(`> ${text}`),
      defaultAnswer: (text) => import_yoctocolors_cjs4.default.dim(`(${text})`),
      help: import_yoctocolors_cjs4.default.dim,
      highlight: import_yoctocolors_cjs4.default.cyan,
      key: (text) => import_yoctocolors_cjs4.default.cyan(import_yoctocolors_cjs4.default.bold(`<${text}>`))
    }
  };
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/make-theme.js
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function deepMerge2(...objects) {
  const output = {};
  for (const obj of objects) {
    for (const [key2, value] of Object.entries(obj)) {
      const prevValue = output[key2];
      output[key2] = isPlainObject2(prevValue) && isPlainObject2(value) ? deepMerge2(prevValue, value) : value;
    }
  }
  return output;
}
function makeTheme2(...themes) {
  const themesToMerge = [
    defaultTheme2,
    ...themes.filter((theme) => theme != null)
  ];
  return deepMerge2(...themesToMerge);
}
var init_make_theme2 = __esm(() => {
  init_theme2();
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/use-prefix.js
import { AsyncResource as AsyncResource5 } from "node:async_hooks";
function usePrefix2({ status = "idle", theme }) {
  const [showLoader, setShowLoader] = useState2(false);
  const [tick, setTick] = useState2(0);
  const { prefix, spinner } = makeTheme2(theme);
  useEffect2(() => {
    if (status === "loading") {
      let tickInterval;
      let inc = -1;
      const delayTimeout = setTimeout(AsyncResource5.bind(() => {
        setShowLoader(true);
        tickInterval = setInterval(AsyncResource5.bind(() => {
          inc = inc + 1;
          setTick(inc % spinner.frames.length);
        }), spinner.interval);
      }), 300);
      return () => {
        clearTimeout(delayTimeout);
        clearInterval(tickInterval);
      };
    } else {
      setShowLoader(false);
    }
  }, [status]);
  if (showLoader) {
    return spinner.frames[tick];
  }
  const iconName = status === "loading" ? "idle" : status;
  return typeof prefix === "string" ? prefix : prefix[iconName] ?? prefix["idle"];
}
var init_use_prefix2 = __esm(() => {
  init_use_state2();
  init_use_effect2();
  init_make_theme2();
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/use-ref.js
function useRef2(val) {
  return useState2({ current: val })[0];
}
var init_use_ref2 = __esm(() => {
  init_use_state2();
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/use-keypress.js
function useKeypress2(userHandler) {
  const signal = useRef2(userHandler);
  signal.current = userHandler;
  useEffect2((rl) => {
    let ignore = false;
    const handler = withUpdates2((_input, event) => {
      if (ignore)
        return;
      signal.current(event, rl);
    });
    rl.input.on("keypress", handler);
    return () => {
      ignore = true;
      rl.input.removeListener("keypress", handler);
    };
  }, []);
}
var init_use_keypress2 = __esm(() => {
  init_use_ref2();
  init_use_effect2();
  init_hook_engine2();
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/utils.js
function breakLines2(content, width) {
  return content.split(`
`).flatMap((line) => import_wrap_ansi2.default(line, width, { trim: false, hard: true }).split(`
`).map((str) => str.trimEnd())).join(`
`);
}
function readlineWidth2() {
  return import_cli_width2.default({ defaultWidth: 80, output: readline3().output });
}
var import_cli_width2, import_wrap_ansi2;
var init_utils2 = __esm(() => {
  import_cli_width2 = __toESM(require_cli_width(), 1);
  import_wrap_ansi2 = __toESM(require_wrap_ansi(), 1);
  init_hook_engine2();
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/node_modules/strip-ansi/node_modules/ansi-regex/index.js
var require_ansi_regex3 = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/node_modules/strip-ansi/index.js
var require_strip_ansi3 = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex3();
  module.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/screen-manager.js
function cursorDown2(n) {
  return n > 0 ? import_ansi_escapes3.default.cursorDown(n) : "";
}

class ScreenManager2 {
  rl;
  height = 0;
  extraLinesUnderPrompt = 0;
  cursorPos;
  constructor(rl) {
    this.rl = rl;
    this.rl = rl;
    this.cursorPos = rl.getCursorPos();
  }
  write(content) {
    this.rl.output.unmute();
    this.rl.output.write(content);
    this.rl.output.mute();
  }
  render(content, bottomContent = "") {
    const promptLine = lastLine2(content);
    const rawPromptLine = import_strip_ansi2.default(promptLine);
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }
    this.rl.setPrompt(prompt);
    this.cursorPos = this.rl.getCursorPos();
    const width = readlineWidth2();
    content = breakLines2(content, width);
    bottomContent = breakLines2(bottomContent, width);
    if (rawPromptLine.length % width === 0) {
      content += `
`;
    }
    let output = content + (bottomContent ? `
` + bottomContent : "");
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - this.cursorPos.rows;
    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height2(bottomContent) : 0);
    if (bottomContentHeight > 0)
      output += import_ansi_escapes3.default.cursorUp(bottomContentHeight);
    output += import_ansi_escapes3.default.cursorTo(this.cursorPos.cols);
    this.write(cursorDown2(this.extraLinesUnderPrompt) + import_ansi_escapes3.default.eraseLines(this.height) + output);
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height2(output);
  }
  checkCursorPos() {
    const cursorPos = this.rl.getCursorPos();
    if (cursorPos.cols !== this.cursorPos.cols) {
      this.write(import_ansi_escapes3.default.cursorTo(cursorPos.cols));
      this.cursorPos = cursorPos;
    }
  }
  done({ clearContent }) {
    this.rl.setPrompt("");
    let output = cursorDown2(this.extraLinesUnderPrompt);
    output += clearContent ? import_ansi_escapes3.default.eraseLines(this.height) : `
`;
    output += import_ansi_escapes3.default.cursorShow;
    this.write(output);
    this.rl.close();
  }
}
var import_strip_ansi2, import_ansi_escapes3, height2 = (content) => content.split(`
`).length, lastLine2 = (content) => content.split(`
`).pop() ?? "";
var init_screen_manager2 = __esm(() => {
  import_strip_ansi2 = __toESM(require_strip_ansi3(), 1);
  import_ansi_escapes3 = __toESM(require_ansi_escapes(), 1);
  init_utils2();
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/promise-polyfill.js
var PromisePolyfill2;
var init_promise_polyfill2 = __esm(() => {
  PromisePolyfill2 = class PromisePolyfill2 extends Promise {
    static withResolver() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return { promise, resolve, reject };
    }
  };
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/lib/create-prompt.js
import * as readline4 from "node:readline";
import { AsyncResource as AsyncResource6 } from "node:async_hooks";
function getCallSites2() {
  const _prepareStackTrace = Error.prepareStackTrace;
  try {
    let result = [];
    Error.prepareStackTrace = (_2, callSites) => {
      const callSitesWithoutCurrent = callSites.slice(1);
      result = callSitesWithoutCurrent;
      return callSitesWithoutCurrent;
    };
    new Error().stack;
    return result;
  } finally {
    Error.prepareStackTrace = _prepareStackTrace;
  }
}
function createPrompt2(view) {
  const callSites = getCallSites2();
  const callerFilename = callSites[1]?.getFileName?.();
  const prompt = (config, context = {}) => {
    const { input = process.stdin, signal } = context;
    const cleanups = new Set;
    const output = new import_mute_stream2.default;
    output.pipe(context.output ?? process.stdout);
    const rl = readline4.createInterface({
      terminal: true,
      input,
      output
    });
    const screen = new ScreenManager2(rl);
    const { promise, resolve, reject } = PromisePolyfill2.withResolver();
    const cancel = () => reject(new CancelPromptError2);
    if (signal) {
      const abort = () => reject(new AbortPromptError2({ cause: signal.reason }));
      if (signal.aborted) {
        abort();
        return Object.assign(promise, { cancel });
      }
      signal.addEventListener("abort", abort);
      cleanups.add(() => signal.removeEventListener("abort", abort));
    }
    cleanups.add(onExit((code, signal2) => {
      reject(new ExitPromptError2(`User force closed the prompt with ${code} ${signal2}`));
    }));
    const checkCursorPos = () => screen.checkCursorPos();
    rl.input.on("keypress", checkCursorPos);
    cleanups.add(() => rl.input.removeListener("keypress", checkCursorPos));
    return withHooks2(rl, (cycle) => {
      const hooksCleanup = AsyncResource6.bind(() => effectScheduler2.clearAll());
      rl.on("close", hooksCleanup);
      cleanups.add(() => rl.removeListener("close", hooksCleanup));
      cycle(() => {
        try {
          const nextView = view(config, (value) => {
            setImmediate(() => resolve(value));
          });
          if (nextView === undefined) {
            throw new Error(`Prompt functions must return a string.
    at ${callerFilename}`);
          }
          const [content, bottomContent] = typeof nextView === "string" ? [nextView] : nextView;
          screen.render(content, bottomContent);
          effectScheduler2.run();
        } catch (error) {
          reject(error);
        }
      });
      return Object.assign(promise.then((answer) => {
        effectScheduler2.clearAll();
        return answer;
      }, (error) => {
        effectScheduler2.clearAll();
        throw error;
      }).finally(() => {
        cleanups.forEach((cleanup) => cleanup());
        screen.done({ clearContent: Boolean(context.clearPromptOnDone) });
        output.end();
      }).then(() => promise), { cancel });
    });
  };
  return prompt;
}
var import_mute_stream2;
var init_create_prompt2 = __esm(() => {
  import_mute_stream2 = __toESM(require_lib2(), 1);
  init_mjs();
  init_screen_manager2();
  init_promise_polyfill2();
  init_hook_engine2();
  init_errors2();
});

// node_modules/@inquirer/editor/node_modules/@inquirer/core/dist/esm/index.js
var init_esm5 = __esm(() => {
  init_errors2();
  init_use_prefix2();
  init_use_state2();
  init_use_effect2();
  init_use_keypress2();
  init_make_theme2();
  init_create_prompt2();
});

// node_modules/@inquirer/editor/dist/esm/index.js
import { AsyncResource as AsyncResource7 } from "node:async_hooks";
var import_external_editor, editorTheme, esm_default4;
var init_esm6 = __esm(() => {
  import_external_editor = __toESM(require_main(), 1);
  init_esm5();
  editorTheme = {
    validationFailureMode: "keep"
  };
  esm_default4 = createPrompt2((config, done) => {
    const { waitForUseInput = true, file: { postfix = config.postfix ?? ".txt", ...fileProps } = {}, validate = () => true } = config;
    const theme = makeTheme2(editorTheme, config.theme);
    const [status, setStatus] = useState2("idle");
    const [value = "", setValue] = useState2(config.default);
    const [errorMsg, setError] = useState2();
    const prefix = usePrefix2({ status, theme });
    function startEditor(rl) {
      rl.pause();
      const editCallback = AsyncResource7.bind(async (error2, answer) => {
        rl.resume();
        if (error2) {
          setError(error2.toString());
        } else {
          setStatus("loading");
          const isValid = await validate(answer);
          if (isValid === true) {
            setError(undefined);
            setStatus("done");
            done(answer);
          } else {
            if (theme.validationFailureMode === "clear") {
              setValue(config.default);
            } else {
              setValue(answer);
            }
            setError(isValid || "You must provide a valid value");
            setStatus("idle");
          }
        }
      });
      import_external_editor.editAsync(value, (error2, answer) => void editCallback(error2, answer), {
        postfix,
        ...fileProps
      });
    }
    useEffect2((rl) => {
      if (!waitForUseInput) {
        startEditor(rl);
      }
    }, []);
    useKeypress2((key3, rl) => {
      if (status !== "idle") {
        return;
      }
      if (isEnterKey2(key3)) {
        startEditor(rl);
      }
    });
    const message = theme.style.message(config.message, status);
    let helpTip = "";
    if (status === "loading") {
      helpTip = theme.style.help("Received");
    } else if (status === "idle") {
      const enterKey = theme.style.key("enter");
      helpTip = theme.style.help(`Press ${enterKey} to launch your preferred editor.`);
    }
    let error = "";
    if (errorMsg) {
      error = theme.style.error(errorMsg);
    }
    return [[prefix, message, helpTip].filter(Boolean).join(" "), error];
  });
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/key.js
var isEnterKey3 = (key3) => key3.name === "enter" || key3.name === "return";

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/errors.js
var AbortPromptError3, CancelPromptError3, ExitPromptError3, HookError3, ValidationError3;
var init_errors3 = __esm(() => {
  AbortPromptError3 = class AbortPromptError3 extends Error {
    name = "AbortPromptError";
    message = "Prompt was aborted";
    constructor(options) {
      super();
      this.cause = options?.cause;
    }
  };
  CancelPromptError3 = class CancelPromptError3 extends Error {
    name = "CancelPromptError";
    message = "Prompt was canceled";
  };
  ExitPromptError3 = class ExitPromptError3 extends Error {
    name = "ExitPromptError";
  };
  HookError3 = class HookError3 extends Error {
    name = "HookError";
  };
  ValidationError3 = class ValidationError3 extends Error {
    name = "ValidationError";
  };
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/hook-engine.js
import { AsyncLocalStorage as AsyncLocalStorage3, AsyncResource as AsyncResource8 } from "node:async_hooks";
function createStore3(rl) {
  const store = {
    rl,
    hooks: [],
    hooksCleanup: [],
    hooksEffect: [],
    index: 0,
    handleChange() {
    }
  };
  return store;
}
function withHooks3(rl, cb) {
  const store = createStore3(rl);
  return hookStorage3.run(store, () => {
    function cycle(render) {
      store.handleChange = () => {
        store.index = 0;
        render();
      };
      store.handleChange();
    }
    return cb(cycle);
  });
}
function getStore3() {
  const store = hookStorage3.getStore();
  if (!store) {
    throw new HookError3("[Inquirer] Hook functions can only be called from within a prompt");
  }
  return store;
}
function readline5() {
  return getStore3().rl;
}
function withUpdates3(fn) {
  const wrapped = (...args) => {
    const store = getStore3();
    let shouldUpdate = false;
    const oldHandleChange = store.handleChange;
    store.handleChange = () => {
      shouldUpdate = true;
    };
    const returnValue = fn(...args);
    if (shouldUpdate) {
      oldHandleChange();
    }
    store.handleChange = oldHandleChange;
    return returnValue;
  };
  return AsyncResource8.bind(wrapped);
}
function withPointer3(cb) {
  const store = getStore3();
  const { index } = store;
  const pointer = {
    get() {
      return store.hooks[index];
    },
    set(value) {
      store.hooks[index] = value;
    },
    initialized: index in store.hooks
  };
  const returnValue = cb(pointer);
  store.index++;
  return returnValue;
}
function handleChange3() {
  getStore3().handleChange();
}
var hookStorage3, effectScheduler3;
var init_hook_engine3 = __esm(() => {
  init_errors3();
  hookStorage3 = new AsyncLocalStorage3;
  effectScheduler3 = {
    queue(cb) {
      const store = getStore3();
      const { index } = store;
      store.hooksEffect.push(() => {
        store.hooksCleanup[index]?.();
        const cleanFn = cb(readline5());
        if (cleanFn != null && typeof cleanFn !== "function") {
          throw new ValidationError3("useEffect return value must be a cleanup function or nothing.");
        }
        store.hooksCleanup[index] = cleanFn;
      });
    },
    run() {
      const store = getStore3();
      withUpdates3(() => {
        store.hooksEffect.forEach((effect) => {
          effect();
        });
        store.hooksEffect.length = 0;
      })();
    },
    clearAll() {
      const store = getStore3();
      store.hooksCleanup.forEach((cleanFn) => {
        cleanFn?.();
      });
      store.hooksEffect.length = 0;
      store.hooksCleanup.length = 0;
    }
  };
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/use-state.js
function useState3(defaultValue) {
  return withPointer3((pointer) => {
    const setFn = (newValue) => {
      if (pointer.get() !== newValue) {
        pointer.set(newValue);
        handleChange3();
      }
    };
    if (pointer.initialized) {
      return [pointer.get(), setFn];
    }
    const value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
    pointer.set(value);
    return [value, setFn];
  });
}
var init_use_state3 = __esm(() => {
  init_hook_engine3();
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/use-effect.js
function useEffect3(cb, depArray) {
  withPointer3((pointer) => {
    const oldDeps = pointer.get();
    const hasChanged = !Array.isArray(oldDeps) || depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    if (hasChanged) {
      effectScheduler3.queue(cb);
    }
    pointer.set(depArray);
  });
}
var init_use_effect3 = __esm(() => {
  init_hook_engine3();
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/node_modules/@inquirer/figures/dist/esm/index.js
import process5 from "node:process";
function isUnicodeSupported3() {
  if (process5.platform !== "win32") {
    return process5.env["TERM"] !== "linux";
  }
  return Boolean(process5.env["WT_SESSION"]) || Boolean(process5.env["TERMINUS_SUBLIME"]) || process5.env["ConEmuTask"] === "{cmd::Cmder}" || process5.env["TERM_PROGRAM"] === "Terminus-Sublime" || process5.env["TERM_PROGRAM"] === "vscode" || process5.env["TERM"] === "xterm-256color" || process5.env["TERM"] === "alacritty" || process5.env["TERMINAL_EMULATOR"] === "JetBrains-JediTerm";
}
var common3, specialMainSymbols3, specialFallbackSymbols3, mainSymbols3, fallbackSymbols3, shouldUseMain3, figures3, esm_default5, replacements3;
var init_esm7 = __esm(() => {
  common3 = {
    circleQuestionMark: "(?)",
    questionMarkPrefix: "(?)",
    square: "",
    squareDarkShade: "",
    squareMediumShade: "",
    squareLightShade: "",
    squareTop: "",
    squareBottom: "",
    squareLeft: "",
    squareRight: "",
    squareCenter: "",
    bullet: "",
    dot: "",
    ellipsis: "",
    pointerSmall: "",
    triangleUp: "",
    triangleUpSmall: "",
    triangleDown: "",
    triangleDownSmall: "",
    triangleLeftSmall: "",
    triangleRightSmall: "",
    home: "",
    heart: "",
    musicNote: "",
    musicNoteBeamed: "",
    arrowUp: "",
    arrowDown: "",
    arrowLeft: "",
    arrowRight: "",
    arrowLeftRight: "",
    arrowUpDown: "",
    almostEqual: "",
    notEqual: "",
    lessOrEqual: "",
    greaterOrEqual: "",
    identical: "",
    infinity: "",
    subscriptZero: "",
    subscriptOne: "",
    subscriptTwo: "",
    subscriptThree: "",
    subscriptFour: "",
    subscriptFive: "",
    subscriptSix: "",
    subscriptSeven: "",
    subscriptEight: "",
    subscriptNine: "",
    oneHalf: "",
    oneThird: "",
    oneQuarter: "",
    oneFifth: "",
    oneSixth: "",
    oneEighth: "",
    twoThirds: "",
    twoFifths: "",
    threeQuarters: "",
    threeFifths: "",
    threeEighths: "",
    fourFifths: "",
    fiveSixths: "",
    fiveEighths: "",
    sevenEighths: "",
    line: "",
    lineBold: "",
    lineDouble: "",
    lineDashed0: "",
    lineDashed1: "",
    lineDashed2: "",
    lineDashed3: "",
    lineDashed4: "",
    lineDashed5: "",
    lineDashed6: "",
    lineDashed7: "",
    lineDashed8: "",
    lineDashed9: "",
    lineDashed10: "",
    lineDashed11: "",
    lineDashed12: "",
    lineDashed13: "",
    lineDashed14: "",
    lineDashed15: "",
    lineVertical: "",
    lineVerticalBold: "",
    lineVerticalDouble: "",
    lineVerticalDashed0: "",
    lineVerticalDashed1: "",
    lineVerticalDashed2: "",
    lineVerticalDashed3: "",
    lineVerticalDashed4: "",
    lineVerticalDashed5: "",
    lineVerticalDashed6: "",
    lineVerticalDashed7: "",
    lineVerticalDashed8: "",
    lineVerticalDashed9: "",
    lineVerticalDashed10: "",
    lineVerticalDashed11: "",
    lineDownLeft: "",
    lineDownLeftArc: "",
    lineDownBoldLeftBold: "",
    lineDownBoldLeft: "",
    lineDownLeftBold: "",
    lineDownDoubleLeftDouble: "",
    lineDownDoubleLeft: "",
    lineDownLeftDouble: "",
    lineDownRight: "",
    lineDownRightArc: "",
    lineDownBoldRightBold: "",
    lineDownBoldRight: "",
    lineDownRightBold: "",
    lineDownDoubleRightDouble: "",
    lineDownDoubleRight: "",
    lineDownRightDouble: "",
    lineUpLeft: "",
    lineUpLeftArc: "",
    lineUpBoldLeftBold: "",
    lineUpBoldLeft: "",
    lineUpLeftBold: "",
    lineUpDoubleLeftDouble: "",
    lineUpDoubleLeft: "",
    lineUpLeftDouble: "",
    lineUpRight: "",
    lineUpRightArc: "",
    lineUpBoldRightBold: "",
    lineUpBoldRight: "",
    lineUpRightBold: "",
    lineUpDoubleRightDouble: "",
    lineUpDoubleRight: "",
    lineUpRightDouble: "",
    lineUpDownLeft: "",
    lineUpBoldDownBoldLeftBold: "",
    lineUpBoldDownBoldLeft: "",
    lineUpDownLeftBold: "",
    lineUpBoldDownLeftBold: "",
    lineUpDownBoldLeftBold: "",
    lineUpDownBoldLeft: "",
    lineUpBoldDownLeft: "",
    lineUpDoubleDownDoubleLeftDouble: "",
    lineUpDoubleDownDoubleLeft: "",
    lineUpDownLeftDouble: "",
    lineUpDownRight: "",
    lineUpBoldDownBoldRightBold: "",
    lineUpBoldDownBoldRight: "",
    lineUpDownRightBold: "",
    lineUpBoldDownRightBold: "",
    lineUpDownBoldRightBold: "",
    lineUpDownBoldRight: "",
    lineUpBoldDownRight: "",
    lineUpDoubleDownDoubleRightDouble: "",
    lineUpDoubleDownDoubleRight: "",
    lineUpDownRightDouble: "",
    lineDownLeftRight: "",
    lineDownBoldLeftBoldRightBold: "",
    lineDownLeftBoldRightBold: "",
    lineDownBoldLeftRight: "",
    lineDownBoldLeftBoldRight: "",
    lineDownBoldLeftRightBold: "",
    lineDownLeftRightBold: "",
    lineDownLeftBoldRight: "",
    lineDownDoubleLeftDoubleRightDouble: "",
    lineDownDoubleLeftRight: "",
    lineDownLeftDoubleRightDouble: "",
    lineUpLeftRight: "",
    lineUpBoldLeftBoldRightBold: "",
    lineUpLeftBoldRightBold: "",
    lineUpBoldLeftRight: "",
    lineUpBoldLeftBoldRight: "",
    lineUpBoldLeftRightBold: "",
    lineUpLeftRightBold: "",
    lineUpLeftBoldRight: "",
    lineUpDoubleLeftDoubleRightDouble: "",
    lineUpDoubleLeftRight: "",
    lineUpLeftDoubleRightDouble: "",
    lineUpDownLeftRight: "",
    lineUpBoldDownBoldLeftBoldRightBold: "",
    lineUpDownBoldLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRightBold: "",
    lineUpBoldDownBoldLeftRightBold: "",
    lineUpBoldDownBoldLeftBoldRight: "",
    lineUpBoldDownLeftRight: "",
    lineUpDownBoldLeftRight: "",
    lineUpDownLeftBoldRight: "",
    lineUpDownLeftRightBold: "",
    lineUpBoldDownBoldLeftRight: "",
    lineUpDownLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRight: "",
    lineUpBoldDownLeftRightBold: "",
    lineUpDownBoldLeftBoldRight: "",
    lineUpDownBoldLeftRightBold: "",
    lineUpDoubleDownDoubleLeftDoubleRightDouble: "",
    lineUpDoubleDownDoubleLeftRight: "",
    lineUpDownLeftDoubleRightDouble: "",
    lineCross: "",
    lineBackslash: "",
    lineSlash: ""
  };
  specialMainSymbols3 = {
    tick: "",
    info: "",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "",
    circleFilled: "",
    circleDotted: "",
    circleDouble: "",
    circleCircle: "",
    circleCross: "",
    circlePipe: "",
    radioOn: "",
    radioOff: "",
    checkboxOn: "",
    checkboxOff: "",
    checkboxCircleOn: "",
    checkboxCircleOff: "",
    pointer: "",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "",
    oneNinth: "",
    oneTenth: ""
  };
  specialFallbackSymbols3 = {
    tick: "",
    info: "i",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "( )",
    circleFilled: "(*)",
    circleDotted: "( )",
    circleDouble: "( )",
    circleCircle: "()",
    circleCross: "()",
    circlePipe: "()",
    radioOn: "(*)",
    radioOff: "( )",
    checkboxOn: "[]",
    checkboxOff: "[ ]",
    checkboxCircleOn: "()",
    checkboxCircleOff: "( )",
    pointer: ">",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "1/7",
    oneNinth: "1/9",
    oneTenth: "1/10"
  };
  mainSymbols3 = { ...common3, ...specialMainSymbols3 };
  fallbackSymbols3 = {
    ...common3,
    ...specialFallbackSymbols3
  };
  shouldUseMain3 = isUnicodeSupported3();
  figures3 = shouldUseMain3 ? mainSymbols3 : fallbackSymbols3;
  esm_default5 = figures3;
  replacements3 = Object.entries(specialMainSymbols3);
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/theme.js
var import_yoctocolors_cjs5, defaultTheme3;
var init_theme3 = __esm(() => {
  import_yoctocolors_cjs5 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm7();
  defaultTheme3 = {
    prefix: {
      idle: import_yoctocolors_cjs5.default.blue("?"),
      done: import_yoctocolors_cjs5.default.green(esm_default5.tick)
    },
    spinner: {
      interval: 80,
      frames: ["", "", "", "", "", "", "", "", "", ""].map((frame) => import_yoctocolors_cjs5.default.yellow(frame))
    },
    style: {
      answer: import_yoctocolors_cjs5.default.cyan,
      message: import_yoctocolors_cjs5.default.bold,
      error: (text) => import_yoctocolors_cjs5.default.red(`> ${text}`),
      defaultAnswer: (text) => import_yoctocolors_cjs5.default.dim(`(${text})`),
      help: import_yoctocolors_cjs5.default.dim,
      highlight: import_yoctocolors_cjs5.default.cyan,
      key: (text) => import_yoctocolors_cjs5.default.cyan(import_yoctocolors_cjs5.default.bold(`<${text}>`))
    }
  };
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/make-theme.js
function isPlainObject3(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function deepMerge3(...objects) {
  const output = {};
  for (const obj of objects) {
    for (const [key3, value] of Object.entries(obj)) {
      const prevValue = output[key3];
      output[key3] = isPlainObject3(prevValue) && isPlainObject3(value) ? deepMerge3(prevValue, value) : value;
    }
  }
  return output;
}
function makeTheme3(...themes) {
  const themesToMerge = [
    defaultTheme3,
    ...themes.filter((theme) => theme != null)
  ];
  return deepMerge3(...themesToMerge);
}
var init_make_theme3 = __esm(() => {
  init_theme3();
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/use-prefix.js
import { AsyncResource as AsyncResource9 } from "node:async_hooks";
function usePrefix3({ status = "idle", theme }) {
  const [showLoader, setShowLoader] = useState3(false);
  const [tick, setTick] = useState3(0);
  const { prefix, spinner } = makeTheme3(theme);
  useEffect3(() => {
    if (status === "loading") {
      let tickInterval;
      let inc = -1;
      const delayTimeout = setTimeout(AsyncResource9.bind(() => {
        setShowLoader(true);
        tickInterval = setInterval(AsyncResource9.bind(() => {
          inc = inc + 1;
          setTick(inc % spinner.frames.length);
        }), spinner.interval);
      }), 300);
      return () => {
        clearTimeout(delayTimeout);
        clearInterval(tickInterval);
      };
    } else {
      setShowLoader(false);
    }
  }, [status]);
  if (showLoader) {
    return spinner.frames[tick];
  }
  const iconName = status === "loading" ? "idle" : status;
  return typeof prefix === "string" ? prefix : prefix[iconName] ?? prefix["idle"];
}
var init_use_prefix3 = __esm(() => {
  init_use_state3();
  init_use_effect3();
  init_make_theme3();
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/use-ref.js
function useRef3(val) {
  return useState3({ current: val })[0];
}
var init_use_ref3 = __esm(() => {
  init_use_state3();
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/use-keypress.js
function useKeypress3(userHandler) {
  const signal = useRef3(userHandler);
  signal.current = userHandler;
  useEffect3((rl) => {
    let ignore = false;
    const handler = withUpdates3((_input, event) => {
      if (ignore)
        return;
      signal.current(event, rl);
    });
    rl.input.on("keypress", handler);
    return () => {
      ignore = true;
      rl.input.removeListener("keypress", handler);
    };
  }, []);
}
var init_use_keypress3 = __esm(() => {
  init_use_ref3();
  init_use_effect3();
  init_hook_engine3();
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/utils.js
function breakLines3(content, width) {
  return content.split(`
`).flatMap((line) => import_wrap_ansi3.default(line, width, { trim: false, hard: true }).split(`
`).map((str) => str.trimEnd())).join(`
`);
}
function readlineWidth3() {
  return import_cli_width3.default({ defaultWidth: 80, output: readline5().output });
}
var import_cli_width3, import_wrap_ansi3;
var init_utils3 = __esm(() => {
  import_cli_width3 = __toESM(require_cli_width(), 1);
  import_wrap_ansi3 = __toESM(require_wrap_ansi(), 1);
  init_hook_engine3();
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/node_modules/strip-ansi/node_modules/ansi-regex/index.js
var require_ansi_regex4 = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/node_modules/strip-ansi/index.js
var require_strip_ansi4 = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex4();
  module.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/screen-manager.js
function cursorDown3(n) {
  return n > 0 ? import_ansi_escapes4.default.cursorDown(n) : "";
}

class ScreenManager3 {
  rl;
  height = 0;
  extraLinesUnderPrompt = 0;
  cursorPos;
  constructor(rl) {
    this.rl = rl;
    this.rl = rl;
    this.cursorPos = rl.getCursorPos();
  }
  write(content) {
    this.rl.output.unmute();
    this.rl.output.write(content);
    this.rl.output.mute();
  }
  render(content, bottomContent = "") {
    const promptLine = lastLine3(content);
    const rawPromptLine = import_strip_ansi3.default(promptLine);
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }
    this.rl.setPrompt(prompt);
    this.cursorPos = this.rl.getCursorPos();
    const width = readlineWidth3();
    content = breakLines3(content, width);
    bottomContent = breakLines3(bottomContent, width);
    if (rawPromptLine.length % width === 0) {
      content += `
`;
    }
    let output = content + (bottomContent ? `
` + bottomContent : "");
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - this.cursorPos.rows;
    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height3(bottomContent) : 0);
    if (bottomContentHeight > 0)
      output += import_ansi_escapes4.default.cursorUp(bottomContentHeight);
    output += import_ansi_escapes4.default.cursorTo(this.cursorPos.cols);
    this.write(cursorDown3(this.extraLinesUnderPrompt) + import_ansi_escapes4.default.eraseLines(this.height) + output);
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height3(output);
  }
  checkCursorPos() {
    const cursorPos = this.rl.getCursorPos();
    if (cursorPos.cols !== this.cursorPos.cols) {
      this.write(import_ansi_escapes4.default.cursorTo(cursorPos.cols));
      this.cursorPos = cursorPos;
    }
  }
  done({ clearContent }) {
    this.rl.setPrompt("");
    let output = cursorDown3(this.extraLinesUnderPrompt);
    output += clearContent ? import_ansi_escapes4.default.eraseLines(this.height) : `
`;
    output += import_ansi_escapes4.default.cursorShow;
    this.write(output);
    this.rl.close();
  }
}
var import_strip_ansi3, import_ansi_escapes4, height3 = (content) => content.split(`
`).length, lastLine3 = (content) => content.split(`
`).pop() ?? "";
var init_screen_manager3 = __esm(() => {
  import_strip_ansi3 = __toESM(require_strip_ansi4(), 1);
  import_ansi_escapes4 = __toESM(require_ansi_escapes(), 1);
  init_utils3();
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/promise-polyfill.js
var PromisePolyfill3;
var init_promise_polyfill3 = __esm(() => {
  PromisePolyfill3 = class PromisePolyfill3 extends Promise {
    static withResolver() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return { promise, resolve, reject };
    }
  };
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/lib/create-prompt.js
import * as readline6 from "node:readline";
import { AsyncResource as AsyncResource10 } from "node:async_hooks";
function getCallSites3() {
  const _prepareStackTrace = Error.prepareStackTrace;
  try {
    let result = [];
    Error.prepareStackTrace = (_2, callSites) => {
      const callSitesWithoutCurrent = callSites.slice(1);
      result = callSitesWithoutCurrent;
      return callSitesWithoutCurrent;
    };
    new Error().stack;
    return result;
  } finally {
    Error.prepareStackTrace = _prepareStackTrace;
  }
}
function createPrompt3(view) {
  const callSites = getCallSites3();
  const callerFilename = callSites[1]?.getFileName?.();
  const prompt = (config, context = {}) => {
    const { input = process.stdin, signal } = context;
    const cleanups = new Set;
    const output = new import_mute_stream3.default;
    output.pipe(context.output ?? process.stdout);
    const rl = readline6.createInterface({
      terminal: true,
      input,
      output
    });
    const screen = new ScreenManager3(rl);
    const { promise, resolve, reject } = PromisePolyfill3.withResolver();
    const cancel = () => reject(new CancelPromptError3);
    if (signal) {
      const abort = () => reject(new AbortPromptError3({ cause: signal.reason }));
      if (signal.aborted) {
        abort();
        return Object.assign(promise, { cancel });
      }
      signal.addEventListener("abort", abort);
      cleanups.add(() => signal.removeEventListener("abort", abort));
    }
    cleanups.add(onExit((code, signal2) => {
      reject(new ExitPromptError3(`User force closed the prompt with ${code} ${signal2}`));
    }));
    const checkCursorPos = () => screen.checkCursorPos();
    rl.input.on("keypress", checkCursorPos);
    cleanups.add(() => rl.input.removeListener("keypress", checkCursorPos));
    return withHooks3(rl, (cycle) => {
      const hooksCleanup = AsyncResource10.bind(() => effectScheduler3.clearAll());
      rl.on("close", hooksCleanup);
      cleanups.add(() => rl.removeListener("close", hooksCleanup));
      cycle(() => {
        try {
          const nextView = view(config, (value) => {
            setImmediate(() => resolve(value));
          });
          if (nextView === undefined) {
            throw new Error(`Prompt functions must return a string.
    at ${callerFilename}`);
          }
          const [content, bottomContent] = typeof nextView === "string" ? [nextView] : nextView;
          screen.render(content, bottomContent);
          effectScheduler3.run();
        } catch (error) {
          reject(error);
        }
      });
      return Object.assign(promise.then((answer) => {
        effectScheduler3.clearAll();
        return answer;
      }, (error) => {
        effectScheduler3.clearAll();
        throw error;
      }).finally(() => {
        cleanups.forEach((cleanup) => cleanup());
        screen.done({ clearContent: Boolean(context.clearPromptOnDone) });
        output.end();
      }).then(() => promise), { cancel });
    });
  };
  return prompt;
}
var import_mute_stream3;
var init_create_prompt3 = __esm(() => {
  import_mute_stream3 = __toESM(require_lib2(), 1);
  init_mjs();
  init_screen_manager3();
  init_promise_polyfill3();
  init_hook_engine3();
  init_errors3();
});

// node_modules/@inquirer/confirm/node_modules/@inquirer/core/dist/esm/index.js
var init_esm8 = __esm(() => {
  init_errors3();
  init_use_prefix3();
  init_use_state3();
  init_use_keypress3();
  init_make_theme3();
  init_create_prompt3();
});

// node_modules/@inquirer/confirm/dist/esm/index.js
function getBooleanValue(value, defaultValue) {
  let answer = defaultValue !== false;
  if (/^(y|yes)/i.test(value))
    answer = true;
  else if (/^(n|no)/i.test(value))
    answer = false;
  return answer;
}
function boolToString(value) {
  return value ? "Yes" : "No";
}
var esm_default6;
var init_esm9 = __esm(() => {
  init_esm8();
  esm_default6 = createPrompt3((config, done) => {
    const { transformer = boolToString } = config;
    const [status, setStatus] = useState3("idle");
    const [value, setValue] = useState3("");
    const theme = makeTheme3(config.theme);
    const prefix = usePrefix3({ status, theme });
    useKeypress3((key4, rl) => {
      if (isEnterKey3(key4)) {
        const answer = getBooleanValue(value, config.default);
        setValue(transformer(answer));
        setStatus("done");
        done(answer);
      } else if (key4.name === "tab") {
        const answer = boolToString(!getBooleanValue(value, config.default));
        rl.clearLine(0);
        rl.write(answer);
        setValue(answer);
      } else {
        setValue(rl.line);
      }
    });
    let formattedValue = value;
    let defaultValue = "";
    if (status === "done") {
      formattedValue = theme.style.answer(value);
    } else {
      defaultValue = ` ${theme.style.defaultAnswer(config.default === false ? "y/N" : "Y/n")}`;
    }
    const message = theme.style.message(config.message, status);
    return `${prefix} ${message}${defaultValue} ${formattedValue}`;
  });
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/key.js
var isBackspaceKey = (key4) => key4.name === "backspace", isEnterKey4 = (key4) => key4.name === "enter" || key4.name === "return";

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/errors.js
var AbortPromptError4, CancelPromptError4, ExitPromptError4, HookError4, ValidationError4;
var init_errors4 = __esm(() => {
  AbortPromptError4 = class AbortPromptError4 extends Error {
    name = "AbortPromptError";
    message = "Prompt was aborted";
    constructor(options) {
      super();
      this.cause = options?.cause;
    }
  };
  CancelPromptError4 = class CancelPromptError4 extends Error {
    name = "CancelPromptError";
    message = "Prompt was canceled";
  };
  ExitPromptError4 = class ExitPromptError4 extends Error {
    name = "ExitPromptError";
  };
  HookError4 = class HookError4 extends Error {
    name = "HookError";
  };
  ValidationError4 = class ValidationError4 extends Error {
    name = "ValidationError";
  };
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/hook-engine.js
import { AsyncLocalStorage as AsyncLocalStorage4, AsyncResource as AsyncResource11 } from "node:async_hooks";
function createStore4(rl) {
  const store = {
    rl,
    hooks: [],
    hooksCleanup: [],
    hooksEffect: [],
    index: 0,
    handleChange() {
    }
  };
  return store;
}
function withHooks4(rl, cb) {
  const store = createStore4(rl);
  return hookStorage4.run(store, () => {
    function cycle(render) {
      store.handleChange = () => {
        store.index = 0;
        render();
      };
      store.handleChange();
    }
    return cb(cycle);
  });
}
function getStore4() {
  const store = hookStorage4.getStore();
  if (!store) {
    throw new HookError4("[Inquirer] Hook functions can only be called from within a prompt");
  }
  return store;
}
function readline7() {
  return getStore4().rl;
}
function withUpdates4(fn) {
  const wrapped = (...args) => {
    const store = getStore4();
    let shouldUpdate = false;
    const oldHandleChange = store.handleChange;
    store.handleChange = () => {
      shouldUpdate = true;
    };
    const returnValue = fn(...args);
    if (shouldUpdate) {
      oldHandleChange();
    }
    store.handleChange = oldHandleChange;
    return returnValue;
  };
  return AsyncResource11.bind(wrapped);
}
function withPointer4(cb) {
  const store = getStore4();
  const { index } = store;
  const pointer = {
    get() {
      return store.hooks[index];
    },
    set(value) {
      store.hooks[index] = value;
    },
    initialized: index in store.hooks
  };
  const returnValue = cb(pointer);
  store.index++;
  return returnValue;
}
function handleChange4() {
  getStore4().handleChange();
}
var hookStorage4, effectScheduler4;
var init_hook_engine4 = __esm(() => {
  init_errors4();
  hookStorage4 = new AsyncLocalStorage4;
  effectScheduler4 = {
    queue(cb) {
      const store = getStore4();
      const { index } = store;
      store.hooksEffect.push(() => {
        store.hooksCleanup[index]?.();
        const cleanFn = cb(readline7());
        if (cleanFn != null && typeof cleanFn !== "function") {
          throw new ValidationError4("useEffect return value must be a cleanup function or nothing.");
        }
        store.hooksCleanup[index] = cleanFn;
      });
    },
    run() {
      const store = getStore4();
      withUpdates4(() => {
        store.hooksEffect.forEach((effect) => {
          effect();
        });
        store.hooksEffect.length = 0;
      })();
    },
    clearAll() {
      const store = getStore4();
      store.hooksCleanup.forEach((cleanFn) => {
        cleanFn?.();
      });
      store.hooksEffect.length = 0;
      store.hooksCleanup.length = 0;
    }
  };
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/use-state.js
function useState4(defaultValue) {
  return withPointer4((pointer) => {
    const setFn = (newValue) => {
      if (pointer.get() !== newValue) {
        pointer.set(newValue);
        handleChange4();
      }
    };
    if (pointer.initialized) {
      return [pointer.get(), setFn];
    }
    const value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
    pointer.set(value);
    return [value, setFn];
  });
}
var init_use_state4 = __esm(() => {
  init_hook_engine4();
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/use-effect.js
function useEffect4(cb, depArray) {
  withPointer4((pointer) => {
    const oldDeps = pointer.get();
    const hasChanged = !Array.isArray(oldDeps) || depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    if (hasChanged) {
      effectScheduler4.queue(cb);
    }
    pointer.set(depArray);
  });
}
var init_use_effect4 = __esm(() => {
  init_hook_engine4();
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/node_modules/@inquirer/figures/dist/esm/index.js
import process6 from "node:process";
function isUnicodeSupported4() {
  if (process6.platform !== "win32") {
    return process6.env["TERM"] !== "linux";
  }
  return Boolean(process6.env["WT_SESSION"]) || Boolean(process6.env["TERMINUS_SUBLIME"]) || process6.env["ConEmuTask"] === "{cmd::Cmder}" || process6.env["TERM_PROGRAM"] === "Terminus-Sublime" || process6.env["TERM_PROGRAM"] === "vscode" || process6.env["TERM"] === "xterm-256color" || process6.env["TERM"] === "alacritty" || process6.env["TERMINAL_EMULATOR"] === "JetBrains-JediTerm";
}
var common4, specialMainSymbols4, specialFallbackSymbols4, mainSymbols4, fallbackSymbols4, shouldUseMain4, figures4, esm_default7, replacements4;
var init_esm10 = __esm(() => {
  common4 = {
    circleQuestionMark: "(?)",
    questionMarkPrefix: "(?)",
    square: "",
    squareDarkShade: "",
    squareMediumShade: "",
    squareLightShade: "",
    squareTop: "",
    squareBottom: "",
    squareLeft: "",
    squareRight: "",
    squareCenter: "",
    bullet: "",
    dot: "",
    ellipsis: "",
    pointerSmall: "",
    triangleUp: "",
    triangleUpSmall: "",
    triangleDown: "",
    triangleDownSmall: "",
    triangleLeftSmall: "",
    triangleRightSmall: "",
    home: "",
    heart: "",
    musicNote: "",
    musicNoteBeamed: "",
    arrowUp: "",
    arrowDown: "",
    arrowLeft: "",
    arrowRight: "",
    arrowLeftRight: "",
    arrowUpDown: "",
    almostEqual: "",
    notEqual: "",
    lessOrEqual: "",
    greaterOrEqual: "",
    identical: "",
    infinity: "",
    subscriptZero: "",
    subscriptOne: "",
    subscriptTwo: "",
    subscriptThree: "",
    subscriptFour: "",
    subscriptFive: "",
    subscriptSix: "",
    subscriptSeven: "",
    subscriptEight: "",
    subscriptNine: "",
    oneHalf: "",
    oneThird: "",
    oneQuarter: "",
    oneFifth: "",
    oneSixth: "",
    oneEighth: "",
    twoThirds: "",
    twoFifths: "",
    threeQuarters: "",
    threeFifths: "",
    threeEighths: "",
    fourFifths: "",
    fiveSixths: "",
    fiveEighths: "",
    sevenEighths: "",
    line: "",
    lineBold: "",
    lineDouble: "",
    lineDashed0: "",
    lineDashed1: "",
    lineDashed2: "",
    lineDashed3: "",
    lineDashed4: "",
    lineDashed5: "",
    lineDashed6: "",
    lineDashed7: "",
    lineDashed8: "",
    lineDashed9: "",
    lineDashed10: "",
    lineDashed11: "",
    lineDashed12: "",
    lineDashed13: "",
    lineDashed14: "",
    lineDashed15: "",
    lineVertical: "",
    lineVerticalBold: "",
    lineVerticalDouble: "",
    lineVerticalDashed0: "",
    lineVerticalDashed1: "",
    lineVerticalDashed2: "",
    lineVerticalDashed3: "",
    lineVerticalDashed4: "",
    lineVerticalDashed5: "",
    lineVerticalDashed6: "",
    lineVerticalDashed7: "",
    lineVerticalDashed8: "",
    lineVerticalDashed9: "",
    lineVerticalDashed10: "",
    lineVerticalDashed11: "",
    lineDownLeft: "",
    lineDownLeftArc: "",
    lineDownBoldLeftBold: "",
    lineDownBoldLeft: "",
    lineDownLeftBold: "",
    lineDownDoubleLeftDouble: "",
    lineDownDoubleLeft: "",
    lineDownLeftDouble: "",
    lineDownRight: "",
    lineDownRightArc: "",
    lineDownBoldRightBold: "",
    lineDownBoldRight: "",
    lineDownRightBold: "",
    lineDownDoubleRightDouble: "",
    lineDownDoubleRight: "",
    lineDownRightDouble: "",
    lineUpLeft: "",
    lineUpLeftArc: "",
    lineUpBoldLeftBold: "",
    lineUpBoldLeft: "",
    lineUpLeftBold: "",
    lineUpDoubleLeftDouble: "",
    lineUpDoubleLeft: "",
    lineUpLeftDouble: "",
    lineUpRight: "",
    lineUpRightArc: "",
    lineUpBoldRightBold: "",
    lineUpBoldRight: "",
    lineUpRightBold: "",
    lineUpDoubleRightDouble: "",
    lineUpDoubleRight: "",
    lineUpRightDouble: "",
    lineUpDownLeft: "",
    lineUpBoldDownBoldLeftBold: "",
    lineUpBoldDownBoldLeft: "",
    lineUpDownLeftBold: "",
    lineUpBoldDownLeftBold: "",
    lineUpDownBoldLeftBold: "",
    lineUpDownBoldLeft: "",
    lineUpBoldDownLeft: "",
    lineUpDoubleDownDoubleLeftDouble: "",
    lineUpDoubleDownDoubleLeft: "",
    lineUpDownLeftDouble: "",
    lineUpDownRight: "",
    lineUpBoldDownBoldRightBold: "",
    lineUpBoldDownBoldRight: "",
    lineUpDownRightBold: "",
    lineUpBoldDownRightBold: "",
    lineUpDownBoldRightBold: "",
    lineUpDownBoldRight: "",
    lineUpBoldDownRight: "",
    lineUpDoubleDownDoubleRightDouble: "",
    lineUpDoubleDownDoubleRight: "",
    lineUpDownRightDouble: "",
    lineDownLeftRight: "",
    lineDownBoldLeftBoldRightBold: "",
    lineDownLeftBoldRightBold: "",
    lineDownBoldLeftRight: "",
    lineDownBoldLeftBoldRight: "",
    lineDownBoldLeftRightBold: "",
    lineDownLeftRightBold: "",
    lineDownLeftBoldRight: "",
    lineDownDoubleLeftDoubleRightDouble: "",
    lineDownDoubleLeftRight: "",
    lineDownLeftDoubleRightDouble: "",
    lineUpLeftRight: "",
    lineUpBoldLeftBoldRightBold: "",
    lineUpLeftBoldRightBold: "",
    lineUpBoldLeftRight: "",
    lineUpBoldLeftBoldRight: "",
    lineUpBoldLeftRightBold: "",
    lineUpLeftRightBold: "",
    lineUpLeftBoldRight: "",
    lineUpDoubleLeftDoubleRightDouble: "",
    lineUpDoubleLeftRight: "",
    lineUpLeftDoubleRightDouble: "",
    lineUpDownLeftRight: "",
    lineUpBoldDownBoldLeftBoldRightBold: "",
    lineUpDownBoldLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRightBold: "",
    lineUpBoldDownBoldLeftRightBold: "",
    lineUpBoldDownBoldLeftBoldRight: "",
    lineUpBoldDownLeftRight: "",
    lineUpDownBoldLeftRight: "",
    lineUpDownLeftBoldRight: "",
    lineUpDownLeftRightBold: "",
    lineUpBoldDownBoldLeftRight: "",
    lineUpDownLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRight: "",
    lineUpBoldDownLeftRightBold: "",
    lineUpDownBoldLeftBoldRight: "",
    lineUpDownBoldLeftRightBold: "",
    lineUpDoubleDownDoubleLeftDoubleRightDouble: "",
    lineUpDoubleDownDoubleLeftRight: "",
    lineUpDownLeftDoubleRightDouble: "",
    lineCross: "",
    lineBackslash: "",
    lineSlash: ""
  };
  specialMainSymbols4 = {
    tick: "",
    info: "",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "",
    circleFilled: "",
    circleDotted: "",
    circleDouble: "",
    circleCircle: "",
    circleCross: "",
    circlePipe: "",
    radioOn: "",
    radioOff: "",
    checkboxOn: "",
    checkboxOff: "",
    checkboxCircleOn: "",
    checkboxCircleOff: "",
    pointer: "",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "",
    oneNinth: "",
    oneTenth: ""
  };
  specialFallbackSymbols4 = {
    tick: "",
    info: "i",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "( )",
    circleFilled: "(*)",
    circleDotted: "( )",
    circleDouble: "( )",
    circleCircle: "()",
    circleCross: "()",
    circlePipe: "()",
    radioOn: "(*)",
    radioOff: "( )",
    checkboxOn: "[]",
    checkboxOff: "[ ]",
    checkboxCircleOn: "()",
    checkboxCircleOff: "( )",
    pointer: ">",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "1/7",
    oneNinth: "1/9",
    oneTenth: "1/10"
  };
  mainSymbols4 = { ...common4, ...specialMainSymbols4 };
  fallbackSymbols4 = {
    ...common4,
    ...specialFallbackSymbols4
  };
  shouldUseMain4 = isUnicodeSupported4();
  figures4 = shouldUseMain4 ? mainSymbols4 : fallbackSymbols4;
  esm_default7 = figures4;
  replacements4 = Object.entries(specialMainSymbols4);
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/theme.js
var import_yoctocolors_cjs6, defaultTheme4;
var init_theme4 = __esm(() => {
  import_yoctocolors_cjs6 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm10();
  defaultTheme4 = {
    prefix: {
      idle: import_yoctocolors_cjs6.default.blue("?"),
      done: import_yoctocolors_cjs6.default.green(esm_default7.tick)
    },
    spinner: {
      interval: 80,
      frames: ["", "", "", "", "", "", "", "", "", ""].map((frame) => import_yoctocolors_cjs6.default.yellow(frame))
    },
    style: {
      answer: import_yoctocolors_cjs6.default.cyan,
      message: import_yoctocolors_cjs6.default.bold,
      error: (text) => import_yoctocolors_cjs6.default.red(`> ${text}`),
      defaultAnswer: (text) => import_yoctocolors_cjs6.default.dim(`(${text})`),
      help: import_yoctocolors_cjs6.default.dim,
      highlight: import_yoctocolors_cjs6.default.cyan,
      key: (text) => import_yoctocolors_cjs6.default.cyan(import_yoctocolors_cjs6.default.bold(`<${text}>`))
    }
  };
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/make-theme.js
function isPlainObject4(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function deepMerge4(...objects) {
  const output = {};
  for (const obj of objects) {
    for (const [key4, value] of Object.entries(obj)) {
      const prevValue = output[key4];
      output[key4] = isPlainObject4(prevValue) && isPlainObject4(value) ? deepMerge4(prevValue, value) : value;
    }
  }
  return output;
}
function makeTheme4(...themes) {
  const themesToMerge = [
    defaultTheme4,
    ...themes.filter((theme) => theme != null)
  ];
  return deepMerge4(...themesToMerge);
}
var init_make_theme4 = __esm(() => {
  init_theme4();
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/use-prefix.js
import { AsyncResource as AsyncResource12 } from "node:async_hooks";
function usePrefix4({ status = "idle", theme }) {
  const [showLoader, setShowLoader] = useState4(false);
  const [tick, setTick] = useState4(0);
  const { prefix, spinner } = makeTheme4(theme);
  useEffect4(() => {
    if (status === "loading") {
      let tickInterval;
      let inc = -1;
      const delayTimeout = setTimeout(AsyncResource12.bind(() => {
        setShowLoader(true);
        tickInterval = setInterval(AsyncResource12.bind(() => {
          inc = inc + 1;
          setTick(inc % spinner.frames.length);
        }), spinner.interval);
      }), 300);
      return () => {
        clearTimeout(delayTimeout);
        clearInterval(tickInterval);
      };
    } else {
      setShowLoader(false);
    }
  }, [status]);
  if (showLoader) {
    return spinner.frames[tick];
  }
  const iconName = status === "loading" ? "idle" : status;
  return typeof prefix === "string" ? prefix : prefix[iconName] ?? prefix["idle"];
}
var init_use_prefix4 = __esm(() => {
  init_use_state4();
  init_use_effect4();
  init_make_theme4();
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/use-ref.js
function useRef4(val) {
  return useState4({ current: val })[0];
}
var init_use_ref4 = __esm(() => {
  init_use_state4();
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/use-keypress.js
function useKeypress4(userHandler) {
  const signal = useRef4(userHandler);
  signal.current = userHandler;
  useEffect4((rl) => {
    let ignore = false;
    const handler = withUpdates4((_input, event) => {
      if (ignore)
        return;
      signal.current(event, rl);
    });
    rl.input.on("keypress", handler);
    return () => {
      ignore = true;
      rl.input.removeListener("keypress", handler);
    };
  }, []);
}
var init_use_keypress4 = __esm(() => {
  init_use_ref4();
  init_use_effect4();
  init_hook_engine4();
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/utils.js
function breakLines4(content, width) {
  return content.split(`
`).flatMap((line) => import_wrap_ansi4.default(line, width, { trim: false, hard: true }).split(`
`).map((str) => str.trimEnd())).join(`
`);
}
function readlineWidth4() {
  return import_cli_width4.default({ defaultWidth: 80, output: readline7().output });
}
var import_cli_width4, import_wrap_ansi4;
var init_utils4 = __esm(() => {
  import_cli_width4 = __toESM(require_cli_width(), 1);
  import_wrap_ansi4 = __toESM(require_wrap_ansi(), 1);
  init_hook_engine4();
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/node_modules/strip-ansi/node_modules/ansi-regex/index.js
var require_ansi_regex5 = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/node_modules/strip-ansi/index.js
var require_strip_ansi5 = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex5();
  module.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/screen-manager.js
function cursorDown4(n) {
  return n > 0 ? import_ansi_escapes5.default.cursorDown(n) : "";
}

class ScreenManager4 {
  rl;
  height = 0;
  extraLinesUnderPrompt = 0;
  cursorPos;
  constructor(rl) {
    this.rl = rl;
    this.rl = rl;
    this.cursorPos = rl.getCursorPos();
  }
  write(content) {
    this.rl.output.unmute();
    this.rl.output.write(content);
    this.rl.output.mute();
  }
  render(content, bottomContent = "") {
    const promptLine = lastLine4(content);
    const rawPromptLine = import_strip_ansi4.default(promptLine);
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }
    this.rl.setPrompt(prompt);
    this.cursorPos = this.rl.getCursorPos();
    const width = readlineWidth4();
    content = breakLines4(content, width);
    bottomContent = breakLines4(bottomContent, width);
    if (rawPromptLine.length % width === 0) {
      content += `
`;
    }
    let output = content + (bottomContent ? `
` + bottomContent : "");
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - this.cursorPos.rows;
    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height4(bottomContent) : 0);
    if (bottomContentHeight > 0)
      output += import_ansi_escapes5.default.cursorUp(bottomContentHeight);
    output += import_ansi_escapes5.default.cursorTo(this.cursorPos.cols);
    this.write(cursorDown4(this.extraLinesUnderPrompt) + import_ansi_escapes5.default.eraseLines(this.height) + output);
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height4(output);
  }
  checkCursorPos() {
    const cursorPos = this.rl.getCursorPos();
    if (cursorPos.cols !== this.cursorPos.cols) {
      this.write(import_ansi_escapes5.default.cursorTo(cursorPos.cols));
      this.cursorPos = cursorPos;
    }
  }
  done({ clearContent }) {
    this.rl.setPrompt("");
    let output = cursorDown4(this.extraLinesUnderPrompt);
    output += clearContent ? import_ansi_escapes5.default.eraseLines(this.height) : `
`;
    output += import_ansi_escapes5.default.cursorShow;
    this.write(output);
    this.rl.close();
  }
}
var import_strip_ansi4, import_ansi_escapes5, height4 = (content) => content.split(`
`).length, lastLine4 = (content) => content.split(`
`).pop() ?? "";
var init_screen_manager4 = __esm(() => {
  import_strip_ansi4 = __toESM(require_strip_ansi5(), 1);
  import_ansi_escapes5 = __toESM(require_ansi_escapes(), 1);
  init_utils4();
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/promise-polyfill.js
var PromisePolyfill4;
var init_promise_polyfill4 = __esm(() => {
  PromisePolyfill4 = class PromisePolyfill4 extends Promise {
    static withResolver() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return { promise, resolve, reject };
    }
  };
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/lib/create-prompt.js
import * as readline8 from "node:readline";
import { AsyncResource as AsyncResource13 } from "node:async_hooks";
function getCallSites4() {
  const _prepareStackTrace = Error.prepareStackTrace;
  try {
    let result = [];
    Error.prepareStackTrace = (_2, callSites) => {
      const callSitesWithoutCurrent = callSites.slice(1);
      result = callSitesWithoutCurrent;
      return callSitesWithoutCurrent;
    };
    new Error().stack;
    return result;
  } finally {
    Error.prepareStackTrace = _prepareStackTrace;
  }
}
function createPrompt4(view) {
  const callSites = getCallSites4();
  const callerFilename = callSites[1]?.getFileName?.();
  const prompt = (config, context = {}) => {
    const { input = process.stdin, signal } = context;
    const cleanups = new Set;
    const output = new import_mute_stream4.default;
    output.pipe(context.output ?? process.stdout);
    const rl = readline8.createInterface({
      terminal: true,
      input,
      output
    });
    const screen = new ScreenManager4(rl);
    const { promise, resolve, reject } = PromisePolyfill4.withResolver();
    const cancel = () => reject(new CancelPromptError4);
    if (signal) {
      const abort = () => reject(new AbortPromptError4({ cause: signal.reason }));
      if (signal.aborted) {
        abort();
        return Object.assign(promise, { cancel });
      }
      signal.addEventListener("abort", abort);
      cleanups.add(() => signal.removeEventListener("abort", abort));
    }
    cleanups.add(onExit((code, signal2) => {
      reject(new ExitPromptError4(`User force closed the prompt with ${code} ${signal2}`));
    }));
    const checkCursorPos = () => screen.checkCursorPos();
    rl.input.on("keypress", checkCursorPos);
    cleanups.add(() => rl.input.removeListener("keypress", checkCursorPos));
    return withHooks4(rl, (cycle) => {
      const hooksCleanup = AsyncResource13.bind(() => effectScheduler4.clearAll());
      rl.on("close", hooksCleanup);
      cleanups.add(() => rl.removeListener("close", hooksCleanup));
      cycle(() => {
        try {
          const nextView = view(config, (value) => {
            setImmediate(() => resolve(value));
          });
          if (nextView === undefined) {
            throw new Error(`Prompt functions must return a string.
    at ${callerFilename}`);
          }
          const [content, bottomContent] = typeof nextView === "string" ? [nextView] : nextView;
          screen.render(content, bottomContent);
          effectScheduler4.run();
        } catch (error) {
          reject(error);
        }
      });
      return Object.assign(promise.then((answer) => {
        effectScheduler4.clearAll();
        return answer;
      }, (error) => {
        effectScheduler4.clearAll();
        throw error;
      }).finally(() => {
        cleanups.forEach((cleanup) => cleanup());
        screen.done({ clearContent: Boolean(context.clearPromptOnDone) });
        output.end();
      }).then(() => promise), { cancel });
    });
  };
  return prompt;
}
var import_mute_stream4;
var init_create_prompt4 = __esm(() => {
  import_mute_stream4 = __toESM(require_lib2(), 1);
  init_mjs();
  init_screen_manager4();
  init_promise_polyfill4();
  init_hook_engine4();
  init_errors4();
});

// node_modules/@inquirer/input/node_modules/@inquirer/core/dist/esm/index.js
var init_esm11 = __esm(() => {
  init_errors4();
  init_use_prefix4();
  init_use_state4();
  init_use_keypress4();
  init_make_theme4();
  init_create_prompt4();
});

// node_modules/@inquirer/input/dist/esm/index.js
var inputTheme, esm_default8;
var init_esm12 = __esm(() => {
  init_esm11();
  inputTheme = {
    validationFailureMode: "keep"
  };
  esm_default8 = createPrompt4((config, done) => {
    const { required, validate = () => true } = config;
    const theme = makeTheme4(inputTheme, config.theme);
    const [status, setStatus] = useState4("idle");
    const [defaultValue = "", setDefaultValue] = useState4(config.default);
    const [errorMsg, setError] = useState4();
    const [value, setValue] = useState4("");
    const prefix = usePrefix4({ status, theme });
    useKeypress4(async (key5, rl) => {
      if (status !== "idle") {
        return;
      }
      if (isEnterKey4(key5)) {
        const answer = value || defaultValue;
        setStatus("loading");
        const isValid = required && !answer ? "You must provide a value" : await validate(answer);
        if (isValid === true) {
          setValue(answer);
          setStatus("done");
          done(answer);
        } else {
          if (theme.validationFailureMode === "clear") {
            setValue("");
          } else {
            rl.write(value);
          }
          setError(isValid || "You must provide a valid value");
          setStatus("idle");
        }
      } else if (isBackspaceKey(key5) && !value) {
        setDefaultValue(undefined);
      } else if (key5.name === "tab" && !value) {
        setDefaultValue(undefined);
        rl.clearLine(0);
        rl.write(defaultValue);
        setValue(defaultValue);
      } else {
        setValue(rl.line);
        setError(undefined);
      }
    });
    const message = theme.style.message(config.message, status);
    let formattedValue = value;
    if (typeof config.transformer === "function") {
      formattedValue = config.transformer(value, { isFinal: status === "done" });
    } else if (status === "done") {
      formattedValue = theme.style.answer(value);
    }
    let defaultStr;
    if (defaultValue && status !== "done" && !value) {
      defaultStr = theme.style.defaultAnswer(defaultValue);
    }
    let error = "";
    if (errorMsg) {
      error = theme.style.error(errorMsg);
    }
    return [
      [prefix, message, defaultStr, formattedValue].filter((v) => v !== undefined).join(" "),
      error
    ];
  });
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/key.js
var isBackspaceKey2 = (key5) => key5.name === "backspace", isEnterKey5 = (key5) => key5.name === "enter" || key5.name === "return";

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/errors.js
var AbortPromptError5, CancelPromptError5, ExitPromptError5, HookError5, ValidationError5;
var init_errors5 = __esm(() => {
  AbortPromptError5 = class AbortPromptError5 extends Error {
    name = "AbortPromptError";
    message = "Prompt was aborted";
    constructor(options) {
      super();
      this.cause = options?.cause;
    }
  };
  CancelPromptError5 = class CancelPromptError5 extends Error {
    name = "CancelPromptError";
    message = "Prompt was canceled";
  };
  ExitPromptError5 = class ExitPromptError5 extends Error {
    name = "ExitPromptError";
  };
  HookError5 = class HookError5 extends Error {
    name = "HookError";
  };
  ValidationError5 = class ValidationError5 extends Error {
    name = "ValidationError";
  };
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/hook-engine.js
import { AsyncLocalStorage as AsyncLocalStorage5, AsyncResource as AsyncResource14 } from "node:async_hooks";
function createStore5(rl) {
  const store = {
    rl,
    hooks: [],
    hooksCleanup: [],
    hooksEffect: [],
    index: 0,
    handleChange() {
    }
  };
  return store;
}
function withHooks5(rl, cb) {
  const store = createStore5(rl);
  return hookStorage5.run(store, () => {
    function cycle(render) {
      store.handleChange = () => {
        store.index = 0;
        render();
      };
      store.handleChange();
    }
    return cb(cycle);
  });
}
function getStore5() {
  const store = hookStorage5.getStore();
  if (!store) {
    throw new HookError5("[Inquirer] Hook functions can only be called from within a prompt");
  }
  return store;
}
function readline9() {
  return getStore5().rl;
}
function withUpdates5(fn) {
  const wrapped = (...args) => {
    const store = getStore5();
    let shouldUpdate = false;
    const oldHandleChange = store.handleChange;
    store.handleChange = () => {
      shouldUpdate = true;
    };
    const returnValue = fn(...args);
    if (shouldUpdate) {
      oldHandleChange();
    }
    store.handleChange = oldHandleChange;
    return returnValue;
  };
  return AsyncResource14.bind(wrapped);
}
function withPointer5(cb) {
  const store = getStore5();
  const { index } = store;
  const pointer = {
    get() {
      return store.hooks[index];
    },
    set(value) {
      store.hooks[index] = value;
    },
    initialized: index in store.hooks
  };
  const returnValue = cb(pointer);
  store.index++;
  return returnValue;
}
function handleChange5() {
  getStore5().handleChange();
}
var hookStorage5, effectScheduler5;
var init_hook_engine5 = __esm(() => {
  init_errors5();
  hookStorage5 = new AsyncLocalStorage5;
  effectScheduler5 = {
    queue(cb) {
      const store = getStore5();
      const { index } = store;
      store.hooksEffect.push(() => {
        store.hooksCleanup[index]?.();
        const cleanFn = cb(readline9());
        if (cleanFn != null && typeof cleanFn !== "function") {
          throw new ValidationError5("useEffect return value must be a cleanup function or nothing.");
        }
        store.hooksCleanup[index] = cleanFn;
      });
    },
    run() {
      const store = getStore5();
      withUpdates5(() => {
        store.hooksEffect.forEach((effect) => {
          effect();
        });
        store.hooksEffect.length = 0;
      })();
    },
    clearAll() {
      const store = getStore5();
      store.hooksCleanup.forEach((cleanFn) => {
        cleanFn?.();
      });
      store.hooksEffect.length = 0;
      store.hooksCleanup.length = 0;
    }
  };
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/use-state.js
function useState5(defaultValue) {
  return withPointer5((pointer) => {
    const setFn = (newValue) => {
      if (pointer.get() !== newValue) {
        pointer.set(newValue);
        handleChange5();
      }
    };
    if (pointer.initialized) {
      return [pointer.get(), setFn];
    }
    const value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
    pointer.set(value);
    return [value, setFn];
  });
}
var init_use_state5 = __esm(() => {
  init_hook_engine5();
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/use-effect.js
function useEffect5(cb, depArray) {
  withPointer5((pointer) => {
    const oldDeps = pointer.get();
    const hasChanged = !Array.isArray(oldDeps) || depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    if (hasChanged) {
      effectScheduler5.queue(cb);
    }
    pointer.set(depArray);
  });
}
var init_use_effect5 = __esm(() => {
  init_hook_engine5();
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/node_modules/@inquirer/figures/dist/esm/index.js
import process7 from "node:process";
function isUnicodeSupported5() {
  if (process7.platform !== "win32") {
    return process7.env["TERM"] !== "linux";
  }
  return Boolean(process7.env["WT_SESSION"]) || Boolean(process7.env["TERMINUS_SUBLIME"]) || process7.env["ConEmuTask"] === "{cmd::Cmder}" || process7.env["TERM_PROGRAM"] === "Terminus-Sublime" || process7.env["TERM_PROGRAM"] === "vscode" || process7.env["TERM"] === "xterm-256color" || process7.env["TERM"] === "alacritty" || process7.env["TERMINAL_EMULATOR"] === "JetBrains-JediTerm";
}
var common5, specialMainSymbols5, specialFallbackSymbols5, mainSymbols5, fallbackSymbols5, shouldUseMain5, figures5, esm_default9, replacements5;
var init_esm13 = __esm(() => {
  common5 = {
    circleQuestionMark: "(?)",
    questionMarkPrefix: "(?)",
    square: "",
    squareDarkShade: "",
    squareMediumShade: "",
    squareLightShade: "",
    squareTop: "",
    squareBottom: "",
    squareLeft: "",
    squareRight: "",
    squareCenter: "",
    bullet: "",
    dot: "",
    ellipsis: "",
    pointerSmall: "",
    triangleUp: "",
    triangleUpSmall: "",
    triangleDown: "",
    triangleDownSmall: "",
    triangleLeftSmall: "",
    triangleRightSmall: "",
    home: "",
    heart: "",
    musicNote: "",
    musicNoteBeamed: "",
    arrowUp: "",
    arrowDown: "",
    arrowLeft: "",
    arrowRight: "",
    arrowLeftRight: "",
    arrowUpDown: "",
    almostEqual: "",
    notEqual: "",
    lessOrEqual: "",
    greaterOrEqual: "",
    identical: "",
    infinity: "",
    subscriptZero: "",
    subscriptOne: "",
    subscriptTwo: "",
    subscriptThree: "",
    subscriptFour: "",
    subscriptFive: "",
    subscriptSix: "",
    subscriptSeven: "",
    subscriptEight: "",
    subscriptNine: "",
    oneHalf: "",
    oneThird: "",
    oneQuarter: "",
    oneFifth: "",
    oneSixth: "",
    oneEighth: "",
    twoThirds: "",
    twoFifths: "",
    threeQuarters: "",
    threeFifths: "",
    threeEighths: "",
    fourFifths: "",
    fiveSixths: "",
    fiveEighths: "",
    sevenEighths: "",
    line: "",
    lineBold: "",
    lineDouble: "",
    lineDashed0: "",
    lineDashed1: "",
    lineDashed2: "",
    lineDashed3: "",
    lineDashed4: "",
    lineDashed5: "",
    lineDashed6: "",
    lineDashed7: "",
    lineDashed8: "",
    lineDashed9: "",
    lineDashed10: "",
    lineDashed11: "",
    lineDashed12: "",
    lineDashed13: "",
    lineDashed14: "",
    lineDashed15: "",
    lineVertical: "",
    lineVerticalBold: "",
    lineVerticalDouble: "",
    lineVerticalDashed0: "",
    lineVerticalDashed1: "",
    lineVerticalDashed2: "",
    lineVerticalDashed3: "",
    lineVerticalDashed4: "",
    lineVerticalDashed5: "",
    lineVerticalDashed6: "",
    lineVerticalDashed7: "",
    lineVerticalDashed8: "",
    lineVerticalDashed9: "",
    lineVerticalDashed10: "",
    lineVerticalDashed11: "",
    lineDownLeft: "",
    lineDownLeftArc: "",
    lineDownBoldLeftBold: "",
    lineDownBoldLeft: "",
    lineDownLeftBold: "",
    lineDownDoubleLeftDouble: "",
    lineDownDoubleLeft: "",
    lineDownLeftDouble: "",
    lineDownRight: "",
    lineDownRightArc: "",
    lineDownBoldRightBold: "",
    lineDownBoldRight: "",
    lineDownRightBold: "",
    lineDownDoubleRightDouble: "",
    lineDownDoubleRight: "",
    lineDownRightDouble: "",
    lineUpLeft: "",
    lineUpLeftArc: "",
    lineUpBoldLeftBold: "",
    lineUpBoldLeft: "",
    lineUpLeftBold: "",
    lineUpDoubleLeftDouble: "",
    lineUpDoubleLeft: "",
    lineUpLeftDouble: "",
    lineUpRight: "",
    lineUpRightArc: "",
    lineUpBoldRightBold: "",
    lineUpBoldRight: "",
    lineUpRightBold: "",
    lineUpDoubleRightDouble: "",
    lineUpDoubleRight: "",
    lineUpRightDouble: "",
    lineUpDownLeft: "",
    lineUpBoldDownBoldLeftBold: "",
    lineUpBoldDownBoldLeft: "",
    lineUpDownLeftBold: "",
    lineUpBoldDownLeftBold: "",
    lineUpDownBoldLeftBold: "",
    lineUpDownBoldLeft: "",
    lineUpBoldDownLeft: "",
    lineUpDoubleDownDoubleLeftDouble: "",
    lineUpDoubleDownDoubleLeft: "",
    lineUpDownLeftDouble: "",
    lineUpDownRight: "",
    lineUpBoldDownBoldRightBold: "",
    lineUpBoldDownBoldRight: "",
    lineUpDownRightBold: "",
    lineUpBoldDownRightBold: "",
    lineUpDownBoldRightBold: "",
    lineUpDownBoldRight: "",
    lineUpBoldDownRight: "",
    lineUpDoubleDownDoubleRightDouble: "",
    lineUpDoubleDownDoubleRight: "",
    lineUpDownRightDouble: "",
    lineDownLeftRight: "",
    lineDownBoldLeftBoldRightBold: "",
    lineDownLeftBoldRightBold: "",
    lineDownBoldLeftRight: "",
    lineDownBoldLeftBoldRight: "",
    lineDownBoldLeftRightBold: "",
    lineDownLeftRightBold: "",
    lineDownLeftBoldRight: "",
    lineDownDoubleLeftDoubleRightDouble: "",
    lineDownDoubleLeftRight: "",
    lineDownLeftDoubleRightDouble: "",
    lineUpLeftRight: "",
    lineUpBoldLeftBoldRightBold: "",
    lineUpLeftBoldRightBold: "",
    lineUpBoldLeftRight: "",
    lineUpBoldLeftBoldRight: "",
    lineUpBoldLeftRightBold: "",
    lineUpLeftRightBold: "",
    lineUpLeftBoldRight: "",
    lineUpDoubleLeftDoubleRightDouble: "",
    lineUpDoubleLeftRight: "",
    lineUpLeftDoubleRightDouble: "",
    lineUpDownLeftRight: "",
    lineUpBoldDownBoldLeftBoldRightBold: "",
    lineUpDownBoldLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRightBold: "",
    lineUpBoldDownBoldLeftRightBold: "",
    lineUpBoldDownBoldLeftBoldRight: "",
    lineUpBoldDownLeftRight: "",
    lineUpDownBoldLeftRight: "",
    lineUpDownLeftBoldRight: "",
    lineUpDownLeftRightBold: "",
    lineUpBoldDownBoldLeftRight: "",
    lineUpDownLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRight: "",
    lineUpBoldDownLeftRightBold: "",
    lineUpDownBoldLeftBoldRight: "",
    lineUpDownBoldLeftRightBold: "",
    lineUpDoubleDownDoubleLeftDoubleRightDouble: "",
    lineUpDoubleDownDoubleLeftRight: "",
    lineUpDownLeftDoubleRightDouble: "",
    lineCross: "",
    lineBackslash: "",
    lineSlash: ""
  };
  specialMainSymbols5 = {
    tick: "",
    info: "",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "",
    circleFilled: "",
    circleDotted: "",
    circleDouble: "",
    circleCircle: "",
    circleCross: "",
    circlePipe: "",
    radioOn: "",
    radioOff: "",
    checkboxOn: "",
    checkboxOff: "",
    checkboxCircleOn: "",
    checkboxCircleOff: "",
    pointer: "",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "",
    oneNinth: "",
    oneTenth: ""
  };
  specialFallbackSymbols5 = {
    tick: "",
    info: "i",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "( )",
    circleFilled: "(*)",
    circleDotted: "( )",
    circleDouble: "( )",
    circleCircle: "()",
    circleCross: "()",
    circlePipe: "()",
    radioOn: "(*)",
    radioOff: "( )",
    checkboxOn: "[]",
    checkboxOff: "[ ]",
    checkboxCircleOn: "()",
    checkboxCircleOff: "( )",
    pointer: ">",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "1/7",
    oneNinth: "1/9",
    oneTenth: "1/10"
  };
  mainSymbols5 = { ...common5, ...specialMainSymbols5 };
  fallbackSymbols5 = {
    ...common5,
    ...specialFallbackSymbols5
  };
  shouldUseMain5 = isUnicodeSupported5();
  figures5 = shouldUseMain5 ? mainSymbols5 : fallbackSymbols5;
  esm_default9 = figures5;
  replacements5 = Object.entries(specialMainSymbols5);
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/theme.js
var import_yoctocolors_cjs7, defaultTheme5;
var init_theme5 = __esm(() => {
  import_yoctocolors_cjs7 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm13();
  defaultTheme5 = {
    prefix: {
      idle: import_yoctocolors_cjs7.default.blue("?"),
      done: import_yoctocolors_cjs7.default.green(esm_default9.tick)
    },
    spinner: {
      interval: 80,
      frames: ["", "", "", "", "", "", "", "", "", ""].map((frame) => import_yoctocolors_cjs7.default.yellow(frame))
    },
    style: {
      answer: import_yoctocolors_cjs7.default.cyan,
      message: import_yoctocolors_cjs7.default.bold,
      error: (text) => import_yoctocolors_cjs7.default.red(`> ${text}`),
      defaultAnswer: (text) => import_yoctocolors_cjs7.default.dim(`(${text})`),
      help: import_yoctocolors_cjs7.default.dim,
      highlight: import_yoctocolors_cjs7.default.cyan,
      key: (text) => import_yoctocolors_cjs7.default.cyan(import_yoctocolors_cjs7.default.bold(`<${text}>`))
    }
  };
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/make-theme.js
function isPlainObject5(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function deepMerge5(...objects) {
  const output = {};
  for (const obj of objects) {
    for (const [key5, value] of Object.entries(obj)) {
      const prevValue = output[key5];
      output[key5] = isPlainObject5(prevValue) && isPlainObject5(value) ? deepMerge5(prevValue, value) : value;
    }
  }
  return output;
}
function makeTheme5(...themes) {
  const themesToMerge = [
    defaultTheme5,
    ...themes.filter((theme) => theme != null)
  ];
  return deepMerge5(...themesToMerge);
}
var init_make_theme5 = __esm(() => {
  init_theme5();
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/use-prefix.js
import { AsyncResource as AsyncResource15 } from "node:async_hooks";
function usePrefix5({ status = "idle", theme }) {
  const [showLoader, setShowLoader] = useState5(false);
  const [tick, setTick] = useState5(0);
  const { prefix, spinner } = makeTheme5(theme);
  useEffect5(() => {
    if (status === "loading") {
      let tickInterval;
      let inc = -1;
      const delayTimeout = setTimeout(AsyncResource15.bind(() => {
        setShowLoader(true);
        tickInterval = setInterval(AsyncResource15.bind(() => {
          inc = inc + 1;
          setTick(inc % spinner.frames.length);
        }), spinner.interval);
      }), 300);
      return () => {
        clearTimeout(delayTimeout);
        clearInterval(tickInterval);
      };
    } else {
      setShowLoader(false);
    }
  }, [status]);
  if (showLoader) {
    return spinner.frames[tick];
  }
  const iconName = status === "loading" ? "idle" : status;
  return typeof prefix === "string" ? prefix : prefix[iconName] ?? prefix["idle"];
}
var init_use_prefix5 = __esm(() => {
  init_use_state5();
  init_use_effect5();
  init_make_theme5();
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/use-ref.js
function useRef5(val) {
  return useState5({ current: val })[0];
}
var init_use_ref5 = __esm(() => {
  init_use_state5();
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/use-keypress.js
function useKeypress5(userHandler) {
  const signal = useRef5(userHandler);
  signal.current = userHandler;
  useEffect5((rl) => {
    let ignore = false;
    const handler = withUpdates5((_input, event) => {
      if (ignore)
        return;
      signal.current(event, rl);
    });
    rl.input.on("keypress", handler);
    return () => {
      ignore = true;
      rl.input.removeListener("keypress", handler);
    };
  }, []);
}
var init_use_keypress5 = __esm(() => {
  init_use_ref5();
  init_use_effect5();
  init_hook_engine5();
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/utils.js
function breakLines5(content, width) {
  return content.split(`
`).flatMap((line) => import_wrap_ansi5.default(line, width, { trim: false, hard: true }).split(`
`).map((str) => str.trimEnd())).join(`
`);
}
function readlineWidth5() {
  return import_cli_width5.default({ defaultWidth: 80, output: readline9().output });
}
var import_cli_width5, import_wrap_ansi5;
var init_utils5 = __esm(() => {
  import_cli_width5 = __toESM(require_cli_width(), 1);
  import_wrap_ansi5 = __toESM(require_wrap_ansi(), 1);
  init_hook_engine5();
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/node_modules/strip-ansi/node_modules/ansi-regex/index.js
var require_ansi_regex6 = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/node_modules/strip-ansi/index.js
var require_strip_ansi6 = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex6();
  module.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/screen-manager.js
function cursorDown5(n) {
  return n > 0 ? import_ansi_escapes6.default.cursorDown(n) : "";
}

class ScreenManager5 {
  rl;
  height = 0;
  extraLinesUnderPrompt = 0;
  cursorPos;
  constructor(rl) {
    this.rl = rl;
    this.rl = rl;
    this.cursorPos = rl.getCursorPos();
  }
  write(content) {
    this.rl.output.unmute();
    this.rl.output.write(content);
    this.rl.output.mute();
  }
  render(content, bottomContent = "") {
    const promptLine = lastLine5(content);
    const rawPromptLine = import_strip_ansi5.default(promptLine);
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }
    this.rl.setPrompt(prompt);
    this.cursorPos = this.rl.getCursorPos();
    const width = readlineWidth5();
    content = breakLines5(content, width);
    bottomContent = breakLines5(bottomContent, width);
    if (rawPromptLine.length % width === 0) {
      content += `
`;
    }
    let output = content + (bottomContent ? `
` + bottomContent : "");
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - this.cursorPos.rows;
    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height5(bottomContent) : 0);
    if (bottomContentHeight > 0)
      output += import_ansi_escapes6.default.cursorUp(bottomContentHeight);
    output += import_ansi_escapes6.default.cursorTo(this.cursorPos.cols);
    this.write(cursorDown5(this.extraLinesUnderPrompt) + import_ansi_escapes6.default.eraseLines(this.height) + output);
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height5(output);
  }
  checkCursorPos() {
    const cursorPos = this.rl.getCursorPos();
    if (cursorPos.cols !== this.cursorPos.cols) {
      this.write(import_ansi_escapes6.default.cursorTo(cursorPos.cols));
      this.cursorPos = cursorPos;
    }
  }
  done({ clearContent }) {
    this.rl.setPrompt("");
    let output = cursorDown5(this.extraLinesUnderPrompt);
    output += clearContent ? import_ansi_escapes6.default.eraseLines(this.height) : `
`;
    output += import_ansi_escapes6.default.cursorShow;
    this.write(output);
    this.rl.close();
  }
}
var import_strip_ansi5, import_ansi_escapes6, height5 = (content) => content.split(`
`).length, lastLine5 = (content) => content.split(`
`).pop() ?? "";
var init_screen_manager5 = __esm(() => {
  import_strip_ansi5 = __toESM(require_strip_ansi6(), 1);
  import_ansi_escapes6 = __toESM(require_ansi_escapes(), 1);
  init_utils5();
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/promise-polyfill.js
var PromisePolyfill5;
var init_promise_polyfill5 = __esm(() => {
  PromisePolyfill5 = class PromisePolyfill5 extends Promise {
    static withResolver() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return { promise, resolve, reject };
    }
  };
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/lib/create-prompt.js
import * as readline10 from "node:readline";
import { AsyncResource as AsyncResource16 } from "node:async_hooks";
function getCallSites5() {
  const _prepareStackTrace = Error.prepareStackTrace;
  try {
    let result = [];
    Error.prepareStackTrace = (_2, callSites) => {
      const callSitesWithoutCurrent = callSites.slice(1);
      result = callSitesWithoutCurrent;
      return callSitesWithoutCurrent;
    };
    new Error().stack;
    return result;
  } finally {
    Error.prepareStackTrace = _prepareStackTrace;
  }
}
function createPrompt5(view) {
  const callSites = getCallSites5();
  const callerFilename = callSites[1]?.getFileName?.();
  const prompt = (config, context = {}) => {
    const { input = process.stdin, signal } = context;
    const cleanups = new Set;
    const output = new import_mute_stream5.default;
    output.pipe(context.output ?? process.stdout);
    const rl = readline10.createInterface({
      terminal: true,
      input,
      output
    });
    const screen = new ScreenManager5(rl);
    const { promise, resolve, reject } = PromisePolyfill5.withResolver();
    const cancel = () => reject(new CancelPromptError5);
    if (signal) {
      const abort = () => reject(new AbortPromptError5({ cause: signal.reason }));
      if (signal.aborted) {
        abort();
        return Object.assign(promise, { cancel });
      }
      signal.addEventListener("abort", abort);
      cleanups.add(() => signal.removeEventListener("abort", abort));
    }
    cleanups.add(onExit((code, signal2) => {
      reject(new ExitPromptError5(`User force closed the prompt with ${code} ${signal2}`));
    }));
    const checkCursorPos = () => screen.checkCursorPos();
    rl.input.on("keypress", checkCursorPos);
    cleanups.add(() => rl.input.removeListener("keypress", checkCursorPos));
    return withHooks5(rl, (cycle) => {
      const hooksCleanup = AsyncResource16.bind(() => effectScheduler5.clearAll());
      rl.on("close", hooksCleanup);
      cleanups.add(() => rl.removeListener("close", hooksCleanup));
      cycle(() => {
        try {
          const nextView = view(config, (value) => {
            setImmediate(() => resolve(value));
          });
          if (nextView === undefined) {
            throw new Error(`Prompt functions must return a string.
    at ${callerFilename}`);
          }
          const [content, bottomContent] = typeof nextView === "string" ? [nextView] : nextView;
          screen.render(content, bottomContent);
          effectScheduler5.run();
        } catch (error) {
          reject(error);
        }
      });
      return Object.assign(promise.then((answer) => {
        effectScheduler5.clearAll();
        return answer;
      }, (error) => {
        effectScheduler5.clearAll();
        throw error;
      }).finally(() => {
        cleanups.forEach((cleanup) => cleanup());
        screen.done({ clearContent: Boolean(context.clearPromptOnDone) });
        output.end();
      }).then(() => promise), { cancel });
    });
  };
  return prompt;
}
var import_mute_stream5;
var init_create_prompt5 = __esm(() => {
  import_mute_stream5 = __toESM(require_lib2(), 1);
  init_mjs();
  init_screen_manager5();
  init_promise_polyfill5();
  init_hook_engine5();
  init_errors5();
});

// node_modules/@inquirer/number/node_modules/@inquirer/core/dist/esm/index.js
var init_esm14 = __esm(() => {
  init_errors5();
  init_use_prefix5();
  init_use_state5();
  init_use_keypress5();
  init_make_theme5();
  init_create_prompt5();
});

// node_modules/@inquirer/number/dist/esm/index.js
function isStepOf(value, step, min) {
  const valuePow = value * Math.pow(10, 6);
  const stepPow = step * Math.pow(10, 6);
  const minPow = min * Math.pow(10, 6);
  return (valuePow - (Number.isFinite(min) ? minPow : 0)) % stepPow === 0;
}
function validateNumber(value, { min, max, step }) {
  if (value == null || Number.isNaN(value)) {
    return false;
  } else if (value < min || value > max) {
    return `Value must be between ${min} and ${max}`;
  } else if (step !== "any" && !isStepOf(value, step, min)) {
    return `Value must be a multiple of ${step}${Number.isFinite(min) ? ` starting from ${min}` : ""}`;
  }
  return true;
}
var esm_default10;
var init_esm15 = __esm(() => {
  init_esm14();
  esm_default10 = createPrompt5((config, done) => {
    const { validate = () => true, min = -Infinity, max = Infinity, step = 1, required = false } = config;
    const theme = makeTheme5(config.theme);
    const [status, setStatus] = useState5("idle");
    const [value, setValue] = useState5("");
    const validDefault = validateNumber(config.default, { min, max, step }) === true ? config.default?.toString() : undefined;
    const [defaultValue = "", setDefaultValue] = useState5(validDefault);
    const [errorMsg, setError] = useState5();
    const prefix = usePrefix5({ status, theme });
    useKeypress5(async (key6, rl) => {
      if (status !== "idle") {
        return;
      }
      if (isEnterKey5(key6)) {
        const input = value || defaultValue;
        const answer = input === "" ? undefined : Number(input);
        setStatus("loading");
        let isValid = true;
        if (required || answer != null) {
          isValid = validateNumber(answer, { min, max, step });
        }
        if (isValid === true) {
          isValid = await validate(answer);
        }
        if (isValid === true) {
          setValue(String(answer ?? ""));
          setStatus("done");
          done(answer);
        } else {
          rl.write(value);
          setError(isValid || "You must provide a valid numeric value");
          setStatus("idle");
        }
      } else if (isBackspaceKey2(key6) && !value) {
        setDefaultValue(undefined);
      } else if (key6.name === "tab" && !value) {
        setDefaultValue(undefined);
        rl.clearLine(0);
        rl.write(defaultValue);
        setValue(defaultValue);
      } else {
        setValue(rl.line);
        setError(undefined);
      }
    });
    const message = theme.style.message(config.message, status);
    let formattedValue = value;
    if (status === "done") {
      formattedValue = theme.style.answer(value);
    }
    let defaultStr;
    if (defaultValue && status !== "done" && !value) {
      defaultStr = theme.style.defaultAnswer(defaultValue);
    }
    let error = "";
    if (errorMsg) {
      error = theme.style.error(errorMsg);
    }
    return [
      [prefix, message, defaultStr, formattedValue].filter((v) => v !== undefined).join(" "),
      error
    ];
  });
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/key.js
var isEnterKey6 = (key6) => key6.name === "enter" || key6.name === "return";

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/errors.js
var AbortPromptError6, CancelPromptError6, ExitPromptError6, HookError6, ValidationError6;
var init_errors6 = __esm(() => {
  AbortPromptError6 = class AbortPromptError6 extends Error {
    name = "AbortPromptError";
    message = "Prompt was aborted";
    constructor(options) {
      super();
      this.cause = options?.cause;
    }
  };
  CancelPromptError6 = class CancelPromptError6 extends Error {
    name = "CancelPromptError";
    message = "Prompt was canceled";
  };
  ExitPromptError6 = class ExitPromptError6 extends Error {
    name = "ExitPromptError";
  };
  HookError6 = class HookError6 extends Error {
    name = "HookError";
  };
  ValidationError6 = class ValidationError6 extends Error {
    name = "ValidationError";
  };
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/hook-engine.js
import { AsyncLocalStorage as AsyncLocalStorage6, AsyncResource as AsyncResource17 } from "node:async_hooks";
function createStore6(rl) {
  const store = {
    rl,
    hooks: [],
    hooksCleanup: [],
    hooksEffect: [],
    index: 0,
    handleChange() {
    }
  };
  return store;
}
function withHooks6(rl, cb) {
  const store = createStore6(rl);
  return hookStorage6.run(store, () => {
    function cycle(render) {
      store.handleChange = () => {
        store.index = 0;
        render();
      };
      store.handleChange();
    }
    return cb(cycle);
  });
}
function getStore6() {
  const store = hookStorage6.getStore();
  if (!store) {
    throw new HookError6("[Inquirer] Hook functions can only be called from within a prompt");
  }
  return store;
}
function readline11() {
  return getStore6().rl;
}
function withUpdates6(fn) {
  const wrapped = (...args) => {
    const store = getStore6();
    let shouldUpdate = false;
    const oldHandleChange = store.handleChange;
    store.handleChange = () => {
      shouldUpdate = true;
    };
    const returnValue = fn(...args);
    if (shouldUpdate) {
      oldHandleChange();
    }
    store.handleChange = oldHandleChange;
    return returnValue;
  };
  return AsyncResource17.bind(wrapped);
}
function withPointer6(cb) {
  const store = getStore6();
  const { index } = store;
  const pointer = {
    get() {
      return store.hooks[index];
    },
    set(value) {
      store.hooks[index] = value;
    },
    initialized: index in store.hooks
  };
  const returnValue = cb(pointer);
  store.index++;
  return returnValue;
}
function handleChange6() {
  getStore6().handleChange();
}
var hookStorage6, effectScheduler6;
var init_hook_engine6 = __esm(() => {
  init_errors6();
  hookStorage6 = new AsyncLocalStorage6;
  effectScheduler6 = {
    queue(cb) {
      const store = getStore6();
      const { index } = store;
      store.hooksEffect.push(() => {
        store.hooksCleanup[index]?.();
        const cleanFn = cb(readline11());
        if (cleanFn != null && typeof cleanFn !== "function") {
          throw new ValidationError6("useEffect return value must be a cleanup function or nothing.");
        }
        store.hooksCleanup[index] = cleanFn;
      });
    },
    run() {
      const store = getStore6();
      withUpdates6(() => {
        store.hooksEffect.forEach((effect) => {
          effect();
        });
        store.hooksEffect.length = 0;
      })();
    },
    clearAll() {
      const store = getStore6();
      store.hooksCleanup.forEach((cleanFn) => {
        cleanFn?.();
      });
      store.hooksEffect.length = 0;
      store.hooksCleanup.length = 0;
    }
  };
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/use-state.js
function useState6(defaultValue) {
  return withPointer6((pointer) => {
    const setFn = (newValue) => {
      if (pointer.get() !== newValue) {
        pointer.set(newValue);
        handleChange6();
      }
    };
    if (pointer.initialized) {
      return [pointer.get(), setFn];
    }
    const value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
    pointer.set(value);
    return [value, setFn];
  });
}
var init_use_state6 = __esm(() => {
  init_hook_engine6();
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/use-effect.js
function useEffect6(cb, depArray) {
  withPointer6((pointer) => {
    const oldDeps = pointer.get();
    const hasChanged = !Array.isArray(oldDeps) || depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    if (hasChanged) {
      effectScheduler6.queue(cb);
    }
    pointer.set(depArray);
  });
}
var init_use_effect6 = __esm(() => {
  init_hook_engine6();
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/node_modules/@inquirer/figures/dist/esm/index.js
import process8 from "node:process";
function isUnicodeSupported6() {
  if (process8.platform !== "win32") {
    return process8.env["TERM"] !== "linux";
  }
  return Boolean(process8.env["WT_SESSION"]) || Boolean(process8.env["TERMINUS_SUBLIME"]) || process8.env["ConEmuTask"] === "{cmd::Cmder}" || process8.env["TERM_PROGRAM"] === "Terminus-Sublime" || process8.env["TERM_PROGRAM"] === "vscode" || process8.env["TERM"] === "xterm-256color" || process8.env["TERM"] === "alacritty" || process8.env["TERMINAL_EMULATOR"] === "JetBrains-JediTerm";
}
var common6, specialMainSymbols6, specialFallbackSymbols6, mainSymbols6, fallbackSymbols6, shouldUseMain6, figures6, esm_default11, replacements6;
var init_esm16 = __esm(() => {
  common6 = {
    circleQuestionMark: "(?)",
    questionMarkPrefix: "(?)",
    square: "",
    squareDarkShade: "",
    squareMediumShade: "",
    squareLightShade: "",
    squareTop: "",
    squareBottom: "",
    squareLeft: "",
    squareRight: "",
    squareCenter: "",
    bullet: "",
    dot: "",
    ellipsis: "",
    pointerSmall: "",
    triangleUp: "",
    triangleUpSmall: "",
    triangleDown: "",
    triangleDownSmall: "",
    triangleLeftSmall: "",
    triangleRightSmall: "",
    home: "",
    heart: "",
    musicNote: "",
    musicNoteBeamed: "",
    arrowUp: "",
    arrowDown: "",
    arrowLeft: "",
    arrowRight: "",
    arrowLeftRight: "",
    arrowUpDown: "",
    almostEqual: "",
    notEqual: "",
    lessOrEqual: "",
    greaterOrEqual: "",
    identical: "",
    infinity: "",
    subscriptZero: "",
    subscriptOne: "",
    subscriptTwo: "",
    subscriptThree: "",
    subscriptFour: "",
    subscriptFive: "",
    subscriptSix: "",
    subscriptSeven: "",
    subscriptEight: "",
    subscriptNine: "",
    oneHalf: "",
    oneThird: "",
    oneQuarter: "",
    oneFifth: "",
    oneSixth: "",
    oneEighth: "",
    twoThirds: "",
    twoFifths: "",
    threeQuarters: "",
    threeFifths: "",
    threeEighths: "",
    fourFifths: "",
    fiveSixths: "",
    fiveEighths: "",
    sevenEighths: "",
    line: "",
    lineBold: "",
    lineDouble: "",
    lineDashed0: "",
    lineDashed1: "",
    lineDashed2: "",
    lineDashed3: "",
    lineDashed4: "",
    lineDashed5: "",
    lineDashed6: "",
    lineDashed7: "",
    lineDashed8: "",
    lineDashed9: "",
    lineDashed10: "",
    lineDashed11: "",
    lineDashed12: "",
    lineDashed13: "",
    lineDashed14: "",
    lineDashed15: "",
    lineVertical: "",
    lineVerticalBold: "",
    lineVerticalDouble: "",
    lineVerticalDashed0: "",
    lineVerticalDashed1: "",
    lineVerticalDashed2: "",
    lineVerticalDashed3: "",
    lineVerticalDashed4: "",
    lineVerticalDashed5: "",
    lineVerticalDashed6: "",
    lineVerticalDashed7: "",
    lineVerticalDashed8: "",
    lineVerticalDashed9: "",
    lineVerticalDashed10: "",
    lineVerticalDashed11: "",
    lineDownLeft: "",
    lineDownLeftArc: "",
    lineDownBoldLeftBold: "",
    lineDownBoldLeft: "",
    lineDownLeftBold: "",
    lineDownDoubleLeftDouble: "",
    lineDownDoubleLeft: "",
    lineDownLeftDouble: "",
    lineDownRight: "",
    lineDownRightArc: "",
    lineDownBoldRightBold: "",
    lineDownBoldRight: "",
    lineDownRightBold: "",
    lineDownDoubleRightDouble: "",
    lineDownDoubleRight: "",
    lineDownRightDouble: "",
    lineUpLeft: "",
    lineUpLeftArc: "",
    lineUpBoldLeftBold: "",
    lineUpBoldLeft: "",
    lineUpLeftBold: "",
    lineUpDoubleLeftDouble: "",
    lineUpDoubleLeft: "",
    lineUpLeftDouble: "",
    lineUpRight: "",
    lineUpRightArc: "",
    lineUpBoldRightBold: "",
    lineUpBoldRight: "",
    lineUpRightBold: "",
    lineUpDoubleRightDouble: "",
    lineUpDoubleRight: "",
    lineUpRightDouble: "",
    lineUpDownLeft: "",
    lineUpBoldDownBoldLeftBold: "",
    lineUpBoldDownBoldLeft: "",
    lineUpDownLeftBold: "",
    lineUpBoldDownLeftBold: "",
    lineUpDownBoldLeftBold: "",
    lineUpDownBoldLeft: "",
    lineUpBoldDownLeft: "",
    lineUpDoubleDownDoubleLeftDouble: "",
    lineUpDoubleDownDoubleLeft: "",
    lineUpDownLeftDouble: "",
    lineUpDownRight: "",
    lineUpBoldDownBoldRightBold: "",
    lineUpBoldDownBoldRight: "",
    lineUpDownRightBold: "",
    lineUpBoldDownRightBold: "",
    lineUpDownBoldRightBold: "",
    lineUpDownBoldRight: "",
    lineUpBoldDownRight: "",
    lineUpDoubleDownDoubleRightDouble: "",
    lineUpDoubleDownDoubleRight: "",
    lineUpDownRightDouble: "",
    lineDownLeftRight: "",
    lineDownBoldLeftBoldRightBold: "",
    lineDownLeftBoldRightBold: "",
    lineDownBoldLeftRight: "",
    lineDownBoldLeftBoldRight: "",
    lineDownBoldLeftRightBold: "",
    lineDownLeftRightBold: "",
    lineDownLeftBoldRight: "",
    lineDownDoubleLeftDoubleRightDouble: "",
    lineDownDoubleLeftRight: "",
    lineDownLeftDoubleRightDouble: "",
    lineUpLeftRight: "",
    lineUpBoldLeftBoldRightBold: "",
    lineUpLeftBoldRightBold: "",
    lineUpBoldLeftRight: "",
    lineUpBoldLeftBoldRight: "",
    lineUpBoldLeftRightBold: "",
    lineUpLeftRightBold: "",
    lineUpLeftBoldRight: "",
    lineUpDoubleLeftDoubleRightDouble: "",
    lineUpDoubleLeftRight: "",
    lineUpLeftDoubleRightDouble: "",
    lineUpDownLeftRight: "",
    lineUpBoldDownBoldLeftBoldRightBold: "",
    lineUpDownBoldLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRightBold: "",
    lineUpBoldDownBoldLeftRightBold: "",
    lineUpBoldDownBoldLeftBoldRight: "",
    lineUpBoldDownLeftRight: "",
    lineUpDownBoldLeftRight: "",
    lineUpDownLeftBoldRight: "",
    lineUpDownLeftRightBold: "",
    lineUpBoldDownBoldLeftRight: "",
    lineUpDownLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRight: "",
    lineUpBoldDownLeftRightBold: "",
    lineUpDownBoldLeftBoldRight: "",
    lineUpDownBoldLeftRightBold: "",
    lineUpDoubleDownDoubleLeftDoubleRightDouble: "",
    lineUpDoubleDownDoubleLeftRight: "",
    lineUpDownLeftDoubleRightDouble: "",
    lineCross: "",
    lineBackslash: "",
    lineSlash: ""
  };
  specialMainSymbols6 = {
    tick: "",
    info: "",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "",
    circleFilled: "",
    circleDotted: "",
    circleDouble: "",
    circleCircle: "",
    circleCross: "",
    circlePipe: "",
    radioOn: "",
    radioOff: "",
    checkboxOn: "",
    checkboxOff: "",
    checkboxCircleOn: "",
    checkboxCircleOff: "",
    pointer: "",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "",
    oneNinth: "",
    oneTenth: ""
  };
  specialFallbackSymbols6 = {
    tick: "",
    info: "i",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "( )",
    circleFilled: "(*)",
    circleDotted: "( )",
    circleDouble: "( )",
    circleCircle: "()",
    circleCross: "()",
    circlePipe: "()",
    radioOn: "(*)",
    radioOff: "( )",
    checkboxOn: "[]",
    checkboxOff: "[ ]",
    checkboxCircleOn: "()",
    checkboxCircleOff: "( )",
    pointer: ">",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "1/7",
    oneNinth: "1/9",
    oneTenth: "1/10"
  };
  mainSymbols6 = { ...common6, ...specialMainSymbols6 };
  fallbackSymbols6 = {
    ...common6,
    ...specialFallbackSymbols6
  };
  shouldUseMain6 = isUnicodeSupported6();
  figures6 = shouldUseMain6 ? mainSymbols6 : fallbackSymbols6;
  esm_default11 = figures6;
  replacements6 = Object.entries(specialMainSymbols6);
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/theme.js
var import_yoctocolors_cjs8, defaultTheme6;
var init_theme6 = __esm(() => {
  import_yoctocolors_cjs8 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm16();
  defaultTheme6 = {
    prefix: {
      idle: import_yoctocolors_cjs8.default.blue("?"),
      done: import_yoctocolors_cjs8.default.green(esm_default11.tick)
    },
    spinner: {
      interval: 80,
      frames: ["", "", "", "", "", "", "", "", "", ""].map((frame) => import_yoctocolors_cjs8.default.yellow(frame))
    },
    style: {
      answer: import_yoctocolors_cjs8.default.cyan,
      message: import_yoctocolors_cjs8.default.bold,
      error: (text) => import_yoctocolors_cjs8.default.red(`> ${text}`),
      defaultAnswer: (text) => import_yoctocolors_cjs8.default.dim(`(${text})`),
      help: import_yoctocolors_cjs8.default.dim,
      highlight: import_yoctocolors_cjs8.default.cyan,
      key: (text) => import_yoctocolors_cjs8.default.cyan(import_yoctocolors_cjs8.default.bold(`<${text}>`))
    }
  };
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/make-theme.js
function isPlainObject6(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function deepMerge6(...objects) {
  const output = {};
  for (const obj of objects) {
    for (const [key6, value] of Object.entries(obj)) {
      const prevValue = output[key6];
      output[key6] = isPlainObject6(prevValue) && isPlainObject6(value) ? deepMerge6(prevValue, value) : value;
    }
  }
  return output;
}
function makeTheme6(...themes) {
  const themesToMerge = [
    defaultTheme6,
    ...themes.filter((theme) => theme != null)
  ];
  return deepMerge6(...themesToMerge);
}
var init_make_theme6 = __esm(() => {
  init_theme6();
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/use-prefix.js
import { AsyncResource as AsyncResource18 } from "node:async_hooks";
function usePrefix6({ status = "idle", theme }) {
  const [showLoader, setShowLoader] = useState6(false);
  const [tick, setTick] = useState6(0);
  const { prefix, spinner } = makeTheme6(theme);
  useEffect6(() => {
    if (status === "loading") {
      let tickInterval;
      let inc = -1;
      const delayTimeout = setTimeout(AsyncResource18.bind(() => {
        setShowLoader(true);
        tickInterval = setInterval(AsyncResource18.bind(() => {
          inc = inc + 1;
          setTick(inc % spinner.frames.length);
        }), spinner.interval);
      }), 300);
      return () => {
        clearTimeout(delayTimeout);
        clearInterval(tickInterval);
      };
    } else {
      setShowLoader(false);
    }
  }, [status]);
  if (showLoader) {
    return spinner.frames[tick];
  }
  const iconName = status === "loading" ? "idle" : status;
  return typeof prefix === "string" ? prefix : prefix[iconName] ?? prefix["idle"];
}
var init_use_prefix6 = __esm(() => {
  init_use_state6();
  init_use_effect6();
  init_make_theme6();
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/use-memo.js
function useMemo2(fn, dependencies) {
  return withPointer6((pointer) => {
    const prev = pointer.get();
    if (!prev || prev.dependencies.length !== dependencies.length || prev.dependencies.some((dep, i) => dep !== dependencies[i])) {
      const value = fn();
      pointer.set({ value, dependencies });
      return value;
    }
    return prev.value;
  });
}
var init_use_memo2 = __esm(() => {
  init_hook_engine6();
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/use-ref.js
function useRef6(val) {
  return useState6({ current: val })[0];
}
var init_use_ref6 = __esm(() => {
  init_use_state6();
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/use-keypress.js
function useKeypress6(userHandler) {
  const signal = useRef6(userHandler);
  signal.current = userHandler;
  useEffect6((rl) => {
    let ignore = false;
    const handler = withUpdates6((_input, event) => {
      if (ignore)
        return;
      signal.current(event, rl);
    });
    rl.input.on("keypress", handler);
    return () => {
      ignore = true;
      rl.input.removeListener("keypress", handler);
    };
  }, []);
}
var init_use_keypress6 = __esm(() => {
  init_use_ref6();
  init_use_effect6();
  init_hook_engine6();
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/utils.js
function breakLines6(content, width) {
  return content.split(`
`).flatMap((line) => import_wrap_ansi6.default(line, width, { trim: false, hard: true }).split(`
`).map((str) => str.trimEnd())).join(`
`);
}
function readlineWidth6() {
  return import_cli_width6.default({ defaultWidth: 80, output: readline11().output });
}
var import_cli_width6, import_wrap_ansi6;
var init_utils6 = __esm(() => {
  import_cli_width6 = __toESM(require_cli_width(), 1);
  import_wrap_ansi6 = __toESM(require_wrap_ansi(), 1);
  init_hook_engine6();
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/node_modules/strip-ansi/node_modules/ansi-regex/index.js
var require_ansi_regex7 = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/node_modules/strip-ansi/index.js
var require_strip_ansi7 = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex7();
  module.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/screen-manager.js
function cursorDown6(n) {
  return n > 0 ? import_ansi_escapes7.default.cursorDown(n) : "";
}

class ScreenManager6 {
  rl;
  height = 0;
  extraLinesUnderPrompt = 0;
  cursorPos;
  constructor(rl) {
    this.rl = rl;
    this.rl = rl;
    this.cursorPos = rl.getCursorPos();
  }
  write(content) {
    this.rl.output.unmute();
    this.rl.output.write(content);
    this.rl.output.mute();
  }
  render(content, bottomContent = "") {
    const promptLine = lastLine6(content);
    const rawPromptLine = import_strip_ansi6.default(promptLine);
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }
    this.rl.setPrompt(prompt);
    this.cursorPos = this.rl.getCursorPos();
    const width = readlineWidth6();
    content = breakLines6(content, width);
    bottomContent = breakLines6(bottomContent, width);
    if (rawPromptLine.length % width === 0) {
      content += `
`;
    }
    let output = content + (bottomContent ? `
` + bottomContent : "");
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - this.cursorPos.rows;
    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height6(bottomContent) : 0);
    if (bottomContentHeight > 0)
      output += import_ansi_escapes7.default.cursorUp(bottomContentHeight);
    output += import_ansi_escapes7.default.cursorTo(this.cursorPos.cols);
    this.write(cursorDown6(this.extraLinesUnderPrompt) + import_ansi_escapes7.default.eraseLines(this.height) + output);
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height6(output);
  }
  checkCursorPos() {
    const cursorPos = this.rl.getCursorPos();
    if (cursorPos.cols !== this.cursorPos.cols) {
      this.write(import_ansi_escapes7.default.cursorTo(cursorPos.cols));
      this.cursorPos = cursorPos;
    }
  }
  done({ clearContent }) {
    this.rl.setPrompt("");
    let output = cursorDown6(this.extraLinesUnderPrompt);
    output += clearContent ? import_ansi_escapes7.default.eraseLines(this.height) : `
`;
    output += import_ansi_escapes7.default.cursorShow;
    this.write(output);
    this.rl.close();
  }
}
var import_strip_ansi6, import_ansi_escapes7, height6 = (content) => content.split(`
`).length, lastLine6 = (content) => content.split(`
`).pop() ?? "";
var init_screen_manager6 = __esm(() => {
  import_strip_ansi6 = __toESM(require_strip_ansi7(), 1);
  import_ansi_escapes7 = __toESM(require_ansi_escapes(), 1);
  init_utils6();
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/promise-polyfill.js
var PromisePolyfill6;
var init_promise_polyfill6 = __esm(() => {
  PromisePolyfill6 = class PromisePolyfill6 extends Promise {
    static withResolver() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return { promise, resolve, reject };
    }
  };
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/create-prompt.js
import * as readline12 from "node:readline";
import { AsyncResource as AsyncResource19 } from "node:async_hooks";
function getCallSites6() {
  const _prepareStackTrace = Error.prepareStackTrace;
  try {
    let result = [];
    Error.prepareStackTrace = (_2, callSites) => {
      const callSitesWithoutCurrent = callSites.slice(1);
      result = callSitesWithoutCurrent;
      return callSitesWithoutCurrent;
    };
    new Error().stack;
    return result;
  } finally {
    Error.prepareStackTrace = _prepareStackTrace;
  }
}
function createPrompt6(view) {
  const callSites = getCallSites6();
  const callerFilename = callSites[1]?.getFileName?.();
  const prompt = (config, context = {}) => {
    const { input = process.stdin, signal } = context;
    const cleanups = new Set;
    const output = new import_mute_stream6.default;
    output.pipe(context.output ?? process.stdout);
    const rl = readline12.createInterface({
      terminal: true,
      input,
      output
    });
    const screen = new ScreenManager6(rl);
    const { promise, resolve, reject } = PromisePolyfill6.withResolver();
    const cancel = () => reject(new CancelPromptError6);
    if (signal) {
      const abort = () => reject(new AbortPromptError6({ cause: signal.reason }));
      if (signal.aborted) {
        abort();
        return Object.assign(promise, { cancel });
      }
      signal.addEventListener("abort", abort);
      cleanups.add(() => signal.removeEventListener("abort", abort));
    }
    cleanups.add(onExit((code, signal2) => {
      reject(new ExitPromptError6(`User force closed the prompt with ${code} ${signal2}`));
    }));
    const checkCursorPos = () => screen.checkCursorPos();
    rl.input.on("keypress", checkCursorPos);
    cleanups.add(() => rl.input.removeListener("keypress", checkCursorPos));
    return withHooks6(rl, (cycle) => {
      const hooksCleanup = AsyncResource19.bind(() => effectScheduler6.clearAll());
      rl.on("close", hooksCleanup);
      cleanups.add(() => rl.removeListener("close", hooksCleanup));
      cycle(() => {
        try {
          const nextView = view(config, (value) => {
            setImmediate(() => resolve(value));
          });
          if (nextView === undefined) {
            throw new Error(`Prompt functions must return a string.
    at ${callerFilename}`);
          }
          const [content, bottomContent] = typeof nextView === "string" ? [nextView] : nextView;
          screen.render(content, bottomContent);
          effectScheduler6.run();
        } catch (error) {
          reject(error);
        }
      });
      return Object.assign(promise.then((answer) => {
        effectScheduler6.clearAll();
        return answer;
      }, (error) => {
        effectScheduler6.clearAll();
        throw error;
      }).finally(() => {
        cleanups.forEach((cleanup) => cleanup());
        screen.done({ clearContent: Boolean(context.clearPromptOnDone) });
        output.end();
      }).then(() => promise), { cancel });
    });
  };
  return prompt;
}
var import_mute_stream6;
var init_create_prompt6 = __esm(() => {
  import_mute_stream6 = __toESM(require_lib2(), 1);
  init_mjs();
  init_screen_manager6();
  init_promise_polyfill6();
  init_hook_engine6();
  init_errors6();
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/lib/Separator.js
class Separator2 {
  separator = import_yoctocolors_cjs9.default.dim(Array.from({ length: 15 }).join(esm_default11.line));
  type = "separator";
  constructor(separator) {
    if (separator) {
      this.separator = separator;
    }
  }
  static isSeparator(choice) {
    return Boolean(choice && typeof choice === "object" && "type" in choice && choice.type === "separator");
  }
}
var import_yoctocolors_cjs9;
var init_Separator2 = __esm(() => {
  import_yoctocolors_cjs9 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm16();
});

// node_modules/@inquirer/expand/node_modules/@inquirer/core/dist/esm/index.js
var init_esm17 = __esm(() => {
  init_errors6();
  init_use_prefix6();
  init_use_state6();
  init_use_memo2();
  init_use_keypress6();
  init_make_theme6();
  init_create_prompt6();
  init_Separator2();
});

// node_modules/@inquirer/expand/dist/esm/index.js
function normalizeChoices2(choices) {
  return choices.map((choice) => {
    if (Separator2.isSeparator(choice)) {
      return choice;
    }
    const name = "name" in choice ? choice.name : String(choice.value);
    const value = "value" in choice ? choice.value : name;
    return {
      value,
      name,
      key: choice.key.toLowerCase()
    };
  });
}
var import_yoctocolors_cjs10, helpChoice, esm_default12;
var init_esm18 = __esm(() => {
  init_esm17();
  import_yoctocolors_cjs10 = __toESM(require_yoctocolors_cjs(), 1);
  helpChoice = {
    key: "h",
    name: "Help, list all options",
    value: undefined
  };
  esm_default12 = createPrompt6((config, done) => {
    const { default: defaultKey = "h" } = config;
    const choices = useMemo2(() => normalizeChoices2(config.choices), [config.choices]);
    const [status, setStatus] = useState6("idle");
    const [value, setValue] = useState6("");
    const [expanded, setExpanded] = useState6(config.expanded ?? false);
    const [errorMsg, setError] = useState6();
    const theme = makeTheme6(config.theme);
    const prefix = usePrefix6({ theme, status });
    useKeypress6((event, rl) => {
      if (isEnterKey6(event)) {
        const answer = (value || defaultKey).toLowerCase();
        if (answer === "h" && !expanded) {
          setExpanded(true);
        } else {
          const selectedChoice = choices.find((choice) => !Separator2.isSeparator(choice) && choice.key === answer);
          if (selectedChoice) {
            setStatus("done");
            setValue(answer);
            done(selectedChoice.value);
          } else if (value === "") {
            setError("Please input a value");
          } else {
            setError(`"${import_yoctocolors_cjs10.default.red(value)}" isn't an available option`);
          }
        }
      } else {
        setValue(rl.line);
        setError(undefined);
      }
    });
    const message = theme.style.message(config.message, status);
    if (status === "done") {
      const selectedChoice = choices.find((choice) => !Separator2.isSeparator(choice) && choice.key === value.toLowerCase());
      return `${prefix} ${message} ${theme.style.answer(selectedChoice.name)}`;
    }
    const allChoices = expanded ? choices : [...choices, helpChoice];
    let longChoices = "";
    let shortChoices = allChoices.map((choice) => {
      if (Separator2.isSeparator(choice))
        return "";
      if (choice.key === defaultKey) {
        return choice.key.toUpperCase();
      }
      return choice.key;
    }).join("");
    shortChoices = ` ${theme.style.defaultAnswer(shortChoices)}`;
    if (expanded) {
      shortChoices = "";
      longChoices = allChoices.map((choice) => {
        if (Separator2.isSeparator(choice)) {
          return ` ${choice.separator}`;
        }
        const line = `  ${choice.key}) ${choice.name}`;
        if (choice.key === value.toLowerCase()) {
          return theme.style.highlight(line);
        }
        return line;
      }).join(`
`);
    }
    let helpTip = "";
    const currentOption = choices.find((choice) => !Separator2.isSeparator(choice) && choice.key === value.toLowerCase());
    if (currentOption) {
      helpTip = `${import_yoctocolors_cjs10.default.cyan(">>")} ${currentOption.name}`;
    }
    let error = "";
    if (errorMsg) {
      error = theme.style.error(errorMsg);
    }
    return [
      `${prefix} ${message}${shortChoices} ${value}`,
      [longChoices, helpTip, error].filter(Boolean).join(`
`)
    ];
  });
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/key.js
var isEnterKey7 = (key7) => key7.name === "enter" || key7.name === "return";

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/errors.js
var AbortPromptError7, CancelPromptError7, ExitPromptError7, HookError7, ValidationError7;
var init_errors7 = __esm(() => {
  AbortPromptError7 = class AbortPromptError7 extends Error {
    name = "AbortPromptError";
    message = "Prompt was aborted";
    constructor(options) {
      super();
      this.cause = options?.cause;
    }
  };
  CancelPromptError7 = class CancelPromptError7 extends Error {
    name = "CancelPromptError";
    message = "Prompt was canceled";
  };
  ExitPromptError7 = class ExitPromptError7 extends Error {
    name = "ExitPromptError";
  };
  HookError7 = class HookError7 extends Error {
    name = "HookError";
  };
  ValidationError7 = class ValidationError7 extends Error {
    name = "ValidationError";
  };
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/hook-engine.js
import { AsyncLocalStorage as AsyncLocalStorage7, AsyncResource as AsyncResource20 } from "node:async_hooks";
function createStore7(rl) {
  const store = {
    rl,
    hooks: [],
    hooksCleanup: [],
    hooksEffect: [],
    index: 0,
    handleChange() {
    }
  };
  return store;
}
function withHooks7(rl, cb) {
  const store = createStore7(rl);
  return hookStorage7.run(store, () => {
    function cycle(render) {
      store.handleChange = () => {
        store.index = 0;
        render();
      };
      store.handleChange();
    }
    return cb(cycle);
  });
}
function getStore7() {
  const store = hookStorage7.getStore();
  if (!store) {
    throw new HookError7("[Inquirer] Hook functions can only be called from within a prompt");
  }
  return store;
}
function readline13() {
  return getStore7().rl;
}
function withUpdates7(fn) {
  const wrapped = (...args) => {
    const store = getStore7();
    let shouldUpdate = false;
    const oldHandleChange = store.handleChange;
    store.handleChange = () => {
      shouldUpdate = true;
    };
    const returnValue = fn(...args);
    if (shouldUpdate) {
      oldHandleChange();
    }
    store.handleChange = oldHandleChange;
    return returnValue;
  };
  return AsyncResource20.bind(wrapped);
}
function withPointer7(cb) {
  const store = getStore7();
  const { index } = store;
  const pointer = {
    get() {
      return store.hooks[index];
    },
    set(value) {
      store.hooks[index] = value;
    },
    initialized: index in store.hooks
  };
  const returnValue = cb(pointer);
  store.index++;
  return returnValue;
}
function handleChange7() {
  getStore7().handleChange();
}
var hookStorage7, effectScheduler7;
var init_hook_engine7 = __esm(() => {
  init_errors7();
  hookStorage7 = new AsyncLocalStorage7;
  effectScheduler7 = {
    queue(cb) {
      const store = getStore7();
      const { index } = store;
      store.hooksEffect.push(() => {
        store.hooksCleanup[index]?.();
        const cleanFn = cb(readline13());
        if (cleanFn != null && typeof cleanFn !== "function") {
          throw new ValidationError7("useEffect return value must be a cleanup function or nothing.");
        }
        store.hooksCleanup[index] = cleanFn;
      });
    },
    run() {
      const store = getStore7();
      withUpdates7(() => {
        store.hooksEffect.forEach((effect) => {
          effect();
        });
        store.hooksEffect.length = 0;
      })();
    },
    clearAll() {
      const store = getStore7();
      store.hooksCleanup.forEach((cleanFn) => {
        cleanFn?.();
      });
      store.hooksEffect.length = 0;
      store.hooksCleanup.length = 0;
    }
  };
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/use-state.js
function useState7(defaultValue) {
  return withPointer7((pointer) => {
    const setFn = (newValue) => {
      if (pointer.get() !== newValue) {
        pointer.set(newValue);
        handleChange7();
      }
    };
    if (pointer.initialized) {
      return [pointer.get(), setFn];
    }
    const value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
    pointer.set(value);
    return [value, setFn];
  });
}
var init_use_state7 = __esm(() => {
  init_hook_engine7();
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/use-effect.js
function useEffect7(cb, depArray) {
  withPointer7((pointer) => {
    const oldDeps = pointer.get();
    const hasChanged = !Array.isArray(oldDeps) || depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    if (hasChanged) {
      effectScheduler7.queue(cb);
    }
    pointer.set(depArray);
  });
}
var init_use_effect7 = __esm(() => {
  init_hook_engine7();
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/node_modules/@inquirer/figures/dist/esm/index.js
import process9 from "node:process";
function isUnicodeSupported7() {
  if (process9.platform !== "win32") {
    return process9.env["TERM"] !== "linux";
  }
  return Boolean(process9.env["WT_SESSION"]) || Boolean(process9.env["TERMINUS_SUBLIME"]) || process9.env["ConEmuTask"] === "{cmd::Cmder}" || process9.env["TERM_PROGRAM"] === "Terminus-Sublime" || process9.env["TERM_PROGRAM"] === "vscode" || process9.env["TERM"] === "xterm-256color" || process9.env["TERM"] === "alacritty" || process9.env["TERMINAL_EMULATOR"] === "JetBrains-JediTerm";
}
var common7, specialMainSymbols7, specialFallbackSymbols7, mainSymbols7, fallbackSymbols7, shouldUseMain7, figures7, esm_default13, replacements7;
var init_esm19 = __esm(() => {
  common7 = {
    circleQuestionMark: "(?)",
    questionMarkPrefix: "(?)",
    square: "",
    squareDarkShade: "",
    squareMediumShade: "",
    squareLightShade: "",
    squareTop: "",
    squareBottom: "",
    squareLeft: "",
    squareRight: "",
    squareCenter: "",
    bullet: "",
    dot: "",
    ellipsis: "",
    pointerSmall: "",
    triangleUp: "",
    triangleUpSmall: "",
    triangleDown: "",
    triangleDownSmall: "",
    triangleLeftSmall: "",
    triangleRightSmall: "",
    home: "",
    heart: "",
    musicNote: "",
    musicNoteBeamed: "",
    arrowUp: "",
    arrowDown: "",
    arrowLeft: "",
    arrowRight: "",
    arrowLeftRight: "",
    arrowUpDown: "",
    almostEqual: "",
    notEqual: "",
    lessOrEqual: "",
    greaterOrEqual: "",
    identical: "",
    infinity: "",
    subscriptZero: "",
    subscriptOne: "",
    subscriptTwo: "",
    subscriptThree: "",
    subscriptFour: "",
    subscriptFive: "",
    subscriptSix: "",
    subscriptSeven: "",
    subscriptEight: "",
    subscriptNine: "",
    oneHalf: "",
    oneThird: "",
    oneQuarter: "",
    oneFifth: "",
    oneSixth: "",
    oneEighth: "",
    twoThirds: "",
    twoFifths: "",
    threeQuarters: "",
    threeFifths: "",
    threeEighths: "",
    fourFifths: "",
    fiveSixths: "",
    fiveEighths: "",
    sevenEighths: "",
    line: "",
    lineBold: "",
    lineDouble: "",
    lineDashed0: "",
    lineDashed1: "",
    lineDashed2: "",
    lineDashed3: "",
    lineDashed4: "",
    lineDashed5: "",
    lineDashed6: "",
    lineDashed7: "",
    lineDashed8: "",
    lineDashed9: "",
    lineDashed10: "",
    lineDashed11: "",
    lineDashed12: "",
    lineDashed13: "",
    lineDashed14: "",
    lineDashed15: "",
    lineVertical: "",
    lineVerticalBold: "",
    lineVerticalDouble: "",
    lineVerticalDashed0: "",
    lineVerticalDashed1: "",
    lineVerticalDashed2: "",
    lineVerticalDashed3: "",
    lineVerticalDashed4: "",
    lineVerticalDashed5: "",
    lineVerticalDashed6: "",
    lineVerticalDashed7: "",
    lineVerticalDashed8: "",
    lineVerticalDashed9: "",
    lineVerticalDashed10: "",
    lineVerticalDashed11: "",
    lineDownLeft: "",
    lineDownLeftArc: "",
    lineDownBoldLeftBold: "",
    lineDownBoldLeft: "",
    lineDownLeftBold: "",
    lineDownDoubleLeftDouble: "",
    lineDownDoubleLeft: "",
    lineDownLeftDouble: "",
    lineDownRight: "",
    lineDownRightArc: "",
    lineDownBoldRightBold: "",
    lineDownBoldRight: "",
    lineDownRightBold: "",
    lineDownDoubleRightDouble: "",
    lineDownDoubleRight: "",
    lineDownRightDouble: "",
    lineUpLeft: "",
    lineUpLeftArc: "",
    lineUpBoldLeftBold: "",
    lineUpBoldLeft: "",
    lineUpLeftBold: "",
    lineUpDoubleLeftDouble: "",
    lineUpDoubleLeft: "",
    lineUpLeftDouble: "",
    lineUpRight: "",
    lineUpRightArc: "",
    lineUpBoldRightBold: "",
    lineUpBoldRight: "",
    lineUpRightBold: "",
    lineUpDoubleRightDouble: "",
    lineUpDoubleRight: "",
    lineUpRightDouble: "",
    lineUpDownLeft: "",
    lineUpBoldDownBoldLeftBold: "",
    lineUpBoldDownBoldLeft: "",
    lineUpDownLeftBold: "",
    lineUpBoldDownLeftBold: "",
    lineUpDownBoldLeftBold: "",
    lineUpDownBoldLeft: "",
    lineUpBoldDownLeft: "",
    lineUpDoubleDownDoubleLeftDouble: "",
    lineUpDoubleDownDoubleLeft: "",
    lineUpDownLeftDouble: "",
    lineUpDownRight: "",
    lineUpBoldDownBoldRightBold: "",
    lineUpBoldDownBoldRight: "",
    lineUpDownRightBold: "",
    lineUpBoldDownRightBold: "",
    lineUpDownBoldRightBold: "",
    lineUpDownBoldRight: "",
    lineUpBoldDownRight: "",
    lineUpDoubleDownDoubleRightDouble: "",
    lineUpDoubleDownDoubleRight: "",
    lineUpDownRightDouble: "",
    lineDownLeftRight: "",
    lineDownBoldLeftBoldRightBold: "",
    lineDownLeftBoldRightBold: "",
    lineDownBoldLeftRight: "",
    lineDownBoldLeftBoldRight: "",
    lineDownBoldLeftRightBold: "",
    lineDownLeftRightBold: "",
    lineDownLeftBoldRight: "",
    lineDownDoubleLeftDoubleRightDouble: "",
    lineDownDoubleLeftRight: "",
    lineDownLeftDoubleRightDouble: "",
    lineUpLeftRight: "",
    lineUpBoldLeftBoldRightBold: "",
    lineUpLeftBoldRightBold: "",
    lineUpBoldLeftRight: "",
    lineUpBoldLeftBoldRight: "",
    lineUpBoldLeftRightBold: "",
    lineUpLeftRightBold: "",
    lineUpLeftBoldRight: "",
    lineUpDoubleLeftDoubleRightDouble: "",
    lineUpDoubleLeftRight: "",
    lineUpLeftDoubleRightDouble: "",
    lineUpDownLeftRight: "",
    lineUpBoldDownBoldLeftBoldRightBold: "",
    lineUpDownBoldLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRightBold: "",
    lineUpBoldDownBoldLeftRightBold: "",
    lineUpBoldDownBoldLeftBoldRight: "",
    lineUpBoldDownLeftRight: "",
    lineUpDownBoldLeftRight: "",
    lineUpDownLeftBoldRight: "",
    lineUpDownLeftRightBold: "",
    lineUpBoldDownBoldLeftRight: "",
    lineUpDownLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRight: "",
    lineUpBoldDownLeftRightBold: "",
    lineUpDownBoldLeftBoldRight: "",
    lineUpDownBoldLeftRightBold: "",
    lineUpDoubleDownDoubleLeftDoubleRightDouble: "",
    lineUpDoubleDownDoubleLeftRight: "",
    lineUpDownLeftDoubleRightDouble: "",
    lineCross: "",
    lineBackslash: "",
    lineSlash: ""
  };
  specialMainSymbols7 = {
    tick: "",
    info: "",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "",
    circleFilled: "",
    circleDotted: "",
    circleDouble: "",
    circleCircle: "",
    circleCross: "",
    circlePipe: "",
    radioOn: "",
    radioOff: "",
    checkboxOn: "",
    checkboxOff: "",
    checkboxCircleOn: "",
    checkboxCircleOff: "",
    pointer: "",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "",
    oneNinth: "",
    oneTenth: ""
  };
  specialFallbackSymbols7 = {
    tick: "",
    info: "i",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "( )",
    circleFilled: "(*)",
    circleDotted: "( )",
    circleDouble: "( )",
    circleCircle: "()",
    circleCross: "()",
    circlePipe: "()",
    radioOn: "(*)",
    radioOff: "( )",
    checkboxOn: "[]",
    checkboxOff: "[ ]",
    checkboxCircleOn: "()",
    checkboxCircleOff: "( )",
    pointer: ">",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "1/7",
    oneNinth: "1/9",
    oneTenth: "1/10"
  };
  mainSymbols7 = { ...common7, ...specialMainSymbols7 };
  fallbackSymbols7 = {
    ...common7,
    ...specialFallbackSymbols7
  };
  shouldUseMain7 = isUnicodeSupported7();
  figures7 = shouldUseMain7 ? mainSymbols7 : fallbackSymbols7;
  esm_default13 = figures7;
  replacements7 = Object.entries(specialMainSymbols7);
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/theme.js
var import_yoctocolors_cjs11, defaultTheme7;
var init_theme7 = __esm(() => {
  import_yoctocolors_cjs11 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm19();
  defaultTheme7 = {
    prefix: {
      idle: import_yoctocolors_cjs11.default.blue("?"),
      done: import_yoctocolors_cjs11.default.green(esm_default13.tick)
    },
    spinner: {
      interval: 80,
      frames: ["", "", "", "", "", "", "", "", "", ""].map((frame) => import_yoctocolors_cjs11.default.yellow(frame))
    },
    style: {
      answer: import_yoctocolors_cjs11.default.cyan,
      message: import_yoctocolors_cjs11.default.bold,
      error: (text) => import_yoctocolors_cjs11.default.red(`> ${text}`),
      defaultAnswer: (text) => import_yoctocolors_cjs11.default.dim(`(${text})`),
      help: import_yoctocolors_cjs11.default.dim,
      highlight: import_yoctocolors_cjs11.default.cyan,
      key: (text) => import_yoctocolors_cjs11.default.cyan(import_yoctocolors_cjs11.default.bold(`<${text}>`))
    }
  };
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/make-theme.js
function isPlainObject7(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function deepMerge7(...objects) {
  const output = {};
  for (const obj of objects) {
    for (const [key7, value] of Object.entries(obj)) {
      const prevValue = output[key7];
      output[key7] = isPlainObject7(prevValue) && isPlainObject7(value) ? deepMerge7(prevValue, value) : value;
    }
  }
  return output;
}
function makeTheme7(...themes) {
  const themesToMerge = [
    defaultTheme7,
    ...themes.filter((theme) => theme != null)
  ];
  return deepMerge7(...themesToMerge);
}
var init_make_theme7 = __esm(() => {
  init_theme7();
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/use-prefix.js
import { AsyncResource as AsyncResource21 } from "node:async_hooks";
function usePrefix7({ status = "idle", theme }) {
  const [showLoader, setShowLoader] = useState7(false);
  const [tick, setTick] = useState7(0);
  const { prefix, spinner } = makeTheme7(theme);
  useEffect7(() => {
    if (status === "loading") {
      let tickInterval;
      let inc = -1;
      const delayTimeout = setTimeout(AsyncResource21.bind(() => {
        setShowLoader(true);
        tickInterval = setInterval(AsyncResource21.bind(() => {
          inc = inc + 1;
          setTick(inc % spinner.frames.length);
        }), spinner.interval);
      }), 300);
      return () => {
        clearTimeout(delayTimeout);
        clearInterval(tickInterval);
      };
    } else {
      setShowLoader(false);
    }
  }, [status]);
  if (showLoader) {
    return spinner.frames[tick];
  }
  const iconName = status === "loading" ? "idle" : status;
  return typeof prefix === "string" ? prefix : prefix[iconName] ?? prefix["idle"];
}
var init_use_prefix7 = __esm(() => {
  init_use_state7();
  init_use_effect7();
  init_make_theme7();
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/use-memo.js
function useMemo3(fn, dependencies) {
  return withPointer7((pointer) => {
    const prev = pointer.get();
    if (!prev || prev.dependencies.length !== dependencies.length || prev.dependencies.some((dep, i) => dep !== dependencies[i])) {
      const value = fn();
      pointer.set({ value, dependencies });
      return value;
    }
    return prev.value;
  });
}
var init_use_memo3 = __esm(() => {
  init_hook_engine7();
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/use-ref.js
function useRef7(val) {
  return useState7({ current: val })[0];
}
var init_use_ref7 = __esm(() => {
  init_use_state7();
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/use-keypress.js
function useKeypress7(userHandler) {
  const signal = useRef7(userHandler);
  signal.current = userHandler;
  useEffect7((rl) => {
    let ignore = false;
    const handler = withUpdates7((_input, event) => {
      if (ignore)
        return;
      signal.current(event, rl);
    });
    rl.input.on("keypress", handler);
    return () => {
      ignore = true;
      rl.input.removeListener("keypress", handler);
    };
  }, []);
}
var init_use_keypress7 = __esm(() => {
  init_use_ref7();
  init_use_effect7();
  init_hook_engine7();
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/utils.js
function breakLines7(content, width) {
  return content.split(`
`).flatMap((line) => import_wrap_ansi7.default(line, width, { trim: false, hard: true }).split(`
`).map((str) => str.trimEnd())).join(`
`);
}
function readlineWidth7() {
  return import_cli_width7.default({ defaultWidth: 80, output: readline13().output });
}
var import_cli_width7, import_wrap_ansi7;
var init_utils7 = __esm(() => {
  import_cli_width7 = __toESM(require_cli_width(), 1);
  import_wrap_ansi7 = __toESM(require_wrap_ansi(), 1);
  init_hook_engine7();
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/node_modules/strip-ansi/node_modules/ansi-regex/index.js
var require_ansi_regex8 = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/node_modules/strip-ansi/index.js
var require_strip_ansi8 = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex8();
  module.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/screen-manager.js
function cursorDown7(n) {
  return n > 0 ? import_ansi_escapes8.default.cursorDown(n) : "";
}

class ScreenManager7 {
  rl;
  height = 0;
  extraLinesUnderPrompt = 0;
  cursorPos;
  constructor(rl) {
    this.rl = rl;
    this.rl = rl;
    this.cursorPos = rl.getCursorPos();
  }
  write(content) {
    this.rl.output.unmute();
    this.rl.output.write(content);
    this.rl.output.mute();
  }
  render(content, bottomContent = "") {
    const promptLine = lastLine7(content);
    const rawPromptLine = import_strip_ansi7.default(promptLine);
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }
    this.rl.setPrompt(prompt);
    this.cursorPos = this.rl.getCursorPos();
    const width = readlineWidth7();
    content = breakLines7(content, width);
    bottomContent = breakLines7(bottomContent, width);
    if (rawPromptLine.length % width === 0) {
      content += `
`;
    }
    let output = content + (bottomContent ? `
` + bottomContent : "");
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - this.cursorPos.rows;
    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height7(bottomContent) : 0);
    if (bottomContentHeight > 0)
      output += import_ansi_escapes8.default.cursorUp(bottomContentHeight);
    output += import_ansi_escapes8.default.cursorTo(this.cursorPos.cols);
    this.write(cursorDown7(this.extraLinesUnderPrompt) + import_ansi_escapes8.default.eraseLines(this.height) + output);
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height7(output);
  }
  checkCursorPos() {
    const cursorPos = this.rl.getCursorPos();
    if (cursorPos.cols !== this.cursorPos.cols) {
      this.write(import_ansi_escapes8.default.cursorTo(cursorPos.cols));
      this.cursorPos = cursorPos;
    }
  }
  done({ clearContent }) {
    this.rl.setPrompt("");
    let output = cursorDown7(this.extraLinesUnderPrompt);
    output += clearContent ? import_ansi_escapes8.default.eraseLines(this.height) : `
`;
    output += import_ansi_escapes8.default.cursorShow;
    this.write(output);
    this.rl.close();
  }
}
var import_strip_ansi7, import_ansi_escapes8, height7 = (content) => content.split(`
`).length, lastLine7 = (content) => content.split(`
`).pop() ?? "";
var init_screen_manager7 = __esm(() => {
  import_strip_ansi7 = __toESM(require_strip_ansi8(), 1);
  import_ansi_escapes8 = __toESM(require_ansi_escapes(), 1);
  init_utils7();
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/promise-polyfill.js
var PromisePolyfill7;
var init_promise_polyfill7 = __esm(() => {
  PromisePolyfill7 = class PromisePolyfill7 extends Promise {
    static withResolver() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return { promise, resolve, reject };
    }
  };
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/create-prompt.js
import * as readline14 from "node:readline";
import { AsyncResource as AsyncResource22 } from "node:async_hooks";
function getCallSites7() {
  const _prepareStackTrace = Error.prepareStackTrace;
  try {
    let result = [];
    Error.prepareStackTrace = (_2, callSites) => {
      const callSitesWithoutCurrent = callSites.slice(1);
      result = callSitesWithoutCurrent;
      return callSitesWithoutCurrent;
    };
    new Error().stack;
    return result;
  } finally {
    Error.prepareStackTrace = _prepareStackTrace;
  }
}
function createPrompt7(view) {
  const callSites = getCallSites7();
  const callerFilename = callSites[1]?.getFileName?.();
  const prompt = (config, context = {}) => {
    const { input = process.stdin, signal } = context;
    const cleanups = new Set;
    const output = new import_mute_stream7.default;
    output.pipe(context.output ?? process.stdout);
    const rl = readline14.createInterface({
      terminal: true,
      input,
      output
    });
    const screen = new ScreenManager7(rl);
    const { promise, resolve, reject } = PromisePolyfill7.withResolver();
    const cancel = () => reject(new CancelPromptError7);
    if (signal) {
      const abort = () => reject(new AbortPromptError7({ cause: signal.reason }));
      if (signal.aborted) {
        abort();
        return Object.assign(promise, { cancel });
      }
      signal.addEventListener("abort", abort);
      cleanups.add(() => signal.removeEventListener("abort", abort));
    }
    cleanups.add(onExit((code, signal2) => {
      reject(new ExitPromptError7(`User force closed the prompt with ${code} ${signal2}`));
    }));
    const checkCursorPos = () => screen.checkCursorPos();
    rl.input.on("keypress", checkCursorPos);
    cleanups.add(() => rl.input.removeListener("keypress", checkCursorPos));
    return withHooks7(rl, (cycle) => {
      const hooksCleanup = AsyncResource22.bind(() => effectScheduler7.clearAll());
      rl.on("close", hooksCleanup);
      cleanups.add(() => rl.removeListener("close", hooksCleanup));
      cycle(() => {
        try {
          const nextView = view(config, (value) => {
            setImmediate(() => resolve(value));
          });
          if (nextView === undefined) {
            throw new Error(`Prompt functions must return a string.
    at ${callerFilename}`);
          }
          const [content, bottomContent] = typeof nextView === "string" ? [nextView] : nextView;
          screen.render(content, bottomContent);
          effectScheduler7.run();
        } catch (error) {
          reject(error);
        }
      });
      return Object.assign(promise.then((answer) => {
        effectScheduler7.clearAll();
        return answer;
      }, (error) => {
        effectScheduler7.clearAll();
        throw error;
      }).finally(() => {
        cleanups.forEach((cleanup) => cleanup());
        screen.done({ clearContent: Boolean(context.clearPromptOnDone) });
        output.end();
      }).then(() => promise), { cancel });
    });
  };
  return prompt;
}
var import_mute_stream7;
var init_create_prompt7 = __esm(() => {
  import_mute_stream7 = __toESM(require_lib2(), 1);
  init_mjs();
  init_screen_manager7();
  init_promise_polyfill7();
  init_hook_engine7();
  init_errors7();
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/lib/Separator.js
class Separator3 {
  separator = import_yoctocolors_cjs12.default.dim(Array.from({ length: 15 }).join(esm_default13.line));
  type = "separator";
  constructor(separator) {
    if (separator) {
      this.separator = separator;
    }
  }
  static isSeparator(choice) {
    return Boolean(choice && typeof choice === "object" && "type" in choice && choice.type === "separator");
  }
}
var import_yoctocolors_cjs12;
var init_Separator3 = __esm(() => {
  import_yoctocolors_cjs12 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm19();
});

// node_modules/@inquirer/rawlist/node_modules/@inquirer/core/dist/esm/index.js
var init_esm20 = __esm(() => {
  init_errors7();
  init_use_prefix7();
  init_use_state7();
  init_use_memo3();
  init_use_keypress7();
  init_make_theme7();
  init_create_prompt7();
  init_Separator3();
});

// node_modules/@inquirer/rawlist/dist/esm/index.js
function isSelectableChoice(choice) {
  return choice != null && !Separator3.isSeparator(choice);
}
function normalizeChoices3(choices) {
  let index = 0;
  return choices.map((choice) => {
    if (Separator3.isSeparator(choice))
      return choice;
    index += 1;
    if (typeof choice === "string") {
      return {
        value: choice,
        name: choice,
        short: choice,
        key: String(index)
      };
    }
    const name = choice.name ?? String(choice.value);
    return {
      value: choice.value,
      name,
      short: choice.short ?? name,
      key: choice.key ?? String(index)
    };
  });
}
var import_yoctocolors_cjs13, numberRegex, esm_default14;
var init_esm21 = __esm(() => {
  init_esm20();
  import_yoctocolors_cjs13 = __toESM(require_yoctocolors_cjs(), 1);
  numberRegex = /\d+/;
  esm_default14 = createPrompt7((config, done) => {
    const choices = useMemo3(() => normalizeChoices3(config.choices), [config.choices]);
    const [status, setStatus] = useState7("idle");
    const [value, setValue] = useState7("");
    const [errorMsg, setError] = useState7();
    const theme = makeTheme7(config.theme);
    const prefix = usePrefix7({ status, theme });
    useKeypress7((key8, rl) => {
      if (isEnterKey7(key8)) {
        let selectedChoice;
        if (numberRegex.test(value)) {
          const answer = Number.parseInt(value, 10) - 1;
          selectedChoice = choices.filter(isSelectableChoice)[answer];
        } else {
          selectedChoice = choices.find((choice) => isSelectableChoice(choice) && choice.key === value);
        }
        if (isSelectableChoice(selectedChoice)) {
          setValue(selectedChoice.short);
          setStatus("done");
          done(selectedChoice.value);
        } else if (value === "") {
          setError("Please input a value");
        } else {
          setError(`"${import_yoctocolors_cjs13.default.red(value)}" isn't an available option`);
        }
      } else {
        setValue(rl.line);
        setError(undefined);
      }
    });
    const message = theme.style.message(config.message, status);
    if (status === "done") {
      return `${prefix} ${message} ${theme.style.answer(value)}`;
    }
    const choicesStr = choices.map((choice) => {
      if (Separator3.isSeparator(choice)) {
        return ` ${choice.separator}`;
      }
      const line = `  ${choice.key}) ${choice.name}`;
      if (choice.key === value.toLowerCase()) {
        return theme.style.highlight(line);
      }
      return line;
    }).join(`
`);
    let error = "";
    if (errorMsg) {
      error = theme.style.error(errorMsg);
    }
    return [
      `${prefix} ${message} ${value}`,
      [choicesStr, error].filter(Boolean).join(`
`)
    ];
  });
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/key.js
var isEnterKey8 = (key8) => key8.name === "enter" || key8.name === "return";

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/errors.js
var AbortPromptError8, CancelPromptError8, ExitPromptError8, HookError8, ValidationError8;
var init_errors8 = __esm(() => {
  AbortPromptError8 = class AbortPromptError8 extends Error {
    name = "AbortPromptError";
    message = "Prompt was aborted";
    constructor(options) {
      super();
      this.cause = options?.cause;
    }
  };
  CancelPromptError8 = class CancelPromptError8 extends Error {
    name = "CancelPromptError";
    message = "Prompt was canceled";
  };
  ExitPromptError8 = class ExitPromptError8 extends Error {
    name = "ExitPromptError";
  };
  HookError8 = class HookError8 extends Error {
    name = "HookError";
  };
  ValidationError8 = class ValidationError8 extends Error {
    name = "ValidationError";
  };
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/hook-engine.js
import { AsyncLocalStorage as AsyncLocalStorage8, AsyncResource as AsyncResource23 } from "node:async_hooks";
function createStore8(rl) {
  const store = {
    rl,
    hooks: [],
    hooksCleanup: [],
    hooksEffect: [],
    index: 0,
    handleChange() {
    }
  };
  return store;
}
function withHooks8(rl, cb) {
  const store = createStore8(rl);
  return hookStorage8.run(store, () => {
    function cycle(render) {
      store.handleChange = () => {
        store.index = 0;
        render();
      };
      store.handleChange();
    }
    return cb(cycle);
  });
}
function getStore8() {
  const store = hookStorage8.getStore();
  if (!store) {
    throw new HookError8("[Inquirer] Hook functions can only be called from within a prompt");
  }
  return store;
}
function readline15() {
  return getStore8().rl;
}
function withUpdates8(fn) {
  const wrapped = (...args) => {
    const store = getStore8();
    let shouldUpdate = false;
    const oldHandleChange = store.handleChange;
    store.handleChange = () => {
      shouldUpdate = true;
    };
    const returnValue = fn(...args);
    if (shouldUpdate) {
      oldHandleChange();
    }
    store.handleChange = oldHandleChange;
    return returnValue;
  };
  return AsyncResource23.bind(wrapped);
}
function withPointer8(cb) {
  const store = getStore8();
  const { index } = store;
  const pointer = {
    get() {
      return store.hooks[index];
    },
    set(value) {
      store.hooks[index] = value;
    },
    initialized: index in store.hooks
  };
  const returnValue = cb(pointer);
  store.index++;
  return returnValue;
}
function handleChange8() {
  getStore8().handleChange();
}
var hookStorage8, effectScheduler8;
var init_hook_engine8 = __esm(() => {
  init_errors8();
  hookStorage8 = new AsyncLocalStorage8;
  effectScheduler8 = {
    queue(cb) {
      const store = getStore8();
      const { index } = store;
      store.hooksEffect.push(() => {
        store.hooksCleanup[index]?.();
        const cleanFn = cb(readline15());
        if (cleanFn != null && typeof cleanFn !== "function") {
          throw new ValidationError8("useEffect return value must be a cleanup function or nothing.");
        }
        store.hooksCleanup[index] = cleanFn;
      });
    },
    run() {
      const store = getStore8();
      withUpdates8(() => {
        store.hooksEffect.forEach((effect) => {
          effect();
        });
        store.hooksEffect.length = 0;
      })();
    },
    clearAll() {
      const store = getStore8();
      store.hooksCleanup.forEach((cleanFn) => {
        cleanFn?.();
      });
      store.hooksEffect.length = 0;
      store.hooksCleanup.length = 0;
    }
  };
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/use-state.js
function useState8(defaultValue) {
  return withPointer8((pointer) => {
    const setFn = (newValue) => {
      if (pointer.get() !== newValue) {
        pointer.set(newValue);
        handleChange8();
      }
    };
    if (pointer.initialized) {
      return [pointer.get(), setFn];
    }
    const value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
    pointer.set(value);
    return [value, setFn];
  });
}
var init_use_state8 = __esm(() => {
  init_hook_engine8();
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/use-effect.js
function useEffect8(cb, depArray) {
  withPointer8((pointer) => {
    const oldDeps = pointer.get();
    const hasChanged = !Array.isArray(oldDeps) || depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    if (hasChanged) {
      effectScheduler8.queue(cb);
    }
    pointer.set(depArray);
  });
}
var init_use_effect8 = __esm(() => {
  init_hook_engine8();
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/node_modules/@inquirer/figures/dist/esm/index.js
import process10 from "node:process";
function isUnicodeSupported8() {
  if (process10.platform !== "win32") {
    return process10.env["TERM"] !== "linux";
  }
  return Boolean(process10.env["WT_SESSION"]) || Boolean(process10.env["TERMINUS_SUBLIME"]) || process10.env["ConEmuTask"] === "{cmd::Cmder}" || process10.env["TERM_PROGRAM"] === "Terminus-Sublime" || process10.env["TERM_PROGRAM"] === "vscode" || process10.env["TERM"] === "xterm-256color" || process10.env["TERM"] === "alacritty" || process10.env["TERMINAL_EMULATOR"] === "JetBrains-JediTerm";
}
var common8, specialMainSymbols8, specialFallbackSymbols8, mainSymbols8, fallbackSymbols8, shouldUseMain8, figures8, esm_default15, replacements8;
var init_esm22 = __esm(() => {
  common8 = {
    circleQuestionMark: "(?)",
    questionMarkPrefix: "(?)",
    square: "",
    squareDarkShade: "",
    squareMediumShade: "",
    squareLightShade: "",
    squareTop: "",
    squareBottom: "",
    squareLeft: "",
    squareRight: "",
    squareCenter: "",
    bullet: "",
    dot: "",
    ellipsis: "",
    pointerSmall: "",
    triangleUp: "",
    triangleUpSmall: "",
    triangleDown: "",
    triangleDownSmall: "",
    triangleLeftSmall: "",
    triangleRightSmall: "",
    home: "",
    heart: "",
    musicNote: "",
    musicNoteBeamed: "",
    arrowUp: "",
    arrowDown: "",
    arrowLeft: "",
    arrowRight: "",
    arrowLeftRight: "",
    arrowUpDown: "",
    almostEqual: "",
    notEqual: "",
    lessOrEqual: "",
    greaterOrEqual: "",
    identical: "",
    infinity: "",
    subscriptZero: "",
    subscriptOne: "",
    subscriptTwo: "",
    subscriptThree: "",
    subscriptFour: "",
    subscriptFive: "",
    subscriptSix: "",
    subscriptSeven: "",
    subscriptEight: "",
    subscriptNine: "",
    oneHalf: "",
    oneThird: "",
    oneQuarter: "",
    oneFifth: "",
    oneSixth: "",
    oneEighth: "",
    twoThirds: "",
    twoFifths: "",
    threeQuarters: "",
    threeFifths: "",
    threeEighths: "",
    fourFifths: "",
    fiveSixths: "",
    fiveEighths: "",
    sevenEighths: "",
    line: "",
    lineBold: "",
    lineDouble: "",
    lineDashed0: "",
    lineDashed1: "",
    lineDashed2: "",
    lineDashed3: "",
    lineDashed4: "",
    lineDashed5: "",
    lineDashed6: "",
    lineDashed7: "",
    lineDashed8: "",
    lineDashed9: "",
    lineDashed10: "",
    lineDashed11: "",
    lineDashed12: "",
    lineDashed13: "",
    lineDashed14: "",
    lineDashed15: "",
    lineVertical: "",
    lineVerticalBold: "",
    lineVerticalDouble: "",
    lineVerticalDashed0: "",
    lineVerticalDashed1: "",
    lineVerticalDashed2: "",
    lineVerticalDashed3: "",
    lineVerticalDashed4: "",
    lineVerticalDashed5: "",
    lineVerticalDashed6: "",
    lineVerticalDashed7: "",
    lineVerticalDashed8: "",
    lineVerticalDashed9: "",
    lineVerticalDashed10: "",
    lineVerticalDashed11: "",
    lineDownLeft: "",
    lineDownLeftArc: "",
    lineDownBoldLeftBold: "",
    lineDownBoldLeft: "",
    lineDownLeftBold: "",
    lineDownDoubleLeftDouble: "",
    lineDownDoubleLeft: "",
    lineDownLeftDouble: "",
    lineDownRight: "",
    lineDownRightArc: "",
    lineDownBoldRightBold: "",
    lineDownBoldRight: "",
    lineDownRightBold: "",
    lineDownDoubleRightDouble: "",
    lineDownDoubleRight: "",
    lineDownRightDouble: "",
    lineUpLeft: "",
    lineUpLeftArc: "",
    lineUpBoldLeftBold: "",
    lineUpBoldLeft: "",
    lineUpLeftBold: "",
    lineUpDoubleLeftDouble: "",
    lineUpDoubleLeft: "",
    lineUpLeftDouble: "",
    lineUpRight: "",
    lineUpRightArc: "",
    lineUpBoldRightBold: "",
    lineUpBoldRight: "",
    lineUpRightBold: "",
    lineUpDoubleRightDouble: "",
    lineUpDoubleRight: "",
    lineUpRightDouble: "",
    lineUpDownLeft: "",
    lineUpBoldDownBoldLeftBold: "",
    lineUpBoldDownBoldLeft: "",
    lineUpDownLeftBold: "",
    lineUpBoldDownLeftBold: "",
    lineUpDownBoldLeftBold: "",
    lineUpDownBoldLeft: "",
    lineUpBoldDownLeft: "",
    lineUpDoubleDownDoubleLeftDouble: "",
    lineUpDoubleDownDoubleLeft: "",
    lineUpDownLeftDouble: "",
    lineUpDownRight: "",
    lineUpBoldDownBoldRightBold: "",
    lineUpBoldDownBoldRight: "",
    lineUpDownRightBold: "",
    lineUpBoldDownRightBold: "",
    lineUpDownBoldRightBold: "",
    lineUpDownBoldRight: "",
    lineUpBoldDownRight: "",
    lineUpDoubleDownDoubleRightDouble: "",
    lineUpDoubleDownDoubleRight: "",
    lineUpDownRightDouble: "",
    lineDownLeftRight: "",
    lineDownBoldLeftBoldRightBold: "",
    lineDownLeftBoldRightBold: "",
    lineDownBoldLeftRight: "",
    lineDownBoldLeftBoldRight: "",
    lineDownBoldLeftRightBold: "",
    lineDownLeftRightBold: "",
    lineDownLeftBoldRight: "",
    lineDownDoubleLeftDoubleRightDouble: "",
    lineDownDoubleLeftRight: "",
    lineDownLeftDoubleRightDouble: "",
    lineUpLeftRight: "",
    lineUpBoldLeftBoldRightBold: "",
    lineUpLeftBoldRightBold: "",
    lineUpBoldLeftRight: "",
    lineUpBoldLeftBoldRight: "",
    lineUpBoldLeftRightBold: "",
    lineUpLeftRightBold: "",
    lineUpLeftBoldRight: "",
    lineUpDoubleLeftDoubleRightDouble: "",
    lineUpDoubleLeftRight: "",
    lineUpLeftDoubleRightDouble: "",
    lineUpDownLeftRight: "",
    lineUpBoldDownBoldLeftBoldRightBold: "",
    lineUpDownBoldLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRightBold: "",
    lineUpBoldDownBoldLeftRightBold: "",
    lineUpBoldDownBoldLeftBoldRight: "",
    lineUpBoldDownLeftRight: "",
    lineUpDownBoldLeftRight: "",
    lineUpDownLeftBoldRight: "",
    lineUpDownLeftRightBold: "",
    lineUpBoldDownBoldLeftRight: "",
    lineUpDownLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRight: "",
    lineUpBoldDownLeftRightBold: "",
    lineUpDownBoldLeftBoldRight: "",
    lineUpDownBoldLeftRightBold: "",
    lineUpDoubleDownDoubleLeftDoubleRightDouble: "",
    lineUpDoubleDownDoubleLeftRight: "",
    lineUpDownLeftDoubleRightDouble: "",
    lineCross: "",
    lineBackslash: "",
    lineSlash: ""
  };
  specialMainSymbols8 = {
    tick: "",
    info: "",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "",
    circleFilled: "",
    circleDotted: "",
    circleDouble: "",
    circleCircle: "",
    circleCross: "",
    circlePipe: "",
    radioOn: "",
    radioOff: "",
    checkboxOn: "",
    checkboxOff: "",
    checkboxCircleOn: "",
    checkboxCircleOff: "",
    pointer: "",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "",
    oneNinth: "",
    oneTenth: ""
  };
  specialFallbackSymbols8 = {
    tick: "",
    info: "i",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "( )",
    circleFilled: "(*)",
    circleDotted: "( )",
    circleDouble: "( )",
    circleCircle: "()",
    circleCross: "()",
    circlePipe: "()",
    radioOn: "(*)",
    radioOff: "( )",
    checkboxOn: "[]",
    checkboxOff: "[ ]",
    checkboxCircleOn: "()",
    checkboxCircleOff: "( )",
    pointer: ">",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "1/7",
    oneNinth: "1/9",
    oneTenth: "1/10"
  };
  mainSymbols8 = { ...common8, ...specialMainSymbols8 };
  fallbackSymbols8 = {
    ...common8,
    ...specialFallbackSymbols8
  };
  shouldUseMain8 = isUnicodeSupported8();
  figures8 = shouldUseMain8 ? mainSymbols8 : fallbackSymbols8;
  esm_default15 = figures8;
  replacements8 = Object.entries(specialMainSymbols8);
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/theme.js
var import_yoctocolors_cjs14, defaultTheme8;
var init_theme8 = __esm(() => {
  import_yoctocolors_cjs14 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm22();
  defaultTheme8 = {
    prefix: {
      idle: import_yoctocolors_cjs14.default.blue("?"),
      done: import_yoctocolors_cjs14.default.green(esm_default15.tick)
    },
    spinner: {
      interval: 80,
      frames: ["", "", "", "", "", "", "", "", "", ""].map((frame) => import_yoctocolors_cjs14.default.yellow(frame))
    },
    style: {
      answer: import_yoctocolors_cjs14.default.cyan,
      message: import_yoctocolors_cjs14.default.bold,
      error: (text) => import_yoctocolors_cjs14.default.red(`> ${text}`),
      defaultAnswer: (text) => import_yoctocolors_cjs14.default.dim(`(${text})`),
      help: import_yoctocolors_cjs14.default.dim,
      highlight: import_yoctocolors_cjs14.default.cyan,
      key: (text) => import_yoctocolors_cjs14.default.cyan(import_yoctocolors_cjs14.default.bold(`<${text}>`))
    }
  };
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/make-theme.js
function isPlainObject8(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function deepMerge8(...objects) {
  const output = {};
  for (const obj of objects) {
    for (const [key8, value] of Object.entries(obj)) {
      const prevValue = output[key8];
      output[key8] = isPlainObject8(prevValue) && isPlainObject8(value) ? deepMerge8(prevValue, value) : value;
    }
  }
  return output;
}
function makeTheme8(...themes) {
  const themesToMerge = [
    defaultTheme8,
    ...themes.filter((theme) => theme != null)
  ];
  return deepMerge8(...themesToMerge);
}
var init_make_theme8 = __esm(() => {
  init_theme8();
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/use-prefix.js
import { AsyncResource as AsyncResource24 } from "node:async_hooks";
function usePrefix8({ status = "idle", theme }) {
  const [showLoader, setShowLoader] = useState8(false);
  const [tick, setTick] = useState8(0);
  const { prefix, spinner } = makeTheme8(theme);
  useEffect8(() => {
    if (status === "loading") {
      let tickInterval;
      let inc = -1;
      const delayTimeout = setTimeout(AsyncResource24.bind(() => {
        setShowLoader(true);
        tickInterval = setInterval(AsyncResource24.bind(() => {
          inc = inc + 1;
          setTick(inc % spinner.frames.length);
        }), spinner.interval);
      }), 300);
      return () => {
        clearTimeout(delayTimeout);
        clearInterval(tickInterval);
      };
    } else {
      setShowLoader(false);
    }
  }, [status]);
  if (showLoader) {
    return spinner.frames[tick];
  }
  const iconName = status === "loading" ? "idle" : status;
  return typeof prefix === "string" ? prefix : prefix[iconName] ?? prefix["idle"];
}
var init_use_prefix8 = __esm(() => {
  init_use_state8();
  init_use_effect8();
  init_make_theme8();
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/use-ref.js
function useRef8(val) {
  return useState8({ current: val })[0];
}
var init_use_ref8 = __esm(() => {
  init_use_state8();
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/use-keypress.js
function useKeypress8(userHandler) {
  const signal = useRef8(userHandler);
  signal.current = userHandler;
  useEffect8((rl) => {
    let ignore = false;
    const handler = withUpdates8((_input, event) => {
      if (ignore)
        return;
      signal.current(event, rl);
    });
    rl.input.on("keypress", handler);
    return () => {
      ignore = true;
      rl.input.removeListener("keypress", handler);
    };
  }, []);
}
var init_use_keypress8 = __esm(() => {
  init_use_ref8();
  init_use_effect8();
  init_hook_engine8();
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/utils.js
function breakLines8(content, width) {
  return content.split(`
`).flatMap((line) => import_wrap_ansi8.default(line, width, { trim: false, hard: true }).split(`
`).map((str) => str.trimEnd())).join(`
`);
}
function readlineWidth8() {
  return import_cli_width8.default({ defaultWidth: 80, output: readline15().output });
}
var import_cli_width8, import_wrap_ansi8;
var init_utils8 = __esm(() => {
  import_cli_width8 = __toESM(require_cli_width(), 1);
  import_wrap_ansi8 = __toESM(require_wrap_ansi(), 1);
  init_hook_engine8();
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/node_modules/strip-ansi/node_modules/ansi-regex/index.js
var require_ansi_regex9 = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/node_modules/strip-ansi/index.js
var require_strip_ansi9 = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex9();
  module.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/screen-manager.js
function cursorDown8(n) {
  return n > 0 ? import_ansi_escapes9.default.cursorDown(n) : "";
}

class ScreenManager8 {
  rl;
  height = 0;
  extraLinesUnderPrompt = 0;
  cursorPos;
  constructor(rl) {
    this.rl = rl;
    this.rl = rl;
    this.cursorPos = rl.getCursorPos();
  }
  write(content) {
    this.rl.output.unmute();
    this.rl.output.write(content);
    this.rl.output.mute();
  }
  render(content, bottomContent = "") {
    const promptLine = lastLine8(content);
    const rawPromptLine = import_strip_ansi8.default(promptLine);
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }
    this.rl.setPrompt(prompt);
    this.cursorPos = this.rl.getCursorPos();
    const width = readlineWidth8();
    content = breakLines8(content, width);
    bottomContent = breakLines8(bottomContent, width);
    if (rawPromptLine.length % width === 0) {
      content += `
`;
    }
    let output = content + (bottomContent ? `
` + bottomContent : "");
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - this.cursorPos.rows;
    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height8(bottomContent) : 0);
    if (bottomContentHeight > 0)
      output += import_ansi_escapes9.default.cursorUp(bottomContentHeight);
    output += import_ansi_escapes9.default.cursorTo(this.cursorPos.cols);
    this.write(cursorDown8(this.extraLinesUnderPrompt) + import_ansi_escapes9.default.eraseLines(this.height) + output);
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height8(output);
  }
  checkCursorPos() {
    const cursorPos = this.rl.getCursorPos();
    if (cursorPos.cols !== this.cursorPos.cols) {
      this.write(import_ansi_escapes9.default.cursorTo(cursorPos.cols));
      this.cursorPos = cursorPos;
    }
  }
  done({ clearContent }) {
    this.rl.setPrompt("");
    let output = cursorDown8(this.extraLinesUnderPrompt);
    output += clearContent ? import_ansi_escapes9.default.eraseLines(this.height) : `
`;
    output += import_ansi_escapes9.default.cursorShow;
    this.write(output);
    this.rl.close();
  }
}
var import_strip_ansi8, import_ansi_escapes9, height8 = (content) => content.split(`
`).length, lastLine8 = (content) => content.split(`
`).pop() ?? "";
var init_screen_manager8 = __esm(() => {
  import_strip_ansi8 = __toESM(require_strip_ansi9(), 1);
  import_ansi_escapes9 = __toESM(require_ansi_escapes(), 1);
  init_utils8();
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/promise-polyfill.js
var PromisePolyfill8;
var init_promise_polyfill8 = __esm(() => {
  PromisePolyfill8 = class PromisePolyfill8 extends Promise {
    static withResolver() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return { promise, resolve, reject };
    }
  };
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/lib/create-prompt.js
import * as readline16 from "node:readline";
import { AsyncResource as AsyncResource25 } from "node:async_hooks";
function getCallSites8() {
  const _prepareStackTrace = Error.prepareStackTrace;
  try {
    let result = [];
    Error.prepareStackTrace = (_2, callSites) => {
      const callSitesWithoutCurrent = callSites.slice(1);
      result = callSitesWithoutCurrent;
      return callSitesWithoutCurrent;
    };
    new Error().stack;
    return result;
  } finally {
    Error.prepareStackTrace = _prepareStackTrace;
  }
}
function createPrompt8(view) {
  const callSites = getCallSites8();
  const callerFilename = callSites[1]?.getFileName?.();
  const prompt = (config, context = {}) => {
    const { input = process.stdin, signal } = context;
    const cleanups = new Set;
    const output = new import_mute_stream8.default;
    output.pipe(context.output ?? process.stdout);
    const rl = readline16.createInterface({
      terminal: true,
      input,
      output
    });
    const screen = new ScreenManager8(rl);
    const { promise, resolve, reject } = PromisePolyfill8.withResolver();
    const cancel = () => reject(new CancelPromptError8);
    if (signal) {
      const abort = () => reject(new AbortPromptError8({ cause: signal.reason }));
      if (signal.aborted) {
        abort();
        return Object.assign(promise, { cancel });
      }
      signal.addEventListener("abort", abort);
      cleanups.add(() => signal.removeEventListener("abort", abort));
    }
    cleanups.add(onExit((code, signal2) => {
      reject(new ExitPromptError8(`User force closed the prompt with ${code} ${signal2}`));
    }));
    const checkCursorPos = () => screen.checkCursorPos();
    rl.input.on("keypress", checkCursorPos);
    cleanups.add(() => rl.input.removeListener("keypress", checkCursorPos));
    return withHooks8(rl, (cycle) => {
      const hooksCleanup = AsyncResource25.bind(() => effectScheduler8.clearAll());
      rl.on("close", hooksCleanup);
      cleanups.add(() => rl.removeListener("close", hooksCleanup));
      cycle(() => {
        try {
          const nextView = view(config, (value) => {
            setImmediate(() => resolve(value));
          });
          if (nextView === undefined) {
            throw new Error(`Prompt functions must return a string.
    at ${callerFilename}`);
          }
          const [content, bottomContent] = typeof nextView === "string" ? [nextView] : nextView;
          screen.render(content, bottomContent);
          effectScheduler8.run();
        } catch (error) {
          reject(error);
        }
      });
      return Object.assign(promise.then((answer) => {
        effectScheduler8.clearAll();
        return answer;
      }, (error) => {
        effectScheduler8.clearAll();
        throw error;
      }).finally(() => {
        cleanups.forEach((cleanup) => cleanup());
        screen.done({ clearContent: Boolean(context.clearPromptOnDone) });
        output.end();
      }).then(() => promise), { cancel });
    });
  };
  return prompt;
}
var import_mute_stream8;
var init_create_prompt8 = __esm(() => {
  import_mute_stream8 = __toESM(require_lib2(), 1);
  init_mjs();
  init_screen_manager8();
  init_promise_polyfill8();
  init_hook_engine8();
  init_errors8();
});

// node_modules/@inquirer/password/node_modules/@inquirer/core/dist/esm/index.js
var init_esm23 = __esm(() => {
  init_errors8();
  init_use_prefix8();
  init_use_state8();
  init_use_keypress8();
  init_make_theme8();
  init_create_prompt8();
});

// node_modules/@inquirer/password/dist/esm/index.js
var import_ansi_escapes10, esm_default16;
var init_esm24 = __esm(() => {
  init_esm23();
  import_ansi_escapes10 = __toESM(require_ansi_escapes(), 1);
  esm_default16 = createPrompt8((config, done) => {
    const { validate = () => true } = config;
    const theme = makeTheme8(config.theme);
    const [status, setStatus] = useState8("idle");
    const [errorMsg, setError] = useState8();
    const [value, setValue] = useState8("");
    const prefix = usePrefix8({ status, theme });
    useKeypress8(async (key9, rl) => {
      if (status !== "idle") {
        return;
      }
      if (isEnterKey8(key9)) {
        const answer = value;
        setStatus("loading");
        const isValid = await validate(answer);
        if (isValid === true) {
          setValue(answer);
          setStatus("done");
          done(answer);
        } else {
          rl.write(value);
          setError(isValid || "You must provide a valid value");
          setStatus("idle");
        }
      } else {
        setValue(rl.line);
        setError(undefined);
      }
    });
    const message = theme.style.message(config.message, status);
    let formattedValue = "";
    let helpTip;
    if (config.mask) {
      const maskChar = typeof config.mask === "string" ? config.mask : "*";
      formattedValue = maskChar.repeat(value.length);
    } else if (status !== "done") {
      helpTip = `${theme.style.help("[input is masked]")}${import_ansi_escapes10.default.cursorHide}`;
    }
    if (status === "done") {
      formattedValue = theme.style.answer(formattedValue);
    }
    let error = "";
    if (errorMsg) {
      error = theme.style.error(errorMsg);
    }
    return [[prefix, message, config.mask ? formattedValue : helpTip].join(" "), error];
  });
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/key.js
var isEnterKey9 = (key9) => key9.name === "enter" || key9.name === "return";

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/errors.js
var AbortPromptError9, CancelPromptError9, ExitPromptError9, HookError9, ValidationError9;
var init_errors9 = __esm(() => {
  AbortPromptError9 = class AbortPromptError9 extends Error {
    name = "AbortPromptError";
    message = "Prompt was aborted";
    constructor(options) {
      super();
      this.cause = options?.cause;
    }
  };
  CancelPromptError9 = class CancelPromptError9 extends Error {
    name = "CancelPromptError";
    message = "Prompt was canceled";
  };
  ExitPromptError9 = class ExitPromptError9 extends Error {
    name = "ExitPromptError";
  };
  HookError9 = class HookError9 extends Error {
    name = "HookError";
  };
  ValidationError9 = class ValidationError9 extends Error {
    name = "ValidationError";
  };
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/hook-engine.js
import { AsyncLocalStorage as AsyncLocalStorage9, AsyncResource as AsyncResource26 } from "node:async_hooks";
function createStore9(rl) {
  const store = {
    rl,
    hooks: [],
    hooksCleanup: [],
    hooksEffect: [],
    index: 0,
    handleChange() {
    }
  };
  return store;
}
function withHooks9(rl, cb) {
  const store = createStore9(rl);
  return hookStorage9.run(store, () => {
    function cycle(render) {
      store.handleChange = () => {
        store.index = 0;
        render();
      };
      store.handleChange();
    }
    return cb(cycle);
  });
}
function getStore9() {
  const store = hookStorage9.getStore();
  if (!store) {
    throw new HookError9("[Inquirer] Hook functions can only be called from within a prompt");
  }
  return store;
}
function readline17() {
  return getStore9().rl;
}
function withUpdates9(fn) {
  const wrapped = (...args) => {
    const store = getStore9();
    let shouldUpdate = false;
    const oldHandleChange = store.handleChange;
    store.handleChange = () => {
      shouldUpdate = true;
    };
    const returnValue = fn(...args);
    if (shouldUpdate) {
      oldHandleChange();
    }
    store.handleChange = oldHandleChange;
    return returnValue;
  };
  return AsyncResource26.bind(wrapped);
}
function withPointer9(cb) {
  const store = getStore9();
  const { index } = store;
  const pointer = {
    get() {
      return store.hooks[index];
    },
    set(value) {
      store.hooks[index] = value;
    },
    initialized: index in store.hooks
  };
  const returnValue = cb(pointer);
  store.index++;
  return returnValue;
}
function handleChange9() {
  getStore9().handleChange();
}
var hookStorage9, effectScheduler9;
var init_hook_engine9 = __esm(() => {
  init_errors9();
  hookStorage9 = new AsyncLocalStorage9;
  effectScheduler9 = {
    queue(cb) {
      const store = getStore9();
      const { index } = store;
      store.hooksEffect.push(() => {
        store.hooksCleanup[index]?.();
        const cleanFn = cb(readline17());
        if (cleanFn != null && typeof cleanFn !== "function") {
          throw new ValidationError9("useEffect return value must be a cleanup function or nothing.");
        }
        store.hooksCleanup[index] = cleanFn;
      });
    },
    run() {
      const store = getStore9();
      withUpdates9(() => {
        store.hooksEffect.forEach((effect) => {
          effect();
        });
        store.hooksEffect.length = 0;
      })();
    },
    clearAll() {
      const store = getStore9();
      store.hooksCleanup.forEach((cleanFn) => {
        cleanFn?.();
      });
      store.hooksEffect.length = 0;
      store.hooksCleanup.length = 0;
    }
  };
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/use-state.js
function useState9(defaultValue) {
  return withPointer9((pointer) => {
    const setFn = (newValue) => {
      if (pointer.get() !== newValue) {
        pointer.set(newValue);
        handleChange9();
      }
    };
    if (pointer.initialized) {
      return [pointer.get(), setFn];
    }
    const value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
    pointer.set(value);
    return [value, setFn];
  });
}
var init_use_state9 = __esm(() => {
  init_hook_engine9();
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/use-effect.js
function useEffect9(cb, depArray) {
  withPointer9((pointer) => {
    const oldDeps = pointer.get();
    const hasChanged = !Array.isArray(oldDeps) || depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    if (hasChanged) {
      effectScheduler9.queue(cb);
    }
    pointer.set(depArray);
  });
}
var init_use_effect9 = __esm(() => {
  init_hook_engine9();
});

// node_modules/@inquirer/search/node_modules/@inquirer/figures/dist/esm/index.js
import process11 from "node:process";
function isUnicodeSupported9() {
  if (process11.platform !== "win32") {
    return process11.env["TERM"] !== "linux";
  }
  return Boolean(process11.env["WT_SESSION"]) || Boolean(process11.env["TERMINUS_SUBLIME"]) || process11.env["ConEmuTask"] === "{cmd::Cmder}" || process11.env["TERM_PROGRAM"] === "Terminus-Sublime" || process11.env["TERM_PROGRAM"] === "vscode" || process11.env["TERM"] === "xterm-256color" || process11.env["TERM"] === "alacritty" || process11.env["TERMINAL_EMULATOR"] === "JetBrains-JediTerm";
}
var common9, specialMainSymbols9, specialFallbackSymbols9, mainSymbols9, fallbackSymbols9, shouldUseMain9, figures9, esm_default17, replacements9;
var init_esm25 = __esm(() => {
  common9 = {
    circleQuestionMark: "(?)",
    questionMarkPrefix: "(?)",
    square: "",
    squareDarkShade: "",
    squareMediumShade: "",
    squareLightShade: "",
    squareTop: "",
    squareBottom: "",
    squareLeft: "",
    squareRight: "",
    squareCenter: "",
    bullet: "",
    dot: "",
    ellipsis: "",
    pointerSmall: "",
    triangleUp: "",
    triangleUpSmall: "",
    triangleDown: "",
    triangleDownSmall: "",
    triangleLeftSmall: "",
    triangleRightSmall: "",
    home: "",
    heart: "",
    musicNote: "",
    musicNoteBeamed: "",
    arrowUp: "",
    arrowDown: "",
    arrowLeft: "",
    arrowRight: "",
    arrowLeftRight: "",
    arrowUpDown: "",
    almostEqual: "",
    notEqual: "",
    lessOrEqual: "",
    greaterOrEqual: "",
    identical: "",
    infinity: "",
    subscriptZero: "",
    subscriptOne: "",
    subscriptTwo: "",
    subscriptThree: "",
    subscriptFour: "",
    subscriptFive: "",
    subscriptSix: "",
    subscriptSeven: "",
    subscriptEight: "",
    subscriptNine: "",
    oneHalf: "",
    oneThird: "",
    oneQuarter: "",
    oneFifth: "",
    oneSixth: "",
    oneEighth: "",
    twoThirds: "",
    twoFifths: "",
    threeQuarters: "",
    threeFifths: "",
    threeEighths: "",
    fourFifths: "",
    fiveSixths: "",
    fiveEighths: "",
    sevenEighths: "",
    line: "",
    lineBold: "",
    lineDouble: "",
    lineDashed0: "",
    lineDashed1: "",
    lineDashed2: "",
    lineDashed3: "",
    lineDashed4: "",
    lineDashed5: "",
    lineDashed6: "",
    lineDashed7: "",
    lineDashed8: "",
    lineDashed9: "",
    lineDashed10: "",
    lineDashed11: "",
    lineDashed12: "",
    lineDashed13: "",
    lineDashed14: "",
    lineDashed15: "",
    lineVertical: "",
    lineVerticalBold: "",
    lineVerticalDouble: "",
    lineVerticalDashed0: "",
    lineVerticalDashed1: "",
    lineVerticalDashed2: "",
    lineVerticalDashed3: "",
    lineVerticalDashed4: "",
    lineVerticalDashed5: "",
    lineVerticalDashed6: "",
    lineVerticalDashed7: "",
    lineVerticalDashed8: "",
    lineVerticalDashed9: "",
    lineVerticalDashed10: "",
    lineVerticalDashed11: "",
    lineDownLeft: "",
    lineDownLeftArc: "",
    lineDownBoldLeftBold: "",
    lineDownBoldLeft: "",
    lineDownLeftBold: "",
    lineDownDoubleLeftDouble: "",
    lineDownDoubleLeft: "",
    lineDownLeftDouble: "",
    lineDownRight: "",
    lineDownRightArc: "",
    lineDownBoldRightBold: "",
    lineDownBoldRight: "",
    lineDownRightBold: "",
    lineDownDoubleRightDouble: "",
    lineDownDoubleRight: "",
    lineDownRightDouble: "",
    lineUpLeft: "",
    lineUpLeftArc: "",
    lineUpBoldLeftBold: "",
    lineUpBoldLeft: "",
    lineUpLeftBold: "",
    lineUpDoubleLeftDouble: "",
    lineUpDoubleLeft: "",
    lineUpLeftDouble: "",
    lineUpRight: "",
    lineUpRightArc: "",
    lineUpBoldRightBold: "",
    lineUpBoldRight: "",
    lineUpRightBold: "",
    lineUpDoubleRightDouble: "",
    lineUpDoubleRight: "",
    lineUpRightDouble: "",
    lineUpDownLeft: "",
    lineUpBoldDownBoldLeftBold: "",
    lineUpBoldDownBoldLeft: "",
    lineUpDownLeftBold: "",
    lineUpBoldDownLeftBold: "",
    lineUpDownBoldLeftBold: "",
    lineUpDownBoldLeft: "",
    lineUpBoldDownLeft: "",
    lineUpDoubleDownDoubleLeftDouble: "",
    lineUpDoubleDownDoubleLeft: "",
    lineUpDownLeftDouble: "",
    lineUpDownRight: "",
    lineUpBoldDownBoldRightBold: "",
    lineUpBoldDownBoldRight: "",
    lineUpDownRightBold: "",
    lineUpBoldDownRightBold: "",
    lineUpDownBoldRightBold: "",
    lineUpDownBoldRight: "",
    lineUpBoldDownRight: "",
    lineUpDoubleDownDoubleRightDouble: "",
    lineUpDoubleDownDoubleRight: "",
    lineUpDownRightDouble: "",
    lineDownLeftRight: "",
    lineDownBoldLeftBoldRightBold: "",
    lineDownLeftBoldRightBold: "",
    lineDownBoldLeftRight: "",
    lineDownBoldLeftBoldRight: "",
    lineDownBoldLeftRightBold: "",
    lineDownLeftRightBold: "",
    lineDownLeftBoldRight: "",
    lineDownDoubleLeftDoubleRightDouble: "",
    lineDownDoubleLeftRight: "",
    lineDownLeftDoubleRightDouble: "",
    lineUpLeftRight: "",
    lineUpBoldLeftBoldRightBold: "",
    lineUpLeftBoldRightBold: "",
    lineUpBoldLeftRight: "",
    lineUpBoldLeftBoldRight: "",
    lineUpBoldLeftRightBold: "",
    lineUpLeftRightBold: "",
    lineUpLeftBoldRight: "",
    lineUpDoubleLeftDoubleRightDouble: "",
    lineUpDoubleLeftRight: "",
    lineUpLeftDoubleRightDouble: "",
    lineUpDownLeftRight: "",
    lineUpBoldDownBoldLeftBoldRightBold: "",
    lineUpDownBoldLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRightBold: "",
    lineUpBoldDownBoldLeftRightBold: "",
    lineUpBoldDownBoldLeftBoldRight: "",
    lineUpBoldDownLeftRight: "",
    lineUpDownBoldLeftRight: "",
    lineUpDownLeftBoldRight: "",
    lineUpDownLeftRightBold: "",
    lineUpBoldDownBoldLeftRight: "",
    lineUpDownLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRight: "",
    lineUpBoldDownLeftRightBold: "",
    lineUpDownBoldLeftBoldRight: "",
    lineUpDownBoldLeftRightBold: "",
    lineUpDoubleDownDoubleLeftDoubleRightDouble: "",
    lineUpDoubleDownDoubleLeftRight: "",
    lineUpDownLeftDoubleRightDouble: "",
    lineCross: "",
    lineBackslash: "",
    lineSlash: ""
  };
  specialMainSymbols9 = {
    tick: "",
    info: "",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "",
    circleFilled: "",
    circleDotted: "",
    circleDouble: "",
    circleCircle: "",
    circleCross: "",
    circlePipe: "",
    radioOn: "",
    radioOff: "",
    checkboxOn: "",
    checkboxOff: "",
    checkboxCircleOn: "",
    checkboxCircleOff: "",
    pointer: "",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "",
    oneNinth: "",
    oneTenth: ""
  };
  specialFallbackSymbols9 = {
    tick: "",
    info: "i",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "( )",
    circleFilled: "(*)",
    circleDotted: "( )",
    circleDouble: "( )",
    circleCircle: "()",
    circleCross: "()",
    circlePipe: "()",
    radioOn: "(*)",
    radioOff: "( )",
    checkboxOn: "[]",
    checkboxOff: "[ ]",
    checkboxCircleOn: "()",
    checkboxCircleOff: "( )",
    pointer: ">",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "1/7",
    oneNinth: "1/9",
    oneTenth: "1/10"
  };
  mainSymbols9 = { ...common9, ...specialMainSymbols9 };
  fallbackSymbols9 = {
    ...common9,
    ...specialFallbackSymbols9
  };
  shouldUseMain9 = isUnicodeSupported9();
  figures9 = shouldUseMain9 ? mainSymbols9 : fallbackSymbols9;
  esm_default17 = figures9;
  replacements9 = Object.entries(specialMainSymbols9);
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/theme.js
var import_yoctocolors_cjs15, defaultTheme9;
var init_theme9 = __esm(() => {
  import_yoctocolors_cjs15 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm25();
  defaultTheme9 = {
    prefix: {
      idle: import_yoctocolors_cjs15.default.blue("?"),
      done: import_yoctocolors_cjs15.default.green(esm_default17.tick)
    },
    spinner: {
      interval: 80,
      frames: ["", "", "", "", "", "", "", "", "", ""].map((frame) => import_yoctocolors_cjs15.default.yellow(frame))
    },
    style: {
      answer: import_yoctocolors_cjs15.default.cyan,
      message: import_yoctocolors_cjs15.default.bold,
      error: (text) => import_yoctocolors_cjs15.default.red(`> ${text}`),
      defaultAnswer: (text) => import_yoctocolors_cjs15.default.dim(`(${text})`),
      help: import_yoctocolors_cjs15.default.dim,
      highlight: import_yoctocolors_cjs15.default.cyan,
      key: (text) => import_yoctocolors_cjs15.default.cyan(import_yoctocolors_cjs15.default.bold(`<${text}>`))
    }
  };
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/make-theme.js
function isPlainObject9(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function deepMerge9(...objects) {
  const output = {};
  for (const obj of objects) {
    for (const [key9, value] of Object.entries(obj)) {
      const prevValue = output[key9];
      output[key9] = isPlainObject9(prevValue) && isPlainObject9(value) ? deepMerge9(prevValue, value) : value;
    }
  }
  return output;
}
function makeTheme9(...themes) {
  const themesToMerge = [
    defaultTheme9,
    ...themes.filter((theme) => theme != null)
  ];
  return deepMerge9(...themesToMerge);
}
var init_make_theme9 = __esm(() => {
  init_theme9();
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/use-prefix.js
import { AsyncResource as AsyncResource27 } from "node:async_hooks";
function usePrefix9({ status = "idle", theme }) {
  const [showLoader, setShowLoader] = useState9(false);
  const [tick, setTick] = useState9(0);
  const { prefix, spinner } = makeTheme9(theme);
  useEffect9(() => {
    if (status === "loading") {
      let tickInterval;
      let inc = -1;
      const delayTimeout = setTimeout(AsyncResource27.bind(() => {
        setShowLoader(true);
        tickInterval = setInterval(AsyncResource27.bind(() => {
          inc = inc + 1;
          setTick(inc % spinner.frames.length);
        }), spinner.interval);
      }), 300);
      return () => {
        clearTimeout(delayTimeout);
        clearInterval(tickInterval);
      };
    } else {
      setShowLoader(false);
    }
  }, [status]);
  if (showLoader) {
    return spinner.frames[tick];
  }
  const iconName = status === "loading" ? "idle" : status;
  return typeof prefix === "string" ? prefix : prefix[iconName] ?? prefix["idle"];
}
var init_use_prefix9 = __esm(() => {
  init_use_state9();
  init_use_effect9();
  init_make_theme9();
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/use-memo.js
function useMemo4(fn, dependencies) {
  return withPointer9((pointer) => {
    const prev = pointer.get();
    if (!prev || prev.dependencies.length !== dependencies.length || prev.dependencies.some((dep, i) => dep !== dependencies[i])) {
      const value = fn();
      pointer.set({ value, dependencies });
      return value;
    }
    return prev.value;
  });
}
var init_use_memo4 = __esm(() => {
  init_hook_engine9();
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/use-ref.js
function useRef9(val) {
  return useState9({ current: val })[0];
}
var init_use_ref9 = __esm(() => {
  init_use_state9();
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/use-keypress.js
function useKeypress9(userHandler) {
  const signal = useRef9(userHandler);
  signal.current = userHandler;
  useEffect9((rl) => {
    let ignore = false;
    const handler = withUpdates9((_input, event) => {
      if (ignore)
        return;
      signal.current(event, rl);
    });
    rl.input.on("keypress", handler);
    return () => {
      ignore = true;
      rl.input.removeListener("keypress", handler);
    };
  }, []);
}
var init_use_keypress9 = __esm(() => {
  init_use_ref9();
  init_use_effect9();
  init_hook_engine9();
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/utils.js
function breakLines9(content, width) {
  return content.split(`
`).flatMap((line) => import_wrap_ansi9.default(line, width, { trim: false, hard: true }).split(`
`).map((str) => str.trimEnd())).join(`
`);
}
function readlineWidth9() {
  return import_cli_width9.default({ defaultWidth: 80, output: readline17().output });
}
var import_cli_width9, import_wrap_ansi9;
var init_utils9 = __esm(() => {
  import_cli_width9 = __toESM(require_cli_width(), 1);
  import_wrap_ansi9 = __toESM(require_wrap_ansi(), 1);
  init_hook_engine9();
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/pagination/lines.js
function split2(content, width) {
  return breakLines9(content, width).split(`
`);
}
function rotate2(count, items) {
  const max = items.length;
  const offset = (count % max + max) % max;
  return [...items.slice(offset), ...items.slice(0, offset)];
}
function lines2({ items, width, renderItem, active, position: requested, pageSize }) {
  const layouts = items.map((item, index) => ({
    item,
    index,
    isActive: index === active
  }));
  const layoutsInPage = rotate2(active - requested, layouts).slice(0, pageSize);
  const renderItemAt = (index) => layoutsInPage[index] == null ? [] : split2(renderItem(layoutsInPage[index]), width);
  const pageBuffer = Array.from({ length: pageSize });
  const activeItem = renderItemAt(requested).slice(0, pageSize);
  const position = requested + activeItem.length <= pageSize ? requested : pageSize - activeItem.length;
  pageBuffer.splice(position, activeItem.length, ...activeItem);
  let bufferPointer = position + activeItem.length;
  let layoutPointer = requested + 1;
  while (bufferPointer < pageSize && layoutPointer < layoutsInPage.length) {
    for (const line of renderItemAt(layoutPointer)) {
      pageBuffer[bufferPointer++] = line;
      if (bufferPointer >= pageSize)
        break;
    }
    layoutPointer++;
  }
  bufferPointer = position - 1;
  layoutPointer = requested - 1;
  while (bufferPointer >= 0 && layoutPointer >= 0) {
    for (const line of renderItemAt(layoutPointer).reverse()) {
      pageBuffer[bufferPointer--] = line;
      if (bufferPointer < 0)
        break;
    }
    layoutPointer--;
  }
  return pageBuffer.filter((line) => typeof line === "string");
}
var init_lines2 = __esm(() => {
  init_utils9();
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/pagination/position.js
function finite2({ active, pageSize, total }) {
  const middle = Math.floor(pageSize / 2);
  if (total <= pageSize || active < middle)
    return active;
  if (active >= total - middle)
    return active + pageSize - total;
  return middle;
}
function infinite2({ active, lastActive, total, pageSize, pointer }) {
  if (total <= pageSize)
    return active;
  if (lastActive < active && active - lastActive < pageSize) {
    return Math.min(Math.floor(pageSize / 2), pointer + active - lastActive);
  }
  return pointer;
}

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/pagination/use-pagination.js
function usePagination2({ items, active, renderItem, pageSize, loop = true }) {
  const state = useRef9({ position: 0, lastActive: 0 });
  const position = loop ? infinite2({
    active,
    lastActive: state.current.lastActive,
    total: items.length,
    pageSize,
    pointer: state.current.position
  }) : finite2({
    active,
    total: items.length,
    pageSize
  });
  state.current.position = position;
  state.current.lastActive = active;
  return lines2({
    items,
    width: readlineWidth9(),
    renderItem,
    active,
    position,
    pageSize
  }).join(`
`);
}
var init_use_pagination2 = __esm(() => {
  init_use_ref9();
  init_utils9();
  init_lines2();
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/node_modules/strip-ansi/node_modules/ansi-regex/index.js
var require_ansi_regex10 = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/node_modules/strip-ansi/index.js
var require_strip_ansi10 = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex10();
  module.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/screen-manager.js
function cursorDown9(n) {
  return n > 0 ? import_ansi_escapes11.default.cursorDown(n) : "";
}

class ScreenManager9 {
  rl;
  height = 0;
  extraLinesUnderPrompt = 0;
  cursorPos;
  constructor(rl) {
    this.rl = rl;
    this.rl = rl;
    this.cursorPos = rl.getCursorPos();
  }
  write(content) {
    this.rl.output.unmute();
    this.rl.output.write(content);
    this.rl.output.mute();
  }
  render(content, bottomContent = "") {
    const promptLine = lastLine9(content);
    const rawPromptLine = import_strip_ansi9.default(promptLine);
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }
    this.rl.setPrompt(prompt);
    this.cursorPos = this.rl.getCursorPos();
    const width = readlineWidth9();
    content = breakLines9(content, width);
    bottomContent = breakLines9(bottomContent, width);
    if (rawPromptLine.length % width === 0) {
      content += `
`;
    }
    let output = content + (bottomContent ? `
` + bottomContent : "");
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - this.cursorPos.rows;
    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height9(bottomContent) : 0);
    if (bottomContentHeight > 0)
      output += import_ansi_escapes11.default.cursorUp(bottomContentHeight);
    output += import_ansi_escapes11.default.cursorTo(this.cursorPos.cols);
    this.write(cursorDown9(this.extraLinesUnderPrompt) + import_ansi_escapes11.default.eraseLines(this.height) + output);
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height9(output);
  }
  checkCursorPos() {
    const cursorPos = this.rl.getCursorPos();
    if (cursorPos.cols !== this.cursorPos.cols) {
      this.write(import_ansi_escapes11.default.cursorTo(cursorPos.cols));
      this.cursorPos = cursorPos;
    }
  }
  done({ clearContent }) {
    this.rl.setPrompt("");
    let output = cursorDown9(this.extraLinesUnderPrompt);
    output += clearContent ? import_ansi_escapes11.default.eraseLines(this.height) : `
`;
    output += import_ansi_escapes11.default.cursorShow;
    this.write(output);
    this.rl.close();
  }
}
var import_strip_ansi9, import_ansi_escapes11, height9 = (content) => content.split(`
`).length, lastLine9 = (content) => content.split(`
`).pop() ?? "";
var init_screen_manager9 = __esm(() => {
  import_strip_ansi9 = __toESM(require_strip_ansi10(), 1);
  import_ansi_escapes11 = __toESM(require_ansi_escapes(), 1);
  init_utils9();
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/promise-polyfill.js
var PromisePolyfill9;
var init_promise_polyfill9 = __esm(() => {
  PromisePolyfill9 = class PromisePolyfill9 extends Promise {
    static withResolver() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return { promise, resolve, reject };
    }
  };
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/create-prompt.js
import * as readline18 from "node:readline";
import { AsyncResource as AsyncResource28 } from "node:async_hooks";
function getCallSites9() {
  const _prepareStackTrace = Error.prepareStackTrace;
  try {
    let result = [];
    Error.prepareStackTrace = (_2, callSites) => {
      const callSitesWithoutCurrent = callSites.slice(1);
      result = callSitesWithoutCurrent;
      return callSitesWithoutCurrent;
    };
    new Error().stack;
    return result;
  } finally {
    Error.prepareStackTrace = _prepareStackTrace;
  }
}
function createPrompt9(view) {
  const callSites = getCallSites9();
  const callerFilename = callSites[1]?.getFileName?.();
  const prompt = (config, context = {}) => {
    const { input = process.stdin, signal } = context;
    const cleanups = new Set;
    const output = new import_mute_stream9.default;
    output.pipe(context.output ?? process.stdout);
    const rl = readline18.createInterface({
      terminal: true,
      input,
      output
    });
    const screen = new ScreenManager9(rl);
    const { promise, resolve, reject } = PromisePolyfill9.withResolver();
    const cancel = () => reject(new CancelPromptError9);
    if (signal) {
      const abort = () => reject(new AbortPromptError9({ cause: signal.reason }));
      if (signal.aborted) {
        abort();
        return Object.assign(promise, { cancel });
      }
      signal.addEventListener("abort", abort);
      cleanups.add(() => signal.removeEventListener("abort", abort));
    }
    cleanups.add(onExit((code, signal2) => {
      reject(new ExitPromptError9(`User force closed the prompt with ${code} ${signal2}`));
    }));
    const checkCursorPos = () => screen.checkCursorPos();
    rl.input.on("keypress", checkCursorPos);
    cleanups.add(() => rl.input.removeListener("keypress", checkCursorPos));
    return withHooks9(rl, (cycle) => {
      const hooksCleanup = AsyncResource28.bind(() => effectScheduler9.clearAll());
      rl.on("close", hooksCleanup);
      cleanups.add(() => rl.removeListener("close", hooksCleanup));
      cycle(() => {
        try {
          const nextView = view(config, (value) => {
            setImmediate(() => resolve(value));
          });
          if (nextView === undefined) {
            throw new Error(`Prompt functions must return a string.
    at ${callerFilename}`);
          }
          const [content, bottomContent] = typeof nextView === "string" ? [nextView] : nextView;
          screen.render(content, bottomContent);
          effectScheduler9.run();
        } catch (error) {
          reject(error);
        }
      });
      return Object.assign(promise.then((answer) => {
        effectScheduler9.clearAll();
        return answer;
      }, (error) => {
        effectScheduler9.clearAll();
        throw error;
      }).finally(() => {
        cleanups.forEach((cleanup) => cleanup());
        screen.done({ clearContent: Boolean(context.clearPromptOnDone) });
        output.end();
      }).then(() => promise), { cancel });
    });
  };
  return prompt;
}
var import_mute_stream9;
var init_create_prompt9 = __esm(() => {
  import_mute_stream9 = __toESM(require_lib2(), 1);
  init_mjs();
  init_screen_manager9();
  init_promise_polyfill9();
  init_hook_engine9();
  init_errors9();
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/lib/Separator.js
class Separator4 {
  separator = import_yoctocolors_cjs16.default.dim(Array.from({ length: 15 }).join(esm_default17.line));
  type = "separator";
  constructor(separator) {
    if (separator) {
      this.separator = separator;
    }
  }
  static isSeparator(choice) {
    return Boolean(choice && typeof choice === "object" && "type" in choice && choice.type === "separator");
  }
}
var import_yoctocolors_cjs16;
var init_Separator4 = __esm(() => {
  import_yoctocolors_cjs16 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm25();
});

// node_modules/@inquirer/search/node_modules/@inquirer/core/dist/esm/index.js
var init_esm26 = __esm(() => {
  init_errors9();
  init_use_prefix9();
  init_use_state9();
  init_use_effect9();
  init_use_memo4();
  init_use_ref9();
  init_use_keypress9();
  init_make_theme9();
  init_use_pagination2();
  init_create_prompt9();
  init_Separator4();
});

// node_modules/@inquirer/search/dist/esm/index.js
function isSelectable2(item) {
  return !Separator4.isSeparator(item) && !item.disabled;
}
function normalizeChoices4(choices) {
  return choices.map((choice) => {
    if (Separator4.isSeparator(choice))
      return choice;
    if (typeof choice === "string") {
      return {
        value: choice,
        name: choice,
        short: choice,
        disabled: false
      };
    }
    const name = choice.name ?? String(choice.value);
    return {
      value: choice.value,
      name,
      description: choice.description,
      short: choice.short ?? name,
      disabled: choice.disabled ?? false
    };
  });
}
var import_yoctocolors_cjs17, searchTheme, esm_default18;
var init_esm27 = __esm(() => {
  init_esm26();
  import_yoctocolors_cjs17 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm25();
  searchTheme = {
    icon: { cursor: esm_default17.pointer },
    style: {
      disabled: (text) => import_yoctocolors_cjs17.default.dim(`- ${text}`),
      searchTerm: (text) => import_yoctocolors_cjs17.default.cyan(text),
      description: (text) => import_yoctocolors_cjs17.default.cyan(text)
    },
    helpMode: "auto"
  };
  esm_default18 = createPrompt9((config, done) => {
    const { pageSize = 7, validate = () => true } = config;
    const theme = makeTheme9(searchTheme, config.theme);
    const firstRender = useRef9(true);
    const [status, setStatus] = useState9("loading");
    const [searchTerm, setSearchTerm] = useState9("");
    const [searchResults, setSearchResults] = useState9([]);
    const [searchError, setSearchError] = useState9();
    const prefix = usePrefix9({ status, theme });
    const bounds = useMemo4(() => {
      const first = searchResults.findIndex(isSelectable2);
      const last = searchResults.findLastIndex(isSelectable2);
      return { first, last };
    }, [searchResults]);
    const [active = bounds.first, setActive] = useState9();
    useEffect9(() => {
      const controller = new AbortController;
      setStatus("loading");
      setSearchError(undefined);
      const fetchResults = async () => {
        try {
          const results = await config.source(searchTerm || undefined, {
            signal: controller.signal
          });
          if (!controller.signal.aborted) {
            setActive(undefined);
            setSearchError(undefined);
            setSearchResults(normalizeChoices4(results));
            setStatus("idle");
          }
        } catch (error2) {
          if (!controller.signal.aborted && error2 instanceof Error) {
            setSearchError(error2.message);
          }
        }
      };
      fetchResults();
      return () => {
        controller.abort();
      };
    }, [searchTerm]);
    const selectedChoice = searchResults[active];
    useKeypress9(async (key10, rl) => {
      if (isEnterKey9(key10)) {
        if (selectedChoice) {
          setStatus("loading");
          const isValid = await validate(selectedChoice.value);
          setStatus("idle");
          if (isValid === true) {
            setStatus("done");
            done(selectedChoice.value);
          } else if (selectedChoice.name === searchTerm) {
            setSearchError(isValid || "You must provide a valid value");
          } else {
            rl.write(selectedChoice.name);
            setSearchTerm(selectedChoice.name);
          }
        } else {
          rl.write(searchTerm);
        }
      } else if (key10.name === "tab" && selectedChoice) {
        rl.clearLine(0);
        rl.write(selectedChoice.name);
        setSearchTerm(selectedChoice.name);
      } else if (status !== "loading" && (key10.name === "up" || key10.name === "down")) {
        rl.clearLine(0);
        if (key10.name === "up" && active !== bounds.first || key10.name === "down" && active !== bounds.last) {
          const offset = key10.name === "up" ? -1 : 1;
          let next = active;
          do {
            next = (next + offset + searchResults.length) % searchResults.length;
          } while (!isSelectable2(searchResults[next]));
          setActive(next);
        }
      } else {
        setSearchTerm(rl.line);
      }
    });
    const message = theme.style.message(config.message, status);
    if (active > 0) {
      firstRender.current = false;
    }
    let helpTip = "";
    if (searchResults.length > 1 && (theme.helpMode === "always" || theme.helpMode === "auto" && firstRender.current)) {
      helpTip = searchResults.length > pageSize ? `
${theme.style.help("(Use arrow keys to reveal more choices)")}` : `
${theme.style.help("(Use arrow keys)")}`;
    }
    const page = usePagination2({
      items: searchResults,
      active,
      renderItem({ item, isActive }) {
        if (Separator4.isSeparator(item)) {
          return ` ${item.separator}`;
        }
        if (item.disabled) {
          const disabledLabel = typeof item.disabled === "string" ? item.disabled : "(disabled)";
          return theme.style.disabled(`${item.name} ${disabledLabel}`);
        }
        const color = isActive ? theme.style.highlight : (x) => x;
        const cursor = isActive ? theme.icon.cursor : ` `;
        return color(`${cursor} ${item.name}`);
      },
      pageSize,
      loop: false
    });
    let error;
    if (searchError) {
      error = theme.style.error(searchError);
    } else if (searchResults.length === 0 && searchTerm !== "" && status === "idle") {
      error = theme.style.error("No results found");
    }
    let searchStr;
    if (status === "done" && selectedChoice) {
      const answer = selectedChoice.short;
      return `${prefix} ${message} ${theme.style.answer(answer)}`;
    } else {
      searchStr = theme.style.searchTerm(searchTerm);
    }
    const choiceDescription = selectedChoice?.description ? `
${theme.style.description(selectedChoice.description)}` : ``;
    return [
      [prefix, message, searchStr].filter(Boolean).join(" "),
      `${error ?? page}${helpTip}${choiceDescription}`
    ];
  });
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/key.js
var isUpKey2 = (key10) => key10.name === "up" || key10.name === "k" || key10.ctrl && key10.name === "p", isDownKey2 = (key10) => key10.name === "down" || key10.name === "j" || key10.ctrl && key10.name === "n", isBackspaceKey3 = (key10) => key10.name === "backspace", isNumberKey2 = (key10) => "123456789".includes(key10.name), isEnterKey10 = (key10) => key10.name === "enter" || key10.name === "return";

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/errors.js
var AbortPromptError10, CancelPromptError10, ExitPromptError10, HookError10, ValidationError10;
var init_errors10 = __esm(() => {
  AbortPromptError10 = class AbortPromptError10 extends Error {
    name = "AbortPromptError";
    message = "Prompt was aborted";
    constructor(options) {
      super();
      this.cause = options?.cause;
    }
  };
  CancelPromptError10 = class CancelPromptError10 extends Error {
    name = "CancelPromptError";
    message = "Prompt was canceled";
  };
  ExitPromptError10 = class ExitPromptError10 extends Error {
    name = "ExitPromptError";
  };
  HookError10 = class HookError10 extends Error {
    name = "HookError";
  };
  ValidationError10 = class ValidationError10 extends Error {
    name = "ValidationError";
  };
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/hook-engine.js
import { AsyncLocalStorage as AsyncLocalStorage10, AsyncResource as AsyncResource29 } from "node:async_hooks";
function createStore10(rl) {
  const store = {
    rl,
    hooks: [],
    hooksCleanup: [],
    hooksEffect: [],
    index: 0,
    handleChange() {
    }
  };
  return store;
}
function withHooks10(rl, cb) {
  const store = createStore10(rl);
  return hookStorage10.run(store, () => {
    function cycle(render) {
      store.handleChange = () => {
        store.index = 0;
        render();
      };
      store.handleChange();
    }
    return cb(cycle);
  });
}
function getStore10() {
  const store = hookStorage10.getStore();
  if (!store) {
    throw new HookError10("[Inquirer] Hook functions can only be called from within a prompt");
  }
  return store;
}
function readline19() {
  return getStore10().rl;
}
function withUpdates10(fn) {
  const wrapped = (...args) => {
    const store = getStore10();
    let shouldUpdate = false;
    const oldHandleChange = store.handleChange;
    store.handleChange = () => {
      shouldUpdate = true;
    };
    const returnValue = fn(...args);
    if (shouldUpdate) {
      oldHandleChange();
    }
    store.handleChange = oldHandleChange;
    return returnValue;
  };
  return AsyncResource29.bind(wrapped);
}
function withPointer10(cb) {
  const store = getStore10();
  const { index } = store;
  const pointer = {
    get() {
      return store.hooks[index];
    },
    set(value) {
      store.hooks[index] = value;
    },
    initialized: index in store.hooks
  };
  const returnValue = cb(pointer);
  store.index++;
  return returnValue;
}
function handleChange10() {
  getStore10().handleChange();
}
var hookStorage10, effectScheduler10;
var init_hook_engine10 = __esm(() => {
  init_errors10();
  hookStorage10 = new AsyncLocalStorage10;
  effectScheduler10 = {
    queue(cb) {
      const store = getStore10();
      const { index } = store;
      store.hooksEffect.push(() => {
        store.hooksCleanup[index]?.();
        const cleanFn = cb(readline19());
        if (cleanFn != null && typeof cleanFn !== "function") {
          throw new ValidationError10("useEffect return value must be a cleanup function or nothing.");
        }
        store.hooksCleanup[index] = cleanFn;
      });
    },
    run() {
      const store = getStore10();
      withUpdates10(() => {
        store.hooksEffect.forEach((effect) => {
          effect();
        });
        store.hooksEffect.length = 0;
      })();
    },
    clearAll() {
      const store = getStore10();
      store.hooksCleanup.forEach((cleanFn) => {
        cleanFn?.();
      });
      store.hooksEffect.length = 0;
      store.hooksCleanup.length = 0;
    }
  };
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/use-state.js
function useState10(defaultValue) {
  return withPointer10((pointer) => {
    const setFn = (newValue) => {
      if (pointer.get() !== newValue) {
        pointer.set(newValue);
        handleChange10();
      }
    };
    if (pointer.initialized) {
      return [pointer.get(), setFn];
    }
    const value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
    pointer.set(value);
    return [value, setFn];
  });
}
var init_use_state10 = __esm(() => {
  init_hook_engine10();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/use-effect.js
function useEffect10(cb, depArray) {
  withPointer10((pointer) => {
    const oldDeps = pointer.get();
    const hasChanged = !Array.isArray(oldDeps) || depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    if (hasChanged) {
      effectScheduler10.queue(cb);
    }
    pointer.set(depArray);
  });
}
var init_use_effect10 = __esm(() => {
  init_hook_engine10();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/figures/dist/esm/index.js
import process12 from "node:process";
function isUnicodeSupported10() {
  if (process12.platform !== "win32") {
    return process12.env["TERM"] !== "linux";
  }
  return Boolean(process12.env["WT_SESSION"]) || Boolean(process12.env["TERMINUS_SUBLIME"]) || process12.env["ConEmuTask"] === "{cmd::Cmder}" || process12.env["TERM_PROGRAM"] === "Terminus-Sublime" || process12.env["TERM_PROGRAM"] === "vscode" || process12.env["TERM"] === "xterm-256color" || process12.env["TERM"] === "alacritty" || process12.env["TERMINAL_EMULATOR"] === "JetBrains-JediTerm";
}
var common10, specialMainSymbols10, specialFallbackSymbols10, mainSymbols10, fallbackSymbols10, shouldUseMain10, figures10, esm_default19, replacements10;
var init_esm28 = __esm(() => {
  common10 = {
    circleQuestionMark: "(?)",
    questionMarkPrefix: "(?)",
    square: "",
    squareDarkShade: "",
    squareMediumShade: "",
    squareLightShade: "",
    squareTop: "",
    squareBottom: "",
    squareLeft: "",
    squareRight: "",
    squareCenter: "",
    bullet: "",
    dot: "",
    ellipsis: "",
    pointerSmall: "",
    triangleUp: "",
    triangleUpSmall: "",
    triangleDown: "",
    triangleDownSmall: "",
    triangleLeftSmall: "",
    triangleRightSmall: "",
    home: "",
    heart: "",
    musicNote: "",
    musicNoteBeamed: "",
    arrowUp: "",
    arrowDown: "",
    arrowLeft: "",
    arrowRight: "",
    arrowLeftRight: "",
    arrowUpDown: "",
    almostEqual: "",
    notEqual: "",
    lessOrEqual: "",
    greaterOrEqual: "",
    identical: "",
    infinity: "",
    subscriptZero: "",
    subscriptOne: "",
    subscriptTwo: "",
    subscriptThree: "",
    subscriptFour: "",
    subscriptFive: "",
    subscriptSix: "",
    subscriptSeven: "",
    subscriptEight: "",
    subscriptNine: "",
    oneHalf: "",
    oneThird: "",
    oneQuarter: "",
    oneFifth: "",
    oneSixth: "",
    oneEighth: "",
    twoThirds: "",
    twoFifths: "",
    threeQuarters: "",
    threeFifths: "",
    threeEighths: "",
    fourFifths: "",
    fiveSixths: "",
    fiveEighths: "",
    sevenEighths: "",
    line: "",
    lineBold: "",
    lineDouble: "",
    lineDashed0: "",
    lineDashed1: "",
    lineDashed2: "",
    lineDashed3: "",
    lineDashed4: "",
    lineDashed5: "",
    lineDashed6: "",
    lineDashed7: "",
    lineDashed8: "",
    lineDashed9: "",
    lineDashed10: "",
    lineDashed11: "",
    lineDashed12: "",
    lineDashed13: "",
    lineDashed14: "",
    lineDashed15: "",
    lineVertical: "",
    lineVerticalBold: "",
    lineVerticalDouble: "",
    lineVerticalDashed0: "",
    lineVerticalDashed1: "",
    lineVerticalDashed2: "",
    lineVerticalDashed3: "",
    lineVerticalDashed4: "",
    lineVerticalDashed5: "",
    lineVerticalDashed6: "",
    lineVerticalDashed7: "",
    lineVerticalDashed8: "",
    lineVerticalDashed9: "",
    lineVerticalDashed10: "",
    lineVerticalDashed11: "",
    lineDownLeft: "",
    lineDownLeftArc: "",
    lineDownBoldLeftBold: "",
    lineDownBoldLeft: "",
    lineDownLeftBold: "",
    lineDownDoubleLeftDouble: "",
    lineDownDoubleLeft: "",
    lineDownLeftDouble: "",
    lineDownRight: "",
    lineDownRightArc: "",
    lineDownBoldRightBold: "",
    lineDownBoldRight: "",
    lineDownRightBold: "",
    lineDownDoubleRightDouble: "",
    lineDownDoubleRight: "",
    lineDownRightDouble: "",
    lineUpLeft: "",
    lineUpLeftArc: "",
    lineUpBoldLeftBold: "",
    lineUpBoldLeft: "",
    lineUpLeftBold: "",
    lineUpDoubleLeftDouble: "",
    lineUpDoubleLeft: "",
    lineUpLeftDouble: "",
    lineUpRight: "",
    lineUpRightArc: "",
    lineUpBoldRightBold: "",
    lineUpBoldRight: "",
    lineUpRightBold: "",
    lineUpDoubleRightDouble: "",
    lineUpDoubleRight: "",
    lineUpRightDouble: "",
    lineUpDownLeft: "",
    lineUpBoldDownBoldLeftBold: "",
    lineUpBoldDownBoldLeft: "",
    lineUpDownLeftBold: "",
    lineUpBoldDownLeftBold: "",
    lineUpDownBoldLeftBold: "",
    lineUpDownBoldLeft: "",
    lineUpBoldDownLeft: "",
    lineUpDoubleDownDoubleLeftDouble: "",
    lineUpDoubleDownDoubleLeft: "",
    lineUpDownLeftDouble: "",
    lineUpDownRight: "",
    lineUpBoldDownBoldRightBold: "",
    lineUpBoldDownBoldRight: "",
    lineUpDownRightBold: "",
    lineUpBoldDownRightBold: "",
    lineUpDownBoldRightBold: "",
    lineUpDownBoldRight: "",
    lineUpBoldDownRight: "",
    lineUpDoubleDownDoubleRightDouble: "",
    lineUpDoubleDownDoubleRight: "",
    lineUpDownRightDouble: "",
    lineDownLeftRight: "",
    lineDownBoldLeftBoldRightBold: "",
    lineDownLeftBoldRightBold: "",
    lineDownBoldLeftRight: "",
    lineDownBoldLeftBoldRight: "",
    lineDownBoldLeftRightBold: "",
    lineDownLeftRightBold: "",
    lineDownLeftBoldRight: "",
    lineDownDoubleLeftDoubleRightDouble: "",
    lineDownDoubleLeftRight: "",
    lineDownLeftDoubleRightDouble: "",
    lineUpLeftRight: "",
    lineUpBoldLeftBoldRightBold: "",
    lineUpLeftBoldRightBold: "",
    lineUpBoldLeftRight: "",
    lineUpBoldLeftBoldRight: "",
    lineUpBoldLeftRightBold: "",
    lineUpLeftRightBold: "",
    lineUpLeftBoldRight: "",
    lineUpDoubleLeftDoubleRightDouble: "",
    lineUpDoubleLeftRight: "",
    lineUpLeftDoubleRightDouble: "",
    lineUpDownLeftRight: "",
    lineUpBoldDownBoldLeftBoldRightBold: "",
    lineUpDownBoldLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRightBold: "",
    lineUpBoldDownBoldLeftRightBold: "",
    lineUpBoldDownBoldLeftBoldRight: "",
    lineUpBoldDownLeftRight: "",
    lineUpDownBoldLeftRight: "",
    lineUpDownLeftBoldRight: "",
    lineUpDownLeftRightBold: "",
    lineUpBoldDownBoldLeftRight: "",
    lineUpDownLeftBoldRightBold: "",
    lineUpBoldDownLeftBoldRight: "",
    lineUpBoldDownLeftRightBold: "",
    lineUpDownBoldLeftBoldRight: "",
    lineUpDownBoldLeftRightBold: "",
    lineUpDoubleDownDoubleLeftDoubleRightDouble: "",
    lineUpDoubleDownDoubleLeftRight: "",
    lineUpDownLeftDoubleRightDouble: "",
    lineCross: "",
    lineBackslash: "",
    lineSlash: ""
  };
  specialMainSymbols10 = {
    tick: "",
    info: "",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "",
    circleFilled: "",
    circleDotted: "",
    circleDouble: "",
    circleCircle: "",
    circleCross: "",
    circlePipe: "",
    radioOn: "",
    radioOff: "",
    checkboxOn: "",
    checkboxOff: "",
    checkboxCircleOn: "",
    checkboxCircleOff: "",
    pointer: "",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "",
    oneNinth: "",
    oneTenth: ""
  };
  specialFallbackSymbols10 = {
    tick: "",
    info: "i",
    warning: "",
    cross: "",
    squareSmall: "",
    squareSmallFilled: "",
    circle: "( )",
    circleFilled: "(*)",
    circleDotted: "( )",
    circleDouble: "( )",
    circleCircle: "()",
    circleCross: "()",
    circlePipe: "()",
    radioOn: "(*)",
    radioOff: "( )",
    checkboxOn: "[]",
    checkboxOff: "[ ]",
    checkboxCircleOn: "()",
    checkboxCircleOff: "( )",
    pointer: ">",
    triangleUpOutline: "",
    triangleLeft: "",
    triangleRight: "",
    lozenge: "",
    lozengeOutline: "",
    hamburger: "",
    smiley: "",
    mustache: "",
    star: "",
    play: "",
    nodejs: "",
    oneSeventh: "1/7",
    oneNinth: "1/9",
    oneTenth: "1/10"
  };
  mainSymbols10 = { ...common10, ...specialMainSymbols10 };
  fallbackSymbols10 = {
    ...common10,
    ...specialFallbackSymbols10
  };
  shouldUseMain10 = isUnicodeSupported10();
  figures10 = shouldUseMain10 ? mainSymbols10 : fallbackSymbols10;
  esm_default19 = figures10;
  replacements10 = Object.entries(specialMainSymbols10);
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/theme.js
var import_yoctocolors_cjs18, defaultTheme10;
var init_theme10 = __esm(() => {
  import_yoctocolors_cjs18 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm28();
  defaultTheme10 = {
    prefix: {
      idle: import_yoctocolors_cjs18.default.blue("?"),
      done: import_yoctocolors_cjs18.default.green(esm_default19.tick)
    },
    spinner: {
      interval: 80,
      frames: ["", "", "", "", "", "", "", "", "", ""].map((frame) => import_yoctocolors_cjs18.default.yellow(frame))
    },
    style: {
      answer: import_yoctocolors_cjs18.default.cyan,
      message: import_yoctocolors_cjs18.default.bold,
      error: (text) => import_yoctocolors_cjs18.default.red(`> ${text}`),
      defaultAnswer: (text) => import_yoctocolors_cjs18.default.dim(`(${text})`),
      help: import_yoctocolors_cjs18.default.dim,
      highlight: import_yoctocolors_cjs18.default.cyan,
      key: (text) => import_yoctocolors_cjs18.default.cyan(import_yoctocolors_cjs18.default.bold(`<${text}>`))
    }
  };
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/make-theme.js
function isPlainObject10(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function deepMerge10(...objects) {
  const output = {};
  for (const obj of objects) {
    for (const [key10, value] of Object.entries(obj)) {
      const prevValue = output[key10];
      output[key10] = isPlainObject10(prevValue) && isPlainObject10(value) ? deepMerge10(prevValue, value) : value;
    }
  }
  return output;
}
function makeTheme10(...themes) {
  const themesToMerge = [
    defaultTheme10,
    ...themes.filter((theme) => theme != null)
  ];
  return deepMerge10(...themesToMerge);
}
var init_make_theme10 = __esm(() => {
  init_theme10();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/use-prefix.js
import { AsyncResource as AsyncResource30 } from "node:async_hooks";
function usePrefix10({ status = "idle", theme }) {
  const [showLoader, setShowLoader] = useState10(false);
  const [tick, setTick] = useState10(0);
  const { prefix, spinner } = makeTheme10(theme);
  useEffect10(() => {
    if (status === "loading") {
      let tickInterval;
      let inc = -1;
      const delayTimeout = setTimeout(AsyncResource30.bind(() => {
        setShowLoader(true);
        tickInterval = setInterval(AsyncResource30.bind(() => {
          inc = inc + 1;
          setTick(inc % spinner.frames.length);
        }), spinner.interval);
      }), 300);
      return () => {
        clearTimeout(delayTimeout);
        clearInterval(tickInterval);
      };
    } else {
      setShowLoader(false);
    }
  }, [status]);
  if (showLoader) {
    return spinner.frames[tick];
  }
  const iconName = status === "loading" ? "idle" : status;
  return typeof prefix === "string" ? prefix : prefix[iconName] ?? prefix["idle"];
}
var init_use_prefix10 = __esm(() => {
  init_use_state10();
  init_use_effect10();
  init_make_theme10();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/use-memo.js
function useMemo5(fn, dependencies) {
  return withPointer10((pointer) => {
    const prev = pointer.get();
    if (!prev || prev.dependencies.length !== dependencies.length || prev.dependencies.some((dep, i) => dep !== dependencies[i])) {
      const value = fn();
      pointer.set({ value, dependencies });
      return value;
    }
    return prev.value;
  });
}
var init_use_memo5 = __esm(() => {
  init_hook_engine10();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/use-ref.js
function useRef10(val) {
  return useState10({ current: val })[0];
}
var init_use_ref10 = __esm(() => {
  init_use_state10();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/use-keypress.js
function useKeypress10(userHandler) {
  const signal = useRef10(userHandler);
  signal.current = userHandler;
  useEffect10((rl) => {
    let ignore = false;
    const handler = withUpdates10((_input, event) => {
      if (ignore)
        return;
      signal.current(event, rl);
    });
    rl.input.on("keypress", handler);
    return () => {
      ignore = true;
      rl.input.removeListener("keypress", handler);
    };
  }, []);
}
var init_use_keypress10 = __esm(() => {
  init_use_ref10();
  init_use_effect10();
  init_hook_engine10();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/utils.js
function breakLines10(content, width) {
  return content.split(`
`).flatMap((line) => import_wrap_ansi10.default(line, width, { trim: false, hard: true }).split(`
`).map((str) => str.trimEnd())).join(`
`);
}
function readlineWidth10() {
  return import_cli_width10.default({ defaultWidth: 80, output: readline19().output });
}
var import_cli_width10, import_wrap_ansi10;
var init_utils10 = __esm(() => {
  import_cli_width10 = __toESM(require_cli_width(), 1);
  import_wrap_ansi10 = __toESM(require_wrap_ansi(), 1);
  init_hook_engine10();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/pagination/lines.js
function split3(content, width) {
  return breakLines10(content, width).split(`
`);
}
function rotate3(count, items) {
  const max = items.length;
  const offset = (count % max + max) % max;
  return [...items.slice(offset), ...items.slice(0, offset)];
}
function lines3({ items, width, renderItem, active, position: requested, pageSize }) {
  const layouts = items.map((item, index) => ({
    item,
    index,
    isActive: index === active
  }));
  const layoutsInPage = rotate3(active - requested, layouts).slice(0, pageSize);
  const renderItemAt = (index) => layoutsInPage[index] == null ? [] : split3(renderItem(layoutsInPage[index]), width);
  const pageBuffer = Array.from({ length: pageSize });
  const activeItem = renderItemAt(requested).slice(0, pageSize);
  const position = requested + activeItem.length <= pageSize ? requested : pageSize - activeItem.length;
  pageBuffer.splice(position, activeItem.length, ...activeItem);
  let bufferPointer = position + activeItem.length;
  let layoutPointer = requested + 1;
  while (bufferPointer < pageSize && layoutPointer < layoutsInPage.length) {
    for (const line of renderItemAt(layoutPointer)) {
      pageBuffer[bufferPointer++] = line;
      if (bufferPointer >= pageSize)
        break;
    }
    layoutPointer++;
  }
  bufferPointer = position - 1;
  layoutPointer = requested - 1;
  while (bufferPointer >= 0 && layoutPointer >= 0) {
    for (const line of renderItemAt(layoutPointer).reverse()) {
      pageBuffer[bufferPointer--] = line;
      if (bufferPointer < 0)
        break;
    }
    layoutPointer--;
  }
  return pageBuffer.filter((line) => typeof line === "string");
}
var init_lines3 = __esm(() => {
  init_utils10();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/pagination/position.js
function finite3({ active, pageSize, total }) {
  const middle = Math.floor(pageSize / 2);
  if (total <= pageSize || active < middle)
    return active;
  if (active >= total - middle)
    return active + pageSize - total;
  return middle;
}
function infinite3({ active, lastActive, total, pageSize, pointer }) {
  if (total <= pageSize)
    return active;
  if (lastActive < active && active - lastActive < pageSize) {
    return Math.min(Math.floor(pageSize / 2), pointer + active - lastActive);
  }
  return pointer;
}

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/pagination/use-pagination.js
function usePagination3({ items, active, renderItem, pageSize, loop = true }) {
  const state = useRef10({ position: 0, lastActive: 0 });
  const position = loop ? infinite3({
    active,
    lastActive: state.current.lastActive,
    total: items.length,
    pageSize,
    pointer: state.current.position
  }) : finite3({
    active,
    total: items.length,
    pageSize
  });
  state.current.position = position;
  state.current.lastActive = active;
  return lines3({
    items,
    width: readlineWidth10(),
    renderItem,
    active,
    position,
    pageSize
  }).join(`
`);
}
var init_use_pagination3 = __esm(() => {
  init_use_ref10();
  init_utils10();
  init_lines3();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/node_modules/strip-ansi/node_modules/ansi-regex/index.js
var require_ansi_regex11 = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? undefined : "g");
  };
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/node_modules/strip-ansi/index.js
var require_strip_ansi11 = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex11();
  module.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/screen-manager.js
function cursorDown10(n) {
  return n > 0 ? import_ansi_escapes12.default.cursorDown(n) : "";
}

class ScreenManager10 {
  rl;
  height = 0;
  extraLinesUnderPrompt = 0;
  cursorPos;
  constructor(rl) {
    this.rl = rl;
    this.rl = rl;
    this.cursorPos = rl.getCursorPos();
  }
  write(content) {
    this.rl.output.unmute();
    this.rl.output.write(content);
    this.rl.output.mute();
  }
  render(content, bottomContent = "") {
    const promptLine = lastLine10(content);
    const rawPromptLine = import_strip_ansi10.default(promptLine);
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }
    this.rl.setPrompt(prompt);
    this.cursorPos = this.rl.getCursorPos();
    const width = readlineWidth10();
    content = breakLines10(content, width);
    bottomContent = breakLines10(bottomContent, width);
    if (rawPromptLine.length % width === 0) {
      content += `
`;
    }
    let output = content + (bottomContent ? `
` + bottomContent : "");
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - this.cursorPos.rows;
    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height10(bottomContent) : 0);
    if (bottomContentHeight > 0)
      output += import_ansi_escapes12.default.cursorUp(bottomContentHeight);
    output += import_ansi_escapes12.default.cursorTo(this.cursorPos.cols);
    this.write(cursorDown10(this.extraLinesUnderPrompt) + import_ansi_escapes12.default.eraseLines(this.height) + output);
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height10(output);
  }
  checkCursorPos() {
    const cursorPos = this.rl.getCursorPos();
    if (cursorPos.cols !== this.cursorPos.cols) {
      this.write(import_ansi_escapes12.default.cursorTo(cursorPos.cols));
      this.cursorPos = cursorPos;
    }
  }
  done({ clearContent }) {
    this.rl.setPrompt("");
    let output = cursorDown10(this.extraLinesUnderPrompt);
    output += clearContent ? import_ansi_escapes12.default.eraseLines(this.height) : `
`;
    output += import_ansi_escapes12.default.cursorShow;
    this.write(output);
    this.rl.close();
  }
}
var import_strip_ansi10, import_ansi_escapes12, height10 = (content) => content.split(`
`).length, lastLine10 = (content) => content.split(`
`).pop() ?? "";
var init_screen_manager10 = __esm(() => {
  import_strip_ansi10 = __toESM(require_strip_ansi11(), 1);
  import_ansi_escapes12 = __toESM(require_ansi_escapes(), 1);
  init_utils10();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/promise-polyfill.js
var PromisePolyfill10;
var init_promise_polyfill10 = __esm(() => {
  PromisePolyfill10 = class PromisePolyfill10 extends Promise {
    static withResolver() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return { promise, resolve, reject };
    }
  };
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/create-prompt.js
import * as readline20 from "node:readline";
import { AsyncResource as AsyncResource31 } from "node:async_hooks";
function getCallSites10() {
  const _prepareStackTrace = Error.prepareStackTrace;
  try {
    let result = [];
    Error.prepareStackTrace = (_2, callSites) => {
      const callSitesWithoutCurrent = callSites.slice(1);
      result = callSitesWithoutCurrent;
      return callSitesWithoutCurrent;
    };
    new Error().stack;
    return result;
  } finally {
    Error.prepareStackTrace = _prepareStackTrace;
  }
}
function createPrompt10(view) {
  const callSites = getCallSites10();
  const callerFilename = callSites[1]?.getFileName?.();
  const prompt = (config, context = {}) => {
    const { input = process.stdin, signal } = context;
    const cleanups = new Set;
    const output = new import_mute_stream10.default;
    output.pipe(context.output ?? process.stdout);
    const rl = readline20.createInterface({
      terminal: true,
      input,
      output
    });
    const screen = new ScreenManager10(rl);
    const { promise, resolve, reject } = PromisePolyfill10.withResolver();
    const cancel = () => reject(new CancelPromptError10);
    if (signal) {
      const abort = () => reject(new AbortPromptError10({ cause: signal.reason }));
      if (signal.aborted) {
        abort();
        return Object.assign(promise, { cancel });
      }
      signal.addEventListener("abort", abort);
      cleanups.add(() => signal.removeEventListener("abort", abort));
    }
    cleanups.add(onExit((code, signal2) => {
      reject(new ExitPromptError10(`User force closed the prompt with ${code} ${signal2}`));
    }));
    const checkCursorPos = () => screen.checkCursorPos();
    rl.input.on("keypress", checkCursorPos);
    cleanups.add(() => rl.input.removeListener("keypress", checkCursorPos));
    return withHooks10(rl, (cycle) => {
      const hooksCleanup = AsyncResource31.bind(() => effectScheduler10.clearAll());
      rl.on("close", hooksCleanup);
      cleanups.add(() => rl.removeListener("close", hooksCleanup));
      cycle(() => {
        try {
          const nextView = view(config, (value) => {
            setImmediate(() => resolve(value));
          });
          if (nextView === undefined) {
            throw new Error(`Prompt functions must return a string.
    at ${callerFilename}`);
          }
          const [content, bottomContent] = typeof nextView === "string" ? [nextView] : nextView;
          screen.render(content, bottomContent);
          effectScheduler10.run();
        } catch (error) {
          reject(error);
        }
      });
      return Object.assign(promise.then((answer) => {
        effectScheduler10.clearAll();
        return answer;
      }, (error) => {
        effectScheduler10.clearAll();
        throw error;
      }).finally(() => {
        cleanups.forEach((cleanup) => cleanup());
        screen.done({ clearContent: Boolean(context.clearPromptOnDone) });
        output.end();
      }).then(() => promise), { cancel });
    });
  };
  return prompt;
}
var import_mute_stream10;
var init_create_prompt10 = __esm(() => {
  import_mute_stream10 = __toESM(require_lib2(), 1);
  init_mjs();
  init_screen_manager10();
  init_promise_polyfill10();
  init_hook_engine10();
  init_errors10();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/lib/Separator.js
class Separator5 {
  separator = import_yoctocolors_cjs19.default.dim(Array.from({ length: 15 }).join(esm_default19.line));
  type = "separator";
  constructor(separator) {
    if (separator) {
      this.separator = separator;
    }
  }
  static isSeparator(choice) {
    return Boolean(choice && typeof choice === "object" && "type" in choice && choice.type === "separator");
  }
}
var import_yoctocolors_cjs19;
var init_Separator5 = __esm(() => {
  import_yoctocolors_cjs19 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm28();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/node_modules/@inquirer/core/dist/esm/index.js
var init_esm29 = __esm(() => {
  init_errors10();
  init_use_prefix10();
  init_use_state10();
  init_use_effect10();
  init_use_memo5();
  init_use_ref10();
  init_use_keypress10();
  init_make_theme10();
  init_use_pagination3();
  init_create_prompt10();
  init_Separator5();
});

// node_modules/@inquirer/prompts/node_modules/@inquirer/select/dist/esm/index.js
function isSelectable3(item) {
  return !Separator5.isSeparator(item) && !item.disabled;
}
function normalizeChoices5(choices) {
  return choices.map((choice) => {
    if (Separator5.isSeparator(choice))
      return choice;
    if (typeof choice === "string") {
      return {
        value: choice,
        name: choice,
        short: choice,
        disabled: false
      };
    }
    const name = choice.name ?? String(choice.value);
    return {
      value: choice.value,
      name,
      description: choice.description,
      short: choice.short ?? name,
      disabled: choice.disabled ?? false
    };
  });
}
var import_yoctocolors_cjs20, import_ansi_escapes13, selectTheme, esm_default20;
var init_esm30 = __esm(() => {
  init_esm29();
  import_yoctocolors_cjs20 = __toESM(require_yoctocolors_cjs(), 1);
  init_esm28();
  import_ansi_escapes13 = __toESM(require_ansi_escapes(), 1);
  selectTheme = {
    icon: { cursor: esm_default19.pointer },
    style: {
      disabled: (text) => import_yoctocolors_cjs20.default.dim(`- ${text}`),
      description: (text) => import_yoctocolors_cjs20.default.cyan(text)
    },
    helpMode: "auto"
  };
  esm_default20 = createPrompt10((config, done) => {
    const { loop = true, pageSize = 7 } = config;
    const firstRender = useRef10(true);
    const theme = makeTheme10(selectTheme, config.theme);
    const [status, setStatus] = useState10("idle");
    const prefix = usePrefix10({ status, theme });
    const searchTimeoutRef = useRef10();
    const items = useMemo5(() => normalizeChoices5(config.choices), [config.choices]);
    const bounds = useMemo5(() => {
      const first = items.findIndex(isSelectable3);
      const last = items.findLastIndex(isSelectable3);
      if (first === -1) {
        throw new ValidationError10("[select prompt] No selectable choices. All choices are disabled.");
      }
      return { first, last };
    }, [items]);
    const defaultItemIndex = useMemo5(() => {
      if (!("default" in config))
        return -1;
      return items.findIndex((item) => isSelectable3(item) && item.value === config.default);
    }, [config.default, items]);
    const [active, setActive] = useState10(defaultItemIndex === -1 ? bounds.first : defaultItemIndex);
    const selectedChoice = items[active];
    useKeypress10((key11, rl) => {
      clearTimeout(searchTimeoutRef.current);
      if (isEnterKey10(key11)) {
        setStatus("done");
        done(selectedChoice.value);
      } else if (isUpKey2(key11) || isDownKey2(key11)) {
        rl.clearLine(0);
        if (loop || isUpKey2(key11) && active !== bounds.first || isDownKey2(key11) && active !== bounds.last) {
          const offset = isUpKey2(key11) ? -1 : 1;
          let next = active;
          do {
            next = (next + offset + items.length) % items.length;
          } while (!isSelectable3(items[next]));
          setActive(next);
        }
      } else if (isNumberKey2(key11)) {
        rl.clearLine(0);
        const position = Number(key11.name) - 1;
        const item = items[position];
        if (item != null && isSelectable3(item)) {
          setActive(position);
        }
      } else if (isBackspaceKey3(key11)) {
        rl.clearLine(0);
      } else {
        const searchTerm = rl.line.toLowerCase();
        const matchIndex = items.findIndex((item) => {
          if (Separator5.isSeparator(item) || !isSelectable3(item))
            return false;
          return item.name.toLowerCase().startsWith(searchTerm);
        });
        if (matchIndex !== -1) {
          setActive(matchIndex);
        }
        searchTimeoutRef.current = setTimeout(() => {
          rl.clearLine(0);
        }, 700);
      }
    });
    useEffect10(() => () => {
      clearTimeout(searchTimeoutRef.current);
    }, []);
    const message = theme.style.message(config.message, status);
    let helpTipTop = "";
    let helpTipBottom = "";
    if (theme.helpMode === "always" || theme.helpMode === "auto" && firstRender.current) {
      firstRender.current = false;
      if (items.length > pageSize) {
        helpTipBottom = `
${theme.style.help("(Use arrow keys to reveal more choices)")}`;
      } else {
        helpTipTop = theme.style.help("(Use arrow keys)");
      }
    }
    const page = usePagination3({
      items,
      active,
      renderItem({ item, isActive }) {
        if (Separator5.isSeparator(item)) {
          return ` ${item.separator}`;
        }
        if (item.disabled) {
          const disabledLabel = typeof item.disabled === "string" ? item.disabled : "(disabled)";
          return theme.style.disabled(`${item.name} ${disabledLabel}`);
        }
        const color = isActive ? theme.style.highlight : (x) => x;
        const cursor = isActive ? theme.icon.cursor : ` `;
        return color(`${cursor} ${item.name}`);
      },
      pageSize,
      loop
    });
    if (status === "done") {
      return `${prefix} ${message} ${theme.style.answer(selectedChoice.short)}`;
    }
    const choiceDescription = selectedChoice.description ? `
${theme.style.description(selectedChoice.description)}` : ``;
    return `${[prefix, message, helpTipTop].filter(Boolean).join(" ")}
${page}${helpTipBottom}${choiceDescription}${import_ansi_escapes13.default.cursorHide}`;
  });
});

// node_modules/@inquirer/prompts/dist/esm/index.js
var init_esm31 = __esm(() => {
  init_esm3();
  init_esm6();
  init_esm9();
  init_esm12();
  init_esm15();
  init_esm18();
  init_esm21();
  init_esm24();
  init_esm27();
  init_esm30();
});

// node_modules/cli-spinners/spinners.json
var require_spinners = __commonJS((exports, module) => {
  module.exports = {
    dots: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots2: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots3: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots4: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots5: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots6: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots7: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots8: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots9: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots10: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots11: {
      interval: 100,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots12: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots13: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots8Bit: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    sand: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    line: {
      interval: 130,
      frames: [
        "-",
        "\\",
        "|",
        "/"
      ]
    },
    line2: {
      interval: 100,
      frames: [
        "",
        "-",
        "",
        "",
        "",
        "-"
      ]
    },
    pipe: {
      interval: 100,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    simpleDots: {
      interval: 400,
      frames: [
        ".  ",
        ".. ",
        "...",
        "   "
      ]
    },
    simpleDotsScrolling: {
      interval: 200,
      frames: [
        ".  ",
        ".. ",
        "...",
        " ..",
        "  .",
        "   "
      ]
    },
    star: {
      interval: 70,
      frames: [
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    star2: {
      interval: 80,
      frames: [
        "+",
        "x",
        "*"
      ]
    },
    flip: {
      interval: 70,
      frames: [
        "_",
        "_",
        "_",
        "-",
        "`",
        "`",
        "'",
        "",
        "-",
        "_",
        "_",
        "_"
      ]
    },
    hamburger: {
      interval: 100,
      frames: [
        "",
        "",
        ""
      ]
    },
    growVertical: {
      interval: 120,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    growHorizontal: {
      interval: 120,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    balloon: {
      interval: 140,
      frames: [
        " ",
        ".",
        "o",
        "O",
        "@",
        "*",
        " "
      ]
    },
    balloon2: {
      interval: 120,
      frames: [
        ".",
        "o",
        "O",
        "",
        "O",
        "o",
        "."
      ]
    },
    noise: {
      interval: 100,
      frames: [
        "",
        "",
        ""
      ]
    },
    bounce: {
      interval: 120,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    boxBounce: {
      interval: 120,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    boxBounce2: {
      interval: 100,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    triangle: {
      interval: 50,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    binary: {
      interval: 80,
      frames: [
        "010010",
        "001100",
        "100101",
        "111010",
        "111101",
        "010111",
        "101011",
        "111000",
        "110011",
        "110101"
      ]
    },
    arc: {
      interval: 100,
      frames: [
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    circle: {
      interval: 120,
      frames: [
        "",
        "",
        ""
      ]
    },
    squareCorners: {
      interval: 180,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    circleQuarters: {
      interval: 120,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    circleHalves: {
      interval: 50,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    squish: {
      interval: 100,
      frames: [
        "",
        ""
      ]
    },
    toggle: {
      interval: 250,
      frames: [
        "",
        ""
      ]
    },
    toggle2: {
      interval: 80,
      frames: [
        "",
        ""
      ]
    },
    toggle3: {
      interval: 120,
      frames: [
        "",
        ""
      ]
    },
    toggle4: {
      interval: 100,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    toggle5: {
      interval: 100,
      frames: [
        "",
        ""
      ]
    },
    toggle6: {
      interval: 300,
      frames: [
        "",
        ""
      ]
    },
    toggle7: {
      interval: 80,
      frames: [
        "",
        ""
      ]
    },
    toggle8: {
      interval: 100,
      frames: [
        "",
        ""
      ]
    },
    toggle9: {
      interval: 100,
      frames: [
        "",
        ""
      ]
    },
    toggle10: {
      interval: 100,
      frames: [
        "",
        "",
        ""
      ]
    },
    toggle11: {
      interval: 50,
      frames: [
        "",
        ""
      ]
    },
    toggle12: {
      interval: 120,
      frames: [
        "",
        ""
      ]
    },
    toggle13: {
      interval: 80,
      frames: [
        "=",
        "*",
        "-"
      ]
    },
    arrow: {
      interval: 100,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    arrow2: {
      interval: 80,
      frames: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    arrow3: {
      interval: 120,
      frames: [
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    bouncingBar: {
      interval: 80,
      frames: [
        "[    ]",
        "[=   ]",
        "[==  ]",
        "[=== ]",
        "[====]",
        "[ ===]",
        "[  ==]",
        "[   =]",
        "[    ]",
        "[   =]",
        "[  ==]",
        "[ ===]",
        "[====]",
        "[=== ]",
        "[==  ]",
        "[=   ]"
      ]
    },
    bouncingBall: {
      interval: 80,
      frames: [
        "(     )",
        "(     )",
        "(     )",
        "(     )",
        "(     )",
        "(     )",
        "(     )",
        "(     )",
        "(     )",
        "(     )"
      ]
    },
    smiley: {
      interval: 200,
      frames: [
        "\uD83D\uDE04 ",
        "\uD83D\uDE1D "
      ]
    },
    monkey: {
      interval: 300,
      frames: [
        "\uD83D\uDE48 ",
        "\uD83D\uDE48 ",
        "\uD83D\uDE49 ",
        "\uD83D\uDE4A "
      ]
    },
    hearts: {
      interval: 100,
      frames: [
        "\uD83D\uDC9B ",
        "\uD83D\uDC99 ",
        "\uD83D\uDC9C ",
        "\uD83D\uDC9A ",
        " "
      ]
    },
    clock: {
      interval: 100,
      frames: [
        "\uD83D\uDD5B ",
        "\uD83D\uDD50 ",
        "\uD83D\uDD51 ",
        "\uD83D\uDD52 ",
        "\uD83D\uDD53 ",
        "\uD83D\uDD54 ",
        "\uD83D\uDD55 ",
        "\uD83D\uDD56 ",
        "\uD83D\uDD57 ",
        "\uD83D\uDD58 ",
        "\uD83D\uDD59 ",
        "\uD83D\uDD5A "
      ]
    },
    earth: {
      interval: 180,
      frames: [
        "\uD83C\uDF0D ",
        "\uD83C\uDF0E ",
        "\uD83C\uDF0F "
      ]
    },
    material: {
      interval: 17,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    moon: {
      interval: 80,
      frames: [
        "\uD83C\uDF11 ",
        "\uD83C\uDF12 ",
        "\uD83C\uDF13 ",
        "\uD83C\uDF14 ",
        "\uD83C\uDF15 ",
        "\uD83C\uDF16 ",
        "\uD83C\uDF17 ",
        "\uD83C\uDF18 "
      ]
    },
    runner: {
      interval: 140,
      frames: [
        "\uD83D\uDEB6 ",
        "\uD83C\uDFC3 "
      ]
    },
    pong: {
      interval: 80,
      frames: [
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       "
      ]
    },
    shark: {
      interval: 120,
      frames: [
        "|\\____________",
        "_|\\___________",
        "__|\\__________",
        "___|\\_________",
        "____|\\________",
        "_____|\\_______",
        "______|\\______",
        "_______|\\_____",
        "________|\\____",
        "_________|\\___",
        "__________|\\__",
        "___________|\\_",
        "____________|\\",
        "____________/|",
        "___________/|_",
        "__________/|__",
        "_________/|___",
        "________/|____",
        "_______/|_____",
        "______/|______",
        "_____/|_______",
        "____/|________",
        "___/|_________",
        "__/|__________",
        "_/|___________",
        "/|____________"
      ]
    },
    dqpb: {
      interval: 100,
      frames: [
        "d",
        "q",
        "p",
        "b"
      ]
    },
    weather: {
      interval: 100,
      frames: [
        " ",
        " ",
        " ",
        "\uD83C\uDF24 ",
        " ",
        "\uD83C\uDF25 ",
        " ",
        "\uD83C\uDF27 ",
        "\uD83C\uDF28 ",
        "\uD83C\uDF27 ",
        "\uD83C\uDF28 ",
        "\uD83C\uDF27 ",
        "\uD83C\uDF28 ",
        " ",
        "\uD83C\uDF28 ",
        "\uD83C\uDF27 ",
        "\uD83C\uDF28 ",
        " ",
        "\uD83C\uDF25 ",
        " ",
        "\uD83C\uDF24 ",
        " ",
        " "
      ]
    },
    christmas: {
      interval: 400,
      frames: [
        "\uD83C\uDF32",
        "\uD83C\uDF84"
      ]
    },
    grenade: {
      interval: 80,
      frames: [
        "  ",
        "  ",
        "  ",
        "  ",
        "  ",
        "  ",
        "  |",
        "  ",
        "  ",
        "  ",
        "  ",
        "   ",
        "   ",
        "   "
      ]
    },
    point: {
      interval: 125,
      frames: [
        "",
        "",
        "",
        "",
        ""
      ]
    },
    layer: {
      interval: 150,
      frames: [
        "-",
        "=",
        ""
      ]
    },
    betaWave: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    fingerDance: {
      interval: 160,
      frames: [
        "\uD83E\uDD18 ",
        "\uD83E\uDD1F ",
        "\uD83D\uDD96 ",
        " ",
        "\uD83E\uDD1A ",
        "\uD83D\uDC46 "
      ]
    },
    fistBump: {
      interval: 80,
      frames: [
        "\uD83E\uDD1C\uD83E\uDD1B ",
        "\uD83E\uDD1C\uD83E\uDD1B ",
        "\uD83E\uDD1C\uD83E\uDD1B ",
        "\uD83E\uDD1C\uD83E\uDD1B ",
        "\uD83E\uDD1C\uD83E\uDD1B ",
        "\uD83E\uDD1C\uD83E\uDD1B ",
        "\uD83E\uDD1C\uD83E\uDD1B "
      ]
    },
    soccerHeader: {
      interval: 80,
      frames: [
        " \uD83E\uDDD1       \uD83E\uDDD1 ",
        "\uD83E\uDDD1        \uD83E\uDDD1 ",
        "\uD83E\uDDD1        \uD83E\uDDD1 ",
        "\uD83E\uDDD1        \uD83E\uDDD1 ",
        "\uD83E\uDDD1        \uD83E\uDDD1 ",
        "\uD83E\uDDD1        \uD83E\uDDD1 ",
        "\uD83E\uDDD1       \uD83E\uDDD1  ",
        "\uD83E\uDDD1        \uD83E\uDDD1 ",
        "\uD83E\uDDD1        \uD83E\uDDD1 ",
        "\uD83E\uDDD1        \uD83E\uDDD1 ",
        "\uD83E\uDDD1        \uD83E\uDDD1 ",
        "\uD83E\uDDD1        \uD83E\uDDD1 "
      ]
    },
    mindblown: {
      interval: 160,
      frames: [
        "\uD83D\uDE10 ",
        "\uD83D\uDE10 ",
        "\uD83D\uDE2E ",
        "\uD83D\uDE2E ",
        "\uD83D\uDE26 ",
        "\uD83D\uDE26 ",
        "\uD83D\uDE27 ",
        "\uD83D\uDE27 ",
        "\uD83E\uDD2F ",
        "\uD83D\uDCA5 ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    speaker: {
      interval: 160,
      frames: [
        "\uD83D\uDD08 ",
        "\uD83D\uDD09 ",
        "\uD83D\uDD0A ",
        "\uD83D\uDD09 "
      ]
    },
    orangePulse: {
      interval: 100,
      frames: [
        "\uD83D\uDD38 ",
        "\uD83D\uDD36 ",
        "\uD83D\uDFE0 ",
        "\uD83D\uDFE0 ",
        "\uD83D\uDD36 "
      ]
    },
    bluePulse: {
      interval: 100,
      frames: [
        "\uD83D\uDD39 ",
        "\uD83D\uDD37 ",
        "\uD83D\uDD35 ",
        "\uD83D\uDD35 ",
        "\uD83D\uDD37 "
      ]
    },
    orangeBluePulse: {
      interval: 100,
      frames: [
        "\uD83D\uDD38 ",
        "\uD83D\uDD36 ",
        "\uD83D\uDFE0 ",
        "\uD83D\uDFE0 ",
        "\uD83D\uDD36 ",
        "\uD83D\uDD39 ",
        "\uD83D\uDD37 ",
        "\uD83D\uDD35 ",
        "\uD83D\uDD35 ",
        "\uD83D\uDD37 "
      ]
    },
    timeTravel: {
      interval: 100,
      frames: [
        "\uD83D\uDD5B ",
        "\uD83D\uDD5A ",
        "\uD83D\uDD59 ",
        "\uD83D\uDD58 ",
        "\uD83D\uDD57 ",
        "\uD83D\uDD56 ",
        "\uD83D\uDD55 ",
        "\uD83D\uDD54 ",
        "\uD83D\uDD53 ",
        "\uD83D\uDD52 ",
        "\uD83D\uDD51 ",
        "\uD83D\uDD50 "
      ]
    },
    aesthetic: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dwarfFortress: {
      interval: 80,
      frames: [
        "   ",
        "  ",
        "  ",
        "  ",
        "  ",
        "  ",
        "  ",
        "  ",
        "  ",
        "   ",
        "   ",
        "   ",
        "   ",
        "   ",
        "   ",
        "   ",
        "   ",
        "   ",
        "    ",
        "    ",
        "    ",
        "    ",
        "    ",
        "    ",
        "    ",
        "    ",
        "    ",
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
        "      ",
        "      ",
        "      ",
        "      ",
        "      ",
        "      ",
        "      ",
        "      ",
        "      ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "          ",
        "          ",
        "          ",
        "          ",
        "          ",
        "          ",
        "          ",
        "          ",
        "          ",
        "           ",
        "          &",
        "         &",
        "         &",
        "         &",
        "        & ",
        "         & ",
        "        &  ",
        "        &  ",
        "       &   ",
        "       &   ",
        "      &    ",
        "      &    ",
        "      &     ",
        "      &     ",
        "     &     ",
        "     &     ",
        "    &      ",
        "    &      ",
        "   &      ",
        "   &      ",
        "  &       ",
        "  &       ",
        " &       ",
        " &       ",
        "&        ",
        "&        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "       ",
        "       ",
        "       ",
        "       ",
        "      ",
        "      ",
        "      ",
        "      ",
        "     ",
        "     ",
        "     ",
        "     ",
        "    ",
        "    ",
        "    ",
        "    ",
        "   ",
        "   ",
        "   ",
        "   ",
        "   "
      ]
    }
  };
});

// node_modules/cli-spinners/index.js
var require_cli_spinners = __commonJS((exports, module) => {
  var spinners = Object.assign({}, require_spinners());
  var spinnersList = Object.keys(spinners);
  Object.defineProperty(spinners, "random", {
    get() {
      const randomIndex = Math.floor(Math.random() * spinnersList.length);
      const spinnerName = spinnersList[randomIndex];
      return spinners[spinnerName];
    }
  });
  module.exports = spinners;
});

// node_modules/emoji-regex/index.js
var require_emoji_regex2 = __commonJS((exports, module) => {
  module.exports = () => {
    return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
  };
});

// node_modules/traverse/index.js
var require_traverse = __commonJS((exports, module) => {
  module.exports = Traverse;
  function Traverse(obj) {
    if (!(this instanceof Traverse))
      return new Traverse(obj);
    this.value = obj;
  }
  Traverse.prototype.get = function(ps) {
    var node = this.value;
    for (var i = 0;i < ps.length; i++) {
      var key11 = ps[i];
      if (!Object.hasOwnProperty.call(node, key11)) {
        node = undefined;
        break;
      }
      node = node[key11];
    }
    return node;
  };
  Traverse.prototype.set = function(ps, value) {
    var node = this.value;
    for (var i = 0;i < ps.length - 1; i++) {
      var key11 = ps[i];
      if (!Object.hasOwnProperty.call(node, key11))
        node[key11] = {};
      node = node[key11];
    }
    node[ps[i]] = value;
    return value;
  };
  Traverse.prototype.map = function(cb) {
    return walk(this.value, cb, true);
  };
  Traverse.prototype.forEach = function(cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
  };
  Traverse.prototype.reduce = function(cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function(x) {
      if (!this.isRoot || !skip) {
        acc = cb.call(this, acc, x);
      }
    });
    return acc;
  };
  Traverse.prototype.deepEqual = function(obj) {
    if (arguments.length !== 1) {
      throw new Error("deepEqual requires exactly one object to compare against");
    }
    var equal = true;
    var node = obj;
    this.forEach(function(y) {
      var notEqual = function() {
        equal = false;
        return;
      }.bind(this);
      if (!this.isRoot) {
        if (typeof node !== "object")
          return notEqual();
        node = node[this.key];
      }
      var x = node;
      this.post(function() {
        node = x;
      });
      var toS = function(o) {
        return Object.prototype.toString.call(o);
      };
      if (this.circular) {
        if (Traverse(obj).get(this.circular.path) !== x)
          notEqual();
      } else if (typeof x !== typeof y) {
        notEqual();
      } else if (x === null || y === null || x === undefined || y === undefined) {
        if (x !== y)
          notEqual();
      } else if (x.__proto__ !== y.__proto__) {
        notEqual();
      } else if (x === y) {
      } else if (typeof x === "function") {
        if (x instanceof RegExp) {
          if (x.toString() != y.toString())
            notEqual();
        } else if (x !== y)
          notEqual();
      } else if (typeof x === "object") {
        if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
          if (toS(x) !== toS(y)) {
            notEqual();
          }
        } else if (x instanceof Date || y instanceof Date) {
          if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {
            notEqual();
          }
        } else {
          var kx = Object.keys(x);
          var ky = Object.keys(y);
          if (kx.length !== ky.length)
            return notEqual();
          for (var i = 0;i < kx.length; i++) {
            var k = kx[i];
            if (!Object.hasOwnProperty.call(y, k)) {
              notEqual();
            }
          }
        }
      }
    });
    return equal;
  };
  Traverse.prototype.paths = function() {
    var acc = [];
    this.forEach(function(x) {
      acc.push(this.path);
    });
    return acc;
  };
  Traverse.prototype.nodes = function() {
    var acc = [];
    this.forEach(function(x) {
      acc.push(this.node);
    });
    return acc;
  };
  Traverse.prototype.clone = function() {
    var parents = [], nodes = [];
    return function clone(src) {
      for (var i = 0;i < parents.length; i++) {
        if (parents[i] === src) {
          return nodes[i];
        }
      }
      if (typeof src === "object" && src !== null) {
        var dst = copy(src);
        parents.push(src);
        nodes.push(dst);
        Object.keys(src).forEach(function(key11) {
          dst[key11] = clone(src[key11]);
        });
        parents.pop();
        nodes.pop();
        return dst;
      } else {
        return src;
      }
    }(this.value);
  };
  function walk(root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    return function walker(node_) {
      var node = immutable ? copy(node_) : node_;
      var modifiers = {};
      var state = {
        node,
        node_,
        path: [].concat(path),
        parent: parents.slice(-1)[0],
        key: path.slice(-1)[0],
        isRoot: path.length === 0,
        level: path.length,
        circular: null,
        update: function(x) {
          if (!state.isRoot) {
            state.parent.node[state.key] = x;
          }
          state.node = x;
        },
        delete: function() {
          delete state.parent.node[state.key];
        },
        remove: function() {
          if (Array.isArray(state.parent.node)) {
            state.parent.node.splice(state.key, 1);
          } else {
            delete state.parent.node[state.key];
          }
        },
        before: function(f) {
          modifiers.before = f;
        },
        after: function(f) {
          modifiers.after = f;
        },
        pre: function(f) {
          modifiers.pre = f;
        },
        post: function(f) {
          modifiers.post = f;
        },
        stop: function() {
          alive = false;
        }
      };
      if (!alive)
        return state;
      if (typeof node === "object" && node !== null) {
        state.isLeaf = Object.keys(node).length == 0;
        for (var i = 0;i < parents.length; i++) {
          if (parents[i].node_ === node_) {
            state.circular = parents[i];
            break;
          }
        }
      } else {
        state.isLeaf = true;
      }
      state.notLeaf = !state.isLeaf;
      state.notRoot = !state.isRoot;
      var ret = cb.call(state, state.node);
      if (ret !== undefined && state.update)
        state.update(ret);
      if (modifiers.before)
        modifiers.before.call(state, state.node);
      if (typeof state.node == "object" && state.node !== null && !state.circular) {
        parents.push(state);
        var keys = Object.keys(state.node);
        keys.forEach(function(key11, i2) {
          path.push(key11);
          if (modifiers.pre)
            modifiers.pre.call(state, state.node[key11], key11);
          var child = walker(state.node[key11]);
          if (immutable && Object.hasOwnProperty.call(state.node, key11)) {
            state.node[key11] = child.node;
          }
          child.isLast = i2 == keys.length - 1;
          child.isFirst = i2 == 0;
          if (modifiers.post)
            modifiers.post.call(state, child);
          path.pop();
        });
        parents.pop();
      }
      if (modifiers.after)
        modifiers.after.call(state, state.node);
      return state;
    }(root).node;
  }
  Object.keys(Traverse.prototype).forEach(function(key11) {
    Traverse[key11] = function(obj) {
      var args = [].slice.call(arguments, 1);
      var t = Traverse(obj);
      return t[key11].apply(t, args);
    };
  });
  function copy(src) {
    if (typeof src === "object" && src !== null) {
      var dst;
      if (Array.isArray(src)) {
        dst = [];
      } else if (src instanceof Date) {
        dst = new Date(src);
      } else if (src instanceof Boolean) {
        dst = new Boolean(src);
      } else if (src instanceof Number) {
        dst = new Number(src);
      } else if (src instanceof String) {
        dst = new String(src);
      } else {
        dst = Object.create(Object.getPrototypeOf(src));
      }
      Object.keys(src).forEach(function(key11) {
        dst[key11] = src[key11];
      });
      return dst;
    } else
      return src;
  }
});

// node_modules/chainsaw/index.js
var require_chainsaw = __commonJS((exports, module) => {
  var Traverse = require_traverse();
  var EventEmitter = __require("events").EventEmitter;
  module.exports = Chainsaw;
  function Chainsaw(builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined)
      saw.handlers = r;
    saw.record();
    return saw.chain();
  }
  Chainsaw.light = function ChainsawLight(builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined)
      saw.handlers = r;
    return saw.chain();
  };
  Chainsaw.saw = function(builder, handlers) {
    var saw = new EventEmitter;
    saw.handlers = handlers;
    saw.actions = [];
    saw.chain = function() {
      var ch = Traverse(saw.handlers).map(function(node) {
        if (this.isRoot)
          return node;
        var ps = this.path;
        if (typeof node === "function") {
          this.update(function() {
            saw.actions.push({
              path: ps,
              args: [].slice.call(arguments)
            });
            return ch;
          });
        }
      });
      process.nextTick(function() {
        saw.emit("begin");
        saw.next();
      });
      return ch;
    };
    saw.pop = function() {
      return saw.actions.shift();
    };
    saw.next = function() {
      var action = saw.pop();
      if (!action) {
        saw.emit("end");
      } else if (!action.trap) {
        var node = saw.handlers;
        action.path.forEach(function(key11) {
          node = node[key11];
        });
        node.apply(saw.handlers, action.args);
      }
    };
    saw.nest = function(cb) {
      var args = [].slice.call(arguments, 1);
      var autonext = true;
      if (typeof cb === "boolean") {
        var autonext = cb;
        cb = args.shift();
      }
      var s = Chainsaw.saw(builder, {});
      var r = builder.call(s.handlers, s);
      if (r !== undefined)
        s.handlers = r;
      if (typeof saw.step !== "undefined") {
        s.record();
      }
      cb.apply(s.chain(), args);
      if (autonext !== false)
        s.on("end", saw.next);
    };
    saw.record = function() {
      upgradeChainsaw(saw);
    };
    ["trap", "down", "jump"].forEach(function(method) {
      saw[method] = function() {
        throw new Error("To use the trap, down and jump features, please " + "call record() first to start recording actions.");
      };
    });
    return saw;
  };
  function upgradeChainsaw(saw) {
    saw.step = 0;
    saw.pop = function() {
      return saw.actions[saw.step++];
    };
    saw.trap = function(name, cb) {
      var ps = Array.isArray(name) ? name : [name];
      saw.actions.push({
        path: ps,
        step: saw.step,
        cb,
        trap: true
      });
    };
    saw.down = function(name) {
      var ps = (Array.isArray(name) ? name : [name]).join("/");
      var i = saw.actions.slice(saw.step).map(function(x) {
        if (x.trap && x.step <= saw.step)
          return false;
        return x.path.join("/") == ps;
      }).indexOf(true);
      if (i >= 0)
        saw.step += i;
      else
        saw.step = saw.actions.length;
      var act = saw.actions[saw.step - 1];
      if (act && act.trap) {
        saw.step = act.step;
        act.cb();
      } else
        saw.next();
    };
    saw.jump = function(step) {
      saw.step = step;
      saw.next();
    };
  }
});

// node_modules/buffers/index.js
var require_buffers = __commonJS((exports, module) => {
  module.exports = Buffers;
  function Buffers(bufs) {
    if (!(this instanceof Buffers))
      return new Buffers(bufs);
    this.buffers = bufs || [];
    this.length = this.buffers.reduce(function(size, buf) {
      return size + buf.length;
    }, 0);
  }
  Buffers.prototype.push = function() {
    for (var i = 0;i < arguments.length; i++) {
      if (!Buffer.isBuffer(arguments[i])) {
        throw new TypeError("Tried to push a non-buffer");
      }
    }
    for (var i = 0;i < arguments.length; i++) {
      var buf = arguments[i];
      this.buffers.push(buf);
      this.length += buf.length;
    }
    return this.length;
  };
  Buffers.prototype.unshift = function() {
    for (var i = 0;i < arguments.length; i++) {
      if (!Buffer.isBuffer(arguments[i])) {
        throw new TypeError("Tried to unshift a non-buffer");
      }
    }
    for (var i = 0;i < arguments.length; i++) {
      var buf = arguments[i];
      this.buffers.unshift(buf);
      this.length += buf.length;
    }
    return this.length;
  };
  Buffers.prototype.copy = function(dst, dStart, start, end) {
    return this.slice(start, end).copy(dst, dStart, 0, end - start);
  };
  Buffers.prototype.splice = function(i, howMany) {
    var buffers = this.buffers;
    var index = i >= 0 ? i : this.length - i;
    var reps = [].slice.call(arguments, 2);
    if (howMany === undefined) {
      howMany = this.length - index;
    } else if (howMany > this.length - index) {
      howMany = this.length - index;
    }
    for (var i = 0;i < reps.length; i++) {
      this.length += reps[i].length;
    }
    var removed = new Buffers;
    var bytes = 0;
    var startBytes = 0;
    for (var ii = 0;ii < buffers.length && startBytes + buffers[ii].length < index; ii++) {
      startBytes += buffers[ii].length;
    }
    if (index - startBytes > 0) {
      var start = index - startBytes;
      if (start + howMany < buffers[ii].length) {
        removed.push(buffers[ii].slice(start, start + howMany));
        var orig = buffers[ii];
        var buf0 = new Buffer(start);
        for (var i = 0;i < start; i++) {
          buf0[i] = orig[i];
        }
        var buf1 = new Buffer(orig.length - start - howMany);
        for (var i = start + howMany;i < orig.length; i++) {
          buf1[i - howMany - start] = orig[i];
        }
        if (reps.length > 0) {
          var reps_ = reps.slice();
          reps_.unshift(buf0);
          reps_.push(buf1);
          buffers.splice.apply(buffers, [ii, 1].concat(reps_));
          ii += reps_.length;
          reps = [];
        } else {
          buffers.splice(ii, 1, buf0, buf1);
          ii += 2;
        }
      } else {
        removed.push(buffers[ii].slice(start));
        buffers[ii] = buffers[ii].slice(0, start);
        ii++;
      }
    }
    if (reps.length > 0) {
      buffers.splice.apply(buffers, [ii, 0].concat(reps));
      ii += reps.length;
    }
    while (removed.length < howMany) {
      var buf = buffers[ii];
      var len = buf.length;
      var take = Math.min(len, howMany - removed.length);
      if (take === len) {
        removed.push(buf);
        buffers.splice(ii, 1);
      } else {
        removed.push(buf.slice(0, take));
        buffers[ii] = buffers[ii].slice(take);
      }
    }
    this.length -= removed.length;
    return removed;
  };
  Buffers.prototype.slice = function(i, j) {
    var buffers = this.buffers;
    if (j === undefined)
      j = this.length;
    if (i === undefined)
      i = 0;
    if (j > this.length)
      j = this.length;
    var startBytes = 0;
    for (var si = 0;si < buffers.length && startBytes + buffers[si].length <= i; si++) {
      startBytes += buffers[si].length;
    }
    var target = new Buffer(j - i);
    var ti = 0;
    for (var ii = si;ti < j - i && ii < buffers.length; ii++) {
      var len = buffers[ii].length;
      var start = ti === 0 ? i - startBytes : 0;
      var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
      buffers[ii].copy(target, ti, start, end);
      ti += end - start;
    }
    return target;
  };
  Buffers.prototype.pos = function(i) {
    if (i < 0 || i >= this.length)
      throw new Error("oob");
    var l = i, bi = 0, bu = null;
    for (;; ) {
      bu = this.buffers[bi];
      if (l < bu.length) {
        return { buf: bi, offset: l };
      } else {
        l -= bu.length;
      }
      bi++;
    }
  };
  Buffers.prototype.get = function get(i) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].get(pos.offset);
  };
  Buffers.prototype.set = function set(i, b) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].set(pos.offset, b);
  };
  Buffers.prototype.indexOf = function(needle, offset) {
    if (typeof needle === "string") {
      needle = new Buffer(needle);
    } else if (needle instanceof Buffer) {
    } else {
      throw new Error("Invalid type for a search string");
    }
    if (!needle.length) {
      return 0;
    }
    if (!this.length) {
      return -1;
    }
    var i = 0, j = 0, match = 0, mstart, pos = 0;
    if (offset) {
      var p = this.pos(offset);
      i = p.buf;
      j = p.offset;
      pos = offset;
    }
    for (;; ) {
      while (j >= this.buffers[i].length) {
        j = 0;
        i++;
        if (i >= this.buffers.length) {
          return -1;
        }
      }
      var char = this.buffers[i][j];
      if (char == needle[match]) {
        if (match == 0) {
          mstart = {
            i,
            j,
            pos
          };
        }
        match++;
        if (match == needle.length) {
          return mstart.pos;
        }
      } else if (match != 0) {
        i = mstart.i;
        j = mstart.j;
        pos = mstart.pos;
        match = 0;
      }
      j++;
      pos++;
    }
  };
  Buffers.prototype.toBuffer = function() {
    return this.slice();
  };
  Buffers.prototype.toString = function(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
});

// node_modules/binary/lib/vars.js
var require_vars = __commonJS((exports, module) => {
  module.exports = function(store) {
    function getset(name, value) {
      var node = vars.store;
      var keys = name.split(".");
      keys.slice(0, -1).forEach(function(k) {
        if (node[k] === undefined)
          node[k] = {};
        node = node[k];
      });
      var key11 = keys[keys.length - 1];
      if (arguments.length == 1) {
        return node[key11];
      } else {
        return node[key11] = value;
      }
    }
    var vars = {
      get: function(name) {
        return getset(name);
      },
      set: function(name, value) {
        return getset(name, value);
      },
      store: store || {}
    };
    return vars;
  };
});

// node_modules/binary/index.js
var require_binary = __commonJS((exports, module) => {
  var Chainsaw = require_chainsaw();
  var EventEmitter = __require("events").EventEmitter;
  var Buffers = require_buffers();
  var Vars = require_vars();
  var Stream = __require("stream").Stream;
  exports = module.exports = function(bufOrEm, eventName) {
    if (Buffer.isBuffer(bufOrEm)) {
      return exports.parse(bufOrEm);
    }
    var s = exports.stream();
    if (bufOrEm && bufOrEm.pipe) {
      bufOrEm.pipe(s);
    } else if (bufOrEm) {
      bufOrEm.on(eventName || "data", function(buf) {
        s.write(buf);
      });
      bufOrEm.on("end", function() {
        s.end();
      });
    }
    return s;
  };
  exports.stream = function(input) {
    if (input)
      return exports.apply(null, arguments);
    var pending = null;
    function getBytes(bytes, cb, skip) {
      pending = {
        bytes,
        skip,
        cb: function(buf) {
          pending = null;
          cb(buf);
        }
      };
      dispatch();
    }
    var offset = null;
    function dispatch() {
      if (!pending) {
        if (caughtEnd)
          done = true;
        return;
      }
      if (typeof pending === "function") {
        pending();
      } else {
        var bytes = offset + pending.bytes;
        if (buffers.length >= bytes) {
          var buf;
          if (offset == null) {
            buf = buffers.splice(0, bytes);
            if (!pending.skip) {
              buf = buf.slice();
            }
          } else {
            if (!pending.skip) {
              buf = buffers.slice(offset, bytes);
            }
            offset = bytes;
          }
          if (pending.skip) {
            pending.cb();
          } else {
            pending.cb(buf);
          }
        }
      }
    }
    function builder(saw) {
      function next() {
        if (!done)
          saw.next();
      }
      var self2 = words(function(bytes, cb) {
        return function(name) {
          getBytes(bytes, function(buf) {
            vars.set(name, cb(buf));
            next();
          });
        };
      });
      self2.tap = function(cb) {
        saw.nest(cb, vars.store);
      };
      self2.into = function(key11, cb) {
        if (!vars.get(key11))
          vars.set(key11, {});
        var parent = vars;
        vars = Vars(parent.get(key11));
        saw.nest(function() {
          cb.apply(this, arguments);
          this.tap(function() {
            vars = parent;
          });
        }, vars.store);
      };
      self2.flush = function() {
        vars.store = {};
        next();
      };
      self2.loop = function(cb) {
        var end = false;
        saw.nest(false, function loop() {
          this.vars = vars.store;
          cb.call(this, function() {
            end = true;
            next();
          }, vars.store);
          this.tap(function() {
            if (end)
              saw.next();
            else
              loop.call(this);
          }.bind(this));
        }, vars.store);
      };
      self2.buffer = function(name, bytes) {
        if (typeof bytes === "string") {
          bytes = vars.get(bytes);
        }
        getBytes(bytes, function(buf) {
          vars.set(name, buf);
          next();
        });
      };
      self2.skip = function(bytes) {
        if (typeof bytes === "string") {
          bytes = vars.get(bytes);
        }
        getBytes(bytes, function() {
          next();
        });
      };
      self2.scan = function find(name, search) {
        if (typeof search === "string") {
          search = new Buffer(search);
        } else if (!Buffer.isBuffer(search)) {
          throw new Error("search must be a Buffer or a string");
        }
        var taken = 0;
        pending = function() {
          var pos = buffers.indexOf(search, offset + taken);
          var i = pos - offset - taken;
          if (pos !== -1) {
            pending = null;
            if (offset != null) {
              vars.set(name, buffers.slice(offset, offset + taken + i));
              offset += taken + i + search.length;
            } else {
              vars.set(name, buffers.slice(0, taken + i));
              buffers.splice(0, taken + i + search.length);
            }
            next();
            dispatch();
          } else {
            i = Math.max(buffers.length - search.length - offset - taken, 0);
          }
          taken += i;
        };
        dispatch();
      };
      self2.peek = function(cb) {
        offset = 0;
        saw.nest(function() {
          cb.call(this, vars.store);
          this.tap(function() {
            offset = null;
          });
        });
      };
      return self2;
    }
    var stream = Chainsaw.light(builder);
    stream.writable = true;
    var buffers = Buffers();
    stream.write = function(buf) {
      buffers.push(buf);
      dispatch();
    };
    var vars = Vars();
    var done = false, caughtEnd = false;
    stream.end = function() {
      caughtEnd = true;
    };
    stream.pipe = Stream.prototype.pipe;
    Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function(name) {
      stream[name] = EventEmitter.prototype[name];
    });
    return stream;
  };
  exports.parse = function parse(buffer) {
    var self2 = words(function(bytes, cb) {
      return function(name) {
        if (offset + bytes <= buffer.length) {
          var buf = buffer.slice(offset, offset + bytes);
          offset += bytes;
          vars.set(name, cb(buf));
        } else {
          vars.set(name, null);
        }
        return self2;
      };
    });
    var offset = 0;
    var vars = Vars();
    self2.vars = vars.store;
    self2.tap = function(cb) {
      cb.call(self2, vars.store);
      return self2;
    };
    self2.into = function(key11, cb) {
      if (!vars.get(key11)) {
        vars.set(key11, {});
      }
      var parent = vars;
      vars = Vars(parent.get(key11));
      cb.call(self2, vars.store);
      vars = parent;
      return self2;
    };
    self2.loop = function(cb) {
      var end = false;
      var ender = function() {
        end = true;
      };
      while (end === false) {
        cb.call(self2, ender, vars.store);
      }
      return self2;
    };
    self2.buffer = function(name, size) {
      if (typeof size === "string") {
        size = vars.get(size);
      }
      var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
      offset += size;
      vars.set(name, buf);
      return self2;
    };
    self2.skip = function(bytes) {
      if (typeof bytes === "string") {
        bytes = vars.get(bytes);
      }
      offset += bytes;
      return self2;
    };
    self2.scan = function(name, search) {
      if (typeof search === "string") {
        search = new Buffer(search);
      } else if (!Buffer.isBuffer(search)) {
        throw new Error("search must be a Buffer or a string");
      }
      vars.set(name, null);
      for (var i = 0;i + offset <= buffer.length - search.length + 1; i++) {
        for (var j = 0;j < search.length && buffer[offset + i + j] === search[j]; j++)
          ;
        if (j === search.length)
          break;
      }
      vars.set(name, buffer.slice(offset, offset + i));
      offset += i + search.length;
      return self2;
    };
    self2.peek = function(cb) {
      var was = offset;
      cb.call(self2, vars.store);
      offset = was;
      return self2;
    };
    self2.flush = function() {
      vars.store = {};
      return self2;
    };
    self2.eof = function() {
      return offset >= buffer.length;
    };
    return self2;
  };
  function decodeLEu(bytes) {
    var acc = 0;
    for (var i = 0;i < bytes.length; i++) {
      acc += Math.pow(256, i) * bytes[i];
    }
    return acc;
  }
  function decodeBEu(bytes) {
    var acc = 0;
    for (var i = 0;i < bytes.length; i++) {
      acc += Math.pow(256, bytes.length - i - 1) * bytes[i];
    }
    return acc;
  }
  function decodeBEs(bytes) {
    var val = decodeBEu(bytes);
    if ((bytes[0] & 128) == 128) {
      val -= Math.pow(256, bytes.length);
    }
    return val;
  }
  function decodeLEs(bytes) {
    var val = decodeLEu(bytes);
    if ((bytes[bytes.length - 1] & 128) == 128) {
      val -= Math.pow(256, bytes.length);
    }
    return val;
  }
  function words(decode) {
    var self2 = {};
    [1, 2, 4, 8].forEach(function(bytes) {
      var bits = bytes * 8;
      self2["word" + bits + "le"] = self2["word" + bits + "lu"] = decode(bytes, decodeLEu);
      self2["word" + bits + "ls"] = decode(bytes, decodeLEs);
      self2["word" + bits + "be"] = self2["word" + bits + "bu"] = decode(bytes, decodeBEu);
      self2["word" + bits + "bs"] = decode(bytes, decodeBEs);
    });
    self2.word8 = self2.word8u = self2.word8be;
    self2.word8s = self2.word8bs;
    return self2;
  }
});

// node_modules/unzip-stream/lib/matcher-stream.js
var require_matcher_stream = __commonJS((exports, module) => {
  var Transform = __require("stream").Transform;
  var util = __require("util");
  function MatcherStream(patternDesc, matchFn) {
    if (!(this instanceof MatcherStream)) {
      return new MatcherStream;
    }
    Transform.call(this);
    var p = typeof patternDesc === "object" ? patternDesc.pattern : patternDesc;
    this.pattern = Buffer.isBuffer(p) ? p : Buffer.from(p);
    this.requiredLength = this.pattern.length;
    if (patternDesc.requiredExtraSize)
      this.requiredLength += patternDesc.requiredExtraSize;
    this.data = new Buffer("");
    this.bytesSoFar = 0;
    this.matchFn = matchFn;
  }
  util.inherits(MatcherStream, Transform);
  MatcherStream.prototype.checkDataChunk = function(ignoreMatchZero) {
    var enoughData = this.data.length >= this.requiredLength;
    if (!enoughData) {
      return;
    }
    var matchIndex = this.data.indexOf(this.pattern, ignoreMatchZero ? 1 : 0);
    if (matchIndex >= 0 && matchIndex + this.requiredLength > this.data.length) {
      if (matchIndex > 0) {
        var packet = this.data.slice(0, matchIndex);
        this.push(packet);
        this.bytesSoFar += matchIndex;
        this.data = this.data.slice(matchIndex);
      }
      return;
    }
    if (matchIndex === -1) {
      var packetLen = this.data.length - this.requiredLength + 1;
      var packet = this.data.slice(0, packetLen);
      this.push(packet);
      this.bytesSoFar += packetLen;
      this.data = this.data.slice(packetLen);
      return;
    }
    if (matchIndex > 0) {
      var packet = this.data.slice(0, matchIndex);
      this.data = this.data.slice(matchIndex);
      this.push(packet);
      this.bytesSoFar += matchIndex;
    }
    var finished = this.matchFn ? this.matchFn(this.data, this.bytesSoFar) : true;
    if (finished) {
      this.data = new Buffer("");
      return;
    }
    return true;
  };
  MatcherStream.prototype._transform = function(chunk, encoding, cb) {
    this.data = Buffer.concat([this.data, chunk]);
    var firstIteration = true;
    while (this.checkDataChunk(!firstIteration)) {
      firstIteration = false;
    }
    cb();
  };
  MatcherStream.prototype._flush = function(cb) {
    if (this.data.length > 0) {
      var firstIteration = true;
      while (this.checkDataChunk(!firstIteration)) {
        firstIteration = false;
      }
    }
    if (this.data.length > 0) {
      this.push(this.data);
      this.data = null;
    }
    cb();
  };
  module.exports = MatcherStream;
});

// node_modules/unzip-stream/lib/entry.js
var require_entry = __commonJS((exports, module) => {
  var stream = __require("stream");
  var inherits = __require("util").inherits;
  function Entry() {
    if (!(this instanceof Entry)) {
      return new Entry;
    }
    stream.PassThrough.call(this);
    this.path = null;
    this.type = null;
    this.isDirectory = false;
  }
  inherits(Entry, stream.PassThrough);
  Entry.prototype.autodrain = function() {
    return this.pipe(new stream.Transform({ transform: function(d, e, cb) {
      cb();
    } }));
  };
  module.exports = Entry;
});

// node_modules/unzip-stream/lib/unzip-stream.js
var require_unzip_stream = __commonJS((exports, module) => {
  var binary = require_binary();
  var stream = __require("stream");
  var util = __require("util");
  var zlib = __require("zlib");
  var MatcherStream = require_matcher_stream();
  var Entry = require_entry();
  var states = {
    STREAM_START: 0,
    START: 1,
    LOCAL_FILE_HEADER: 2,
    LOCAL_FILE_HEADER_SUFFIX: 3,
    FILE_DATA: 4,
    FILE_DATA_END: 5,
    DATA_DESCRIPTOR: 6,
    CENTRAL_DIRECTORY_FILE_HEADER: 7,
    CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX: 8,
    CDIR64_END: 9,
    CDIR64_END_DATA_SECTOR: 10,
    CDIR64_LOCATOR: 11,
    CENTRAL_DIRECTORY_END: 12,
    CENTRAL_DIRECTORY_END_COMMENT: 13,
    TRAILING_JUNK: 14,
    ERROR: 99
  };
  var FOUR_GIGS = 4294967296;
  var SIG_LOCAL_FILE_HEADER = 67324752;
  var SIG_DATA_DESCRIPTOR = 134695760;
  var SIG_CDIR_RECORD = 33639248;
  var SIG_CDIR64_RECORD_END = 101075792;
  var SIG_CDIR64_LOCATOR_END = 117853008;
  var SIG_CDIR_RECORD_END = 101010256;
  function UnzipStream(options) {
    if (!(this instanceof UnzipStream)) {
      return new UnzipStream(options);
    }
    stream.Transform.call(this);
    this.options = options || {};
    this.data = new Buffer("");
    this.state = states.STREAM_START;
    this.skippedBytes = 0;
    this.parsedEntity = null;
    this.outStreamInfo = {};
  }
  util.inherits(UnzipStream, stream.Transform);
  UnzipStream.prototype.processDataChunk = function(chunk) {
    var requiredLength;
    switch (this.state) {
      case states.STREAM_START:
      case states.START:
        requiredLength = 4;
        break;
      case states.LOCAL_FILE_HEADER:
        requiredLength = 26;
        break;
      case states.LOCAL_FILE_HEADER_SUFFIX:
        requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength;
        break;
      case states.DATA_DESCRIPTOR:
        requiredLength = 12;
        break;
      case states.CENTRAL_DIRECTORY_FILE_HEADER:
        requiredLength = 42;
        break;
      case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
        requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength + this.parsedEntity.fileCommentLength;
        break;
      case states.CDIR64_END:
        requiredLength = 52;
        break;
      case states.CDIR64_END_DATA_SECTOR:
        requiredLength = this.parsedEntity.centralDirectoryRecordSize - 44;
        break;
      case states.CDIR64_LOCATOR:
        requiredLength = 16;
        break;
      case states.CENTRAL_DIRECTORY_END:
        requiredLength = 18;
        break;
      case states.CENTRAL_DIRECTORY_END_COMMENT:
        requiredLength = this.parsedEntity.commentLength;
        break;
      case states.FILE_DATA:
        return 0;
      case states.FILE_DATA_END:
        return 0;
      case states.TRAILING_JUNK:
        if (this.options.debug)
          console.log("found", chunk.length, "bytes of TRAILING_JUNK");
        return chunk.length;
      default:
        return chunk.length;
    }
    var chunkLength = chunk.length;
    if (chunkLength < requiredLength) {
      return 0;
    }
    switch (this.state) {
      case states.STREAM_START:
      case states.START:
        var signature = chunk.readUInt32LE(0);
        switch (signature) {
          case SIG_LOCAL_FILE_HEADER:
            this.state = states.LOCAL_FILE_HEADER;
            break;
          case SIG_CDIR_RECORD:
            this.state = states.CENTRAL_DIRECTORY_FILE_HEADER;
            break;
          case SIG_CDIR64_RECORD_END:
            this.state = states.CDIR64_END;
            break;
          case SIG_CDIR64_LOCATOR_END:
            this.state = states.CDIR64_LOCATOR;
            break;
          case SIG_CDIR_RECORD_END:
            this.state = states.CENTRAL_DIRECTORY_END;
            break;
          default:
            var isStreamStart = this.state === states.STREAM_START;
            if (!isStreamStart && (signature & 65535) !== 19280 && this.skippedBytes < 26) {
              var remaining = signature;
              var toSkip = 4;
              for (var i = 1;i < 4 && remaining !== 0; i++) {
                remaining = remaining >>> 8;
                if ((remaining & 255) === 80) {
                  toSkip = i;
                  break;
                }
              }
              this.skippedBytes += toSkip;
              if (this.options.debug)
                console.log("Skipped", this.skippedBytes, "bytes");
              return toSkip;
            }
            this.state = states.ERROR;
            var errMsg = isStreamStart ? "Not a valid zip file" : "Invalid signature in zip file";
            if (this.options.debug) {
              var sig = chunk.readUInt32LE(0);
              var asString;
              try {
                asString = chunk.slice(0, 4).toString();
              } catch (e) {
              }
              console.log("Unexpected signature in zip file: 0x" + sig.toString(16), '"' + asString + '", skipped', this.skippedBytes, "bytes");
            }
            this.emit("error", new Error(errMsg));
            return chunk.length;
        }
        this.skippedBytes = 0;
        return requiredLength;
      case states.LOCAL_FILE_HEADER:
        this.parsedEntity = this._readFile(chunk);
        this.state = states.LOCAL_FILE_HEADER_SUFFIX;
        return requiredLength;
      case states.LOCAL_FILE_HEADER_SUFFIX:
        var entry = new Entry;
        var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
        entry.path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
        var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
        var extra = this._readExtraFields(extraDataBuffer);
        if (extra && extra.parsed) {
          if (extra.parsed.path && !isUtf8) {
            entry.path = extra.parsed.path;
          }
          if (Number.isFinite(extra.parsed.uncompressedSize) && this.parsedEntity.uncompressedSize === FOUR_GIGS - 1) {
            this.parsedEntity.uncompressedSize = extra.parsed.uncompressedSize;
          }
          if (Number.isFinite(extra.parsed.compressedSize) && this.parsedEntity.compressedSize === FOUR_GIGS - 1) {
            this.parsedEntity.compressedSize = extra.parsed.compressedSize;
          }
        }
        this.parsedEntity.extra = extra.parsed || {};
        if (this.options.debug) {
          const debugObj = Object.assign({}, this.parsedEntity, {
            path: entry.path,
            flags: "0x" + this.parsedEntity.flags.toString(16),
            extraFields: extra && extra.debug
          });
          console.log("decoded LOCAL_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
        }
        this._prepareOutStream(this.parsedEntity, entry);
        this.emit("entry", entry);
        this.state = states.FILE_DATA;
        return requiredLength;
      case states.CENTRAL_DIRECTORY_FILE_HEADER:
        this.parsedEntity = this._readCentralDirectoryEntry(chunk);
        this.state = states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX;
        return requiredLength;
      case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
        var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
        var path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
        var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
        var extra = this._readExtraFields(extraDataBuffer);
        if (extra && extra.parsed && extra.parsed.path && !isUtf8) {
          path = extra.parsed.path;
        }
        this.parsedEntity.extra = extra.parsed;
        var isUnix = (this.parsedEntity.versionMadeBy & 65280) >> 8 === 3;
        var unixAttrs, isSymlink;
        if (isUnix) {
          unixAttrs = this.parsedEntity.externalFileAttributes >>> 16;
          var fileType = unixAttrs >>> 12;
          isSymlink = (fileType & 10) === 10;
        }
        if (this.options.debug) {
          const debugObj = Object.assign({}, this.parsedEntity, {
            path,
            flags: "0x" + this.parsedEntity.flags.toString(16),
            unixAttrs: unixAttrs && "0" + unixAttrs.toString(8),
            isSymlink,
            extraFields: extra.debug
          });
          console.log("decoded CENTRAL_DIRECTORY_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
        }
        this.state = states.START;
        return requiredLength;
      case states.CDIR64_END:
        this.parsedEntity = this._readEndOfCentralDirectory64(chunk);
        if (this.options.debug) {
          console.log("decoded CDIR64_END_RECORD:", this.parsedEntity);
        }
        this.state = states.CDIR64_END_DATA_SECTOR;
        return requiredLength;
      case states.CDIR64_END_DATA_SECTOR:
        this.state = states.START;
        return requiredLength;
      case states.CDIR64_LOCATOR:
        this.state = states.START;
        return requiredLength;
      case states.CENTRAL_DIRECTORY_END:
        this.parsedEntity = this._readEndOfCentralDirectory(chunk);
        if (this.options.debug) {
          console.log("decoded CENTRAL_DIRECTORY_END:", this.parsedEntity);
        }
        this.state = states.CENTRAL_DIRECTORY_END_COMMENT;
        return requiredLength;
      case states.CENTRAL_DIRECTORY_END_COMMENT:
        if (this.options.debug) {
          console.log("decoded CENTRAL_DIRECTORY_END_COMMENT:", chunk.slice(0, requiredLength).toString());
        }
        this.state = states.TRAILING_JUNK;
        return requiredLength;
      case states.ERROR:
        return chunk.length;
      default:
        console.log("didn't handle state #", this.state, "discarding");
        return chunk.length;
    }
  };
  UnzipStream.prototype._prepareOutStream = function(vars, entry) {
    var self2 = this;
    var isDirectory = vars.uncompressedSize === 0 && /[\/\\]$/.test(entry.path);
    entry.path = entry.path.replace(/(?<=^|[/\\]+)[.][.]+(?=[/\\]+|$)/g, ".");
    entry.type = isDirectory ? "Directory" : "File";
    entry.isDirectory = isDirectory;
    var fileSizeKnown = !(vars.flags & 8);
    if (fileSizeKnown) {
      entry.size = vars.uncompressedSize;
    }
    var isVersionSupported = vars.versionsNeededToExtract <= 45;
    this.outStreamInfo = {
      stream: null,
      limit: fileSizeKnown ? vars.compressedSize : -1,
      written: 0
    };
    if (!fileSizeKnown) {
      var pattern = new Buffer(4);
      pattern.writeUInt32LE(SIG_DATA_DESCRIPTOR, 0);
      var zip64Mode = vars.extra.zip64Mode;
      var extraSize = zip64Mode ? 20 : 12;
      var searchPattern = {
        pattern,
        requiredExtraSize: extraSize
      };
      var matcherStream = new MatcherStream(searchPattern, function(matchedChunk, sizeSoFar) {
        var vars2 = self2._readDataDescriptor(matchedChunk, zip64Mode);
        var compressedSizeMatches = vars2.compressedSize === sizeSoFar;
        if (!zip64Mode && !compressedSizeMatches && sizeSoFar >= FOUR_GIGS) {
          var overflown = sizeSoFar - FOUR_GIGS;
          while (overflown >= 0) {
            compressedSizeMatches = vars2.compressedSize === overflown;
            if (compressedSizeMatches)
              break;
            overflown -= FOUR_GIGS;
          }
        }
        if (!compressedSizeMatches) {
          return;
        }
        self2.state = states.FILE_DATA_END;
        var sliceOffset = zip64Mode ? 24 : 16;
        if (self2.data.length > 0) {
          self2.data = Buffer.concat([matchedChunk.slice(sliceOffset), self2.data]);
        } else {
          self2.data = matchedChunk.slice(sliceOffset);
        }
        return true;
      });
      this.outStreamInfo.stream = matcherStream;
    } else {
      this.outStreamInfo.stream = new stream.PassThrough;
    }
    var isEncrypted = vars.flags & 1 || vars.flags & 64;
    if (isEncrypted || !isVersionSupported) {
      var message = isEncrypted ? "Encrypted files are not supported!" : "Zip version " + Math.floor(vars.versionsNeededToExtract / 10) + "." + vars.versionsNeededToExtract % 10 + " is not supported";
      entry.skip = true;
      setImmediate(() => {
        self2.emit("error", new Error(message));
      });
      this.outStreamInfo.stream.pipe(new Entry().autodrain());
      return;
    }
    var isCompressed = vars.compressionMethod > 0;
    if (isCompressed) {
      var inflater = zlib.createInflateRaw();
      inflater.on("error", function(err) {
        self2.state = states.ERROR;
        self2.emit("error", err);
      });
      this.outStreamInfo.stream.pipe(inflater).pipe(entry);
    } else {
      this.outStreamInfo.stream.pipe(entry);
    }
    if (this._drainAllEntries) {
      entry.autodrain();
    }
  };
  UnzipStream.prototype._readFile = function(data) {
    var vars = binary.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
    return vars;
  };
  UnzipStream.prototype._readExtraFields = function(data) {
    var extra = {};
    var result = { parsed: extra };
    if (this.options.debug) {
      result.debug = [];
    }
    var index = 0;
    while (index < data.length) {
      var vars = binary.parse(data).skip(index).word16lu("extraId").word16lu("extraSize").vars;
      index += 4;
      var fieldType = undefined;
      switch (vars.extraId) {
        case 1:
          fieldType = "Zip64 extended information extra field";
          var z64vars = binary.parse(data.slice(index, index + vars.extraSize)).word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offsetToLocalHeader").word32lu("diskStartNumber").vars;
          if (z64vars.uncompressedSize !== null) {
            extra.uncompressedSize = z64vars.uncompressedSize;
          }
          if (z64vars.compressedSize !== null) {
            extra.compressedSize = z64vars.compressedSize;
          }
          extra.zip64Mode = true;
          break;
        case 10:
          fieldType = "NTFS extra field";
          break;
        case 21589:
          fieldType = "extended timestamp";
          var timestampFields = data.readUInt8(index);
          var offset = 1;
          if (vars.extraSize >= offset + 4 && timestampFields & 1) {
            extra.mtime = new Date(data.readUInt32LE(index + offset) * 1000);
            offset += 4;
          }
          if (vars.extraSize >= offset + 4 && timestampFields & 2) {
            extra.atime = new Date(data.readUInt32LE(index + offset) * 1000);
            offset += 4;
          }
          if (vars.extraSize >= offset + 4 && timestampFields & 4) {
            extra.ctime = new Date(data.readUInt32LE(index + offset) * 1000);
          }
          break;
        case 28789:
          fieldType = "Info-ZIP Unicode Path Extra Field";
          var fieldVer = data.readUInt8(index);
          if (fieldVer === 1) {
            var offset = 1;
            var nameCrc32 = data.readUInt32LE(index + offset);
            offset += 4;
            var pathBuffer = data.slice(index + offset);
            extra.path = pathBuffer.toString();
          }
          break;
        case 13:
        case 22613:
          fieldType = vars.extraId === 13 ? "PKWARE Unix" : "Info-ZIP UNIX (type 1)";
          var offset = 0;
          if (vars.extraSize >= 8) {
            var atime = new Date(data.readUInt32LE(index + offset) * 1000);
            offset += 4;
            var mtime = new Date(data.readUInt32LE(index + offset) * 1000);
            offset += 4;
            extra.atime = atime;
            extra.mtime = mtime;
            if (vars.extraSize >= 12) {
              var uid = data.readUInt16LE(index + offset);
              offset += 2;
              var gid = data.readUInt16LE(index + offset);
              offset += 2;
              extra.uid = uid;
              extra.gid = gid;
            }
          }
          break;
        case 30805:
          fieldType = "Info-ZIP UNIX (type 2)";
          var offset = 0;
          if (vars.extraSize >= 4) {
            var uid = data.readUInt16LE(index + offset);
            offset += 2;
            var gid = data.readUInt16LE(index + offset);
            offset += 2;
            extra.uid = uid;
            extra.gid = gid;
          }
          break;
        case 30837:
          fieldType = "Info-ZIP New Unix";
          var offset = 0;
          var extraVer = data.readUInt8(index);
          offset += 1;
          if (extraVer === 1) {
            var uidSize = data.readUInt8(index + offset);
            offset += 1;
            if (uidSize <= 6) {
              extra.uid = data.readUIntLE(index + offset, uidSize);
            }
            offset += uidSize;
            var gidSize = data.readUInt8(index + offset);
            offset += 1;
            if (gidSize <= 6) {
              extra.gid = data.readUIntLE(index + offset, gidSize);
            }
          }
          break;
        case 30062:
          fieldType = "ASi Unix";
          var offset = 0;
          if (vars.extraSize >= 14) {
            var crc = data.readUInt32LE(index + offset);
            offset += 4;
            var mode = data.readUInt16LE(index + offset);
            offset += 2;
            var sizdev = data.readUInt32LE(index + offset);
            offset += 4;
            var uid = data.readUInt16LE(index + offset);
            offset += 2;
            var gid = data.readUInt16LE(index + offset);
            offset += 2;
            extra.mode = mode;
            extra.uid = uid;
            extra.gid = gid;
            if (vars.extraSize > 14) {
              var start = index + offset;
              var end = index + vars.extraSize - 14;
              var symlinkName = this._decodeString(data.slice(start, end));
              extra.symlink = symlinkName;
            }
          }
          break;
      }
      if (this.options.debug) {
        result.debug.push({
          extraId: "0x" + vars.extraId.toString(16),
          description: fieldType,
          data: data.slice(index, index + vars.extraSize).inspect()
        });
      }
      index += vars.extraSize;
    }
    return result;
  };
  UnzipStream.prototype._readDataDescriptor = function(data, zip64Mode) {
    if (zip64Mode) {
      var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word64lu("compressedSize").word64lu("uncompressedSize").vars;
      return vars;
    }
    var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
    return vars;
  };
  UnzipStream.prototype._readCentralDirectoryEntry = function(data) {
    var vars = binary.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
    return vars;
  };
  UnzipStream.prototype._readEndOfCentralDirectory64 = function(data) {
    var vars = binary.parse(data).word64lu("centralDirectoryRecordSize").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskNumberWithCentralDirectoryStart").word64lu("centralDirectoryEntries").word64lu("totalCentralDirectoryEntries").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
    return vars;
  };
  UnzipStream.prototype._readEndOfCentralDirectory = function(data) {
    var vars = binary.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("centralDirectoryEntries").word16lu("totalCentralDirectoryEntries").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
    return vars;
  };
  var cp437 = "\x00 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ";
  UnzipStream.prototype._decodeString = function(buffer, isUtf8) {
    if (isUtf8) {
      return buffer.toString("utf8");
    }
    if (this.options.decodeString) {
      return this.options.decodeString(buffer);
    }
    let result = "";
    for (var i = 0;i < buffer.length; i++) {
      result += cp437[buffer[i]];
    }
    return result;
  };
  UnzipStream.prototype._parseOrOutput = function(encoding, cb) {
    var consume;
    while ((consume = this.processDataChunk(this.data)) > 0) {
      this.data = this.data.slice(consume);
      if (this.data.length === 0)
        break;
    }
    if (this.state === states.FILE_DATA) {
      if (this.outStreamInfo.limit >= 0) {
        var remaining = this.outStreamInfo.limit - this.outStreamInfo.written;
        var packet;
        if (remaining < this.data.length) {
          packet = this.data.slice(0, remaining);
          this.data = this.data.slice(remaining);
        } else {
          packet = this.data;
          this.data = new Buffer("");
        }
        this.outStreamInfo.written += packet.length;
        if (this.outStreamInfo.limit === this.outStreamInfo.written) {
          this.state = states.START;
          this.outStreamInfo.stream.end(packet, encoding, cb);
        } else {
          this.outStreamInfo.stream.write(packet, encoding, cb);
        }
      } else {
        var packet = this.data;
        this.data = new Buffer("");
        this.outStreamInfo.written += packet.length;
        var outputStream = this.outStreamInfo.stream;
        outputStream.write(packet, encoding, () => {
          if (this.state === states.FILE_DATA_END) {
            this.state = states.START;
            return outputStream.end(cb);
          }
          cb();
        });
      }
      return;
    }
    cb();
  };
  UnzipStream.prototype.drainAll = function() {
    this._drainAllEntries = true;
  };
  UnzipStream.prototype._transform = function(chunk, encoding, cb) {
    var self2 = this;
    if (self2.data.length > 0) {
      self2.data = Buffer.concat([self2.data, chunk]);
    } else {
      self2.data = chunk;
    }
    var startDataLength = self2.data.length;
    var done = function() {
      if (self2.data.length > 0 && self2.data.length < startDataLength) {
        startDataLength = self2.data.length;
        self2._parseOrOutput(encoding, done);
        return;
      }
      cb();
    };
    self2._parseOrOutput(encoding, done);
  };
  UnzipStream.prototype._flush = function(cb) {
    var self2 = this;
    if (self2.data.length > 0) {
      self2._parseOrOutput("buffer", function() {
        if (self2.data.length > 0)
          return setImmediate(function() {
            self2._flush(cb);
          });
        cb();
      });
      return;
    }
    if (self2.state === states.FILE_DATA) {
      return cb(new Error("Stream finished in an invalid state, uncompression failed"));
    }
    setImmediate(cb);
  };
  module.exports = UnzipStream;
});

// node_modules/unzip-stream/lib/parser-stream.js
var require_parser_stream = __commonJS((exports, module) => {
  var Transform = __require("stream").Transform;
  var util = __require("util");
  var UnzipStream = require_unzip_stream();
  function ParserStream(opts) {
    if (!(this instanceof ParserStream)) {
      return new ParserStream(opts);
    }
    var transformOpts = opts || {};
    Transform.call(this, { readableObjectMode: true });
    this.opts = opts || {};
    this.unzipStream = new UnzipStream(this.opts);
    var self2 = this;
    this.unzipStream.on("entry", function(entry) {
      self2.push(entry);
    });
    this.unzipStream.on("error", function(error) {
      self2.emit("error", error);
    });
  }
  util.inherits(ParserStream, Transform);
  ParserStream.prototype._transform = function(chunk, encoding, cb) {
    this.unzipStream.write(chunk, encoding, cb);
  };
  ParserStream.prototype._flush = function(cb) {
    var self2 = this;
    this.unzipStream.end(function() {
      process.nextTick(function() {
        self2.emit("close");
      });
      cb();
    });
  };
  ParserStream.prototype.on = function(eventName, fn) {
    if (eventName === "entry") {
      return Transform.prototype.on.call(this, "data", fn);
    }
    return Transform.prototype.on.call(this, eventName, fn);
  };
  ParserStream.prototype.drainAll = function() {
    this.unzipStream.drainAll();
    return this.pipe(new Transform({ objectMode: true, transform: function(d, e, cb) {
      cb();
    } }));
  };
  module.exports = ParserStream;
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = __require("fs");
  var _0777 = parseInt("0777", 8);
  module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
  function mkdirP(p, opts, f, made) {
    if (typeof opts === "function") {
      f = opts;
      opts = {};
    } else if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    if (mode === undefined) {
      mode = _0777;
    }
    if (!made)
      made = null;
    var cb = f || function() {
    };
    p = path.resolve(p);
    xfs.mkdir(p, mode, function(er) {
      if (!er) {
        made = made || p;
        return cb(null, made);
      }
      switch (er.code) {
        case "ENOENT":
          if (path.dirname(p) === p)
            return cb(er);
          mkdirP(path.dirname(p), opts, function(er2, made2) {
            if (er2)
              cb(er2, made2);
            else
              mkdirP(p, opts, cb, made2);
          });
          break;
        default:
          xfs.stat(p, function(er2, stat) {
            if (er2 || !stat.isDirectory())
              cb(er, made);
            else
              cb(null, made);
          });
          break;
      }
    });
  }
  mkdirP.sync = function sync(p, opts, made) {
    if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    if (mode === undefined) {
      mode = _0777;
    }
    if (!made)
      made = null;
    p = path.resolve(p);
    try {
      xfs.mkdirSync(p, mode);
      made = made || p;
    } catch (err0) {
      switch (err0.code) {
        case "ENOENT":
          made = sync(path.dirname(p), opts, made);
          sync(p, opts, made);
          break;
        default:
          var stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory())
            throw err0;
          break;
      }
    }
    return made;
  };
});

// node_modules/unzip-stream/lib/extract.js
var require_extract = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path = __require("path");
  var util = __require("util");
  var mkdirp = require_mkdirp();
  var Transform = __require("stream").Transform;
  var UnzipStream = require_unzip_stream();
  function Extract(opts) {
    if (!(this instanceof Extract))
      return new Extract(opts);
    Transform.call(this);
    this.opts = opts || {};
    this.unzipStream = new UnzipStream(this.opts);
    this.unfinishedEntries = 0;
    this.afterFlushWait = false;
    this.createdDirectories = {};
    var self2 = this;
    this.unzipStream.on("entry", this._processEntry.bind(this));
    this.unzipStream.on("error", function(error) {
      self2.emit("error", error);
    });
  }
  util.inherits(Extract, Transform);
  Extract.prototype._transform = function(chunk, encoding, cb) {
    this.unzipStream.write(chunk, encoding, cb);
  };
  Extract.prototype._flush = function(cb) {
    var self2 = this;
    var allDone = function() {
      process.nextTick(function() {
        self2.emit("close");
      });
      cb();
    };
    this.unzipStream.end(function() {
      if (self2.unfinishedEntries > 0) {
        self2.afterFlushWait = true;
        return self2.on("await-finished", allDone);
      }
      allDone();
    });
  };
  Extract.prototype._processEntry = function(entry) {
    var self2 = this;
    var destPath = path.join(this.opts.path, entry.path);
    var directory = entry.isDirectory ? destPath : path.dirname(destPath);
    this.unfinishedEntries++;
    var writeFileFn = function() {
      var pipedStream = fs.createWriteStream(destPath);
      pipedStream.on("close", function() {
        self2.unfinishedEntries--;
        self2._notifyAwaiter();
      });
      pipedStream.on("error", function(error) {
        self2.emit("error", error);
      });
      entry.pipe(pipedStream);
    };
    if (this.createdDirectories[directory] || directory === ".") {
      return writeFileFn();
    }
    mkdirp(directory, function(err) {
      if (err)
        return self2.emit("error", err);
      self2.createdDirectories[directory] = true;
      if (entry.isDirectory) {
        self2.unfinishedEntries--;
        self2._notifyAwaiter();
        return;
      }
      writeFileFn();
    });
  };
  Extract.prototype._notifyAwaiter = function() {
    if (this.afterFlushWait && this.unfinishedEntries === 0) {
      this.emit("await-finished");
      this.afterFlushWait = false;
    }
  };
  module.exports = Extract;
});

// node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isFunction = undefined;
  function isFunction(value) {
    return typeof value === "function";
  }
  exports.isFunction = isFunction;
});

// node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createErrorClass = undefined;
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  exports.createErrorClass = createErrorClass;
});

// node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnsubscriptionError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors11) {
      _super(this);
      this.message = errors11 ? errors11.length + ` errors occurred during unsubscription:
` + errors11.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join(`
  `) : "";
      this.name = "UnsubscriptionError";
      this.errors = errors11;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.arrRemove = undefined;
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }
  exports.arrRemove = arrRemove;
});

// node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSubscription = exports.EMPTY_SUBSCRIPTION = exports.Subscription = undefined;
  var isFunction_1 = require_isFunction();
  var UnsubscriptionError_1 = require_UnsubscriptionError();
  var arrRemove_1 = require_arrRemove();
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors11;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next();!_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                  _a.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction_1.isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors11 = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next();!_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors11 = errors11 !== null && errors11 !== undefined ? errors11 : [];
                if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                  errors11 = __spreadArray(__spreadArray([], __read(errors11)), __read(err.errors));
                } else {
                  errors11.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                _b.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors11) {
          throw new UnsubscriptionError_1.UnsubscriptionError(errors11);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== undefined ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove_1.arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2;
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  exports.Subscription = Subscription;
  exports.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
  }
  exports.isSubscription = isSubscription;
  function execFinalizer(finalizer) {
    if (isFunction_1.isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.config = undefined;
  exports.config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeoutProvider = undefined;
  exports.timeoutProvider = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i = 2;_i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = exports.timeoutProvider.delegate;
      if (delegate === null || delegate === undefined ? undefined : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setTimeout.apply(undefined, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = exports.timeoutProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportUnhandledError = undefined;
  var config_1 = require_config();
  var timeoutProvider_1 = require_timeoutProvider();
  function reportUnhandledError(err) {
    timeoutProvider_1.timeoutProvider.setTimeout(function() {
      var onUnhandledError = config_1.config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  }
  exports.reportUnhandledError = reportUnhandledError;
});

// node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.noop = undefined;
  function noop() {
  }
  exports.noop = noop;
});

// node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNotification = exports.nextNotification = exports.errorNotification = exports.COMPLETE_NOTIFICATION = undefined;
  exports.COMPLETE_NOTIFICATION = function() {
    return createNotification("C", undefined, undefined);
  }();
  function errorNotification(error) {
    return createNotification("E", undefined, error);
  }
  exports.errorNotification = errorNotification;
  function nextNotification(value) {
    return createNotification("N", value, undefined);
  }
  exports.nextNotification = nextNotification;
  function createNotification(kind, value, error) {
    return {
      kind,
      value,
      error
    };
  }
  exports.createNotification = createNotification;
});

// node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.captureError = exports.errorContext = undefined;
  var config_1 = require_config();
  var context = null;
  function errorContext(cb) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context, errorThrown = _a.errorThrown, error = _a.error;
        context = null;
        if (errorThrown) {
          throw error;
        }
      }
    } else {
      cb();
    }
  }
  exports.errorContext = errorContext;
  function captureError(err) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err;
    }
  }
  exports.captureError = captureError;
});

// node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = undefined;
  var isFunction_1 = require_isFunction();
  var Subscription_1 = require_Subscription();
  var config_1 = require_config();
  var reportUnhandledError_1 = require_reportUnhandledError();
  var noop_1 = require_noop();
  var NotificationFactories_1 = require_NotificationFactories();
  var timeoutProvider_1 = require_timeoutProvider();
  var errorContext_1 = require_errorContext();
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (Subscription_1.isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = exports.EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription_1.Subscription);
  exports.Subscriber = Subscriber;
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== undefined ? observerOrNext : undefined,
          error: error !== null && error !== undefined ? error : undefined,
          complete: complete !== null && complete !== undefined ? complete : undefined
        };
      } else {
        var context_1;
        if (_this && config_1.config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  exports.SafeSubscriber = SafeSubscriber;
  function handleUnhandledError(error) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      errorContext_1.captureError(error);
    } else {
      reportUnhandledError_1.reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config_1.config.onStoppedNotification;
    onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  exports.EMPTY_OBSERVER = {
    closed: true,
    next: noop_1.noop,
    error: defaultErrorHandler,
    complete: noop_1.noop
  };
});

// node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observable = undefined;
  exports.observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
});

// node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.identity = undefined;
  function identity(x) {
    return x;
  }
  exports.identity = identity;
});

// node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pipeFromArray = exports.pipe = undefined;
  var identity_1 = require_identity();
  function pipe() {
    var fns = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
  }
  exports.pipe = pipe;
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity_1.identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }
  exports.pipeFromArray = pipeFromArray;
});

// node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Observable = undefined;
  var Subscriber_1 = require_Subscriber();
  var Subscription_1 = require_Subscription();
  var observable_1 = require_observable();
  var pipe_1 = require_pipe();
  var config_1 = require_config();
  var isFunction_1 = require_isFunction();
  var errorContext_1 = require_errorContext();
  var Observable = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable = new Observable2;
      observable.source = this;
      observable.operator = operator;
      return observable;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
      errorContext_1.errorContext(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === undefined ? undefined : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable_1.observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipe_1.pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  exports.Observable = Observable;
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== undefined ? promiseCtor : config_1.config.Promise) !== null && _a !== undefined ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
  }
});

// node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.operate = exports.hasLift = undefined;
  var isFunction_1 = require_isFunction();
  function hasLift(source) {
    return isFunction_1.isFunction(source === null || source === undefined ? undefined : source.lift);
  }
  exports.hasLift = hasLift;
  function operate(init) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  exports.operate = operate;
});

// node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperatorSubscriber = exports.createOperatorSubscriber = undefined;
  var Subscriber_1 = require_Subscriber();
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  exports.createOperatorSubscriber = createOperatorSubscriber;
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === undefined || _a.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber_1.Subscriber);
  exports.OperatorSubscriber = OperatorSubscriber;
});

// node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.refCount = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function refCount() {
    return lift_1.operate(function(source, subscriber) {
      var connection = null;
      source._refCount++;
      var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, undefined, function() {
        if (!source || source._refCount <= 0 || 0 < --source._refCount) {
          connection = null;
          return;
        }
        var sharedConnection = source._connection;
        var conn = connection;
        connection = null;
        if (sharedConnection && (!conn || sharedConnection === conn)) {
          sharedConnection.unsubscribe();
        }
        subscriber.unsubscribe();
      });
      source.subscribe(refCounter);
      if (!refCounter.closed) {
        connection = source.connect();
      }
    });
  }
  exports.refCount = refCount;
});

// node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectableObservable = undefined;
  var Observable_1 = require_Observable();
  var Subscription_1 = require_Subscription();
  var refCount_1 = require_refCount();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var lift_1 = require_lift();
  var ConnectableObservable = function(_super) {
    __extends(ConnectableObservable2, _super);
    function ConnectableObservable2(source, subjectFactory) {
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.subjectFactory = subjectFactory;
      _this._subject = null;
      _this._refCount = 0;
      _this._connection = null;
      if (lift_1.hasLift(source)) {
        _this.lift = source.lift;
      }
      return _this;
    }
    ConnectableObservable2.prototype._subscribe = function(subscriber) {
      return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable2.prototype.getSubject = function() {
      var subject = this._subject;
      if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
      }
      return this._subject;
    };
    ConnectableObservable2.prototype._teardown = function() {
      this._refCount = 0;
      var _connection = this._connection;
      this._subject = this._connection = null;
      _connection === null || _connection === undefined || _connection.unsubscribe();
    };
    ConnectableObservable2.prototype.connect = function() {
      var _this = this;
      var connection = this._connection;
      if (!connection) {
        connection = this._connection = new Subscription_1.Subscription;
        var subject_1 = this.getSubject();
        connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, undefined, function() {
          _this._teardown();
          subject_1.complete();
        }, function(err) {
          _this._teardown();
          subject_1.error(err);
        }, function() {
          return _this._teardown();
        })));
        if (connection.closed) {
          this._connection = null;
          connection = Subscription_1.Subscription.EMPTY;
        }
      }
      return connection;
    };
    ConnectableObservable2.prototype.refCount = function() {
      return refCount_1.refCount()(this);
    };
    return ConnectableObservable2;
  }(Observable_1.Observable);
  exports.ConnectableObservable = ConnectableObservable;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.performanceTimestampProvider = undefined;
  exports.performanceTimestampProvider = {
    now: function() {
      return (exports.performanceTimestampProvider.delegate || performance).now();
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrameProvider = undefined;
  var Subscription_1 = require_Subscription();
  exports.animationFrameProvider = {
    schedule: function(callback) {
      var request = requestAnimationFrame;
      var cancel = cancelAnimationFrame;
      var delegate = exports.animationFrameProvider.delegate;
      if (delegate) {
        request = delegate.requestAnimationFrame;
        cancel = delegate.cancelAnimationFrame;
      }
      var handle = request(function(timestamp) {
        cancel = undefined;
        callback(timestamp);
      });
      return new Subscription_1.Subscription(function() {
        return cancel === null || cancel === undefined ? undefined : cancel(handle);
      });
    },
    requestAnimationFrame: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.requestAnimationFrame) || requestAnimationFrame).apply(undefined, __spreadArray([], __read(args)));
    },
    cancelAnimationFrame: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(undefined, __spreadArray([], __read(args)));
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrames = undefined;
  var Observable_1 = require_Observable();
  var performanceTimestampProvider_1 = require_performanceTimestampProvider();
  var animationFrameProvider_1 = require_animationFrameProvider();
  function animationFrames(timestampProvider) {
    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
  }
  exports.animationFrames = animationFrames;
  function animationFramesFactory(timestampProvider) {
    return new Observable_1.Observable(function(subscriber) {
      var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
      var start = provider.now();
      var id = 0;
      var run2 = function() {
        if (!subscriber.closed) {
          id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp) {
            id = 0;
            var now = provider.now();
            subscriber.next({
              timestamp: timestampProvider ? now : timestamp,
              elapsed: now - start
            });
            run2();
          });
        }
      };
      run2();
      return function() {
        if (id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        }
      };
    });
  }
  var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
});

// node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ObjectUnsubscribedError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnonymousSubject = exports.Subject = undefined;
  var Observable_1 = require_Observable();
  var Subscription_1 = require_Subscription();
  var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
  var arrRemove_1 = require_arrRemove();
  var errorContext_1 = require_errorContext();
  var Subject = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError;
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext_1.errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next();!_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === undefined ? undefined : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return Subscription_1.EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription_1.Subscription(function() {
        _this.currentObservers = null;
        arrRemove_1.arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable = new Observable_1.Observable;
      observable.source = this;
      return observable;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable_1.Observable);
  exports.Subject = Subject;
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === undefined ? undefined : _a.next) === null || _b === undefined || _b.call(_a, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === undefined ? undefined : _a.error) === null || _b === undefined || _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === undefined ? undefined : _a.complete) === null || _b === undefined || _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === undefined ? undefined : _a.subscribe(subscriber)) !== null && _b !== undefined ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);
  exports.AnonymousSubject = AnonymousSubject;
});

// node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BehaviorSubject = undefined;
  var Subject_1 = require_Subject();
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject_1.Subject);
  exports.BehaviorSubject = BehaviorSubject;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dateTimestampProvider = undefined;
  exports.dateTimestampProvider = {
    now: function() {
      return (exports.dateTimestampProvider.delegate || Date).now();
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplaySubject = undefined;
  var Subject_1 = require_Subject();
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var ReplaySubject = function(_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
      if (_bufferSize === undefined) {
        _bufferSize = Infinity;
      }
      if (_windowTime === undefined) {
        _windowTime = Infinity;
      }
      if (_timestampProvider === undefined) {
        _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      var _this = _super.call(this) || this;
      _this._bufferSize = _bufferSize;
      _this._windowTime = _windowTime;
      _this._timestampProvider = _timestampProvider;
      _this._buffer = [];
      _this._infiniteTimeWindow = true;
      _this._infiniteTimeWindow = _windowTime === Infinity;
      _this._bufferSize = Math.max(1, _bufferSize);
      _this._windowTime = Math.max(1, _windowTime);
      return _this;
    }
    ReplaySubject2.prototype.next = function(value) {
      var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
      if (!isStopped) {
        _buffer.push(value);
        !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
      }
      this._trimBuffer();
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._trimBuffer();
      var subscription = this._innerSubscribe(subscriber);
      var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
      var copy = _buffer.slice();
      for (var i = 0;i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
        subscriber.next(copy[i]);
      }
      this._checkFinalizedStatuses(subscriber);
      return subscription;
    };
    ReplaySubject2.prototype._trimBuffer = function() {
      var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
      var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
      _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
      if (!_infiniteTimeWindow) {
        var now = _timestampProvider.now();
        var last = 0;
        for (var i = 1;i < _buffer.length && _buffer[i] <= now; i += 2) {
          last = i;
        }
        last && _buffer.splice(0, last + 1);
      }
    };
    return ReplaySubject2;
  }(Subject_1.Subject);
  exports.ReplaySubject = ReplaySubject;
});

// node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncSubject = undefined;
  var Subject_1 = require_Subject();
  var AsyncSubject = function(_super) {
    __extends(AsyncSubject2, _super);
    function AsyncSubject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._value = null;
      _this._hasValue = false;
      _this._isComplete = false;
      return _this;
    }
    AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped || _isComplete) {
        _hasValue && subscriber.next(_value);
        subscriber.complete();
      }
    };
    AsyncSubject2.prototype.next = function(value) {
      if (!this.isStopped) {
        this._value = value;
        this._hasValue = true;
      }
    };
    AsyncSubject2.prototype.complete = function() {
      var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
      if (!_isComplete) {
        this._isComplete = true;
        _hasValue && _super.prototype.next.call(this, _value);
        _super.prototype.complete.call(this);
      }
    };
    return AsyncSubject2;
  }(Subject_1.Subject);
  exports.AsyncSubject = AsyncSubject;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Action = undefined;
  var Subscription_1 = require_Subscription();
  var Action = function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return this;
    };
    return Action2;
  }(Subscription_1.Subscription);
  exports.Action = Action;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.intervalProvider = undefined;
  exports.intervalProvider = {
    setInterval: function(handler, timeout) {
      var args = [];
      for (var _i = 2;_i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = exports.intervalProvider.delegate;
      if (delegate === null || delegate === undefined ? undefined : delegate.setInterval) {
        return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setInterval.apply(undefined, __spreadArray([handler, timeout], __read(args)));
    },
    clearInterval: function(handle) {
      var delegate = exports.intervalProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncAction = undefined;
  var Action_1 = require_Action();
  var intervalProvider_1 = require_intervalProvider();
  var arrRemove_1 = require_arrRemove();
  var AsyncAction = function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state, delay) {
      var _a;
      if (delay === undefined) {
        delay = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler;
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay);
      }
      this.pending = true;
      this.delay = delay;
      this.id = (_a = this.id) !== null && _a !== undefined ? _a : this.requestAsyncId(scheduler, this.id, delay);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null && this.delay === delay && this.pending === false) {
        return id;
      }
      if (id != null) {
        intervalProvider_1.intervalProvider.clearInterval(id);
      }
      return;
    };
    AsyncAction2.prototype.execute = function(state, delay) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error = this._execute(state, delay);
      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state, _delay) {
      var errored = false;
      var errorValue;
      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function() {
      if (!this.closed) {
        var _a = this, id = _a.id, scheduler = _a.scheduler;
        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove_1.arrRemove(actions, this);
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action_1.Action);
  exports.AsyncAction = AsyncAction;
});

// node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TestTools = exports.Immediate = undefined;
  var nextHandle = 1;
  var resolved;
  var activeHandles = {};
  function findAndClearHandle(handle) {
    if (handle in activeHandles) {
      delete activeHandles[handle];
      return true;
    }
    return false;
  }
  exports.Immediate = {
    setImmediate: function(cb) {
      var handle = nextHandle++;
      activeHandles[handle] = true;
      if (!resolved) {
        resolved = Promise.resolve();
      }
      resolved.then(function() {
        return findAndClearHandle(handle) && cb();
      });
      return handle;
    },
    clearImmediate: function(handle) {
      findAndClearHandle(handle);
    }
  };
  exports.TestTools = {
    pending: function() {
      return Object.keys(activeHandles).length;
    }
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.immediateProvider = undefined;
  var Immediate_1 = require_Immediate();
  var setImmediate2 = Immediate_1.Immediate.setImmediate;
  var clearImmediate = Immediate_1.Immediate.clearImmediate;
  exports.immediateProvider = {
    setImmediate: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.setImmediate) || setImmediate2).apply(undefined, __spreadArray([], __read(args)));
    },
    clearImmediate: function(handle) {
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearImmediate) || clearImmediate)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsapAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var immediateProvider_1 = require_immediateProvider();
  var AsapAction = function(_super) {
    __extends(AsapAction2, _super);
    function AsapAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));
    };
    AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      var _a;
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null ? delay > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      }
      var actions = scheduler.actions;
      if (id != null && ((_a = actions[actions.length - 1]) === null || _a === undefined ? undefined : _a.id) !== id) {
        immediateProvider_1.immediateProvider.clearImmediate(id);
        if (scheduler._scheduled === id) {
          scheduler._scheduled = undefined;
        }
      }
      return;
    };
    return AsapAction2;
  }(AsyncAction_1.AsyncAction);
  exports.AsapAction = AsapAction;
});

// node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Scheduler = undefined;
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var Scheduler = function() {
    function Scheduler2(schedulerActionCtor, now) {
      if (now === undefined) {
        now = Scheduler2.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now;
    }
    Scheduler2.prototype.schedule = function(work, delay, state) {
      if (delay === undefined) {
        delay = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state, delay);
    };
    Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
    return Scheduler2;
  }();
  exports.Scheduler = Scheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncScheduler = undefined;
  var Scheduler_1 = require_Scheduler();
  var AsyncScheduler = function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === undefined) {
        now = Scheduler_1.Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action);
        return;
      }
      var error;
      this._active = true;
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this._active = false;
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsyncScheduler2;
  }(Scheduler_1.Scheduler);
  exports.AsyncScheduler = AsyncScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsapScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var AsapScheduler = function(_super) {
    __extends(AsapScheduler2, _super);
    function AsapScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId = this._scheduled;
      this._scheduled = undefined;
      var actions = this.actions;
      var error;
      action = action || actions.shift();
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsapScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.AsapScheduler = AsapScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.asap = exports.asapScheduler = undefined;
  var AsapAction_1 = require_AsapAction();
  var AsapScheduler_1 = require_AsapScheduler();
  exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
  exports.asap = exports.asapScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.async = exports.asyncScheduler = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var AsyncScheduler_1 = require_AsyncScheduler();
  exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
  exports.async = exports.asyncScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueueAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var QueueAction = function(_super) {
    __extends(QueueAction2, _super);
    function QueueAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    QueueAction2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay > 0) {
        return _super.prototype.schedule.call(this, state, delay);
      }
      this.delay = delay;
      this.state = state;
      this.scheduler.flush(this);
      return this;
    };
    QueueAction2.prototype.execute = function(state, delay) {
      return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
    };
    QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null && delay > 0 || delay == null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.flush(this);
      return 0;
    };
    return QueueAction2;
  }(AsyncAction_1.AsyncAction);
  exports.QueueAction = QueueAction;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueueScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var QueueScheduler = function(_super) {
    __extends(QueueScheduler2, _super);
    function QueueScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.QueueScheduler = QueueScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.queue = exports.queueScheduler = undefined;
  var QueueAction_1 = require_QueueAction();
  var QueueScheduler_1 = require_QueueScheduler();
  exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
  exports.queue = exports.queueScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnimationFrameAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var animationFrameProvider_1 = require_animationFrameProvider();
  var AnimationFrameAction = function(_super) {
    __extends(AnimationFrameAction2, _super);
    function AnimationFrameAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
        return scheduler.flush(undefined);
      }));
    };
    AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      var _a;
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null ? delay > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      }
      var actions = scheduler.actions;
      if (id != null && ((_a = actions[actions.length - 1]) === null || _a === undefined ? undefined : _a.id) !== id) {
        animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        scheduler._scheduled = undefined;
      }
      return;
    };
    return AnimationFrameAction2;
  }(AsyncAction_1.AsyncAction);
  exports.AnimationFrameAction = AnimationFrameAction;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnimationFrameScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var AnimationFrameScheduler = function(_super) {
    __extends(AnimationFrameScheduler2, _super);
    function AnimationFrameScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId = this._scheduled;
      this._scheduled = undefined;
      var actions = this.actions;
      var error;
      action = action || actions.shift();
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AnimationFrameScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.AnimationFrameScheduler = AnimationFrameScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrame = exports.animationFrameScheduler = undefined;
  var AnimationFrameAction_1 = require_AnimationFrameAction();
  var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
  exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
  exports.animationFrame = exports.animationFrameScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VirtualAction = exports.VirtualTimeScheduler = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var Subscription_1 = require_Subscription();
  var AsyncScheduler_1 = require_AsyncScheduler();
  var VirtualTimeScheduler = function(_super) {
    __extends(VirtualTimeScheduler2, _super);
    function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
      if (schedulerActionCtor === undefined) {
        schedulerActionCtor = VirtualAction;
      }
      if (maxFrames === undefined) {
        maxFrames = Infinity;
      }
      var _this = _super.call(this, schedulerActionCtor, function() {
        return _this.frame;
      }) || this;
      _this.maxFrames = maxFrames;
      _this.frame = 0;
      _this.index = -1;
      return _this;
    }
    VirtualTimeScheduler2.prototype.flush = function() {
      var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
      var error;
      var action;
      while ((action = actions[0]) && action.delay <= maxFrames) {
        actions.shift();
        this.frame = action.delay;
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      }
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    VirtualTimeScheduler2.frameTimeFactor = 10;
    return VirtualTimeScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.VirtualTimeScheduler = VirtualTimeScheduler;
  var VirtualAction = function(_super) {
    __extends(VirtualAction2, _super);
    function VirtualAction2(scheduler, work, index) {
      if (index === undefined) {
        index = scheduler.index += 1;
      }
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.index = index;
      _this.active = true;
      _this.index = scheduler.index = index;
      return _this;
    }
    VirtualAction2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (Number.isFinite(delay)) {
        if (!this.id) {
          return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction2(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
      } else {
        return Subscription_1.Subscription.EMPTY;
      }
    };
    VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      this.delay = scheduler.frame + delay;
      var actions = scheduler.actions;
      actions.push(this);
      actions.sort(VirtualAction2.sortActions);
      return 1;
    };
    VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return;
    };
    VirtualAction2.prototype._execute = function(state, delay) {
      if (this.active === true) {
        return _super.prototype._execute.call(this, state, delay);
      }
    };
    VirtualAction2.sortActions = function(a, b) {
      if (a.delay === b.delay) {
        if (a.index === b.index) {
          return 0;
        } else if (a.index > b.index) {
          return 1;
        } else {
          return -1;
        }
      } else if (a.delay > b.delay) {
        return 1;
      } else {
        return -1;
      }
    };
    return VirtualAction2;
  }(AsyncAction_1.AsyncAction);
  exports.VirtualAction = VirtualAction;
});

// node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.empty = exports.EMPTY = undefined;
  var Observable_1 = require_Observable();
  exports.EMPTY = new Observable_1.Observable(function(subscriber) {
    return subscriber.complete();
  });
  function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
  }
  exports.empty = empty;
  function emptyScheduled(scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      return scheduler.schedule(function() {
        return subscriber.complete();
      });
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isScheduler = undefined;
  var isFunction_1 = require_isFunction();
  function isScheduler(value) {
    return value && isFunction_1.isFunction(value.schedule);
  }
  exports.isScheduler = isScheduler;
});

// node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.popNumber = exports.popScheduler = exports.popResultSelector = undefined;
  var isFunction_1 = require_isFunction();
  var isScheduler_1 = require_isScheduler();
  function last(arr) {
    return arr[arr.length - 1];
  }
  function popResultSelector(args) {
    return isFunction_1.isFunction(last(args)) ? args.pop() : undefined;
  }
  exports.popResultSelector = popResultSelector;
  function popScheduler(args) {
    return isScheduler_1.isScheduler(last(args)) ? args.pop() : undefined;
  }
  exports.popScheduler = popScheduler;
  function popNumber(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
  }
  exports.popNumber = popNumber;
});

// node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isArrayLike = undefined;
  exports.isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  };
});

// node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isPromise = undefined;
  var isFunction_1 = require_isFunction();
  function isPromise(value) {
    return isFunction_1.isFunction(value === null || value === undefined ? undefined : value.then);
  }
  exports.isPromise = isPromise;
});

// node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isInteropObservable = undefined;
  var observable_1 = require_observable();
  var isFunction_1 = require_isFunction();
  function isInteropObservable(input) {
    return isFunction_1.isFunction(input[observable_1.observable]);
  }
  exports.isInteropObservable = isInteropObservable;
});

// node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAsyncIterable = undefined;
  var isFunction_1 = require_isFunction();
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === undefined ? undefined : obj[Symbol.asyncIterator]);
  }
  exports.isAsyncIterable = isAsyncIterable;
});

// node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createInvalidObservableTypeError = undefined;
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  exports.createInvalidObservableTypeError = createInvalidObservableTypeError;
});

// node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iterator = exports.getSymbolIterator = undefined;
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  exports.getSymbolIterator = getSymbolIterator;
  exports.iterator = getSymbolIterator();
});

// node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isIterable = undefined;
  var iterator_1 = require_iterator();
  var isFunction_1 = require_isFunction();
  function isIterable(input) {
    return isFunction_1.isFunction(input === null || input === undefined ? undefined : input[iterator_1.iterator]);
  }
  exports.isIterable = isIterable;
});

// node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS((exports) => {
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t[1]) {
                _2.label = t[1];
                t = op;
                break;
              }
              if (t && _2.label < t[2]) {
                _2.label = t[2];
                _2.ops.push(op);
                break;
              }
              if (t[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isReadableStreamLike = exports.readableStreamLikeToAsyncGenerator = undefined;
  var isFunction_1 = require_isFunction();
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            if (false)
              ;
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done = _a.done;
            if (!done)
              return [3, 5];
            return [4, __await(undefined)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  exports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
  function isReadableStreamLike(obj) {
    return isFunction_1.isFunction(obj === null || obj === undefined ? undefined : obj.getReader);
  }
  exports.isReadableStreamLike = isReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t[1]) {
                _2.label = t[1];
                t = op;
                break;
              }
              if (t && _2.label < t[2]) {
                _2.label = t[2];
                _2.ops.push(op);
                break;
              }
              if (t[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = undefined;
  var isArrayLike_1 = require_isArrayLike();
  var isPromise_1 = require_isPromise();
  var Observable_1 = require_Observable();
  var isInteropObservable_1 = require_isInteropObservable();
  var isAsyncIterable_1 = require_isAsyncIterable();
  var throwUnobservableError_1 = require_throwUnobservableError();
  var isIterable_1 = require_isIterable();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  var isFunction_1 = require_isFunction();
  var reportUnhandledError_1 = require_reportUnhandledError();
  var observable_1 = require_observable();
  function innerFrom(input) {
    if (input instanceof Observable_1.Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise_1.isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable_1.isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  }
  exports.innerFrom = innerFrom;
  function fromInteropObservable(obj) {
    return new Observable_1.Observable(function(subscriber) {
      var obs = obj[observable_1.observable]();
      if (isFunction_1.isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  exports.fromInteropObservable = fromInteropObservable;
  function fromArrayLike(array) {
    return new Observable_1.Observable(function(subscriber) {
      for (var i = 0;i < array.length && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    });
  }
  exports.fromArrayLike = fromArrayLike;
  function fromPromise(promise) {
    return new Observable_1.Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError_1.reportUnhandledError);
    });
  }
  exports.fromPromise = fromPromise;
  function fromIterable(iterable) {
    return new Observable_1.Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next();!iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
            _a.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  exports.fromIterable = fromIterable;
  function fromAsyncIterable(asyncIterable) {
    return new Observable_1.Observable(function(subscriber) {
      process20(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  exports.fromAsyncIterable = fromAsyncIterable;
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
  }
  exports.fromReadableStreamLike = fromReadableStreamLike;
  function process20(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, undefined, undefined, function() {
      var value, e_2_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.executeSchedule = undefined;
  function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === undefined) {
      delay = 0;
    }
    if (repeat === undefined) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay));
      } else {
        this.unsubscribe();
      }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  }
  exports.executeSchedule = executeSchedule;
});

// node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observeOn = undefined;
  var executeSchedule_1 = require_executeSchedule();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function observeOn(scheduler, delay) {
    if (delay === undefined) {
      delay = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay);
      }, function() {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay);
      }, function(err) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay);
      }));
    });
  }
  exports.observeOn = observeOn;
});

// node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.subscribeOn = undefined;
  var lift_1 = require_lift();
  function subscribeOn(scheduler, delay) {
    if (delay === undefined) {
      delay = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay));
    });
  }
  exports.subscribeOn = subscribeOn;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleObservable = undefined;
  var innerFrom_1 = require_innerFrom();
  var observeOn_1 = require_observeOn();
  var subscribeOn_1 = require_subscribeOn();
  function scheduleObservable(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  }
  exports.scheduleObservable = scheduleObservable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.schedulePromise = undefined;
  var innerFrom_1 = require_innerFrom();
  var observeOn_1 = require_observeOn();
  var subscribeOn_1 = require_subscribeOn();
  function schedulePromise(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  }
  exports.schedulePromise = schedulePromise;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleArray = undefined;
  var Observable_1 = require_Observable();
  function scheduleArray(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var i = 0;
      return scheduler.schedule(function() {
        if (i === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }
  exports.scheduleArray = scheduleArray;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleIterable = undefined;
  var Observable_1 = require_Observable();
  var iterator_1 = require_iterator();
  var isFunction_1 = require_isFunction();
  var executeSchedule_1 = require_executeSchedule();
  function scheduleIterable(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var iterator;
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        iterator = input[iterator_1.iterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var _a;
          var value;
          var done;
          try {
            _a = iterator.next(), value = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction_1.isFunction(iterator === null || iterator === undefined ? undefined : iterator.return) && iterator.return();
      };
    });
  }
  exports.scheduleIterable = scheduleIterable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleAsyncIterable = undefined;
  var Observable_1 = require_Observable();
  var executeSchedule_1 = require_executeSchedule();
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable_1.Observable(function(subscriber) {
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        var iterator = input[Symbol.asyncIterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }
  exports.scheduleAsyncIterable = scheduleAsyncIterable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleReadableStreamLike = undefined;
  var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
  }
  exports.scheduleReadableStreamLike = scheduleReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduled = undefined;
  var scheduleObservable_1 = require_scheduleObservable();
  var schedulePromise_1 = require_schedulePromise();
  var scheduleArray_1 = require_scheduleArray();
  var scheduleIterable_1 = require_scheduleIterable();
  var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
  var isInteropObservable_1 = require_isInteropObservable();
  var isPromise_1 = require_isPromise();
  var isArrayLike_1 = require_isArrayLike();
  var isIterable_1 = require_isIterable();
  var isAsyncIterable_1 = require_isAsyncIterable();
  var throwUnobservableError_1 = require_throwUnobservableError();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return scheduleObservable_1.scheduleObservable(input, scheduler);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return scheduleArray_1.scheduleArray(input, scheduler);
      }
      if (isPromise_1.isPromise(input)) {
        return schedulePromise_1.schedulePromise(input, scheduler);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable_1.isIterable(input)) {
        return scheduleIterable_1.scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  }
  exports.scheduled = scheduled;
});

// node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.from = undefined;
  var scheduled_1 = require_scheduled();
  var innerFrom_1 = require_innerFrom();
  function from(input, scheduler) {
    return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
  }
  exports.from = from;
});

// node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.of = undefined;
  var args_1 = require_args();
  var from_1 = require_from();
  function of() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    return from_1.from(args, scheduler);
  }
  exports.of = of;
});

// node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throwError = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  function throwError(errorOrErrorFactory, scheduler) {
    var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
      return errorOrErrorFactory;
    };
    var init = function(subscriber) {
      return subscriber.error(errorFactory());
    };
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      return scheduler.schedule(init, 0, subscriber);
    } : init);
  }
  exports.throwError = throwError;
});

// node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observeNotification = exports.Notification = exports.NotificationKind = undefined;
  var empty_1 = require_empty2();
  var of_1 = require_of();
  var throwError_1 = require_throwError();
  var isFunction_1 = require_isFunction();
  var NotificationKind;
  (function(NotificationKind2) {
    NotificationKind2["NEXT"] = "N";
    NotificationKind2["ERROR"] = "E";
    NotificationKind2["COMPLETE"] = "C";
  })(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
  var Notification = function() {
    function Notification2(kind, value, error) {
      this.kind = kind;
      this.value = value;
      this.error = error;
      this.hasValue = kind === "N";
    }
    Notification2.prototype.observe = function(observer) {
      return observeNotification(this, observer);
    };
    Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
      var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
      return kind === "N" ? nextHandler === null || nextHandler === undefined ? undefined : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === undefined ? undefined : errorHandler(error) : completeHandler === null || completeHandler === undefined ? undefined : completeHandler();
    };
    Notification2.prototype.accept = function(nextOrObserver, error, complete) {
      var _a;
      return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === undefined ? undefined : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
    };
    Notification2.prototype.toObservable = function() {
      var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
      var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
        return error;
      }) : kind === "C" ? empty_1.EMPTY : 0;
      if (!result) {
        throw new TypeError("Unexpected notification kind " + kind);
      }
      return result;
    };
    Notification2.createNext = function(value) {
      return new Notification2("N", value);
    };
    Notification2.createError = function(err) {
      return new Notification2("E", undefined, err);
    };
    Notification2.createComplete = function() {
      return Notification2.completeNotification;
    };
    Notification2.completeNotification = new Notification2("C");
    return Notification2;
  }();
  exports.Notification = Notification;
  function observeNotification(notification, observer) {
    var _a, _b, _c;
    var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
    if (typeof kind !== "string") {
      throw new TypeError('Invalid notification, missing "kind"');
    }
    kind === "N" ? (_a = observer.next) === null || _a === undefined || _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === undefined || _b.call(observer, error) : (_c = observer.complete) === null || _c === undefined || _c.call(observer);
  }
  exports.observeNotification = observeNotification;
});

// node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isObservable = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  function isObservable(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
  }
  exports.isObservable = isObservable;
});

// node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmptyError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lastValueFrom = undefined;
  var EmptyError_1 = require_EmptyError();
  function lastValueFrom(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
      var _hasValue = false;
      var _value;
      source.subscribe({
        next: function(value) {
          _value = value;
          _hasValue = true;
        },
        error: reject,
        complete: function() {
          if (_hasValue) {
            resolve(_value);
          } else if (hasConfig) {
            resolve(config.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError);
          }
        }
      });
    });
  }
  exports.lastValueFrom = lastValueFrom;
});

// node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.firstValueFrom = undefined;
  var EmptyError_1 = require_EmptyError();
  var Subscriber_1 = require_Subscriber();
  function firstValueFrom(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
      var subscriber = new Subscriber_1.SafeSubscriber({
        next: function(value) {
          resolve(value);
          subscriber.unsubscribe();
        },
        error: reject,
        complete: function() {
          if (hasConfig) {
            resolve(config.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError);
          }
        }
      });
      source.subscribe(subscriber);
    });
  }
  exports.firstValueFrom = firstValueFrom;
});

// node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ArgumentOutOfRangeError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
    return function ArgumentOutOfRangeErrorImpl() {
      _super(this);
      this.name = "ArgumentOutOfRangeError";
      this.message = "argument out of range";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NotFoundError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
    return function NotFoundErrorImpl(message) {
      _super(this);
      this.name = "NotFoundError";
      this.message = message;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SequenceError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
    return function SequenceErrorImpl(message) {
      _super(this);
      this.name = "SequenceError";
      this.message = message;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidDate = undefined;
  function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
  }
  exports.isValidDate = isValidDate;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeout = exports.TimeoutError = undefined;
  var async_1 = require_async();
  var isDate_1 = require_isDate();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var createErrorClass_1 = require_createErrorClass();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var executeSchedule_1 = require_executeSchedule();
  exports.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
    return function TimeoutErrorImpl(info) {
      if (info === undefined) {
        info = null;
      }
      _super(this);
      this.message = "Timeout has occurred";
      this.name = "TimeoutError";
      this.info = info;
    };
  });
  function timeout(config, schedulerArg) {
    var _a = isDate_1.isValidDate(config) ? { first: config } : typeof config === "number" ? { each: config } : config, first = _a.first, each = _a.each, _b = _a.with, _with = _b === undefined ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === undefined ? schedulerArg !== null && schedulerArg !== undefined ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === undefined ? null : _d;
    if (first == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return lift_1.operate(function(source, subscriber) {
      var originalSourceSubscription;
      var timerSubscription;
      var lastValue = null;
      var seen = 0;
      var startTimer = function(delay) {
        timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          try {
            originalSourceSubscription.unsubscribe();
            innerFrom_1.innerFrom(_with({
              meta,
              lastValue,
              seen
            })).subscribe(subscriber);
          } catch (err) {
            subscriber.error(err);
          }
        }, delay);
      };
      originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        timerSubscription === null || timerSubscription === undefined || timerSubscription.unsubscribe();
        seen++;
        subscriber.next(lastValue = value);
        each > 0 && startTimer(each);
      }, undefined, undefined, function() {
        if (!(timerSubscription === null || timerSubscription === undefined ? undefined : timerSubscription.closed)) {
          timerSubscription === null || timerSubscription === undefined || timerSubscription.unsubscribe();
        }
        lastValue = null;
      }));
      !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
    });
  }
  exports.timeout = timeout;
  function timeoutErrorFactory(info) {
    throw new exports.TimeoutError(info);
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.map = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function map(project, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }
  exports.map = map;
});

// node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapOneOrManyArgs = undefined;
  var map_1 = require_map();
  var isArray = Array.isArray;
  function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(undefined, __spreadArray([], __read(args))) : fn(args);
  }
  function mapOneOrManyArgs(fn) {
    return map_1.map(function(args) {
      return callOrApply(fn, args);
    });
  }
  exports.mapOneOrManyArgs = mapOneOrManyArgs;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindCallbackInternals = undefined;
  var isScheduler_1 = require_isScheduler();
  var Observable_1 = require_Observable();
  var subscribeOn_1 = require_subscribeOn();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var observeOn_1 = require_observeOn();
  var AsyncSubject_1 = require_AsyncSubject();
  function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
      if (isScheduler_1.isScheduler(resultSelector)) {
        scheduler = resultSelector;
      } else {
        return function() {
          var args = [];
          for (var _i = 0;_i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
        };
      }
    }
    if (scheduler) {
      return function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
      };
    }
    return function() {
      var _this = this;
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var subject = new AsyncSubject_1.AsyncSubject;
      var uninitialized = true;
      return new Observable_1.Observable(function(subscriber) {
        var subs = subject.subscribe(subscriber);
        if (uninitialized) {
          uninitialized = false;
          var isAsync_1 = false;
          var isComplete_1 = false;
          callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
            function() {
              var results = [];
              for (var _i2 = 0;_i2 < arguments.length; _i2++) {
                results[_i2] = arguments[_i2];
              }
              if (isNodeStyle) {
                var err = results.shift();
                if (err != null) {
                  subject.error(err);
                  return;
                }
              }
              subject.next(1 < results.length ? results : results[0]);
              isComplete_1 = true;
              if (isAsync_1) {
                subject.complete();
              }
            }
          ]));
          if (isComplete_1) {
            subject.complete();
          }
          isAsync_1 = true;
        }
        return subs;
      });
    };
  }
  exports.bindCallbackInternals = bindCallbackInternals;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindCallback = undefined;
  var bindCallbackInternals_1 = require_bindCallbackInternals();
  function bindCallback(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
  }
  exports.bindCallback = bindCallback;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindNodeCallback = undefined;
  var bindCallbackInternals_1 = require_bindCallbackInternals();
  function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
  }
  exports.bindNodeCallback = bindNodeCallback;
});

// node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argsArgArrayOrObject = undefined;
  var isArray = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var getKeys = Object.keys;
  function argsArgArrayOrObject(args) {
    if (args.length === 1) {
      var first_1 = args[0];
      if (isArray(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key11) {
            return first_1[key11];
          }),
          keys
        };
      }
    }
    return { args, keys: null };
  }
  exports.argsArgArrayOrObject = argsArgArrayOrObject;
  function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createObject = undefined;
  function createObject(keys, values) {
    return keys.reduce(function(result, key11, i) {
      return result[key11] = values[i], result;
    }, {});
  }
  exports.createObject = createObject;
});

// node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestInit = exports.combineLatest = undefined;
  var Observable_1 = require_Observable();
  var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
  var from_1 = require_from();
  var identity_1 = require_identity();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var args_1 = require_args();
  var createObject_1 = require_createObject();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var executeSchedule_1 = require_executeSchedule();
  function combineLatest() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var resultSelector = args_1.popResultSelector(args);
    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
    if (observables.length === 0) {
      return from_1.from([], scheduler);
    }
    var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
      return createObject_1.createObject(keys, values);
    } : identity_1.identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  }
  exports.combineLatest = combineLatest;
  function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === undefined) {
      valueTransform = identity_1.identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i2) {
          maybeSchedule(scheduler, function() {
            var source = from_1.from(observables[i2], scheduler);
            var hasFirstValue = false;
            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              values[i2] = value;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i = 0;i < length; i++) {
          _loop_1(i);
        }
      }, subscriber);
    };
  }
  exports.combineLatestInit = combineLatestInit;
  function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule_1.executeSchedule(subscription, scheduler, execute);
    } else {
      execute();
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeInternals = undefined;
  var innerFrom_1 = require_innerFrom();
  var executeSchedule_1 = require_executeSchedule();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };
    var doInnerSub = function(value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === undefined || onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, undefined, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer.shift();
              if (innerSubScheduler) {
                executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === undefined || additionalFinalizer();
    };
  }
  exports.mergeInternals = mergeInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeMap = undefined;
  var map_1 = require_map();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  var isFunction_1 = require_isFunction();
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap(function(a, i) {
        return map_1.map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        })(innerFrom_1.innerFrom(project(a, i)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
    });
  }
  exports.mergeMap = mergeMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeAll = undefined;
  var mergeMap_1 = require_mergeMap();
  var identity_1 = require_identity();
  function mergeAll(concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
  }
  exports.mergeAll = mergeAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatAll = undefined;
  var mergeAll_1 = require_mergeAll();
  function concatAll() {
    return mergeAll_1.mergeAll(1);
  }
  exports.concatAll = concatAll;
});

// node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = undefined;
  var concatAll_1 = require_concatAll();
  var args_1 = require_args();
  var from_1 = require_from();
  function concat() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
  }
  exports.concat = concat;
});

// node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defer = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  function defer(observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
    });
  }
  exports.defer = defer;
});

// node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.connectable = undefined;
  var Subject_1 = require_Subject();
  var Observable_1 = require_Observable();
  var defer_1 = require_defer();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject;
    },
    resetOnDisconnect: true
  };
  function connectable(source, config) {
    if (config === undefined) {
      config = DEFAULT_CONFIG;
    }
    var connection = null;
    var { connector, resetOnDisconnect: _a } = config, resetOnDisconnect = _a === undefined ? true : _a;
    var subject = connector();
    var result = new Observable_1.Observable(function(subscriber) {
      return subject.subscribe(subscriber);
    });
    result.connect = function() {
      if (!connection || connection.closed) {
        connection = defer_1.defer(function() {
          return source;
        }).subscribe(subject);
        if (resetOnDisconnect) {
          connection.add(function() {
            return subject = connector();
          });
        }
      }
      return connection;
    };
    return result;
  }
  exports.connectable = connectable;
});

// node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.forkJoin = undefined;
  var Observable_1 = require_Observable();
  var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
  var innerFrom_1 = require_innerFrom();
  var args_1 = require_args();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var createObject_1 = require_createObject();
  function forkJoin() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
    var result = new Observable_1.Observable(function(subscriber) {
      var length = sources.length;
      if (!length) {
        subscriber.complete();
        return;
      }
      var values = new Array(length);
      var remainingCompletions = length;
      var remainingEmissions = length;
      var _loop_1 = function(sourceIndex2) {
        var hasValue = false;
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!hasValue) {
            hasValue = true;
            remainingEmissions--;
          }
          values[sourceIndex2] = value;
        }, function() {
          return remainingCompletions--;
        }, undefined, function() {
          if (!remainingCompletions || !hasValue) {
            if (!remainingEmissions) {
              subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
            }
            subscriber.complete();
          }
        }));
      };
      for (var sourceIndex = 0;sourceIndex < length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
    });
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  }
  exports.forkJoin = forkJoin;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromEvent = undefined;
  var innerFrom_1 = require_innerFrom();
  var Observable_1 = require_Observable();
  var mergeMap_1 = require_mergeMap();
  var isArrayLike_1 = require_isArrayLike();
  var isFunction_1 = require_isFunction();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
      resultSelector = options;
      options = undefined;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
    if (!add) {
      if (isArrayLike_1.isArrayLike(target)) {
        return mergeMap_1.mergeMap(function(subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom_1.innerFrom(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return subscriber.next(1 < args.length ? args : args[0]);
      };
      add(handler);
      return function() {
        return remove(handler);
      };
    });
  }
  exports.fromEvent = fromEvent;
  function toCommonHandlerRegistry(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  }
  function isNodeStyleEventEmitter(target) {
    return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
  }
  function isJQueryStyleEventEmitter(target) {
    return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
  }
  function isEventTarget(target) {
    return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromEventPattern = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
      return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var e = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          e[_i] = arguments[_i];
        }
        return subscriber.next(e.length === 1 ? e[0] : e);
      };
      var retValue = addHandler(handler);
      return isFunction_1.isFunction(removeHandler) ? function() {
        return removeHandler(handler, retValue);
      } : undefined;
    });
  }
  exports.fromEventPattern = fromEventPattern;
});

// node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS((exports) => {
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t[1]) {
                _2.label = t[1];
                t = op;
                break;
              }
              if (t && _2.label < t[2]) {
                _2.label = t[2];
                _2.ops.push(op);
                break;
              }
              if (t[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generate = undefined;
  var identity_1 = require_identity();
  var isScheduler_1 = require_isScheduler();
  var defer_1 = require_defer();
  var scheduleIterable_1 = require_scheduleIterable();
  function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
    var _a, _b;
    var resultSelector;
    var initialState;
    if (arguments.length === 1) {
      _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === undefined ? identity_1.identity : _b, scheduler = _a.scheduler;
    } else {
      initialState = initialStateOrOptions;
      if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrScheduler;
      } else {
        resultSelector = resultSelectorOrScheduler;
      }
    }
    function gen() {
      var state;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            state = initialState;
            _a2.label = 1;
          case 1:
            if (!(!condition || condition(state)))
              return [3, 4];
            return [4, resultSelector(state)];
          case 2:
            _a2.sent();
            _a2.label = 3;
          case 3:
            state = iterate(state);
            return [3, 1];
          case 4:
            return [2];
        }
      });
    }
    return defer_1.defer(scheduler ? function() {
      return scheduleIterable_1.scheduleIterable(gen(), scheduler);
    } : gen);
  }
  exports.generate = generate;
});

// node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iif = undefined;
  var defer_1 = require_defer();
  function iif(condition, trueResult, falseResult) {
    return defer_1.defer(function() {
      return condition() ? trueResult : falseResult;
    });
  }
  exports.iif = iif;
});

// node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timer = undefined;
  var Observable_1 = require_Observable();
  var async_1 = require_async();
  var isScheduler_1 = require_isScheduler();
  var isDate_1 = require_isDate();
  function timer(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === undefined) {
      dueTime = 0;
    }
    if (scheduler === undefined) {
      scheduler = async_1.async;
    }
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
      if (isScheduler_1.isScheduler(intervalOrScheduler)) {
        scheduler = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }
    return new Observable_1.Observable(function(subscriber) {
      var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n = 0;
      return scheduler.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n++);
          if (0 <= intervalDuration) {
            this.schedule(undefined, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  }
  exports.timer = timer;
});

// node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.interval = undefined;
  var async_1 = require_async();
  var timer_1 = require_timer();
  function interval(period, scheduler) {
    if (period === undefined) {
      period = 0;
    }
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    if (period < 0) {
      period = 0;
    }
    return timer_1.timer(period, period, scheduler);
  }
  exports.interval = interval;
});

// node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var mergeAll_1 = require_mergeAll();
  var innerFrom_1 = require_innerFrom();
  var empty_1 = require_empty2();
  var args_1 = require_args();
  var from_1 = require_from();
  function merge() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var concurrent = args_1.popNumber(args, Infinity);
    var sources = args;
    return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
  }
  exports.merge = merge;
});

// node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.never = exports.NEVER = undefined;
  var Observable_1 = require_Observable();
  var noop_1 = require_noop();
  exports.NEVER = new Observable_1.Observable(noop_1.noop);
  function never() {
    return exports.NEVER;
  }
  exports.never = never;
});

// node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argsOrArgArray = undefined;
  var isArray = Array.isArray;
  function argsOrArgArray(args) {
    return args.length === 1 && isArray(args[0]) ? args[0] : args;
  }
  exports.argsOrArgArray = argsOrArgArray;
});

// node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.onErrorResumeNext = undefined;
  var Observable_1 = require_Observable();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return new Observable_1.Observable(function(subscriber) {
      var sourceIndex = 0;
      var subscribeNext = function() {
        if (sourceIndex < nextSources.length) {
          var nextSource = undefined;
          try {
            nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
          } catch (err) {
            subscribeNext();
            return;
          }
          var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, undefined, noop_1.noop, noop_1.noop);
          nextSource.subscribe(innerSubscriber);
          innerSubscriber.add(subscribeNext);
        } else {
          subscriber.complete();
        }
      };
      subscribeNext();
    });
  }
  exports.onErrorResumeNext = onErrorResumeNext;
});

// node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pairs = undefined;
  var from_1 = require_from();
  function pairs(obj, scheduler) {
    return from_1.from(Object.entries(obj), scheduler);
  }
  exports.pairs = pairs;
});

// node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.not = undefined;
  function not(pred, thisArg) {
    return function(value, index) {
      return !pred.call(thisArg, value, index);
    };
  }
  exports.not = not;
});

// node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filter = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function filter(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }
  exports.filter = filter;
});

// node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.partition = undefined;
  var not_1 = require_not();
  var filter_1 = require_filter();
  var innerFrom_1 = require_innerFrom();
  function partition(source, predicate, thisArg) {
    return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
  }
  exports.partition = partition;
});

// node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.raceInit = exports.race = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function race() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    sources = argsOrArgArray_1.argsOrArgArray(sources);
    return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
  }
  exports.race = race;
  function raceInit(sources) {
    return function(subscriber) {
      var subscriptions = [];
      var _loop_1 = function(i2) {
        subscriptions.push(innerFrom_1.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (subscriptions) {
            for (var s = 0;s < subscriptions.length; s++) {
              s !== i2 && subscriptions[s].unsubscribe();
            }
            subscriptions = null;
          }
          subscriber.next(value);
        })));
      };
      for (var i = 0;subscriptions && !subscriber.closed && i < sources.length; i++) {
        _loop_1(i);
      }
    };
  }
  exports.raceInit = raceInit;
});

// node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.range = undefined;
  var Observable_1 = require_Observable();
  var empty_1 = require_empty2();
  function range(start, count, scheduler) {
    if (count == null) {
      count = start;
      start = 0;
    }
    if (count <= 0) {
      return empty_1.EMPTY;
    }
    var end = count + start;
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      var n = start;
      return scheduler.schedule(function() {
        if (n < end) {
          subscriber.next(n++);
          this.schedule();
        } else {
          subscriber.complete();
        }
      });
    } : function(subscriber) {
      var n = start;
      while (n < end && !subscriber.closed) {
        subscriber.next(n++);
      }
      subscriber.complete();
    });
  }
  exports.range = range;
});

// node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.using = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var empty_1 = require_empty2();
  function using(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      var resource = resourceFactory();
      var result = observableFactory(resource);
      var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
      source.subscribe(subscriber);
      return function() {
        if (resource) {
          resource.unsubscribe();
        }
      };
    });
  }
  exports.using = using;
});

// node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zip = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var empty_1 = require_empty2();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var args_1 = require_args();
  function zip() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    var sources = argsOrArgArray_1.argsOrArgArray(args);
    return sources.length ? new Observable_1.Observable(function(subscriber) {
      var buffers = sources.map(function() {
        return [];
      });
      var completed = sources.map(function() {
        return false;
      });
      subscriber.add(function() {
        buffers = completed = null;
      });
      var _loop_1 = function(sourceIndex2) {
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffers[sourceIndex2].push(value);
          if (buffers.every(function(buffer) {
            return buffer.length;
          })) {
            var result = buffers.map(function(buffer) {
              return buffer.shift();
            });
            subscriber.next(resultSelector ? resultSelector.apply(undefined, __spreadArray([], __read(result))) : result);
            if (buffers.some(function(buffer, i) {
              return !buffer.length && completed[i];
            })) {
              subscriber.complete();
            }
          }
        }, function() {
          completed[sourceIndex2] = true;
          !buffers[sourceIndex2].length && subscriber.complete();
        }));
      };
      for (var sourceIndex = 0;!subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
      return function() {
        buffers = completed = null;
      };
    }) : empty_1.EMPTY;
  }
  exports.zip = zip;
});

// node_modules/rxjs/dist/cjs/internal/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.audit = undefined;
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function audit(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var isComplete = false;
      var endDuration = function() {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
        isComplete && subscriber.complete();
      };
      var cleanupDuration = function() {
        durationSubscriber = null;
        isComplete && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        lastValue = value;
        if (!durationSubscriber) {
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
        }
      }, function() {
        isComplete = true;
        (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
      }));
    });
  }
  exports.audit = audit;
});

// node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.auditTime = undefined;
  var async_1 = require_async();
  var audit_1 = require_audit();
  var timer_1 = require_timer();
  function auditTime(duration, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return audit_1.audit(function() {
      return timer_1.timer(duration, scheduler);
    });
  }
  exports.auditTime = auditTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buffer = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function buffer(closingNotifier) {
    return lift_1.operate(function(source, subscriber) {
      var currentBuffer = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return currentBuffer.push(value);
      }, function() {
        subscriber.next(currentBuffer);
        subscriber.complete();
      }));
      innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        var b = currentBuffer;
        currentBuffer = [];
        subscriber.next(b);
      }, noop_1.noop));
      return function() {
        currentBuffer = null;
      };
    });
  }
  exports.buffer = buffer;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferCount = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === undefined) {
      startBufferEvery = null;
    }
    startBufferEvery = startBufferEvery !== null && startBufferEvery !== undefined ? startBufferEvery : bufferSize;
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      var count = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a, e_2, _b;
        var toEmit = null;
        if (count++ % startBufferEvery === 0) {
          buffers.push([]);
        }
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next();!buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer = buffers_1_1.value;
            buffer.push(value);
            if (bufferSize <= buffer.length) {
              toEmit = toEmit !== null && toEmit !== undefined ? toEmit : [];
              toEmit.push(buffer);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
              _a.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (toEmit) {
          try {
            for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next();!toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
              var buffer = toEmit_1_1.value;
              arrRemove_1.arrRemove(buffers, buffer);
              subscriber.next(buffer);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
                _b.call(toEmit_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      }, function() {
        var e_3, _a;
        try {
          for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next();!buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
            var buffer = buffers_2_1.value;
            subscriber.next(buffer);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
              _a.call(buffers_2);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        subscriber.complete();
      }, undefined, function() {
        buffers = null;
      }));
    });
  }
  exports.bufferCount = bufferCount;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferTime = undefined;
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  var async_1 = require_async();
  var args_1 = require_args();
  var executeSchedule_1 = require_executeSchedule();
  function bufferTime(bufferTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== undefined ? _a : async_1.asyncScheduler;
    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== undefined ? _b : null;
    var maxBufferSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var bufferRecords = [];
      var restartOnEmit = false;
      var emit = function(record) {
        var { buffer, subs } = record;
        subs.unsubscribe();
        arrRemove_1.arrRemove(bufferRecords, record);
        subscriber.next(buffer);
        restartOnEmit && startBuffer();
      };
      var startBuffer = function() {
        if (bufferRecords) {
          var subs = new Subscription_1.Subscription;
          subscriber.add(subs);
          var buffer = [];
          var record_1 = {
            buffer,
            subs
          };
          bufferRecords.push(record_1);
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return emit(record_1);
          }, bufferTimeSpan);
        }
      };
      if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
      } else {
        restartOnEmit = true;
      }
      startBuffer();
      var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a2;
        var recordsCopy = bufferRecords.slice();
        try {
          for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next();!recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
            var record = recordsCopy_1_1.value;
            var buffer = record.buffer;
            buffer.push(value);
            maxBufferSize <= buffer.length && emit(record);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
              _a2.call(recordsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (bufferRecords === null || bufferRecords === undefined ? undefined : bufferRecords.length) {
          subscriber.next(bufferRecords.shift().buffer);
        }
        bufferTimeSubscriber === null || bufferTimeSubscriber === undefined || bufferTimeSubscriber.unsubscribe();
        subscriber.complete();
        subscriber.unsubscribe();
      }, undefined, function() {
        return bufferRecords = null;
      });
      source.subscribe(bufferTimeSubscriber);
    });
  }
  exports.bufferTime = bufferTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferToggle = undefined;
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var arrRemove_1 = require_arrRemove();
  function bufferToggle(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var buffer = [];
        buffers.push(buffer);
        var closingSubscription = new Subscription_1.Subscription;
        var emitBuffer = function() {
          arrRemove_1.arrRemove(buffers, buffer);
          subscriber.next(buffer);
          closingSubscription.unsubscribe();
        };
        closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a;
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next();!buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer = buffers_1_1.value;
            buffer.push(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
              _a.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (buffers.length > 0) {
          subscriber.next(buffers.shift());
        }
        subscriber.complete();
      }));
    });
  }
  exports.bufferToggle = bufferToggle;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferWhen = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function bufferWhen(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffer = null;
      var closingSubscriber = null;
      var openBuffer = function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        var b = buffer;
        buffer = [];
        b && subscriber.next(b);
        innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
      };
      openBuffer();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return buffer === null || buffer === undefined ? undefined : buffer.push(value);
      }, function() {
        buffer && subscriber.next(buffer);
        subscriber.complete();
      }, undefined, function() {
        return buffer = closingSubscriber = null;
      }));
    });
  }
  exports.bufferWhen = bufferWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.catchError = undefined;
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var lift_1 = require_lift();
  function catchError(selector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function(err) {
        handledResult = innerFrom_1.innerFrom(selector(err, catchError(selector)(source)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  }
  exports.catchError = catchError;
});

// node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scanInternals = undefined;
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
      var hasState = hasSeed;
      var state = seed;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var i = index++;
        state = hasState ? accumulator(state, value, i) : (hasState = true, value);
        emitOnNext && subscriber.next(state);
      }, emitBeforeComplete && function() {
        hasState && subscriber.next(state);
        subscriber.complete();
      }));
    };
  }
  exports.scanInternals = scanInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reduce = undefined;
  var scanInternals_1 = require_scanInternals();
  var lift_1 = require_lift();
  function reduce(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
  }
  exports.reduce = reduce;
});

// node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toArray = undefined;
  var reduce_1 = require_reduce();
  var lift_1 = require_lift();
  var arrReducer = function(arr, value) {
    return arr.push(value), arr;
  };
  function toArray() {
    return lift_1.operate(function(source, subscriber) {
      reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
    });
  }
  exports.toArray = toArray;
});

// node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.joinAllInternals = undefined;
  var identity_1 = require_identity();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var pipe_1 = require_pipe();
  var mergeMap_1 = require_mergeMap();
  var toArray_1 = require_toArray();
  function joinAllInternals(joinFn, project) {
    return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
      return joinFn(sources);
    }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
  }
  exports.joinAllInternals = joinAllInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestAll = undefined;
  var combineLatest_1 = require_combineLatest();
  var joinAllInternals_1 = require_joinAllInternals();
  function combineLatestAll(project) {
    return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
  }
  exports.combineLatestAll = combineLatestAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineAll = undefined;
  var combineLatestAll_1 = require_combineLatestAll();
  exports.combineAll = combineLatestAll_1.combineLatestAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatest = undefined;
  var combineLatest_1 = require_combineLatest();
  var lift_1 = require_lift();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var pipe_1 = require_pipe();
  var args_1 = require_args();
  function combineLatest() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    return resultSelector ? pipe_1.pipe(combineLatest.apply(undefined, __spreadArray([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
      combineLatest_1.combineLatestInit(__spreadArray([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
    });
  }
  exports.combineLatest = combineLatest;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestWith = undefined;
  var combineLatest_1 = require_combineLatest2();
  function combineLatestWith() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return combineLatest_1.combineLatest.apply(undefined, __spreadArray([], __read(otherSources)));
  }
  exports.combineLatestWith = combineLatestWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatMap = undefined;
  var mergeMap_1 = require_mergeMap();
  var isFunction_1 = require_isFunction();
  function concatMap(project, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
  }
  exports.concatMap = concatMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatMapTo = undefined;
  var concatMap_1 = require_concatMap();
  var isFunction_1 = require_isFunction();
  function concatMapTo(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
      return innerObservable;
    }, resultSelector) : concatMap_1.concatMap(function() {
      return innerObservable;
    });
  }
  exports.concatMapTo = concatMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = undefined;
  var lift_1 = require_lift();
  var concatAll_1 = require_concatAll();
  var args_1 = require_args();
  var from_1 = require_from();
  function concat() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    return lift_1.operate(function(source, subscriber) {
      concatAll_1.concatAll()(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  }
  exports.concat = concat;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatWith = undefined;
  var concat_1 = require_concat2();
  function concatWith() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return concat_1.concat.apply(undefined, __spreadArray([], __read(otherSources)));
  }
  exports.concatWith = concatWith;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromSubscribable = undefined;
  var Observable_1 = require_Observable();
  function fromSubscribable(subscribable) {
    return new Observable_1.Observable(function(subscriber) {
      return subscribable.subscribe(subscriber);
    });
  }
  exports.fromSubscribable = fromSubscribable;
});

// node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.connect = undefined;
  var Subject_1 = require_Subject();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var fromSubscribable_1 = require_fromSubscribable();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject;
    }
  };
  function connect(selector, config) {
    if (config === undefined) {
      config = DEFAULT_CONFIG;
    }
    var connector = config.connector;
    return lift_1.operate(function(source, subscriber) {
      var subject = connector();
      innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
      subscriber.add(source.subscribe(subject));
    });
  }
  exports.connect = connect;
});

// node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.count = undefined;
  var reduce_1 = require_reduce();
  function count(predicate) {
    return reduce_1.reduce(function(total, value, i) {
      return !predicate || predicate(value, i) ? total + 1 : total;
    }, 0);
  }
  exports.count = count;
});

// node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debounce = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function debounce(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var emit = function() {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        hasValue = true;
        lastValue = value;
        durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
        innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
      }, function() {
        emit();
        subscriber.complete();
      }, undefined, function() {
        lastValue = durationSubscriber = null;
      }));
    });
  }
  exports.debounce = debounce;
});

// node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debounceTime = undefined;
  var async_1 = require_async();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function debounceTime(dueTime, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var activeTask = null;
      var lastValue = null;
      var lastTime = null;
      var emit = function() {
        if (activeTask) {
          activeTask.unsubscribe();
          activeTask = null;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      function emitWhenIdle() {
        var targetTime = lastTime + dueTime;
        var now = scheduler.now();
        if (now < targetTime) {
          activeTask = this.schedule(undefined, targetTime - now);
          subscriber.add(activeTask);
          return;
        }
        emit();
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        lastValue = value;
        lastTime = scheduler.now();
        if (!activeTask) {
          activeTask = scheduler.schedule(emitWhenIdle, dueTime);
          subscriber.add(activeTask);
        }
      }, function() {
        emit();
        subscriber.complete();
      }, undefined, function() {
        lastValue = activeTask = null;
      }));
    });
  }
  exports.debounceTime = debounceTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultIfEmpty = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function defaultIfEmpty(defaultValue) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  }
  exports.defaultIfEmpty = defaultIfEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.take = undefined;
  var empty_1 = require_empty2();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function take(count) {
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (++seen <= count) {
          subscriber.next(value);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }
  exports.take = take;
});

// node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ignoreElements = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  function ignoreElements() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
    });
  }
  exports.ignoreElements = ignoreElements;
});

// node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapTo = undefined;
  var map_1 = require_map();
  function mapTo(value) {
    return map_1.map(function() {
      return value;
    });
  }
  exports.mapTo = mapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delayWhen = undefined;
  var concat_1 = require_concat();
  var take_1 = require_take();
  var ignoreElements_1 = require_ignoreElements();
  var mapTo_1 = require_mapTo();
  var mergeMap_1 = require_mergeMap();
  var innerFrom_1 = require_innerFrom();
  function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
      return function(source) {
        return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
      };
    }
    return mergeMap_1.mergeMap(function(value, index) {
      return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
    });
  }
  exports.delayWhen = delayWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = undefined;
  var async_1 = require_async();
  var delayWhen_1 = require_delayWhen();
  var timer_1 = require_timer();
  function delay(due, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    var duration = timer_1.timer(due, scheduler);
    return delayWhen_1.delayWhen(function() {
      return duration;
    });
  }
  exports.delay = delay;
});

// node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dematerialize = undefined;
  var Notification_1 = require_Notification();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function dematerialize() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
        return Notification_1.observeNotification(notification, subscriber);
      }));
    });
  }
  exports.dematerialize = dematerialize;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinct = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  function distinct(keySelector, flushes) {
    return lift_1.operate(function(source, subscriber) {
      var distinctKeys = new Set;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var key11 = keySelector ? keySelector(value) : value;
        if (!distinctKeys.has(key11)) {
          distinctKeys.add(key11);
          subscriber.next(value);
        }
      }));
      flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return distinctKeys.clear();
      }, noop_1.noop));
    });
  }
  exports.distinct = distinct;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinctUntilChanged = undefined;
  var identity_1 = require_identity();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function distinctUntilChanged(comparator, keySelector) {
    if (keySelector === undefined) {
      keySelector = identity_1.identity;
    }
    comparator = comparator !== null && comparator !== undefined ? comparator : defaultCompare;
    return lift_1.operate(function(source, subscriber) {
      var previousKey;
      var first = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var currentKey = keySelector(value);
        if (first || !comparator(previousKey, currentKey)) {
          first = false;
          previousKey = currentKey;
          subscriber.next(value);
        }
      }));
    });
  }
  exports.distinctUntilChanged = distinctUntilChanged;
  function defaultCompare(a, b) {
    return a === b;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinctUntilKeyChanged = undefined;
  var distinctUntilChanged_1 = require_distinctUntilChanged();
  function distinctUntilKeyChanged(key11, compare) {
    return distinctUntilChanged_1.distinctUntilChanged(function(x, y) {
      return compare ? compare(x[key11], y[key11]) : x[key11] === y[key11];
    });
  }
  exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
});

// node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throwIfEmpty = undefined;
  var EmptyError_1 = require_EmptyError();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function throwIfEmpty(errorFactory) {
    if (errorFactory === undefined) {
      errorFactory = defaultErrorFactory;
    }
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  }
  exports.throwIfEmpty = throwIfEmpty;
  function defaultErrorFactory() {
    return new EmptyError_1.EmptyError;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.elementAt = undefined;
  var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
  var filter_1 = require_filter();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var take_1 = require_take();
  function elementAt(index, defaultValue) {
    if (index < 0) {
      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    }
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(filter_1.filter(function(v, i) {
        return i === index;
      }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
      }));
    };
  }
  exports.elementAt = elementAt;
});

// node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.endWith = undefined;
  var concat_1 = require_concat();
  var of_1 = require_of();
  function endWith() {
    var values = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    return function(source) {
      return concat_1.concat(source, of_1.of.apply(undefined, __spreadArray([], __read(values))));
    };
  }
  exports.endWith = endWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.every = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function every(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (!predicate.call(thisArg, value, index++, source)) {
          subscriber.next(false);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  }
  exports.every = every;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaustMap = undefined;
  var map_1 = require_map();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function exhaustMap(project, resultSelector) {
    if (resultSelector) {
      return function(source) {
        return source.pipe(exhaustMap(function(a, i) {
          return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          }));
        }));
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      var innerSub = null;
      var isComplete = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
        if (!innerSub) {
          innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
            innerSub = null;
            isComplete && subscriber.complete();
          });
          innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
        }
      }, function() {
        isComplete = true;
        !innerSub && subscriber.complete();
      }));
    });
  }
  exports.exhaustMap = exhaustMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaustAll = undefined;
  var exhaustMap_1 = require_exhaustMap();
  var identity_1 = require_identity();
  function exhaustAll() {
    return exhaustMap_1.exhaustMap(identity_1.identity);
  }
  exports.exhaustAll = exhaustAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaust = undefined;
  var exhaustAll_1 = require_exhaustAll();
  exports.exhaust = exhaustAll_1.exhaustAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.expand = undefined;
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  function expand(project, concurrent, scheduler) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);
    });
  }
  exports.expand = expand;
});

// node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.finalize = undefined;
  var lift_1 = require_lift();
  function finalize(callback) {
    return lift_1.operate(function(source, subscriber) {
      try {
        source.subscribe(subscriber);
      } finally {
        subscriber.add(callback);
      }
    });
  }
  exports.finalize = finalize;
});

// node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFind = exports.find = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function find(predicate, thisArg) {
    return lift_1.operate(createFind(predicate, thisArg, "value"));
  }
  exports.find = find;
  function createFind(predicate, thisArg, emit) {
    var findIndex = emit === "index";
    return function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var i = index++;
        if (predicate.call(thisArg, value, i, source)) {
          subscriber.next(findIndex ? i : value);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(findIndex ? -1 : undefined);
        subscriber.complete();
      }));
    };
  }
  exports.createFind = createFind;
});

// node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.findIndex = undefined;
  var lift_1 = require_lift();
  var find_1 = require_find();
  function findIndex(predicate, thisArg) {
    return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
  }
  exports.findIndex = findIndex;
});

// node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.first = undefined;
  var EmptyError_1 = require_EmptyError();
  var filter_1 = require_filter();
  var take_1 = require_take();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var identity_1 = require_identity();
  function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i) {
        return predicate(v, i, source);
      }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError;
      }));
    };
  }
  exports.first = first;
});

// node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.groupBy = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function groupBy(keySelector, elementOrOptions, duration, connector) {
    return lift_1.operate(function(source, subscriber) {
      var element;
      if (!elementOrOptions || typeof elementOrOptions === "function") {
        element = elementOrOptions;
      } else {
        duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
      }
      var groups = new Map;
      var notify = function(cb) {
        groups.forEach(cb);
        cb(subscriber);
      };
      var handleError = function(err) {
        return notify(function(consumer) {
          return consumer.error(err);
        });
      };
      var activeGroups = 0;
      var teardownAttempted = false;
      var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
        try {
          var key_1 = keySelector(value);
          var group_1 = groups.get(key_1);
          if (!group_1) {
            groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject);
            var grouped = createGroupedObservable(key_1, group_1);
            subscriber.next(grouped);
            if (duration) {
              var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                group_1.complete();
                durationSubscriber_1 === null || durationSubscriber_1 === undefined || durationSubscriber_1.unsubscribe();
              }, undefined, undefined, function() {
                return groups.delete(key_1);
              });
              groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
            }
          }
          group_1.next(element ? element(value) : value);
        } catch (err) {
          handleError(err);
        }
      }, function() {
        return notify(function(consumer) {
          return consumer.complete();
        });
      }, handleError, function() {
        return groups.clear();
      }, function() {
        teardownAttempted = true;
        return activeGroups === 0;
      });
      source.subscribe(groupBySourceSubscriber);
      function createGroupedObservable(key11, groupSubject) {
        var result = new Observable_1.Observable(function(groupSubscriber) {
          activeGroups++;
          var innerSub = groupSubject.subscribe(groupSubscriber);
          return function() {
            innerSub.unsubscribe();
            --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
          };
        });
        result.key = key11;
        return result;
      }
    });
  }
  exports.groupBy = groupBy;
});

// node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEmpty = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function isEmpty() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        subscriber.next(false);
        subscriber.complete();
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  }
  exports.isEmpty = isEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeLast = undefined;
  var empty_1 = require_empty2();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function takeLast(count) {
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var buffer = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        buffer.push(value);
        count < buffer.length && buffer.shift();
      }, function() {
        var e_1, _a;
        try {
          for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next();!buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
            var value = buffer_1_1.value;
            subscriber.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
              _a.call(buffer_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        subscriber.complete();
      }, undefined, function() {
        buffer = null;
      }));
    });
  }
  exports.takeLast = takeLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.last = undefined;
  var EmptyError_1 = require_EmptyError();
  var filter_1 = require_filter();
  var takeLast_1 = require_takeLast();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var identity_1 = require_identity();
  function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i) {
        return predicate(v, i, source);
      }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError;
      }));
    };
  }
  exports.last = last;
});

// node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.materialize = undefined;
  var Notification_1 = require_Notification();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function materialize() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(Notification_1.Notification.createNext(value));
      }, function() {
        subscriber.next(Notification_1.Notification.createComplete());
        subscriber.complete();
      }, function(err) {
        subscriber.next(Notification_1.Notification.createError(err));
        subscriber.complete();
      }));
    });
  }
  exports.materialize = materialize;
});

// node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.max = undefined;
  var reduce_1 = require_reduce();
  var isFunction_1 = require_isFunction();
  function max(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
      return comparer(x, y) > 0 ? x : y;
    } : function(x, y) {
      return x > y ? x : y;
    });
  }
  exports.max = max;
});

// node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flatMap = undefined;
  var mergeMap_1 = require_mergeMap();
  exports.flatMap = mergeMap_1.mergeMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeMapTo = undefined;
  var mergeMap_1 = require_mergeMap();
  var isFunction_1 = require_isFunction();
  function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, resultSelector, concurrent);
    }
    if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return mergeMap_1.mergeMap(function() {
      return innerObservable;
    }, concurrent);
  }
  exports.mergeMapTo = mergeMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeScan = undefined;
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    return lift_1.operate(function(source, subscriber) {
      var state = seed;
      return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
        return accumulator(state, value, index);
      }, concurrent, function(value) {
        state = value;
      }, false, undefined, function() {
        return state = null;
      });
    });
  }
  exports.mergeScan = mergeScan;
});

// node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge2 = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var lift_1 = require_lift();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var mergeAll_1 = require_mergeAll();
  var args_1 = require_args();
  var from_1 = require_from();
  function merge() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var concurrent = args_1.popNumber(args, Infinity);
    args = argsOrArgArray_1.argsOrArgArray(args);
    return lift_1.operate(function(source, subscriber) {
      mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  }
  exports.merge = merge;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeWith = undefined;
  var merge_1 = require_merge2();
  function mergeWith() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return merge_1.merge.apply(undefined, __spreadArray([], __read(otherSources)));
  }
  exports.mergeWith = mergeWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.min = undefined;
  var reduce_1 = require_reduce();
  var isFunction_1 = require_isFunction();
  function min(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
      return comparer(x, y) < 0 ? x : y;
    } : function(x, y) {
      return x < y ? x : y;
    });
  }
  exports.min = min;
});

// node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.multicast = undefined;
  var ConnectableObservable_1 = require_ConnectableObservable();
  var isFunction_1 = require_isFunction();
  var connect_1 = require_connect();
  function multicast(subjectOrSubjectFactory, selector) {
    var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
      return subjectOrSubjectFactory;
    };
    if (isFunction_1.isFunction(selector)) {
      return connect_1.connect(selector, {
        connector: subjectFactory
      });
    }
    return function(source) {
      return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
    };
  }
  exports.multicast = multicast;
});

// node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.onErrorResumeNext = exports.onErrorResumeNextWith = undefined;
  var argsOrArgArray_1 = require_argsOrArgArray();
  var onErrorResumeNext_1 = require_onErrorResumeNext();
  function onErrorResumeNextWith() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return function(source) {
      return onErrorResumeNext_1.onErrorResumeNext.apply(undefined, __spreadArray([source], __read(nextSources)));
    };
  }
  exports.onErrorResumeNextWith = onErrorResumeNextWith;
  exports.onErrorResumeNext = onErrorResumeNextWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pairwise = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function pairwise() {
    return lift_1.operate(function(source, subscriber) {
      var prev;
      var hasPrev = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var p = prev;
        prev = value;
        hasPrev && subscriber.next([p, value]);
        hasPrev = true;
      }));
    });
  }
  exports.pairwise = pairwise;
});

// node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pluck = undefined;
  var map_1 = require_map();
  function pluck() {
    var properties = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
      throw new Error("list of properties cannot be empty.");
    }
    return map_1.map(function(x) {
      var currentProp = x;
      for (var i = 0;i < length; i++) {
        var p = currentProp === null || currentProp === undefined ? undefined : currentProp[properties[i]];
        if (typeof p !== "undefined") {
          currentProp = p;
        } else {
          return;
        }
      }
      return currentProp;
    });
  }
  exports.pluck = pluck;
});

// node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publish = undefined;
  var Subject_1 = require_Subject();
  var multicast_1 = require_multicast();
  var connect_1 = require_connect();
  function publish(selector) {
    return selector ? function(source) {
      return connect_1.connect(selector)(source);
    } : function(source) {
      return multicast_1.multicast(new Subject_1.Subject)(source);
    };
  }
  exports.publish = publish;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishBehavior = undefined;
  var BehaviorSubject_1 = require_BehaviorSubject();
  var ConnectableObservable_1 = require_ConnectableObservable();
  function publishBehavior(initialValue) {
    return function(source) {
      var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  }
  exports.publishBehavior = publishBehavior;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishLast = undefined;
  var AsyncSubject_1 = require_AsyncSubject();
  var ConnectableObservable_1 = require_ConnectableObservable();
  function publishLast() {
    return function(source) {
      var subject = new AsyncSubject_1.AsyncSubject;
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  }
  exports.publishLast = publishLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishReplay = undefined;
  var ReplaySubject_1 = require_ReplaySubject();
  var multicast_1 = require_multicast();
  var isFunction_1 = require_isFunction();
  function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
    if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
      timestampProvider = selectorOrScheduler;
    }
    var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;
    return function(source) {
      return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
    };
  }
  exports.publishReplay = publishReplay;
});

// node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.raceWith = undefined;
  var race_1 = require_race();
  var lift_1 = require_lift();
  var identity_1 = require_identity();
  function raceWith() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
    });
  }
  exports.raceWith = raceWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.repeat = undefined;
  var empty_1 = require_empty2();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var timer_1 = require_timer();
  function repeat(countOrConfig) {
    var _a;
    var count = Infinity;
    var delay;
    if (countOrConfig != null) {
      if (typeof countOrConfig === "object") {
        _a = countOrConfig.count, count = _a === undefined ? Infinity : _a, delay = countOrConfig.delay;
      } else {
        count = countOrConfig;
      }
    }
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var sourceSub;
      var resubscribe = function() {
        sourceSub === null || sourceSub === undefined || sourceSub.unsubscribe();
        sourceSub = null;
        if (delay != null) {
          var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
          var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            notifierSubscriber_1.unsubscribe();
            subscribeToSource();
          });
          notifier.subscribe(notifierSubscriber_1);
        } else {
          subscribeToSource();
        }
      };
      var subscribeToSource = function() {
        var syncUnsub = false;
        sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
          if (++soFar < count) {
            if (sourceSub) {
              resubscribe();
            } else {
              syncUnsub = true;
            }
          } else {
            subscriber.complete();
          }
        }));
        if (syncUnsub) {
          resubscribe();
        }
      };
      subscribeToSource();
    });
  }
  exports.repeat = repeat;
});

// node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.repeatWhen = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function repeatWhen(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var completions$;
      var isNotifierComplete = false;
      var isMainComplete = false;
      var checkComplete = function() {
        return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
      };
      var getCompletionSubject = function() {
        if (!completions$) {
          completions$ = new Subject_1.Subject;
          innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            if (innerSub) {
              subscribeForRepeatWhen();
            } else {
              syncResub = true;
            }
          }, function() {
            isNotifierComplete = true;
            checkComplete();
          }));
        }
        return completions$;
      };
      var subscribeForRepeatWhen = function() {
        isMainComplete = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
          isMainComplete = true;
          !checkComplete() && getCompletionSubject().next();
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRepeatWhen();
        }
      };
      subscribeForRepeatWhen();
    });
  }
  exports.repeatWhen = repeatWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retry = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var identity_1 = require_identity();
  var timer_1 = require_timer();
  var innerFrom_1 = require_innerFrom();
  function retry(configOrCount) {
    if (configOrCount === undefined) {
      configOrCount = Infinity;
    }
    var config;
    if (configOrCount && typeof configOrCount === "object") {
      config = configOrCount;
    } else {
      config = {
        count: configOrCount
      };
    }
    var _a = config.count, count = _a === undefined ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === undefined ? false : _b;
    return count <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var innerSub;
      var subscribeForRetry = function() {
        var syncUnsub = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (resetOnSuccess) {
            soFar = 0;
          }
          subscriber.next(value);
        }, undefined, function(err) {
          if (soFar++ < count) {
            var resub_1 = function() {
              if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                subscribeForRetry();
              } else {
                syncUnsub = true;
              }
            };
            if (delay != null) {
              var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
              var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                notifierSubscriber_1.unsubscribe();
                resub_1();
              }, function() {
                subscriber.complete();
              });
              notifier.subscribe(notifierSubscriber_1);
            } else {
              resub_1();
            }
          } else {
            subscriber.error(err);
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          subscribeForRetry();
        }
      };
      subscribeForRetry();
    });
  }
  exports.retry = retry;
});

// node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryWhen = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function retryWhen(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var errors$;
      var subscribeForRetryWhen = function() {
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function(err) {
          if (!errors$) {
            errors$ = new Subject_1.Subject;
            innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              return innerSub ? subscribeForRetryWhen() : syncResub = true;
            }));
          }
          if (errors$) {
            errors$.next(err);
          }
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRetryWhen();
        }
      };
      subscribeForRetryWhen();
    });
  }
  exports.retryWhen = retryWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sample = undefined;
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function sample2(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        lastValue = value;
      }));
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      }, noop_1.noop));
    });
  }
  exports.sample = sample2;
});

// node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sampleTime = undefined;
  var async_1 = require_async();
  var sample_1 = require_sample();
  var interval_1 = require_interval();
  function sampleTime(period, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return sample_1.sample(interval_1.interval(period, scheduler));
  }
  exports.sampleTime = sampleTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scan = undefined;
  var lift_1 = require_lift();
  var scanInternals_1 = require_scanInternals();
  function scan(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
  }
  exports.scan = scan;
});

// node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sequenceEqual = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function sequenceEqual(compareTo, comparator) {
    if (comparator === undefined) {
      comparator = function(a, b) {
        return a === b;
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var aState = createState();
      var bState = createState();
      var emit = function(isEqual) {
        subscriber.next(isEqual);
        subscriber.complete();
      };
      var createSubscriber = function(selfState, otherState) {
        var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
          var { buffer, complete } = otherState;
          if (buffer.length === 0) {
            complete ? emit(false) : selfState.buffer.push(a);
          } else {
            !comparator(a, buffer.shift()) && emit(false);
          }
        }, function() {
          selfState.complete = true;
          var { complete, buffer } = otherState;
          complete && emit(buffer.length === 0);
          sequenceEqualSubscriber === null || sequenceEqualSubscriber === undefined || sequenceEqualSubscriber.unsubscribe();
        });
        return sequenceEqualSubscriber;
      };
      source.subscribe(createSubscriber(aState, bState));
      innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
    });
  }
  exports.sequenceEqual = sequenceEqual;
  function createState() {
    return {
      buffer: [],
      complete: false
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.share = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var Subscriber_1 = require_Subscriber();
  var lift_1 = require_lift();
  function share(options) {
    if (options === undefined) {
      options = {};
    }
    var _a = options.connector, connector = _a === undefined ? function() {
      return new Subject_1.Subject;
    } : _a, _b = options.resetOnError, resetOnError = _b === undefined ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === undefined ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === undefined ? true : _d;
    return function(wrapperSource) {
      var connection;
      var resetConnection;
      var subject;
      var refCount = 0;
      var hasCompleted = false;
      var hasErrored = false;
      var cancelReset = function() {
        resetConnection === null || resetConnection === undefined || resetConnection.unsubscribe();
        resetConnection = undefined;
      };
      var reset = function() {
        cancelReset();
        connection = subject = undefined;
        hasCompleted = hasErrored = false;
      };
      var resetAndUnsubscribe = function() {
        var conn = connection;
        reset();
        conn === null || conn === undefined || conn.unsubscribe();
      };
      return lift_1.operate(function(source, subscriber) {
        refCount++;
        if (!hasErrored && !hasCompleted) {
          cancelReset();
        }
        var dest = subject = subject !== null && subject !== undefined ? subject : connector();
        subscriber.add(function() {
          refCount--;
          if (refCount === 0 && !hasErrored && !hasCompleted) {
            resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
          }
        });
        dest.subscribe(subscriber);
        if (!connection && refCount > 0) {
          connection = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              return dest.next(value);
            },
            error: function(err) {
              hasErrored = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnError, err);
              dest.error(err);
            },
            complete: function() {
              hasCompleted = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnComplete);
              dest.complete();
            }
          });
          innerFrom_1.innerFrom(source).subscribe(connection);
        }
      })(wrapperSource);
    };
  }
  exports.share = share;
  function handleReset(reset, on) {
    var args = [];
    for (var _i = 2;_i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    if (on === true) {
      reset();
      return;
    }
    if (on === false) {
      return;
    }
    var onSubscriber = new Subscriber_1.SafeSubscriber({
      next: function() {
        onSubscriber.unsubscribe();
        reset();
      }
    });
    return innerFrom_1.innerFrom(on.apply(undefined, __spreadArray([], __read(args)))).subscribe(onSubscriber);
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shareReplay = undefined;
  var ReplaySubject_1 = require_ReplaySubject();
  var share_1 = require_share();
  function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var _a, _b, _c;
    var bufferSize;
    var refCount = false;
    if (configOrBufferSize && typeof configOrBufferSize === "object") {
      _a = configOrBufferSize.bufferSize, bufferSize = _a === undefined ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === undefined ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === undefined ? false : _c, scheduler = configOrBufferSize.scheduler;
    } else {
      bufferSize = configOrBufferSize !== null && configOrBufferSize !== undefined ? configOrBufferSize : Infinity;
    }
    return share_1.share({
      connector: function() {
        return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
      },
      resetOnError: true,
      resetOnComplete: false,
      resetOnRefCountZero: refCount
    });
  }
  exports.shareReplay = shareReplay;
});

// node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.single = undefined;
  var EmptyError_1 = require_EmptyError();
  var SequenceError_1 = require_SequenceError();
  var NotFoundError_1 = require_NotFoundError();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function single(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var singleValue;
      var seenValue = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        seenValue = true;
        if (!predicate || predicate(value, index++, source)) {
          hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
          hasValue = true;
          singleValue = value;
        }
      }, function() {
        if (hasValue) {
          subscriber.next(singleValue);
          subscriber.complete();
        } else {
          subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError);
        }
      }));
    });
  }
  exports.single = single;
});

// node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skip = undefined;
  var filter_1 = require_filter();
  function skip(count) {
    return filter_1.filter(function(_2, index) {
      return count <= index;
    });
  }
  exports.skip = skip;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipLast = undefined;
  var identity_1 = require_identity();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function skipLast(skipCount) {
    return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var ring = new Array(skipCount);
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var valueIndex = seen++;
        if (valueIndex < skipCount) {
          ring[valueIndex] = value;
        } else {
          var index = valueIndex % skipCount;
          var oldValue = ring[index];
          ring[index] = value;
          subscriber.next(oldValue);
        }
      }));
      return function() {
        ring = null;
      };
    });
  }
  exports.skipLast = skipLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipUntil = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var noop_1 = require_noop();
  function skipUntil(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        skipSubscriber === null || skipSubscriber === undefined || skipSubscriber.unsubscribe();
        taking = true;
      }, noop_1.noop);
      innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return taking && subscriber.next(value);
      }));
    });
  }
  exports.skipUntil = skipUntil;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipWhile = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function skipWhile(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
      }));
    });
  }
  exports.skipWhile = skipWhile;
});

// node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.startWith = undefined;
  var concat_1 = require_concat();
  var args_1 = require_args();
  var lift_1 = require_lift();
  function startWith() {
    var values = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(values);
    return lift_1.operate(function(source, subscriber) {
      (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
    });
  }
  exports.startWith = startWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchMap = undefined;
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function switchMap(project, resultSelector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        innerSubscriber === null || innerSubscriber === undefined || innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  }
  exports.switchMap = switchMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchAll = undefined;
  var switchMap_1 = require_switchMap();
  var identity_1 = require_identity();
  function switchAll() {
    return switchMap_1.switchMap(identity_1.identity);
  }
  exports.switchAll = switchAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchMapTo = undefined;
  var switchMap_1 = require_switchMap();
  var isFunction_1 = require_isFunction();
  function switchMapTo(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
      return innerObservable;
    }, resultSelector) : switchMap_1.switchMap(function() {
      return innerObservable;
    });
  }
  exports.switchMapTo = switchMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchScan = undefined;
  var switchMap_1 = require_switchMap();
  var lift_1 = require_lift();
  function switchScan(accumulator, seed) {
    return lift_1.operate(function(source, subscriber) {
      var state = seed;
      switchMap_1.switchMap(function(value, index) {
        return accumulator(state, value, index);
      }, function(_2, innerValue) {
        return state = innerValue, innerValue;
      })(source).subscribe(subscriber);
      return function() {
        state = null;
      };
    });
  }
  exports.switchScan = switchScan;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeUntil = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var noop_1 = require_noop();
  function takeUntil(notifier) {
    return lift_1.operate(function(source, subscriber) {
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop_1.noop));
      !subscriber.closed && source.subscribe(subscriber);
    });
  }
  exports.takeUntil = takeUntil;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeWhile = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function takeWhile(predicate, inclusive) {
    if (inclusive === undefined) {
      inclusive = false;
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var result = predicate(value, index++);
        (result || inclusive) && subscriber.next(value);
        !result && subscriber.complete();
      }));
    });
  }
  exports.takeWhile = takeWhile;
});

// node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tap = undefined;
  var isFunction_1 = require_isFunction();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var identity_1 = require_identity();
  function tap(observerOrNext, error, complete) {
    var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
    return tapObserver ? lift_1.operate(function(source, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === undefined || _a.call(tapObserver);
      var isUnsub = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === undefined || _a2.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === undefined || _a2.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === undefined || _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === undefined || _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === undefined || _b.call(tapObserver);
      }));
    }) : identity_1.identity;
  }
  exports.tap = tap;
});

// node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttle = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function throttle(durationSelector, config) {
    return lift_1.operate(function(source, subscriber) {
      var _a = config !== null && config !== undefined ? config : {}, _b = _a.leading, leading = _b === undefined ? true : _b, _c = _a.trailing, trailing = _c === undefined ? false : _c;
      var hasValue = false;
      var sendValue = null;
      var throttled = null;
      var isComplete = false;
      var endThrottling = function() {
        throttled === null || throttled === undefined || throttled.unsubscribe();
        throttled = null;
        if (trailing) {
          send();
          isComplete && subscriber.complete();
        }
      };
      var cleanupThrottling = function() {
        throttled = null;
        isComplete && subscriber.complete();
      };
      var startThrottle = function(value) {
        return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
      };
      var send = function() {
        if (hasValue) {
          hasValue = false;
          var value = sendValue;
          sendValue = null;
          subscriber.next(value);
          !isComplete && startThrottle(value);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        sendValue = value;
        !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
      }, function() {
        isComplete = true;
        !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
      }));
    });
  }
  exports.throttle = throttle;
});

// node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttleTime = undefined;
  var async_1 = require_async();
  var throttle_1 = require_throttle();
  var timer_1 = require_timer();
  function throttleTime(duration, scheduler, config) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    var duration$ = timer_1.timer(duration, scheduler);
    return throttle_1.throttle(function() {
      return duration$;
    }, config);
  }
  exports.throttleTime = throttleTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TimeInterval = exports.timeInterval = undefined;
  var async_1 = require_async();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function timeInterval(scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var last = scheduler.now();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var now = scheduler.now();
        var interval = now - last;
        last = now;
        subscriber.next(new TimeInterval(value, interval));
      }));
    });
  }
  exports.timeInterval = timeInterval;
  var TimeInterval = function() {
    function TimeInterval2(value, interval) {
      this.value = value;
      this.interval = interval;
    }
    return TimeInterval2;
  }();
  exports.TimeInterval = TimeInterval;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeoutWith = undefined;
  var async_1 = require_async();
  var isDate_1 = require_isDate();
  var timeout_1 = require_timeout();
  function timeoutWith(due, withObservable, scheduler) {
    var first;
    var each;
    var _with;
    scheduler = scheduler !== null && scheduler !== undefined ? scheduler : async_1.async;
    if (isDate_1.isValidDate(due)) {
      first = due;
    } else if (typeof due === "number") {
      each = due;
    }
    if (withObservable) {
      _with = function() {
        return withObservable;
      };
    } else {
      throw new TypeError("No observable provided to switch to");
    }
    if (first == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return timeout_1.timeout({
      first,
      each,
      scheduler,
      with: _with
    });
  }
  exports.timeoutWith = timeoutWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timestamp = undefined;
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var map_1 = require_map();
  function timestamp(timestampProvider) {
    if (timestampProvider === undefined) {
      timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
    }
    return map_1.map(function(value) {
      return { value, timestamp: timestampProvider.now() };
    });
  }
  exports.timestamp = timestamp;
});

// node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.window = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  function window2(windowBoundaries) {
    return lift_1.operate(function(source, subscriber) {
      var windowSubject = new Subject_1.Subject;
      subscriber.next(windowSubject.asObservable());
      var errorHandler = function(err) {
        windowSubject.error(err);
        subscriber.error(err);
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return windowSubject === null || windowSubject === undefined ? undefined : windowSubject.next(value);
      }, function() {
        windowSubject.complete();
        subscriber.complete();
      }, errorHandler));
      innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        windowSubject.complete();
        subscriber.next(windowSubject = new Subject_1.Subject);
      }, noop_1.noop, errorHandler));
      return function() {
        windowSubject === null || windowSubject === undefined || windowSubject.unsubscribe();
        windowSubject = null;
      };
    });
  }
  exports.window = window2;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowCount = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === undefined) {
      startWindowEvery = 0;
    }
    var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
    return lift_1.operate(function(source, subscriber) {
      var windows = [new Subject_1.Subject];
      var starts = [];
      var count = 0;
      subscriber.next(windows[0].asObservable());
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a;
        try {
          for (var windows_1 = __values(windows), windows_1_1 = windows_1.next();!windows_1_1.done; windows_1_1 = windows_1.next()) {
            var window_1 = windows_1_1.value;
            window_1.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
              _a.call(windows_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var c = count - windowSize + 1;
        if (c >= 0 && c % startEvery === 0) {
          windows.shift().complete();
        }
        if (++count % startEvery === 0) {
          var window_2 = new Subject_1.Subject;
          windows.push(window_2);
          subscriber.next(window_2.asObservable());
        }
      }, function() {
        while (windows.length > 0) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, function(err) {
        while (windows.length > 0) {
          windows.shift().error(err);
        }
        subscriber.error(err);
      }, function() {
        starts = null;
        windows = null;
      }));
    });
  }
  exports.windowCount = windowCount;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowTime = undefined;
  var Subject_1 = require_Subject();
  var async_1 = require_async();
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  var args_1 = require_args();
  var executeSchedule_1 = require_executeSchedule();
  function windowTime(windowTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== undefined ? _a : async_1.asyncScheduler;
    var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== undefined ? _b : null;
    var maxWindowSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var windowRecords = [];
      var restartOnClose = false;
      var closeWindow = function(record) {
        var { window: window2, subs } = record;
        window2.complete();
        subs.unsubscribe();
        arrRemove_1.arrRemove(windowRecords, record);
        restartOnClose && startWindow();
      };
      var startWindow = function() {
        if (windowRecords) {
          var subs = new Subscription_1.Subscription;
          subscriber.add(subs);
          var window_1 = new Subject_1.Subject;
          var record_1 = {
            window: window_1,
            subs,
            seen: 0
          };
          windowRecords.push(record_1);
          subscriber.next(window_1.asObservable());
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return closeWindow(record_1);
          }, windowTimeSpan);
        }
      };
      if (windowCreationInterval !== null && windowCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
      } else {
        restartOnClose = true;
      }
      startWindow();
      var loop = function(cb) {
        return windowRecords.slice().forEach(cb);
      };
      var terminate = function(cb) {
        loop(function(_a2) {
          var window2 = _a2.window;
          return cb(window2);
        });
        cb(subscriber);
        subscriber.unsubscribe();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        loop(function(record) {
          record.window.next(value);
          maxWindowSize <= ++record.seen && closeWindow(record);
        });
      }, function() {
        return terminate(function(consumer) {
          return consumer.complete();
        });
      }, function(err) {
        return terminate(function(consumer) {
          return consumer.error(err);
        });
      }));
      return function() {
        windowRecords = null;
      };
    });
  }
  exports.windowTime = windowTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowToggle = undefined;
  var Subject_1 = require_Subject();
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var arrRemove_1 = require_arrRemove();
  function windowToggle(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var windows = [];
      var handleError = function(err) {
        while (0 < windows.length) {
          windows.shift().error(err);
        }
        subscriber.error(err);
      };
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var window2 = new Subject_1.Subject;
        windows.push(window2);
        var closingSubscription = new Subscription_1.Subscription;
        var closeWindow = function() {
          arrRemove_1.arrRemove(windows, window2);
          window2.complete();
          closingSubscription.unsubscribe();
        };
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
        } catch (err) {
          handleError(err);
          return;
        }
        subscriber.next(window2.asObservable());
        closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a;
        var windowsCopy = windows.slice();
        try {
          for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next();!windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
            var window_1 = windowsCopy_1_1.value;
            window_1.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
              _a.call(windowsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (0 < windows.length) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, handleError, function() {
        while (0 < windows.length) {
          windows.shift().unsubscribe();
        }
      }));
    });
  }
  exports.windowToggle = windowToggle;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowWhen = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function windowWhen(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var window2;
      var closingSubscriber;
      var handleError = function(err) {
        window2.error(err);
        subscriber.error(err);
      };
      var openWindow = function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        window2 === null || window2 === undefined || window2.complete();
        window2 = new Subject_1.Subject;
        subscriber.next(window2.asObservable());
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector());
        } catch (err) {
          handleError(err);
          return;
        }
        closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
      };
      openWindow();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return window2.next(value);
      }, function() {
        window2.complete();
        subscriber.complete();
      }, handleError, function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        window2 = null;
      }));
    });
  }
  exports.windowWhen = windowWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.withLatestFrom = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var identity_1 = require_identity();
  var noop_1 = require_noop();
  var args_1 = require_args();
  function withLatestFrom() {
    var inputs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      inputs[_i] = arguments[_i];
    }
    var project = args_1.popResultSelector(inputs);
    return lift_1.operate(function(source, subscriber) {
      var len = inputs.length;
      var otherValues = new Array(len);
      var hasValue = inputs.map(function() {
        return false;
      });
      var ready = false;
      var _loop_1 = function(i2) {
        innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          otherValues[i2] = value;
          if (!ready && !hasValue[i2]) {
            hasValue[i2] = true;
            (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
          }
        }, noop_1.noop));
      };
      for (var i = 0;i < len; i++) {
        _loop_1(i);
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (ready) {
          var values = __spreadArray([value], __read(otherValues));
          subscriber.next(project ? project.apply(undefined, __spreadArray([], __read(values))) : values);
        }
      }));
    });
  }
  exports.withLatestFrom = withLatestFrom;
});

// node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zipAll = undefined;
  var zip_1 = require_zip();
  var joinAllInternals_1 = require_joinAllInternals();
  function zipAll(project) {
    return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
  }
  exports.zipAll = zipAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zip = undefined;
  var zip_1 = require_zip();
  var lift_1 = require_lift();
  function zip() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    return lift_1.operate(function(source, subscriber) {
      zip_1.zip.apply(undefined, __spreadArray([source], __read(sources))).subscribe(subscriber);
    });
  }
  exports.zip = zip;
});

// node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zipWith = undefined;
  var zip_1 = require_zip2();
  function zipWith() {
    var otherInputs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherInputs[_i] = arguments[_i];
    }
    return zip_1.zip.apply(undefined, __spreadArray([], __read(otherInputs)));
  }
  exports.zipWith = zipWith;
});

// node_modules/rxjs/dist/cjs/index.js
var require_cjs = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = undefined;
  exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = undefined;
  exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = undefined;
  exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = undefined;
  var Observable_1 = require_Observable();
  Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
    return Observable_1.Observable;
  } });
  var ConnectableObservable_1 = require_ConnectableObservable();
  Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
    return ConnectableObservable_1.ConnectableObservable;
  } });
  var observable_1 = require_observable();
  Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
    return observable_1.observable;
  } });
  var animationFrames_1 = require_animationFrames();
  Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
    return animationFrames_1.animationFrames;
  } });
  var Subject_1 = require_Subject();
  Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
    return Subject_1.Subject;
  } });
  var BehaviorSubject_1 = require_BehaviorSubject();
  Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
    return BehaviorSubject_1.BehaviorSubject;
  } });
  var ReplaySubject_1 = require_ReplaySubject();
  Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
    return ReplaySubject_1.ReplaySubject;
  } });
  var AsyncSubject_1 = require_AsyncSubject();
  Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
    return AsyncSubject_1.AsyncSubject;
  } });
  var asap_1 = require_asap();
  Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
    return asap_1.asap;
  } });
  Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
    return asap_1.asapScheduler;
  } });
  var async_1 = require_async();
  Object.defineProperty(exports, "async", { enumerable: true, get: function() {
    return async_1.async;
  } });
  Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
    return async_1.asyncScheduler;
  } });
  var queue_1 = require_queue();
  Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
    return queue_1.queue;
  } });
  Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
    return queue_1.queueScheduler;
  } });
  var animationFrame_1 = require_animationFrame();
  Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
    return animationFrame_1.animationFrame;
  } });
  Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
    return animationFrame_1.animationFrameScheduler;
  } });
  var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
  Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualTimeScheduler;
  } });
  Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualAction;
  } });
  var Scheduler_1 = require_Scheduler();
  Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
    return Scheduler_1.Scheduler;
  } });
  var Subscription_1 = require_Subscription();
  Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
    return Subscription_1.Subscription;
  } });
  var Subscriber_1 = require_Subscriber();
  Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
    return Subscriber_1.Subscriber;
  } });
  var Notification_1 = require_Notification();
  Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
    return Notification_1.Notification;
  } });
  Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
    return Notification_1.NotificationKind;
  } });
  var pipe_1 = require_pipe();
  Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
    return pipe_1.pipe;
  } });
  var noop_1 = require_noop();
  Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
    return noop_1.noop;
  } });
  var identity_1 = require_identity();
  Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
    return identity_1.identity;
  } });
  var isObservable_1 = require_isObservable();
  Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
    return isObservable_1.isObservable;
  } });
  var lastValueFrom_1 = require_lastValueFrom();
  Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
    return lastValueFrom_1.lastValueFrom;
  } });
  var firstValueFrom_1 = require_firstValueFrom();
  Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
    return firstValueFrom_1.firstValueFrom;
  } });
  var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
  Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
    return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
  } });
  var EmptyError_1 = require_EmptyError();
  Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
    return EmptyError_1.EmptyError;
  } });
  var NotFoundError_1 = require_NotFoundError();
  Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
    return NotFoundError_1.NotFoundError;
  } });
  var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
  Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
    return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
  } });
  var SequenceError_1 = require_SequenceError();
  Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
    return SequenceError_1.SequenceError;
  } });
  var timeout_1 = require_timeout();
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return timeout_1.TimeoutError;
  } });
  var UnsubscriptionError_1 = require_UnsubscriptionError();
  Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
    return UnsubscriptionError_1.UnsubscriptionError;
  } });
  var bindCallback_1 = require_bindCallback();
  Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
    return bindCallback_1.bindCallback;
  } });
  var bindNodeCallback_1 = require_bindNodeCallback();
  Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
    return bindNodeCallback_1.bindNodeCallback;
  } });
  var combineLatest_1 = require_combineLatest();
  Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
    return combineLatest_1.combineLatest;
  } });
  var concat_1 = require_concat();
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return concat_1.concat;
  } });
  var connectable_1 = require_connectable();
  Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
    return connectable_1.connectable;
  } });
  var defer_1 = require_defer();
  Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
    return defer_1.defer;
  } });
  var empty_1 = require_empty2();
  Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
    return empty_1.empty;
  } });
  var forkJoin_1 = require_forkJoin();
  Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
    return forkJoin_1.forkJoin;
  } });
  var from_1 = require_from();
  Object.defineProperty(exports, "from", { enumerable: true, get: function() {
    return from_1.from;
  } });
  var fromEvent_1 = require_fromEvent();
  Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
    return fromEvent_1.fromEvent;
  } });
  var fromEventPattern_1 = require_fromEventPattern();
  Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
    return fromEventPattern_1.fromEventPattern;
  } });
  var generate_1 = require_generate();
  Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
    return generate_1.generate;
  } });
  var iif_1 = require_iif();
  Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
    return iif_1.iif;
  } });
  var interval_1 = require_interval();
  Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
    return interval_1.interval;
  } });
  var merge_1 = require_merge();
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_1.merge;
  } });
  var never_1 = require_never();
  Object.defineProperty(exports, "never", { enumerable: true, get: function() {
    return never_1.never;
  } });
  var of_1 = require_of();
  Object.defineProperty(exports, "of", { enumerable: true, get: function() {
    return of_1.of;
  } });
  var onErrorResumeNext_1 = require_onErrorResumeNext();
  Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
    return onErrorResumeNext_1.onErrorResumeNext;
  } });
  var pairs_1 = require_pairs();
  Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
    return pairs_1.pairs;
  } });
  var partition_1 = require_partition();
  Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
    return partition_1.partition;
  } });
  var race_1 = require_race();
  Object.defineProperty(exports, "race", { enumerable: true, get: function() {
    return race_1.race;
  } });
  var range_1 = require_range();
  Object.defineProperty(exports, "range", { enumerable: true, get: function() {
    return range_1.range;
  } });
  var throwError_1 = require_throwError();
  Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
    return throwError_1.throwError;
  } });
  var timer_1 = require_timer();
  Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
    return timer_1.timer;
  } });
  var using_1 = require_using();
  Object.defineProperty(exports, "using", { enumerable: true, get: function() {
    return using_1.using;
  } });
  var zip_1 = require_zip();
  Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
    return zip_1.zip;
  } });
  var scheduled_1 = require_scheduled();
  Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
    return scheduled_1.scheduled;
  } });
  var empty_2 = require_empty2();
  Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
    return empty_2.EMPTY;
  } });
  var never_2 = require_never();
  Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
    return never_2.NEVER;
  } });
  __exportStar(require_types(), exports);
  var config_1 = require_config();
  Object.defineProperty(exports, "config", { enumerable: true, get: function() {
    return config_1.config;
  } });
  var audit_1 = require_audit();
  Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
    return audit_1.audit;
  } });
  var auditTime_1 = require_auditTime();
  Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
    return auditTime_1.auditTime;
  } });
  var buffer_1 = require_buffer();
  Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
    return buffer_1.buffer;
  } });
  var bufferCount_1 = require_bufferCount();
  Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
    return bufferCount_1.bufferCount;
  } });
  var bufferTime_1 = require_bufferTime();
  Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
    return bufferTime_1.bufferTime;
  } });
  var bufferToggle_1 = require_bufferToggle();
  Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
    return bufferToggle_1.bufferToggle;
  } });
  var bufferWhen_1 = require_bufferWhen();
  Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
    return bufferWhen_1.bufferWhen;
  } });
  var catchError_1 = require_catchError();
  Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
    return catchError_1.catchError;
  } });
  var combineAll_1 = require_combineAll();
  Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
    return combineAll_1.combineAll;
  } });
  var combineLatestAll_1 = require_combineLatestAll();
  Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
    return combineLatestAll_1.combineLatestAll;
  } });
  var combineLatestWith_1 = require_combineLatestWith();
  Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
    return combineLatestWith_1.combineLatestWith;
  } });
  var concatAll_1 = require_concatAll();
  Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
    return concatAll_1.concatAll;
  } });
  var concatMap_1 = require_concatMap();
  Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
    return concatMap_1.concatMap;
  } });
  var concatMapTo_1 = require_concatMapTo();
  Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
    return concatMapTo_1.concatMapTo;
  } });
  var concatWith_1 = require_concatWith();
  Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
    return concatWith_1.concatWith;
  } });
  var connect_1 = require_connect();
  Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
    return connect_1.connect;
  } });
  var count_1 = require_count();
  Object.defineProperty(exports, "count", { enumerable: true, get: function() {
    return count_1.count;
  } });
  var debounce_1 = require_debounce();
  Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
    return debounce_1.debounce;
  } });
  var debounceTime_1 = require_debounceTime();
  Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
    return debounceTime_1.debounceTime;
  } });
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
    return defaultIfEmpty_1.defaultIfEmpty;
  } });
  var delay_1 = require_delay();
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_1.delay;
  } });
  var delayWhen_1 = require_delayWhen();
  Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
    return delayWhen_1.delayWhen;
  } });
  var dematerialize_1 = require_dematerialize();
  Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
    return dematerialize_1.dematerialize;
  } });
  var distinct_1 = require_distinct();
  Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
    return distinct_1.distinct;
  } });
  var distinctUntilChanged_1 = require_distinctUntilChanged();
  Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
    return distinctUntilChanged_1.distinctUntilChanged;
  } });
  var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
  Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
    return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
  } });
  var elementAt_1 = require_elementAt();
  Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
    return elementAt_1.elementAt;
  } });
  var endWith_1 = require_endWith();
  Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
    return endWith_1.endWith;
  } });
  var every_1 = require_every();
  Object.defineProperty(exports, "every", { enumerable: true, get: function() {
    return every_1.every;
  } });
  var exhaust_1 = require_exhaust();
  Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
    return exhaust_1.exhaust;
  } });
  var exhaustAll_1 = require_exhaustAll();
  Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
    return exhaustAll_1.exhaustAll;
  } });
  var exhaustMap_1 = require_exhaustMap();
  Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
    return exhaustMap_1.exhaustMap;
  } });
  var expand_1 = require_expand();
  Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
    return expand_1.expand;
  } });
  var filter_1 = require_filter();
  Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
    return filter_1.filter;
  } });
  var finalize_1 = require_finalize();
  Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
    return finalize_1.finalize;
  } });
  var find_1 = require_find();
  Object.defineProperty(exports, "find", { enumerable: true, get: function() {
    return find_1.find;
  } });
  var findIndex_1 = require_findIndex();
  Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
    return findIndex_1.findIndex;
  } });
  var first_1 = require_first();
  Object.defineProperty(exports, "first", { enumerable: true, get: function() {
    return first_1.first;
  } });
  var groupBy_1 = require_groupBy();
  Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
    return groupBy_1.groupBy;
  } });
  var ignoreElements_1 = require_ignoreElements();
  Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
    return ignoreElements_1.ignoreElements;
  } });
  var isEmpty_1 = require_isEmpty();
  Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
    return isEmpty_1.isEmpty;
  } });
  var last_1 = require_last();
  Object.defineProperty(exports, "last", { enumerable: true, get: function() {
    return last_1.last;
  } });
  var map_1 = require_map();
  Object.defineProperty(exports, "map", { enumerable: true, get: function() {
    return map_1.map;
  } });
  var mapTo_1 = require_mapTo();
  Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
    return mapTo_1.mapTo;
  } });
  var materialize_1 = require_materialize();
  Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
    return materialize_1.materialize;
  } });
  var max_1 = require_max();
  Object.defineProperty(exports, "max", { enumerable: true, get: function() {
    return max_1.max;
  } });
  var mergeAll_1 = require_mergeAll();
  Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
    return mergeAll_1.mergeAll;
  } });
  var flatMap_1 = require_flatMap();
  Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
    return flatMap_1.flatMap;
  } });
  var mergeMap_1 = require_mergeMap();
  Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
    return mergeMap_1.mergeMap;
  } });
  var mergeMapTo_1 = require_mergeMapTo();
  Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
    return mergeMapTo_1.mergeMapTo;
  } });
  var mergeScan_1 = require_mergeScan();
  Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
    return mergeScan_1.mergeScan;
  } });
  var mergeWith_1 = require_mergeWith();
  Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
    return mergeWith_1.mergeWith;
  } });
  var min_1 = require_min();
  Object.defineProperty(exports, "min", { enumerable: true, get: function() {
    return min_1.min;
  } });
  var multicast_1 = require_multicast();
  Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
    return multicast_1.multicast;
  } });
  var observeOn_1 = require_observeOn();
  Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
    return observeOn_1.observeOn;
  } });
  var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
  Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
    return onErrorResumeNextWith_1.onErrorResumeNextWith;
  } });
  var pairwise_1 = require_pairwise();
  Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
    return pairwise_1.pairwise;
  } });
  var pluck_1 = require_pluck();
  Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
    return pluck_1.pluck;
  } });
  var publish_1 = require_publish();
  Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
    return publish_1.publish;
  } });
  var publishBehavior_1 = require_publishBehavior();
  Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
    return publishBehavior_1.publishBehavior;
  } });
  var publishLast_1 = require_publishLast();
  Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
    return publishLast_1.publishLast;
  } });
  var publishReplay_1 = require_publishReplay();
  Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
    return publishReplay_1.publishReplay;
  } });
  var raceWith_1 = require_raceWith();
  Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
    return raceWith_1.raceWith;
  } });
  var reduce_1 = require_reduce();
  Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
    return reduce_1.reduce;
  } });
  var repeat_1 = require_repeat();
  Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
    return repeat_1.repeat;
  } });
  var repeatWhen_1 = require_repeatWhen();
  Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
    return repeatWhen_1.repeatWhen;
  } });
  var retry_1 = require_retry();
  Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var retryWhen_1 = require_retryWhen();
  Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
    return retryWhen_1.retryWhen;
  } });
  var refCount_1 = require_refCount();
  Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
    return refCount_1.refCount;
  } });
  var sample_1 = require_sample();
  Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
    return sample_1.sample;
  } });
  var sampleTime_1 = require_sampleTime();
  Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
    return sampleTime_1.sampleTime;
  } });
  var scan_1 = require_scan();
  Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
    return scan_1.scan;
  } });
  var sequenceEqual_1 = require_sequenceEqual();
  Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
    return sequenceEqual_1.sequenceEqual;
  } });
  var share_1 = require_share();
  Object.defineProperty(exports, "share", { enumerable: true, get: function() {
    return share_1.share;
  } });
  var shareReplay_1 = require_shareReplay();
  Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
    return shareReplay_1.shareReplay;
  } });
  var single_1 = require_single();
  Object.defineProperty(exports, "single", { enumerable: true, get: function() {
    return single_1.single;
  } });
  var skip_1 = require_skip();
  Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
    return skip_1.skip;
  } });
  var skipLast_1 = require_skipLast();
  Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
    return skipLast_1.skipLast;
  } });
  var skipUntil_1 = require_skipUntil();
  Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
    return skipUntil_1.skipUntil;
  } });
  var skipWhile_1 = require_skipWhile();
  Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
    return skipWhile_1.skipWhile;
  } });
  var startWith_1 = require_startWith();
  Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
    return startWith_1.startWith;
  } });
  var subscribeOn_1 = require_subscribeOn();
  Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
    return subscribeOn_1.subscribeOn;
  } });
  var switchAll_1 = require_switchAll();
  Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
    return switchAll_1.switchAll;
  } });
  var switchMap_1 = require_switchMap();
  Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
    return switchMap_1.switchMap;
  } });
  var switchMapTo_1 = require_switchMapTo();
  Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
    return switchMapTo_1.switchMapTo;
  } });
  var switchScan_1 = require_switchScan();
  Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
    return switchScan_1.switchScan;
  } });
  var take_1 = require_take();
  Object.defineProperty(exports, "take", { enumerable: true, get: function() {
    return take_1.take;
  } });
  var takeLast_1 = require_takeLast();
  Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
    return takeLast_1.takeLast;
  } });
  var takeUntil_1 = require_takeUntil();
  Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
    return takeUntil_1.takeUntil;
  } });
  var takeWhile_1 = require_takeWhile();
  Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
    return takeWhile_1.takeWhile;
  } });
  var tap_1 = require_tap();
  Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
    return tap_1.tap;
  } });
  var throttle_1 = require_throttle();
  Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
    return throttle_1.throttle;
  } });
  var throttleTime_1 = require_throttleTime();
  Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
    return throttleTime_1.throttleTime;
  } });
  var throwIfEmpty_1 = require_throwIfEmpty();
  Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
    return throwIfEmpty_1.throwIfEmpty;
  } });
  var timeInterval_1 = require_timeInterval();
  Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
    return timeInterval_1.timeInterval;
  } });
  var timeout_2 = require_timeout();
  Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
    return timeout_2.timeout;
  } });
  var timeoutWith_1 = require_timeoutWith();
  Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
    return timeoutWith_1.timeoutWith;
  } });
  var timestamp_1 = require_timestamp();
  Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
    return timestamp_1.timestamp;
  } });
  var toArray_1 = require_toArray();
  Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
    return toArray_1.toArray;
  } });
  var window_1 = require_window();
  Object.defineProperty(exports, "window", { enumerable: true, get: function() {
    return window_1.window;
  } });
  var windowCount_1 = require_windowCount();
  Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
    return windowCount_1.windowCount;
  } });
  var windowTime_1 = require_windowTime();
  Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
    return windowTime_1.windowTime;
  } });
  var windowToggle_1 = require_windowToggle();
  Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
    return windowToggle_1.windowToggle;
  } });
  var windowWhen_1 = require_windowWhen();
  Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
    return windowWhen_1.windowWhen;
  } });
  var withLatestFrom_1 = require_withLatestFrom();
  Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
    return withLatestFrom_1.withLatestFrom;
  } });
  var zipAll_1 = require_zipAll();
  Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
    return zipAll_1.zipAll;
  } });
  var zipWith_1 = require_zipWith();
  Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
    return zipWith_1.zipWith;
  } });
});

// node_modules/run-async/index.js
var require_run_async = __commonJS((exports, module) => {
  function isPromise(obj) {
    return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
  }
  var runAsync = module.exports = function(func, cb, proxyProperty = "async") {
    if (typeof cb === "string") {
      proxyProperty = cb;
      cb = undefined;
    }
    cb = cb || function() {
    };
    return function() {
      var args = arguments;
      var originalThis = this;
      var promise = new Promise(function(resolve, reject) {
        var resolved = false;
        const wrappedResolve = function(value) {
          if (resolved) {
            console.warn("Run-async promise already resolved.");
          }
          resolved = true;
          resolve(value);
        };
        var rejected = false;
        const wrappedReject = function(value) {
          if (rejected) {
            console.warn("Run-async promise already rejected.");
          }
          rejected = true;
          reject(value);
        };
        var usingCallback = false;
        var callbackConflict = false;
        var contextEnded = false;
        var doneFactory = function() {
          if (contextEnded) {
            console.warn("Run-async async() called outside a valid run-async context, callback will be ignored.");
            return function() {
            };
          }
          if (callbackConflict) {
            console.warn(`Run-async wrapped function (async) returned a promise.
Calls to async() callback can have unexpected results.`);
          }
          usingCallback = true;
          return function(err, value) {
            if (err) {
              wrappedReject(err);
            } else {
              wrappedResolve(value);
            }
          };
        };
        var _this;
        if (originalThis && proxyProperty && Proxy) {
          _this = new Proxy(originalThis, {
            get(_target, prop) {
              if (prop === proxyProperty) {
                if (prop in _target) {
                  console.warn(`${proxyProperty} property is been shadowed by run-sync`);
                }
                return doneFactory;
              }
              return Reflect.get(...arguments);
            }
          });
        } else {
          _this = { [proxyProperty]: doneFactory };
        }
        var answer = func.apply(_this, Array.prototype.slice.call(args));
        if (usingCallback) {
          if (isPromise(answer)) {
            console.warn("Run-async wrapped function (sync) returned a promise but async() callback must be executed to resolve.");
          }
        } else {
          if (isPromise(answer)) {
            callbackConflict = true;
            answer.then(wrappedResolve, wrappedReject);
          } else {
            wrappedResolve(answer);
          }
        }
        contextEnded = true;
      });
      promise.then(cb.bind(null, null), cb);
      return promise;
    };
  };
  runAsync.cb = function(func, cb) {
    return runAsync(function() {
      var args = Array.prototype.slice.call(arguments);
      if (args.length === func.length - 1) {
        args.push(this.async());
      }
      return func.apply(this, args);
    }, cb);
  };
});

// node_modules/inquirer/node_modules/@inquirer/core/dist/esm/lib/errors.js
var AbortPromptError11;
var init_errors11 = __esm(() => {
  AbortPromptError11 = class AbortPromptError11 extends Error {
    name = "AbortPromptError";
    message = "Prompt was aborted";
    constructor(options) {
      super();
      this.cause = options?.cause;
    }
  };
});

// node_modules/inquirer/node_modules/@inquirer/core/dist/esm/index.js
var init_esm32 = __esm(() => {
  init_errors11();
});

// node_modules/inquirer/dist/esm/ui/prompt.js
import readline21 from "node:readline";
async function fetchAsyncQuestionProperty(question, prop, answers) {
  const propGetter = question[prop];
  if (typeof propGetter === "function") {
    return import_run_async.default(propGetter)(answers);
  }
  return propGetter;
}
function setupReadlineOptions(opt) {
  opt.skipTTYChecks = opt.skipTTYChecks === undefined ? true : opt.skipTTYChecks;
  const input = opt.input || process.stdin;
  if (!opt.skipTTYChecks && !input.isTTY) {
    throw new TTYError("Prompts can not be meaningfully rendered in non-TTY environments");
  }
  const ms = new import_mute_stream11.default;
  ms.pipe(opt.output || process.stdout);
  const output = ms;
  return {
    terminal: true,
    ...opt,
    input,
    output
  };
}
function isQuestionArray(questions) {
  return Array.isArray(questions);
}
function isQuestionMap(questions) {
  return Object.values(questions).every((maybeQuestion) => typeof maybeQuestion === "object" && !Array.isArray(maybeQuestion) && maybeQuestion != null);
}
function isPromptConstructor(prompt) {
  return Boolean(prompt.prototype && "run" in prompt.prototype && typeof prompt.prototype.run === "function");
}

class PromptsRunner {
  prompts;
  answers = {};
  process = import_rxjs.EMPTY;
  abortController = new AbortController;
  opt;
  constructor(prompts, opt = {}) {
    this.opt = opt;
    this.prompts = prompts;
  }
  async run(questions, answers) {
    this.abortController = new AbortController;
    this.answers = typeof answers === "object" ? { ...answers } : {};
    let obs;
    if (isQuestionArray(questions)) {
      obs = import_rxjs.from(questions);
    } else if (import_rxjs.isObservable(questions)) {
      obs = questions;
    } else if (isQuestionMap(questions)) {
      obs = import_rxjs.from(Object.entries(questions).map(([name, question]) => {
        return Object.assign({}, question, { name });
      }));
    } else {
      obs = import_rxjs.from([questions]);
    }
    this.process = obs.pipe(import_rxjs.concatMap((question) => import_rxjs.of(question).pipe(import_rxjs.concatMap((question2) => import_rxjs.from(this.shouldRun(question2).then((shouldRun) => {
      if (shouldRun) {
        return question2;
      }
      return;
    })).pipe(import_rxjs.filter((val) => val != null))), import_rxjs.concatMap((question2) => import_rxjs.defer(() => import_rxjs.from(this.fetchAnswer(question2)))))));
    return import_rxjs.lastValueFrom(this.process.pipe(import_rxjs.reduce((answersObj, answer) => {
      _2.set(answersObj, answer.name, answer.answer);
      return answersObj;
    }, this.answers))).then(() => this.answers).finally(() => this.close());
  }
  prepareQuestion = async (question) => {
    const [message, defaultValue, resolvedChoices] = await Promise.all([
      fetchAsyncQuestionProperty(question, "message", this.answers),
      fetchAsyncQuestionProperty(question, "default", this.answers),
      fetchAsyncQuestionProperty(question, "choices", this.answers)
    ]);
    let choices;
    if (Array.isArray(resolvedChoices)) {
      choices = resolvedChoices.map((choice) => {
        const choiceObj = typeof choice !== "object" || choice == null ? { name: choice, value: choice } : {
          ...choice,
          value: "value" in choice ? choice.value : ("name" in choice) ? choice.name : undefined
        };
        if ("value" in choiceObj && Array.isArray(defaultValue)) {
          return {
            checked: defaultValue.includes(choiceObj.value),
            ...choiceObj
          };
        }
        return choiceObj;
      });
    }
    return Object.assign({}, question, {
      message,
      default: defaultValue,
      choices,
      type: question.type in this.prompts ? question.type : "input"
    });
  };
  fetchAnswer = async (rawQuestion) => {
    const question = await this.prepareQuestion(rawQuestion);
    const prompt = this.prompts[question.type];
    if (prompt == null) {
      throw new Error(`Prompt for type ${question.type} not found`);
    }
    let cleanupSignal;
    const promptFn = isPromptConstructor(prompt) ? (q, opt) => new Promise((resolve, reject) => {
      const { signal: signal2 } = opt;
      if (signal2.aborted) {
        reject(new AbortPromptError11({ cause: signal2.reason }));
        return;
      }
      const rl = readline21.createInterface(setupReadlineOptions(opt));
      const onForceClose = () => {
        this.close();
        process.kill(process.pid, "SIGINT");
        console.log("");
      };
      const onClose = () => {
        process.removeListener("exit", onForceClose);
        rl.removeListener("SIGINT", onForceClose);
        rl.setPrompt("");
        rl.output.unmute();
        rl.output.write(import_ansi_escapes14.default.cursorShow);
        rl.output.end();
        rl.close();
      };
      process.on("exit", onForceClose);
      rl.on("SIGINT", onForceClose);
      const activePrompt = new prompt(q, rl, this.answers);
      const cleanup = () => {
        onClose();
        cleanupSignal?.();
      };
      const abort = () => {
        reject(new AbortPromptError11({ cause: signal2.reason }));
        cleanup();
      };
      signal2.addEventListener("abort", abort);
      cleanupSignal = () => {
        signal2.removeEventListener("abort", abort);
        cleanupSignal = undefined;
      };
      activePrompt.run().then(resolve, reject).finally(cleanup);
    }) : prompt;
    let cleanupModuleSignal;
    const { signal: moduleSignal } = this.opt;
    if (moduleSignal?.aborted) {
      this.abortController.abort(moduleSignal.reason);
    } else if (moduleSignal) {
      const abort = () => this.abortController.abort(moduleSignal.reason);
      moduleSignal.addEventListener("abort", abort);
      cleanupModuleSignal = () => {
        moduleSignal.removeEventListener("abort", abort);
      };
    }
    const { filter: filter2 = (value) => value } = question;
    const { signal } = this.abortController;
    return promptFn(question, { ...this.opt, signal }).then((answer) => ({
      name: question.name,
      answer: filter2(answer, this.answers)
    })).finally(() => {
      cleanupSignal?.();
      cleanupModuleSignal?.();
    });
  };
  close = () => {
    this.abortController.abort();
  };
  shouldRun = async (question) => {
    if (question.askAnswered !== true && _2.get(this.answers, question.name) !== undefined) {
      return false;
    }
    const { when } = question;
    if (typeof when === "function") {
      const shouldRun = await import_run_async.default(when)(this.answers);
      return Boolean(shouldRun);
    }
    return when !== false;
  };
}
var import_rxjs, import_run_async, import_mute_stream11, import_ansi_escapes14, _2, TTYError;
var init_prompt = __esm(() => {
  import_rxjs = __toESM(require_cjs(), 1);
  import_run_async = __toESM(require_run_async(), 1);
  import_mute_stream11 = __toESM(require_lib2(), 1);
  init_esm32();
  import_ansi_escapes14 = __toESM(require_ansi_escapes(), 1);
  _2 = {
    set: (obj, path3 = "", value) => {
      let pointer = obj;
      path3.split(".").forEach((key12, index, arr) => {
        if (key12 === "__proto__" || key12 === "constructor")
          return;
        if (index === arr.length - 1) {
          pointer[key12] = value;
        } else if (!(key12 in pointer) || typeof pointer[key12] !== "object") {
          pointer[key12] = {};
        }
        pointer = pointer[key12];
      });
    },
    get: (obj, path3 = "", defaultValue) => {
      const travel = (regexp) => String.prototype.split.call(path3, regexp).filter(Boolean).reduce((res, key12) => res == null ? res : res[key12], obj);
      const result = travel(/[,[\]]+?/) || travel(/[,.[\]]+?/);
      return result === undefined || result === obj ? defaultValue : result;
    }
  };
  TTYError = class TTYError extends Error {
    name = "TTYError";
    isTtyError = true;
  };
});

// node_modules/inquirer/dist/esm/index.js
var exports_esm = {};
__export(exports_esm, {
  default: () => esm_default21,
  createPromptModule: () => createPromptModule
});
function createPromptModule(opt) {
  function promptModule(questions, answers) {
    const runner = new PromptsRunner(promptModule.prompts, opt);
    const promptPromise = runner.run(questions, answers);
    return Object.assign(promptPromise, { ui: runner });
  }
  promptModule.prompts = { ...builtInPrompts };
  promptModule.registerPrompt = function(name, prompt) {
    promptModule.prompts[name] = prompt;
    return this;
  };
  promptModule.restoreDefaultPrompts = function() {
    promptModule.prompts = { ...builtInPrompts };
  };
  return promptModule;
}
function registerPrompt(name, newPrompt) {
  prompt.registerPrompt(name, newPrompt);
}
function restoreDefaultPrompts() {
  prompt.restoreDefaultPrompts();
}
var builtInPrompts, prompt, inquirer, esm_default21;
var init_esm33 = __esm(() => {
  init_esm31();
  init_prompt();
  builtInPrompts = {
    input: esm_default8,
    select: esm_default20,
    list: esm_default20,
    number: esm_default10,
    confirm: esm_default6,
    rawlist: esm_default14,
    expand: esm_default12,
    checkbox: esm_default2,
    password: esm_default16,
    editor: esm_default4,
    search: esm_default18
  };
  prompt = createPromptModule();
  inquirer = {
    prompt,
    ui: {
      Prompt: PromptsRunner
    },
    createPromptModule,
    registerPrompt,
    restoreDefaultPrompts,
    Separator
  };
  esm_default21 = inquirer;
});

// node_modules/minimatch/lib/path.js
var require_path = __commonJS((exports, module) => {
  var isWindows = typeof process === "object" && process && process.platform === "win32";
  module.exports = isWindows ? { sep: "\\" } : { sep: "/" };
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports, module) => {
  module.exports = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports, module) => {
  var balanced = require_balanced_match();
  module.exports = expandTop;
  var escSlash = "\x00SLASH" + Math.random() + "\x00";
  var escOpen = "\x00OPEN" + Math.random() + "\x00";
  var escClose = "\x00CLOSE" + Math.random() + "\x00";
  var escComma = "\x00COMMA" + Math.random() + "\x00";
  var escPeriod = "\x00PERIOD" + Math.random() + "\x00";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m)
      return [str];
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    if (/\$$/.test(m.pre)) {
      for (var k = 0;k < post.length; k++) {
        var expansion = pre + "{" + m.body + "}" + post[k];
        expansions.push(expansion);
      }
    } else {
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x;test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = [];
        for (var j = 0;j < n.length; j++) {
          N.push.apply(N, expand(n[j], false));
        }
      }
      for (var j = 0;j < N.length; j++) {
        for (var k = 0;k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
    }
    return expansions;
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports, module) => {
  var minimatch = module.exports = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  };
  module.exports = minimatch;
  var path3 = require_path();
  minimatch.sep = path3.sep;
  var GLOBSTAR = Symbol("globstar **");
  minimatch.GLOBSTAR = GLOBSTAR;
  var expand = require_brace_expansion();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var charSet = (s) => s.split("").reduce((set, c) => {
    set[c] = true;
    return set;
  }, {});
  var reSpecials = charSet("().*{}+?[]^$\\!");
  var addPatternStartSet = charSet("[.(");
  var slashSplit = /\/+/;
  minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
  var ext = (a, b = {}) => {
    const t = {};
    Object.keys(a).forEach((k) => t[k] = a[k]);
    Object.keys(b).forEach((k) => t[k] = b[k]);
    return t;
  };
  minimatch.defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
    m.Minimatch = class Minimatch2 extends orig.Minimatch {
      constructor(pattern, options) {
        super(pattern, ext(def, options));
      }
    };
    m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
    m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
    m.defaults = (options) => orig.defaults(ext(def, options));
    m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
    m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
    m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
    return m;
  };
  minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
  var braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  };
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = (pattern) => {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  var SUBPARSE = Symbol("subparse");
  minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
  minimatch.match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter((f) => mm.match(f));
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
  var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
  var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");

  class Minimatch {
    constructor(pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        this.pattern = this.pattern.replace(/\\/g, "/");
      }
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    debug() {
    }
    make() {
      const pattern = this.pattern;
      const options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      let set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = (...args) => console.error(...args);
      this.debug(this.pattern, set);
      set = this.globParts = set.map((s) => s.split(slashSplit));
      this.debug(this.pattern, set);
      set = set.map((s, si, set2) => s.map(this.parse, this));
      this.debug(this.pattern, set);
      set = set.filter((s) => s.indexOf(false) === -1);
      this.debug(this.pattern, set);
      this.set = set;
    }
    parseNegate() {
      if (this.options.nonegate)
        return;
      const pattern = this.pattern;
      let negate = false;
      let negateOffset = 0;
      for (let i = 0;i < pattern.length && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.slice(negateOffset);
      this.negate = negate;
    }
    matchOne(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { this: this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (;fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug(`
globstar while`, file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug(`
>>> no match, partial?`, file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern, isSub) {
      assertValidPattern(pattern);
      const options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      let re = "";
      let hasMagic = false;
      let escaping = false;
      const patternListStack = [];
      const negativeLists = [];
      let stateChar;
      let inClass = false;
      let reClassStart = -1;
      let classStart = -1;
      let cs;
      let pl;
      let sp;
      let dotTravAllowed = pattern.charAt(0) === ".";
      let dotFileAllowed = options.dot || dotTravAllowed;
      const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      const clearStateChar = () => {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          this.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      };
      for (let i = 0, c;i < pattern.length && (c = pattern.charAt(i)); i++) {
        this.debug("%s\t%s %s %j", pattern, i, re, c);
        if (escaping) {
          if (c === "/") {
            return false;
          }
          if (reSpecials[c]) {
            re += "\\";
          }
          re += c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            if (inClass && pattern.charAt(i + 1) === "-") {
              re += c;
              continue;
            }
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            this.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(": {
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            const plEntry = {
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            };
            this.debug(this.pattern, "\t", plEntry);
            patternListStack.push(plEntry);
            re += plEntry.open;
            if (plEntry.start === 0 && plEntry.type !== "!") {
              dotTravAllowed = true;
              re += subPatternStart(pattern.slice(i + 1));
            }
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          }
          case ")": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\)";
              continue;
            }
            patternListStack.pop();
            clearStateChar();
            hasMagic = true;
            pl = plEntry;
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(Object.assign(pl, { reEnd: re.length }));
            }
            continue;
          }
          case "|": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\|";
              continue;
            }
            clearStateChar();
            re += "|";
            if (plEntry.start === 0 && plEntry.type !== "!") {
              dotTravAllowed = true;
              re += subPatternStart(pattern.slice(i + 1));
            }
            continue;
          }
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              continue;
            }
            cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
              re += c;
            } catch (er) {
              re = re.substring(0, reClassStart) + "(?:$.)";
            }
            hasMagic = true;
            inClass = false;
            continue;
          default:
            clearStateChar();
            if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
            break;
        }
      }
      if (inClass) {
        cs = pattern.slice(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substring(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop();pl; pl = patternListStack.pop()) {
        let tail;
        tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_3, $1, $2) => {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug(`tail=%j
   %s`, tail, tail, pl, re);
        const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      const addPatternStart = addPatternStartSet[re.charAt(0)];
      for (let n = negativeLists.length - 1;n > -1; n--) {
        const nl = negativeLists[n];
        const nlBefore = re.slice(0, nl.reStart);
        const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        let nlAfter = re.slice(nl.reEnd);
        const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
        const closeParensBefore = nlBefore.split(")").length;
        const openParensBefore = nlBefore.split("(").length - closeParensBefore;
        let cleanAfter = nlAfter;
        for (let i = 0;i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
        re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart() + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (options.nocase && !hasMagic) {
        hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      const flags = options.nocase ? "i" : "";
      try {
        return Object.assign(new RegExp("^" + re + "$", flags), {
          _glob: pattern,
          _src: re
        });
      } catch (er) {
        return new RegExp("$.");
      }
    }
    makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      const set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      const options = this.options;
      const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      const flags = options.nocase ? "i" : "";
      let re = set.map((pattern) => {
        pattern = pattern.map((p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set2, p) => {
          if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
            set2.push(p);
          }
          return set2;
        }, []);
        pattern.forEach((p, i) => {
          if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
            return;
          }
          if (i === 0) {
            if (pattern.length > 1) {
              pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
            } else {
              pattern[i] = twoStar;
            }
          } else if (i === pattern.length - 1) {
            pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
          } else {
            pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
            pattern[i + 1] = GLOBSTAR;
          }
        });
        return pattern.filter((p) => p !== GLOBSTAR).join("/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    match(f, partial = this.partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      const options = this.options;
      if (path3.sep !== "/") {
        f = f.split(path3.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      const set = this.set;
      this.debug(this.pattern, "set", set);
      let filename;
      for (let i = f.length - 1;i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (let i = 0;i < set.length; i++) {
        const pattern = set[i];
        let file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        const hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  }
  minimatch.Minimatch = Minimatch;
});

// node_modules/readdir-glob/index.js
var require_readdir_glob = __commonJS((exports, module) => {
  module.exports = readdirGlob;
  var fs3 = __require("fs");
  var { EventEmitter } = __require("events");
  var { Minimatch } = require_minimatch();
  var { resolve } = __require("path");
  function readdir(dir, strict) {
    return new Promise((resolve2, reject) => {
      fs3.readdir(dir, { withFileTypes: true }, (err, files) => {
        if (err) {
          switch (err.code) {
            case "ENOTDIR":
              if (strict) {
                reject(err);
              } else {
                resolve2([]);
              }
              break;
            case "ENOTSUP":
            case "ENOENT":
            case "ENAMETOOLONG":
            case "UNKNOWN":
              resolve2([]);
              break;
            case "ELOOP":
            default:
              reject(err);
              break;
          }
        } else {
          resolve2(files);
        }
      });
    });
  }
  function stat(file, followSymlinks) {
    return new Promise((resolve2, reject) => {
      const statFunc = followSymlinks ? fs3.stat : fs3.lstat;
      statFunc(file, (err, stats) => {
        if (err) {
          switch (err.code) {
            case "ENOENT":
              if (followSymlinks) {
                resolve2(stat(file, false));
              } else {
                resolve2(null);
              }
              break;
            default:
              resolve2(null);
              break;
          }
        } else {
          resolve2(stats);
        }
      });
    });
  }
  async function* exploreWalkAsync(dir, path3, followSymlinks, useStat, shouldSkip, strict) {
    let files = await readdir(path3 + dir, strict);
    for (const file of files) {
      let name = file.name;
      if (name === undefined) {
        name = file;
        useStat = true;
      }
      const filename = dir + "/" + name;
      const relative = filename.slice(1);
      const absolute = path3 + "/" + relative;
      let stats = null;
      if (useStat || followSymlinks) {
        stats = await stat(absolute, followSymlinks);
      }
      if (!stats && file.name !== undefined) {
        stats = file;
      }
      if (stats === null) {
        stats = { isDirectory: () => false };
      }
      if (stats.isDirectory()) {
        if (!shouldSkip(relative)) {
          yield { relative, absolute, stats };
          yield* exploreWalkAsync(filename, path3, followSymlinks, useStat, shouldSkip, false);
        }
      } else {
        yield { relative, absolute, stats };
      }
    }
  }
  async function* explore(path3, followSymlinks, useStat, shouldSkip) {
    yield* exploreWalkAsync("", path3, followSymlinks, useStat, shouldSkip, true);
  }
  function readOptions(options) {
    return {
      pattern: options.pattern,
      dot: !!options.dot,
      noglobstar: !!options.noglobstar,
      matchBase: !!options.matchBase,
      nocase: !!options.nocase,
      ignore: options.ignore,
      skip: options.skip,
      follow: !!options.follow,
      stat: !!options.stat,
      nodir: !!options.nodir,
      mark: !!options.mark,
      silent: !!options.silent,
      absolute: !!options.absolute
    };
  }

  class ReaddirGlob extends EventEmitter {
    constructor(cwd, options, cb) {
      super();
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      this.options = readOptions(options || {});
      this.matchers = [];
      if (this.options.pattern) {
        const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];
        this.matchers = matchers.map((m) => new Minimatch(m, {
          dot: this.options.dot,
          noglobstar: this.options.noglobstar,
          matchBase: this.options.matchBase,
          nocase: this.options.nocase
        }));
      }
      this.ignoreMatchers = [];
      if (this.options.ignore) {
        const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];
        this.ignoreMatchers = ignorePatterns.map((ignore) => new Minimatch(ignore, { dot: true }));
      }
      this.skipMatchers = [];
      if (this.options.skip) {
        const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];
        this.skipMatchers = skipPatterns.map((skip) => new Minimatch(skip, { dot: true }));
      }
      this.iterator = explore(resolve(cwd || "."), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));
      this.paused = false;
      this.inactive = false;
      this.aborted = false;
      if (cb) {
        this._matches = [];
        this.on("match", (match) => this._matches.push(this.options.absolute ? match.absolute : match.relative));
        this.on("error", (err) => cb(err));
        this.on("end", () => cb(null, this._matches));
      }
      setTimeout(() => this._next(), 0);
    }
    _shouldSkipDirectory(relative) {
      return this.skipMatchers.some((m) => m.match(relative));
    }
    _fileMatches(relative, isDirectory) {
      const file = relative + (isDirectory ? "/" : "");
      return (this.matchers.length === 0 || this.matchers.some((m) => m.match(file))) && !this.ignoreMatchers.some((m) => m.match(file)) && (!this.options.nodir || !isDirectory);
    }
    _next() {
      if (!this.paused && !this.aborted) {
        this.iterator.next().then((obj) => {
          if (!obj.done) {
            const isDirectory = obj.value.stats.isDirectory();
            if (this._fileMatches(obj.value.relative, isDirectory)) {
              let relative = obj.value.relative;
              let absolute = obj.value.absolute;
              if (this.options.mark && isDirectory) {
                relative += "/";
                absolute += "/";
              }
              if (this.options.stat) {
                this.emit("match", { relative, absolute, stat: obj.value.stats });
              } else {
                this.emit("match", { relative, absolute });
              }
            }
            this._next(this.iterator);
          } else {
            this.emit("end");
          }
        }).catch((err) => {
          this.abort();
          this.emit("error", err);
          if (!err.code && !this.options.silent) {
            console.error(err);
          }
        });
      } else {
        this.inactive = true;
      }
    }
    abort() {
      this.aborted = true;
    }
    pause() {
      this.paused = true;
    }
    resume() {
      this.paused = false;
      if (this.inactive) {
        this.inactive = false;
        this._next();
      }
    }
  }
  function readdirGlob(pattern, options, cb) {
    return new ReaddirGlob(pattern, options, cb);
  }
  readdirGlob.ReaddirGlob = ReaddirGlob;
});

// node_modules/async/dist/async.js
var require_async2 = __commonJS((exports, module) => {
  (function(global3, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global3 = typeof globalThis !== "undefined" ? globalThis : global3 || self, factory(global3.async = {}));
  })(exports, function(exports2) {
    function apply(fn, ...args) {
      return (...callArgs) => fn(...args, ...callArgs);
    }
    function initialParams(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    }
    var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback2(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer2) {
      return (fn, ...args) => defer2(() => fn(...args));
    }
    var _defer$1;
    if (hasQueueMicrotask) {
      _defer$1 = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer$1 = setImmediate;
    } else if (hasNextTick) {
      _defer$1 = process.nextTick;
    } else {
      _defer$1 = fallback2;
    }
    var setImmediate$1 = wrap(_defer$1);
    function asyncify(func) {
      if (isAsync(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return initialParams(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        setImmediate$1((e) => {
          throw e;
        }, err);
      }
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function")
        throw new Error("expected a function");
      return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
    }
    function awaitify(asyncFn, arity) {
      if (!arity)
        arity = asyncFn.length;
      if (!arity)
        throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject2) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject2(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    function applyEach$1(eachfn) {
      return function applyEach(fns, ...callArgs) {
        const go = awaitify(function(callback) {
          var that = this;
          return eachfn(fns, (fn, cb) => {
            wrapAsync(fn).apply(that, callArgs.concat(cb));
          }, callback);
        });
        return go;
      };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
      arr = arr || [];
      var results = [];
      var counter = 0;
      var _iteratee = wrapAsync(iteratee);
      return eachfn(arr, (value, _3, iterCb) => {
        var index2 = counter++;
        _iteratee(value, (err, v) => {
          results[index2] = v;
          iterCb(err);
        });
      }, (err) => {
        callback(err, results);
      });
    }
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    const breakLoop = {};
    function once(fn) {
      function wrapper(...args) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    function getIterator(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done)
          return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key12 = okeys[++i];
        if (key12 === "__proto__") {
          return next();
        }
        return i < len ? { value: obj[key12], key: key12 } : null;
      };
    }
    function createIterator(coll) {
      if (isArrayLike(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = getIterator(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done)
            return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled)
          return;
        if (err)
          return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === breakLoop || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    var eachOfLimit$2 = (limit) => {
      return (obj, iteratee, callback) => {
        callback = once(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if (isAsyncGenerator(obj)) {
          return asyncEachOfLimit(obj, limit, iteratee, callback);
        }
        if (isAsyncIterable(obj)) {
          return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = createIterator(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    function eachOfLimit(coll, limit, iteratee, callback) {
      return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
    }
    var eachOfLimit$1 = awaitify(eachOfLimit, 4);
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = once(callback);
      var index2 = 0, completed = 0, { length } = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true)
          return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === breakLoop) {
          callback(null);
        }
      }
      for (;index2 < length; index2++) {
        iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return eachOfLimit$1(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, wrapAsync(iteratee), callback);
    }
    var eachOf$1 = awaitify(eachOf, 3);
    function map(coll, iteratee, callback) {
      return _asyncMap(eachOf$1, coll, iteratee, callback);
    }
    var map$1 = awaitify(map, 3);
    var applyEach = applyEach$1(map$1);
    function eachOfSeries(coll, iteratee, callback) {
      return eachOfLimit$1(coll, 1, iteratee, callback);
    }
    var eachOfSeries$1 = awaitify(eachOfSeries, 3);
    function mapSeries(coll, iteratee, callback) {
      return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
    }
    var mapSeries$1 = awaitify(mapSeries, 3);
    var applyEachSeries = applyEach$1(mapSeries$1);
    const PROMISE_SYMBOL = Symbol("promiseCallback");
    function promiseCallback() {
      let resolve, reject2;
      function callback(err, ...args) {
        if (err)
          return reject2(err);
        resolve(args.length > 1 ? args : args[0]);
      }
      callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
        resolve = res, reject2 = rej;
      });
      return callback;
    }
    function auto(tasks, concurrency, callback) {
      if (typeof concurrency !== "number") {
        callback = concurrency;
        concurrency = null;
      }
      callback = once(callback || promiseCallback());
      var numTasks = Object.keys(tasks).length;
      if (!numTasks) {
        return callback(null);
      }
      if (!concurrency) {
        concurrency = numTasks;
      }
      var results = {};
      var runningTasks = 0;
      var canceled = false;
      var hasError = false;
      var listeners = Object.create(null);
      var readyTasks = [];
      var readyToCheck = [];
      var uncheckedDependencies = {};
      Object.keys(tasks).forEach((key12) => {
        var task = tasks[key12];
        if (!Array.isArray(task)) {
          enqueueTask(key12, [task]);
          readyToCheck.push(key12);
          return;
        }
        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
          enqueueTask(key12, task);
          readyToCheck.push(key12);
          return;
        }
        uncheckedDependencies[key12] = remainingDependencies;
        dependencies.forEach((dependencyName) => {
          if (!tasks[dependencyName]) {
            throw new Error("async.auto task `" + key12 + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
          }
          addListener(dependencyName, () => {
            remainingDependencies--;
            if (remainingDependencies === 0) {
              enqueueTask(key12, task);
            }
          });
        });
      });
      checkForDeadlocks();
      processQueue();
      function enqueueTask(key12, task) {
        readyTasks.push(() => runTask(key12, task));
      }
      function processQueue() {
        if (canceled)
          return;
        if (readyTasks.length === 0 && runningTasks === 0) {
          return callback(null, results);
        }
        while (readyTasks.length && runningTasks < concurrency) {
          var run2 = readyTasks.shift();
          run2();
        }
      }
      function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
          taskListeners = listeners[taskName] = [];
        }
        taskListeners.push(fn);
      }
      function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        taskListeners.forEach((fn) => fn());
        processQueue();
      }
      function runTask(key12, task) {
        if (hasError)
          return;
        var taskCallback = onlyOnce((err, ...result) => {
          runningTasks--;
          if (err === false) {
            canceled = true;
            return;
          }
          if (result.length < 2) {
            [result] = result;
          }
          if (err) {
            var safeResults = {};
            Object.keys(results).forEach((rkey) => {
              safeResults[rkey] = results[rkey];
            });
            safeResults[key12] = result;
            hasError = true;
            listeners = Object.create(null);
            if (canceled)
              return;
            callback(err, safeResults);
          } else {
            results[key12] = result;
            taskComplete(key12);
          }
        });
        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length > 1) {
          taskFn(results, taskCallback);
        } else {
          taskFn(taskCallback);
        }
      }
      function checkForDeadlocks() {
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) {
          currentTask = readyToCheck.pop();
          counter++;
          getDependents(currentTask).forEach((dependent) => {
            if (--uncheckedDependencies[dependent] === 0) {
              readyToCheck.push(dependent);
            }
          });
        }
        if (counter !== numTasks) {
          throw new Error("async.auto cannot execute tasks due to a recursive dependency");
        }
      }
      function getDependents(taskName) {
        var result = [];
        Object.keys(tasks).forEach((key12) => {
          const task = tasks[key12];
          if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
            result.push(key12);
          }
        });
        return result;
      }
      return callback[PROMISE_SYMBOL];
    }
    var FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/;
    var ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /(=.+)?(\s*)$/;
    function stripComments(string2) {
      let stripped = "";
      let index2 = 0;
      let endBlockComment = string2.indexOf("*/");
      while (index2 < string2.length) {
        if (string2[index2] === "/" && string2[index2 + 1] === "/") {
          let endIndex = string2.indexOf(`
`, index2);
          index2 = endIndex === -1 ? string2.length : endIndex;
        } else if (endBlockComment !== -1 && string2[index2] === "/" && string2[index2 + 1] === "*") {
          let endIndex = string2.indexOf("*/", index2);
          if (endIndex !== -1) {
            index2 = endIndex + 2;
            endBlockComment = string2.indexOf("*/", index2);
          } else {
            stripped += string2[index2];
            index2++;
          }
        } else {
          stripped += string2[index2];
          index2++;
        }
      }
      return stripped;
    }
    function parseParams(func) {
      const src = stripComments(func.toString());
      let match = src.match(FN_ARGS);
      if (!match) {
        match = src.match(ARROW_FN_ARGS);
      }
      if (!match)
        throw new Error(`could not parse args in autoInject
Source:
` + src);
      let [, args] = match;
      return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
    }
    function autoInject(tasks, callback) {
      var newTasks = {};
      Object.keys(tasks).forEach((key12) => {
        var taskFn = tasks[key12];
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
        if (Array.isArray(taskFn)) {
          params = [...taskFn];
          taskFn = params.pop();
          newTasks[key12] = params.concat(params.length > 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
          newTasks[key12] = taskFn;
        } else {
          params = parseParams(taskFn);
          if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
            throw new Error("autoInject task functions require explicit parameters.");
          }
          if (!fnIsAsync)
            params.pop();
          newTasks[key12] = params.concat(newTask);
        }
        function newTask(results, taskCb) {
          var newArgs = params.map((name) => results[name]);
          newArgs.push(taskCb);
          wrapAsync(taskFn)(...newArgs);
        }
      });
      return auto(newTasks, callback);
    }

    class DLL {
      constructor() {
        this.head = this.tail = null;
        this.length = 0;
      }
      removeLink(node) {
        if (node.prev)
          node.prev.next = node.next;
        else
          this.head = node.next;
        if (node.next)
          node.next.prev = node.prev;
        else
          this.tail = node.prev;
        node.prev = node.next = null;
        this.length -= 1;
        return node;
      }
      empty() {
        while (this.head)
          this.shift();
        return this;
      }
      insertAfter(node, newNode) {
        newNode.prev = node;
        newNode.next = node.next;
        if (node.next)
          node.next.prev = newNode;
        else
          this.tail = newNode;
        node.next = newNode;
        this.length += 1;
      }
      insertBefore(node, newNode) {
        newNode.prev = node.prev;
        newNode.next = node;
        if (node.prev)
          node.prev.next = newNode;
        else
          this.head = newNode;
        node.prev = newNode;
        this.length += 1;
      }
      unshift(node) {
        if (this.head)
          this.insertBefore(this.head, node);
        else
          setInitial(this, node);
      }
      push(node) {
        if (this.tail)
          this.insertAfter(this.tail, node);
        else
          setInitial(this, node);
      }
      shift() {
        return this.head && this.removeLink(this.head);
      }
      pop() {
        return this.tail && this.removeLink(this.tail);
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        var cur = this.head;
        while (cur) {
          yield cur.data;
          cur = cur.next;
        }
      }
      remove(testFn) {
        var curr = this.head;
        while (curr) {
          var { next } = curr;
          if (testFn(curr)) {
            this.removeLink(curr);
          }
          curr = next;
        }
        return this;
      }
    }
    function setInitial(dll, node) {
      dll.length = 1;
      dll.head = dll.tail = node;
    }
    function queue$1(worker, concurrency, payload) {
      if (concurrency == null) {
        concurrency = 1;
      } else if (concurrency === 0) {
        throw new RangeError("Concurrency must not be zero");
      }
      var _worker = wrapAsync(worker);
      var numRunning = 0;
      var workersList = [];
      const events = {
        error: [],
        drain: [],
        saturated: [],
        unsaturated: [],
        empty: []
      };
      function on(event, handler) {
        events[event].push(handler);
      }
      function once2(event, handler) {
        const handleAndRemove = (...args) => {
          off(event, handleAndRemove);
          handler(...args);
        };
        events[event].push(handleAndRemove);
      }
      function off(event, handler) {
        if (!event)
          return Object.keys(events).forEach((ev) => events[ev] = []);
        if (!handler)
          return events[event] = [];
        events[event] = events[event].filter((ev) => ev !== handler);
      }
      function trigger(event, ...args) {
        events[event].forEach((handler) => handler(...args));
      }
      var processingScheduled = false;
      function _insert(data, insertAtFront, rejectOnError, callback) {
        if (callback != null && typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        q.started = true;
        var res, rej;
        function promiseCallback2(err, ...args) {
          if (err)
            return rejectOnError ? rej(err) : res();
          if (args.length <= 1)
            return res(args[0]);
          res(args);
        }
        var item = q._createTaskItem(data, rejectOnError ? promiseCallback2 : callback || promiseCallback2);
        if (insertAtFront) {
          q._tasks.unshift(item);
        } else {
          q._tasks.push(item);
        }
        if (!processingScheduled) {
          processingScheduled = true;
          setImmediate$1(() => {
            processingScheduled = false;
            q.process();
          });
        }
        if (rejectOnError || !callback) {
          return new Promise((resolve, reject2) => {
            res = resolve;
            rej = reject2;
          });
        }
      }
      function _createCB(tasks) {
        return function(err, ...args) {
          numRunning -= 1;
          for (var i = 0, l = tasks.length;i < l; i++) {
            var task = tasks[i];
            var index2 = workersList.indexOf(task);
            if (index2 === 0) {
              workersList.shift();
            } else if (index2 > 0) {
              workersList.splice(index2, 1);
            }
            task.callback(err, ...args);
            if (err != null) {
              trigger("error", err, task.data);
            }
          }
          if (numRunning <= q.concurrency - q.buffer) {
            trigger("unsaturated");
          }
          if (q.idle()) {
            trigger("drain");
          }
          q.process();
        };
      }
      function _maybeDrain(data) {
        if (data.length === 0 && q.idle()) {
          setImmediate$1(() => trigger("drain"));
          return true;
        }
        return false;
      }
      const eventMethod = (name) => (handler) => {
        if (!handler) {
          return new Promise((resolve, reject2) => {
            once2(name, (err, data) => {
              if (err)
                return reject2(err);
              resolve(data);
            });
          });
        }
        off(name);
        on(name, handler);
      };
      var isProcessing = false;
      var q = {
        _tasks: new DLL,
        _createTaskItem(data, callback) {
          return {
            data,
            callback
          };
        },
        *[Symbol.iterator]() {
          yield* q._tasks[Symbol.iterator]();
        },
        concurrency,
        payload,
        buffer: concurrency / 4,
        started: false,
        paused: false,
        push(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, false, false, callback));
          }
          return _insert(data, false, false, callback);
        },
        pushAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, false, true, callback));
          }
          return _insert(data, false, true, callback);
        },
        kill() {
          off();
          q._tasks.empty();
        },
        unshift(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, true, false, callback));
          }
          return _insert(data, true, false, callback);
        },
        unshiftAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, true, true, callback));
          }
          return _insert(data, true, true, callback);
        },
        remove(testFn) {
          q._tasks.remove(testFn);
        },
        process() {
          if (isProcessing) {
            return;
          }
          isProcessing = true;
          while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
            var tasks = [], data = [];
            var l = q._tasks.length;
            if (q.payload)
              l = Math.min(l, q.payload);
            for (var i = 0;i < l; i++) {
              var node = q._tasks.shift();
              tasks.push(node);
              workersList.push(node);
              data.push(node.data);
            }
            numRunning += 1;
            if (q._tasks.length === 0) {
              trigger("empty");
            }
            if (numRunning === q.concurrency) {
              trigger("saturated");
            }
            var cb = onlyOnce(_createCB(tasks));
            _worker(data, cb);
          }
          isProcessing = false;
        },
        length() {
          return q._tasks.length;
        },
        running() {
          return numRunning;
        },
        workersList() {
          return workersList;
        },
        idle() {
          return q._tasks.length + numRunning === 0;
        },
        pause() {
          q.paused = true;
        },
        resume() {
          if (q.paused === false) {
            return;
          }
          q.paused = false;
          setImmediate$1(q.process);
        }
      };
      Object.defineProperties(q, {
        saturated: {
          writable: false,
          value: eventMethod("saturated")
        },
        unsaturated: {
          writable: false,
          value: eventMethod("unsaturated")
        },
        empty: {
          writable: false,
          value: eventMethod("empty")
        },
        drain: {
          writable: false,
          value: eventMethod("drain")
        },
        error: {
          writable: false,
          value: eventMethod("error")
        }
      });
      return q;
    }
    function cargo$1(worker, payload) {
      return queue$1(worker, 1, payload);
    }
    function cargo(worker, concurrency, payload) {
      return queue$1(worker, concurrency, payload);
    }
    function reduce2(coll, memo, iteratee, callback) {
      callback = once(callback);
      var _iteratee = wrapAsync(iteratee);
      return eachOfSeries$1(coll, (x, i, iterCb) => {
        _iteratee(memo, x, (err, v) => {
          memo = v;
          iterCb(err);
        });
      }, (err) => callback(err, memo));
    }
    var reduce$1 = awaitify(reduce2, 4);
    function seq(...functions) {
      var _functions = functions.map(wrapAsync);
      return function(...args) {
        var that = this;
        var cb = args[args.length - 1];
        if (typeof cb == "function") {
          args.pop();
        } else {
          cb = promiseCallback();
        }
        reduce$1(_functions, args, (newargs, fn, iterCb) => {
          fn.apply(that, newargs.concat((err, ...nextargs) => {
            iterCb(err, nextargs);
          }));
        }, (err, results) => cb(err, ...results));
        return cb[PROMISE_SYMBOL];
      };
    }
    function compose(...args) {
      return seq(...args.reverse());
    }
    function mapLimit(coll, limit, iteratee, callback) {
      return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var mapLimit$1 = awaitify(mapLimit, 4);
    function concatLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, ...args) => {
          if (err)
            return iterCb(err);
          return iterCb(err, args);
        });
      }, (err, mapResults) => {
        var result = [];
        for (var i = 0;i < mapResults.length; i++) {
          if (mapResults[i]) {
            result = result.concat(...mapResults[i]);
          }
        }
        return callback(err, result);
      });
    }
    var concatLimit$1 = awaitify(concatLimit, 4);
    function concat(coll, iteratee, callback) {
      return concatLimit$1(coll, Infinity, iteratee, callback);
    }
    var concat$1 = awaitify(concat, 3);
    function concatSeries(coll, iteratee, callback) {
      return concatLimit$1(coll, 1, iteratee, callback);
    }
    var concatSeries$1 = awaitify(concatSeries, 3);
    function constant$1(...args) {
      return function(...ignoredArgs) {
        var callback = ignoredArgs.pop();
        return callback(null, ...args);
      };
    }
    function _createTester(check2, getResult) {
      return (eachfn, arr, _iteratee, cb) => {
        var testPassed = false;
        var testResult;
        const iteratee = wrapAsync(_iteratee);
        eachfn(arr, (value, _3, callback) => {
          iteratee(value, (err, result) => {
            if (err || err === false)
              return callback(err);
            if (check2(result) && !testResult) {
              testPassed = true;
              testResult = getResult(true, value);
              return callback(null, breakLoop);
            }
            callback();
          });
        }, (err) => {
          if (err)
            return cb(err);
          cb(null, testPassed ? testResult : getResult(false));
        });
      };
    }
    function detect(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
    }
    var detect$1 = awaitify(detect, 3);
    function detectLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var detectLimit$1 = awaitify(detectLimit, 4);
    function detectSeries(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
    }
    var detectSeries$1 = awaitify(detectSeries, 3);
    function consoleFunc(name) {
      return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
        if (typeof console === "object") {
          if (err) {
            if (console.error) {
              console.error(err);
            }
          } else if (console[name]) {
            resultArgs.forEach((x) => console[name](x));
          }
        }
      });
    }
    var dir = consoleFunc("dir");
    function doWhilst(iteratee, test, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee);
      var _test = wrapAsync(test);
      var results;
      function next(err, ...args) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        results = args;
        _test(...args, check2);
      }
      function check2(err, truth) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        if (!truth)
          return callback(null, ...results);
        _fn(next);
      }
      return check2(null, true);
    }
    var doWhilst$1 = awaitify(doWhilst, 3);
    function doUntil(iteratee, test, callback) {
      const _test = wrapAsync(test);
      return doWhilst$1(iteratee, (...args) => {
        const cb = args.pop();
        _test(...args, (err, truth) => cb(err, !truth));
      }, callback);
    }
    function _withoutIndex(iteratee) {
      return (value, index2, callback) => iteratee(value, callback);
    }
    function eachLimit$2(coll, iteratee, callback) {
      return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var each = awaitify(eachLimit$2, 3);
    function eachLimit(coll, limit, iteratee, callback) {
      return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var eachLimit$1 = awaitify(eachLimit, 4);
    function eachSeries(coll, iteratee, callback) {
      return eachLimit$1(coll, 1, iteratee, callback);
    }
    var eachSeries$1 = awaitify(eachSeries, 3);
    function ensureAsync(fn) {
      if (isAsync(fn))
        return fn;
      return function(...args) {
        var callback = args.pop();
        var sync = true;
        args.push((...innerArgs) => {
          if (sync) {
            setImmediate$1(() => callback(...innerArgs));
          } else {
            callback(...innerArgs);
          }
        });
        fn.apply(this, args);
        sync = false;
      };
    }
    function every(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
    }
    var every$1 = awaitify(every, 3);
    function everyLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var everyLimit$1 = awaitify(everyLimit, 4);
    function everySeries(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var everySeries$1 = awaitify(everySeries, 3);
    function filterArray(eachfn, arr, iteratee, callback) {
      var truthValues = new Array(arr.length);
      eachfn(arr, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          truthValues[index2] = !!v;
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        var results = [];
        for (var i = 0;i < arr.length; i++) {
          if (truthValues[i])
            results.push(arr[i]);
        }
        callback(null, results);
      });
    }
    function filterGeneric(eachfn, coll, iteratee, callback) {
      var results = [];
      eachfn(coll, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          if (err)
            return iterCb(err);
          if (v) {
            results.push({ index: index2, value: x });
          }
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
      });
    }
    function _filter(eachfn, coll, iteratee, callback) {
      var filter3 = isArrayLike(coll) ? filterArray : filterGeneric;
      return filter3(eachfn, coll, wrapAsync(iteratee), callback);
    }
    function filter2(coll, iteratee, callback) {
      return _filter(eachOf$1, coll, iteratee, callback);
    }
    var filter$1 = awaitify(filter2, 3);
    function filterLimit(coll, limit, iteratee, callback) {
      return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var filterLimit$1 = awaitify(filterLimit, 4);
    function filterSeries(coll, iteratee, callback) {
      return _filter(eachOfSeries$1, coll, iteratee, callback);
    }
    var filterSeries$1 = awaitify(filterSeries, 3);
    function forever(fn, errback) {
      var done = onlyOnce(errback);
      var task = wrapAsync(ensureAsync(fn));
      function next(err) {
        if (err)
          return done(err);
        if (err === false)
          return;
        task(next);
      }
      return next();
    }
    var forever$1 = awaitify(forever, 2);
    function groupByLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, key12) => {
          if (err)
            return iterCb(err);
          return iterCb(err, { key: key12, val });
        });
      }, (err, mapResults) => {
        var result = {};
        var { hasOwnProperty } = Object.prototype;
        for (var i = 0;i < mapResults.length; i++) {
          if (mapResults[i]) {
            var { key: key12 } = mapResults[i];
            var { val } = mapResults[i];
            if (hasOwnProperty.call(result, key12)) {
              result[key12].push(val);
            } else {
              result[key12] = [val];
            }
          }
        }
        return callback(err, result);
      });
    }
    var groupByLimit$1 = awaitify(groupByLimit, 4);
    function groupBy(coll, iteratee, callback) {
      return groupByLimit$1(coll, Infinity, iteratee, callback);
    }
    function groupBySeries(coll, iteratee, callback) {
      return groupByLimit$1(coll, 1, iteratee, callback);
    }
    var log = consoleFunc("log");
    function mapValuesLimit(obj, limit, iteratee, callback) {
      callback = once(callback);
      var newObj = {};
      var _iteratee = wrapAsync(iteratee);
      return eachOfLimit$2(limit)(obj, (val, key12, next) => {
        _iteratee(val, key12, (err, result) => {
          if (err)
            return next(err);
          newObj[key12] = result;
          next(err);
        });
      }, (err) => callback(err, newObj));
    }
    var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
    function mapValues(obj, iteratee, callback) {
      return mapValuesLimit$1(obj, Infinity, iteratee, callback);
    }
    function mapValuesSeries(obj, iteratee, callback) {
      return mapValuesLimit$1(obj, 1, iteratee, callback);
    }
    function memoize(fn, hasher = (v) => v) {
      var memo = Object.create(null);
      var queues = Object.create(null);
      var _fn = wrapAsync(fn);
      var memoized = initialParams((args, callback) => {
        var key12 = hasher(...args);
        if (key12 in memo) {
          setImmediate$1(() => callback(null, ...memo[key12]));
        } else if (key12 in queues) {
          queues[key12].push(callback);
        } else {
          queues[key12] = [callback];
          _fn(...args, (err, ...resultArgs) => {
            if (!err) {
              memo[key12] = resultArgs;
            }
            var q = queues[key12];
            delete queues[key12];
            for (var i = 0, l = q.length;i < l; i++) {
              q[i](err, ...resultArgs);
            }
          });
        }
      });
      memoized.memo = memo;
      memoized.unmemoized = fn;
      return memoized;
    }
    var _defer;
    if (hasNextTick) {
      _defer = process.nextTick;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else {
      _defer = fallback2;
    }
    var nextTick = wrap(_defer);
    var _parallel = awaitify((eachfn, tasks, callback) => {
      var results = isArrayLike(tasks) ? [] : {};
      eachfn(tasks, (task, key12, taskCb) => {
        wrapAsync(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key12] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    function parallel(tasks, callback) {
      return _parallel(eachOf$1, tasks, callback);
    }
    function parallelLimit(tasks, limit, callback) {
      return _parallel(eachOfLimit$2(limit), tasks, callback);
    }
    function queue(worker, concurrency) {
      var _worker = wrapAsync(worker);
      return queue$1((items, cb) => {
        _worker(items[0], cb);
      }, concurrency, 1);
    }

    class Heap {
      constructor() {
        this.heap = [];
        this.pushCount = Number.MIN_SAFE_INTEGER;
      }
      get length() {
        return this.heap.length;
      }
      empty() {
        this.heap = [];
        return this;
      }
      percUp(index2) {
        let p;
        while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
          let t = this.heap[index2];
          this.heap[index2] = this.heap[p];
          this.heap[p] = t;
          index2 = p;
        }
      }
      percDown(index2) {
        let l;
        while ((l = leftChi(index2)) < this.heap.length) {
          if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
            l = l + 1;
          }
          if (smaller(this.heap[index2], this.heap[l])) {
            break;
          }
          let t = this.heap[index2];
          this.heap[index2] = this.heap[l];
          this.heap[l] = t;
          index2 = l;
        }
      }
      push(node) {
        node.pushCount = ++this.pushCount;
        this.heap.push(node);
        this.percUp(this.heap.length - 1);
      }
      unshift(node) {
        return this.heap.push(node);
      }
      shift() {
        let [top] = this.heap;
        this.heap[0] = this.heap[this.heap.length - 1];
        this.heap.pop();
        this.percDown(0);
        return top;
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        for (let i = 0;i < this.heap.length; i++) {
          yield this.heap[i].data;
        }
      }
      remove(testFn) {
        let j = 0;
        for (let i = 0;i < this.heap.length; i++) {
          if (!testFn(this.heap[i])) {
            this.heap[j] = this.heap[i];
            j++;
          }
        }
        this.heap.splice(j);
        for (let i = parent(this.heap.length - 1);i >= 0; i--) {
          this.percDown(i);
        }
        return this;
      }
    }
    function leftChi(i) {
      return (i << 1) + 1;
    }
    function parent(i) {
      return (i + 1 >> 1) - 1;
    }
    function smaller(x, y) {
      if (x.priority !== y.priority) {
        return x.priority < y.priority;
      } else {
        return x.pushCount < y.pushCount;
      }
    }
    function priorityQueue(worker, concurrency) {
      var q = queue(worker, concurrency);
      var {
        push,
        pushAsync
      } = q;
      q._tasks = new Heap;
      q._createTaskItem = ({ data, priority }, callback) => {
        return {
          data,
          priority,
          callback
        };
      };
      function createDataItems(tasks, priority) {
        if (!Array.isArray(tasks)) {
          return { data: tasks, priority };
        }
        return tasks.map((data) => {
          return { data, priority };
        });
      }
      q.push = function(data, priority = 0, callback) {
        return push(createDataItems(data, priority), callback);
      };
      q.pushAsync = function(data, priority = 0, callback) {
        return pushAsync(createDataItems(data, priority), callback);
      };
      delete q.unshift;
      delete q.unshiftAsync;
      return q;
    }
    function race(tasks, callback) {
      callback = once(callback);
      if (!Array.isArray(tasks))
        return callback(new TypeError("First argument to race must be an array of functions"));
      if (!tasks.length)
        return callback();
      for (var i = 0, l = tasks.length;i < l; i++) {
        wrapAsync(tasks[i])(callback);
      }
    }
    var race$1 = awaitify(race, 2);
    function reduceRight(array, memo, iteratee, callback) {
      var reversed = [...array].reverse();
      return reduce$1(reversed, memo, iteratee, callback);
    }
    function reflect(fn) {
      var _fn = wrapAsync(fn);
      return initialParams(function reflectOn(args, reflectCallback) {
        args.push((error, ...cbArgs) => {
          let retVal = {};
          if (error) {
            retVal.error = error;
          }
          if (cbArgs.length > 0) {
            var value = cbArgs;
            if (cbArgs.length <= 1) {
              [value] = cbArgs;
            }
            retVal.value = value;
          }
          reflectCallback(null, retVal);
        });
        return _fn.apply(this, args);
      });
    }
    function reflectAll(tasks) {
      var results;
      if (Array.isArray(tasks)) {
        results = tasks.map(reflect);
      } else {
        results = {};
        Object.keys(tasks).forEach((key12) => {
          results[key12] = reflect.call(this, tasks[key12]);
        });
      }
      return results;
    }
    function reject$2(eachfn, arr, _iteratee, callback) {
      const iteratee = wrapAsync(_iteratee);
      return _filter(eachfn, arr, (value, cb) => {
        iteratee(value, (err, v) => {
          cb(err, !v);
        });
      }, callback);
    }
    function reject(coll, iteratee, callback) {
      return reject$2(eachOf$1, coll, iteratee, callback);
    }
    var reject$1 = awaitify(reject, 3);
    function rejectLimit(coll, limit, iteratee, callback) {
      return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var rejectLimit$1 = awaitify(rejectLimit, 4);
    function rejectSeries(coll, iteratee, callback) {
      return reject$2(eachOfSeries$1, coll, iteratee, callback);
    }
    var rejectSeries$1 = awaitify(rejectSeries, 3);
    function constant(value) {
      return function() {
        return value;
      };
    }
    const DEFAULT_TIMES = 5;
    const DEFAULT_INTERVAL = 0;
    function retry(opts, task, callback) {
      var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant(DEFAULT_INTERVAL)
      };
      if (arguments.length < 3 && typeof opts === "function") {
        callback = task || promiseCallback();
        task = opts;
      } else {
        parseTimes(options, opts);
        callback = callback || promiseCallback();
      }
      if (typeof task !== "function") {
        throw new Error("Invalid arguments for async.retry");
      }
      var _task = wrapAsync(task);
      var attempt = 1;
      function retryAttempt() {
        _task((err, ...args) => {
          if (err === false)
            return;
          if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
            setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
          } else {
            callback(err, ...args);
          }
        });
      }
      retryAttempt();
      return callback[PROMISE_SYMBOL];
    }
    function parseTimes(acc, t) {
      if (typeof t === "object") {
        acc.times = +t.times || DEFAULT_TIMES;
        acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);
        acc.errorFilter = t.errorFilter;
      } else if (typeof t === "number" || typeof t === "string") {
        acc.times = +t || DEFAULT_TIMES;
      } else {
        throw new Error("Invalid arguments for async.retry");
      }
    }
    function retryable(opts, task) {
      if (!task) {
        task = opts;
        opts = null;
      }
      let arity = opts && opts.arity || task.length;
      if (isAsync(task)) {
        arity += 1;
      }
      var _task = wrapAsync(task);
      return initialParams((args, callback) => {
        if (args.length < arity - 1 || callback == null) {
          args.push(callback);
          callback = promiseCallback();
        }
        function taskFn(cb) {
          _task(...args, cb);
        }
        if (opts)
          retry(opts, taskFn, callback);
        else
          retry(taskFn, callback);
        return callback[PROMISE_SYMBOL];
      });
    }
    function series(tasks, callback) {
      return _parallel(eachOfSeries$1, tasks, callback);
    }
    function some(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
    }
    var some$1 = awaitify(some, 3);
    function someLimit(coll, limit, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var someLimit$1 = awaitify(someLimit, 4);
    function someSeries(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var someSeries$1 = awaitify(someSeries, 3);
    function sortBy(coll, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return map$1(coll, (x, iterCb) => {
        _iteratee(x, (err, criteria) => {
          if (err)
            return iterCb(err);
          iterCb(err, { value: x, criteria });
        });
      }, (err, results) => {
        if (err)
          return callback(err);
        callback(null, results.sort(comparator).map((v) => v.value));
      });
      function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
      }
    }
    var sortBy$1 = awaitify(sortBy, 3);
    function timeout(asyncFn, milliseconds, info) {
      var fn = wrapAsync(asyncFn);
      return initialParams((args, callback) => {
        var timedOut = false;
        var timer;
        function timeoutCallback() {
          var name = asyncFn.name || "anonymous";
          var error = new Error('Callback function "' + name + '" timed out.');
          error.code = "ETIMEDOUT";
          if (info) {
            error.info = info;
          }
          timedOut = true;
          callback(error);
        }
        args.push((...cbArgs) => {
          if (!timedOut) {
            callback(...cbArgs);
            clearTimeout(timer);
          }
        });
        timer = setTimeout(timeoutCallback, milliseconds);
        fn(...args);
      });
    }
    function range(size) {
      var result = Array(size);
      while (size--) {
        result[size] = size;
      }
      return result;
    }
    function timesLimit(count, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(range(count), limit, _iteratee, callback);
    }
    function times(n, iteratee, callback) {
      return timesLimit(n, Infinity, iteratee, callback);
    }
    function timesSeries(n, iteratee, callback) {
      return timesLimit(n, 1, iteratee, callback);
    }
    function transform(coll, accumulator, iteratee, callback) {
      if (arguments.length <= 3 && typeof accumulator === "function") {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = Array.isArray(coll) ? [] : {};
      }
      callback = once(callback || promiseCallback());
      var _iteratee = wrapAsync(iteratee);
      eachOf$1(coll, (v, k, cb) => {
        _iteratee(accumulator, v, k, cb);
      }, (err) => callback(err, accumulator));
      return callback[PROMISE_SYMBOL];
    }
    function tryEach(tasks, callback) {
      var error = null;
      var result;
      return eachSeries$1(tasks, (task, taskCb) => {
        wrapAsync(task)((err, ...args) => {
          if (err === false)
            return taskCb(err);
          if (args.length < 2) {
            [result] = args;
          } else {
            result = args;
          }
          error = err;
          taskCb(err ? null : {});
        });
      }, () => callback(error, result));
    }
    var tryEach$1 = awaitify(tryEach);
    function unmemoize(fn) {
      return (...args) => {
        return (fn.unmemoized || fn)(...args);
      };
    }
    function whilst(test, iteratee, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee);
      var _test = wrapAsync(test);
      var results = [];
      function next(err, ...rest) {
        if (err)
          return callback(err);
        results = rest;
        if (err === false)
          return;
        _test(check2);
      }
      function check2(err, truth) {
        if (err)
          return callback(err);
        if (err === false)
          return;
        if (!truth)
          return callback(null, ...results);
        _fn(next);
      }
      return _test(check2);
    }
    var whilst$1 = awaitify(whilst, 3);
    function until(test, iteratee, callback) {
      const _test = wrapAsync(test);
      return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
    }
    function waterfall(tasks, callback) {
      callback = once(callback);
      if (!Array.isArray(tasks))
        return callback(new Error("First argument to waterfall must be an array of functions"));
      if (!tasks.length)
        return callback();
      var taskIndex = 0;
      function nextTask(args) {
        var task = wrapAsync(tasks[taskIndex++]);
        task(...args, onlyOnce(next));
      }
      function next(err, ...args) {
        if (err === false)
          return;
        if (err || taskIndex === tasks.length) {
          return callback(err, ...args);
        }
        nextTask(args);
      }
      nextTask([]);
    }
    var waterfall$1 = awaitify(waterfall);
    var index = {
      apply,
      applyEach,
      applyEachSeries,
      asyncify,
      auto,
      autoInject,
      cargo: cargo$1,
      cargoQueue: cargo,
      compose,
      concat: concat$1,
      concatLimit: concatLimit$1,
      concatSeries: concatSeries$1,
      constant: constant$1,
      detect: detect$1,
      detectLimit: detectLimit$1,
      detectSeries: detectSeries$1,
      dir,
      doUntil,
      doWhilst: doWhilst$1,
      each,
      eachLimit: eachLimit$1,
      eachOf: eachOf$1,
      eachOfLimit: eachOfLimit$1,
      eachOfSeries: eachOfSeries$1,
      eachSeries: eachSeries$1,
      ensureAsync,
      every: every$1,
      everyLimit: everyLimit$1,
      everySeries: everySeries$1,
      filter: filter$1,
      filterLimit: filterLimit$1,
      filterSeries: filterSeries$1,
      forever: forever$1,
      groupBy,
      groupByLimit: groupByLimit$1,
      groupBySeries,
      log,
      map: map$1,
      mapLimit: mapLimit$1,
      mapSeries: mapSeries$1,
      mapValues,
      mapValuesLimit: mapValuesLimit$1,
      mapValuesSeries,
      memoize,
      nextTick,
      parallel,
      parallelLimit,
      priorityQueue,
      queue,
      race: race$1,
      reduce: reduce$1,
      reduceRight,
      reflect,
      reflectAll,
      reject: reject$1,
      rejectLimit: rejectLimit$1,
      rejectSeries: rejectSeries$1,
      retry,
      retryable,
      seq,
      series,
      setImmediate: setImmediate$1,
      some: some$1,
      someLimit: someLimit$1,
      someSeries: someSeries$1,
      sortBy: sortBy$1,
      timeout,
      times,
      timesLimit,
      timesSeries,
      transform,
      tryEach: tryEach$1,
      unmemoize,
      until,
      waterfall: waterfall$1,
      whilst: whilst$1,
      all: every$1,
      allLimit: everyLimit$1,
      allSeries: everySeries$1,
      any: some$1,
      anyLimit: someLimit$1,
      anySeries: someSeries$1,
      find: detect$1,
      findLimit: detectLimit$1,
      findSeries: detectSeries$1,
      flatMap: concat$1,
      flatMapLimit: concatLimit$1,
      flatMapSeries: concatSeries$1,
      forEach: each,
      forEachSeries: eachSeries$1,
      forEachLimit: eachLimit$1,
      forEachOf: eachOf$1,
      forEachOfSeries: eachOfSeries$1,
      forEachOfLimit: eachOfLimit$1,
      inject: reduce$1,
      foldl: reduce$1,
      foldr: reduceRight,
      select: filter$1,
      selectLimit: filterLimit$1,
      selectSeries: filterSeries$1,
      wrapSync: asyncify,
      during: whilst$1,
      doDuring: doWhilst$1
    };
    exports2.all = every$1;
    exports2.allLimit = everyLimit$1;
    exports2.allSeries = everySeries$1;
    exports2.any = some$1;
    exports2.anyLimit = someLimit$1;
    exports2.anySeries = someSeries$1;
    exports2.apply = apply;
    exports2.applyEach = applyEach;
    exports2.applyEachSeries = applyEachSeries;
    exports2.asyncify = asyncify;
    exports2.auto = auto;
    exports2.autoInject = autoInject;
    exports2.cargo = cargo$1;
    exports2.cargoQueue = cargo;
    exports2.compose = compose;
    exports2.concat = concat$1;
    exports2.concatLimit = concatLimit$1;
    exports2.concatSeries = concatSeries$1;
    exports2.constant = constant$1;
    exports2.default = index;
    exports2.detect = detect$1;
    exports2.detectLimit = detectLimit$1;
    exports2.detectSeries = detectSeries$1;
    exports2.dir = dir;
    exports2.doDuring = doWhilst$1;
    exports2.doUntil = doUntil;
    exports2.doWhilst = doWhilst$1;
    exports2.during = whilst$1;
    exports2.each = each;
    exports2.eachLimit = eachLimit$1;
    exports2.eachOf = eachOf$1;
    exports2.eachOfLimit = eachOfLimit$1;
    exports2.eachOfSeries = eachOfSeries$1;
    exports2.eachSeries = eachSeries$1;
    exports2.ensureAsync = ensureAsync;
    exports2.every = every$1;
    exports2.everyLimit = everyLimit$1;
    exports2.everySeries = everySeries$1;
    exports2.filter = filter$1;
    exports2.filterLimit = filterLimit$1;
    exports2.filterSeries = filterSeries$1;
    exports2.find = detect$1;
    exports2.findLimit = detectLimit$1;
    exports2.findSeries = detectSeries$1;
    exports2.flatMap = concat$1;
    exports2.flatMapLimit = concatLimit$1;
    exports2.flatMapSeries = concatSeries$1;
    exports2.foldl = reduce$1;
    exports2.foldr = reduceRight;
    exports2.forEach = each;
    exports2.forEachLimit = eachLimit$1;
    exports2.forEachOf = eachOf$1;
    exports2.forEachOfLimit = eachOfLimit$1;
    exports2.forEachOfSeries = eachOfSeries$1;
    exports2.forEachSeries = eachSeries$1;
    exports2.forever = forever$1;
    exports2.groupBy = groupBy;
    exports2.groupByLimit = groupByLimit$1;
    exports2.groupBySeries = groupBySeries;
    exports2.inject = reduce$1;
    exports2.log = log;
    exports2.map = map$1;
    exports2.mapLimit = mapLimit$1;
    exports2.mapSeries = mapSeries$1;
    exports2.mapValues = mapValues;
    exports2.mapValuesLimit = mapValuesLimit$1;
    exports2.mapValuesSeries = mapValuesSeries;
    exports2.memoize = memoize;
    exports2.nextTick = nextTick;
    exports2.parallel = parallel;
    exports2.parallelLimit = parallelLimit;
    exports2.priorityQueue = priorityQueue;
    exports2.queue = queue;
    exports2.race = race$1;
    exports2.reduce = reduce$1;
    exports2.reduceRight = reduceRight;
    exports2.reflect = reflect;
    exports2.reflectAll = reflectAll;
    exports2.reject = reject$1;
    exports2.rejectLimit = rejectLimit$1;
    exports2.rejectSeries = rejectSeries$1;
    exports2.retry = retry;
    exports2.retryable = retryable;
    exports2.select = filter$1;
    exports2.selectLimit = filterLimit$1;
    exports2.selectSeries = filterSeries$1;
    exports2.seq = seq;
    exports2.series = series;
    exports2.setImmediate = setImmediate$1;
    exports2.some = some$1;
    exports2.someLimit = someLimit$1;
    exports2.someSeries = someSeries$1;
    exports2.sortBy = sortBy$1;
    exports2.timeout = timeout;
    exports2.times = times;
    exports2.timesLimit = timesLimit;
    exports2.timesSeries = timesSeries;
    exports2.transform = transform;
    exports2.tryEach = tryEach$1;
    exports2.unmemoize = unmemoize;
    exports2.until = until;
    exports2.waterfall = waterfall$1;
    exports2.whilst = whilst$1;
    exports2.wrapSync = asyncify;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/archiver-utils/node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports, module) => {
  var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
  isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
  isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
  module.exports = isStream;
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS((exports, module) => {
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    module.exports = { nextTick };
  } else {
    module.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS((exports, module) => {
  var toString = {}.toString;
  module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
});

// node_modules/lazystream/node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key12 in src) {
      dst[key12] = src[key12];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS((exports) => {
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === undefined;
  }
  exports.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  exports.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports.isError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports.isPrimitive = isPrimitive;
  exports.isBuffer = __require("buffer").Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    util = __require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module.exports = util.inherits;
  } catch (e) {
    module.exports = require_inherits_browser();
  }
  var util;
});

// node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS((exports, module) => {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util = __require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util && util.inspect && util.inspect.custom) {
    module.exports.prototype[util.inspect.custom] = function() {
      var obj = util.inspect({ length: this.length });
      return this.constructor.name + " " + obj;
    };
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy
  };
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS((exports, module) => {
  module.exports = __require("util").deprecate;
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node()
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  util.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_3) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key12 in obj) {
      keys2.push(key12);
    }
    return keys2;
  };
  module.exports = Duplex;
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var Readable = require__stream_readable();
  var Writable = require__stream_writable();
  util.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// node_modules/lazystream/node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS((exports) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = __require("stream");
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  var debugUtil = __require("util");
  var debug = undefined;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {
    };
  }
  var BufferList = require_BufferList();
  var destroyImpl = require_destroy();
  var StringDecoder;
  util.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length;i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform = __commonJS((exports, module) => {
  module.exports = Transform;
  var Duplex = require__stream_duplex();
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  util.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough = __commonJS((exports, module) => {
  module.exports = PassThrough;
  var Transform = require__stream_transform();
  var util = Object.create(require_util());
  util.inherits = require_inherits();
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/lazystream/node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream;
    exports = module.exports = Stream.Readable;
    exports.Readable = Stream.Readable;
    exports.Writable = Stream.Writable;
    exports.Duplex = Stream.Duplex;
    exports.Transform = Stream.Transform;
    exports.PassThrough = Stream.PassThrough;
    exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable();
    exports.Duplex = require__stream_duplex();
    exports.Transform = require__stream_transform();
    exports.PassThrough = require__stream_passthrough();
  }
});

// node_modules/lazystream/node_modules/readable-stream/passthrough.js
var require_passthrough = __commonJS((exports, module) => {
  module.exports = require_readable().PassThrough;
});

// node_modules/lazystream/lib/lazystream.js
var require_lazystream = __commonJS((exports, module) => {
  var util = __require("util");
  var PassThrough = require_passthrough();
  module.exports = {
    Readable,
    Writable
  };
  util.inherits(Readable, PassThrough);
  util.inherits(Writable, PassThrough);
  function beforeFirstCall(instance, method, callback) {
    instance[method] = function() {
      delete instance[method];
      callback.apply(this, arguments);
      return this[method].apply(this, arguments);
    };
  }
  function Readable(fn, options) {
    if (!(this instanceof Readable))
      return new Readable(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_read", function() {
      var source = fn.call(this, options);
      var emit = this.emit.bind(this, "error");
      source.on("error", emit);
      source.pipe(this);
    });
    this.emit("readable");
  }
  function Writable(fn, options) {
    if (!(this instanceof Writable))
      return new Writable(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_write", function() {
      var destination = fn.call(this, options);
      var emit = this.emit.bind(this, "error");
      destination.on("error", emit);
      this.pipe(destination);
    });
    this.emit("writable");
  }
});

// node_modules/normalize-path/index.js
var require_normalize_path = __commonJS((exports, module) => {
  /*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   */
  module.exports = function(path3, stripTrailing) {
    if (typeof path3 !== "string") {
      throw new TypeError("expected path to be a string");
    }
    if (path3 === "\\" || path3 === "/")
      return "/";
    var len = path3.length;
    if (len <= 1)
      return path3;
    var prefix = "";
    if (len > 4 && path3[3] === "\\") {
      var ch = path3[2];
      if ((ch === "?" || ch === ".") && path3.slice(0, 2) === "\\\\") {
        path3 = path3.slice(2);
        prefix = "//";
      }
    }
    var segs = path3.split(/[/\\]+/);
    if (stripTrailing !== false && segs[segs.length - 1] === "") {
      segs.pop();
    }
    return prefix + segs.join("/");
  };
});

// node_modules/lodash/identity.js
var require_identity2 = __commonJS((exports, module) => {
  function identity(value) {
    return value;
  }
  module.exports = identity;
});

// node_modules/lodash/_apply.js
var require__apply = __commonJS((exports, module) => {
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  module.exports = apply;
});

// node_modules/lodash/_overRest.js
var require__overRest = __commonJS((exports, module) => {
  var apply = require__apply();
  var nativeMax = Math.max;
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  module.exports = overRest;
});

// node_modules/lodash/constant.js
var require_constant = __commonJS((exports, module) => {
  function constant(value) {
    return function() {
      return value;
    };
  }
  module.exports = constant;
});

// node_modules/lodash/_freeGlobal.js
var require__freeGlobal = __commonJS((exports, module) => {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module.exports = freeGlobal;
});

// node_modules/lodash/_root.js
var require__root = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  module.exports = root;
});

// node_modules/lodash/_Symbol.js
var require__Symbol = __commonJS((exports, module) => {
  var root = require__root();
  var Symbol2 = root.Symbol;
  module.exports = Symbol2;
});

// node_modules/lodash/_getRawTag.js
var require__getRawTag = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  module.exports = getRawTag;
});

// node_modules/lodash/_objectToString.js
var require__objectToString = __commonJS((exports, module) => {
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  module.exports = objectToString;
});

// node_modules/lodash/_baseGetTag.js
var require__baseGetTag = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol();
  var getRawTag = require__getRawTag();
  var objectToString = require__objectToString();
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  module.exports = baseGetTag;
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS((exports, module) => {
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  module.exports = isObject;
});

// node_modules/lodash/isFunction.js
var require_isFunction2 = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag();
  var isObject = require_isObject();
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  module.exports = isFunction;
});

// node_modules/lodash/_coreJsData.js
var require__coreJsData = __commonJS((exports, module) => {
  var root = require__root();
  var coreJsData = root["__core-js_shared__"];
  module.exports = coreJsData;
});

// node_modules/lodash/_isMasked.js
var require__isMasked = __commonJS((exports, module) => {
  var coreJsData = require__coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  module.exports = isMasked;
});

// node_modules/lodash/_toSource.js
var require__toSource = __commonJS((exports, module) => {
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  module.exports = toSource;
});

// node_modules/lodash/_baseIsNative.js
var require__baseIsNative = __commonJS((exports, module) => {
  var isFunction = require_isFunction2();
  var isMasked = require__isMasked();
  var isObject = require_isObject();
  var toSource = require__toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  module.exports = baseIsNative;
});

// node_modules/lodash/_getValue.js
var require__getValue = __commonJS((exports, module) => {
  function getValue(object, key12) {
    return object == null ? undefined : object[key12];
  }
  module.exports = getValue;
});

// node_modules/lodash/_getNative.js
var require__getNative = __commonJS((exports, module) => {
  var baseIsNative = require__baseIsNative();
  var getValue = require__getValue();
  function getNative(object, key12) {
    var value = getValue(object, key12);
    return baseIsNative(value) ? value : undefined;
  }
  module.exports = getNative;
});

// node_modules/lodash/_defineProperty.js
var require__defineProperty = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  module.exports = defineProperty;
});

// node_modules/lodash/_baseSetToString.js
var require__baseSetToString = __commonJS((exports, module) => {
  var constant = require_constant();
  var defineProperty = require__defineProperty();
  var identity = require_identity2();
  var baseSetToString = !defineProperty ? identity : function(func, string2) {
    return defineProperty(func, "toString", {
      configurable: true,
      enumerable: false,
      value: constant(string2),
      writable: true
    });
  };
  module.exports = baseSetToString;
});

// node_modules/lodash/_shortOut.js
var require__shortOut = __commonJS((exports, module) => {
  var HOT_COUNT = 800;
  var HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }
  module.exports = shortOut;
});

// node_modules/lodash/_setToString.js
var require__setToString = __commonJS((exports, module) => {
  var baseSetToString = require__baseSetToString();
  var shortOut = require__shortOut();
  var setToString = shortOut(baseSetToString);
  module.exports = setToString;
});

// node_modules/lodash/_baseRest.js
var require__baseRest = __commonJS((exports, module) => {
  var identity = require_identity2();
  var overRest = require__overRest();
  var setToString = require__setToString();
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  module.exports = baseRest;
});

// node_modules/lodash/eq.js
var require_eq = __commonJS((exports, module) => {
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  module.exports = eq;
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS((exports, module) => {
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  module.exports = isLength;
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike2 = __commonJS((exports, module) => {
  var isFunction = require_isFunction2();
  var isLength = require_isLength();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  module.exports = isArrayLike;
});

// node_modules/lodash/_isIndex.js
var require__isIndex = __commonJS((exports, module) => {
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  module.exports = isIndex;
});

// node_modules/lodash/_isIterateeCall.js
var require__isIterateeCall = __commonJS((exports, module) => {
  var eq = require_eq();
  var isArrayLike = require_isArrayLike2();
  var isIndex = require__isIndex();
  var isObject = require_isObject();
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && (index in object)) {
      return eq(object[index], value);
    }
    return false;
  }
  module.exports = isIterateeCall;
});

// node_modules/lodash/_baseTimes.js
var require__baseTimes = __commonJS((exports, module) => {
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  module.exports = baseTimes;
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS((exports, module) => {
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  module.exports = isObjectLike;
});

// node_modules/lodash/_baseIsArguments.js
var require__baseIsArguments = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  module.exports = baseIsArguments;
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS((exports, module) => {
  var baseIsArguments = require__baseIsArguments();
  var isObjectLike = require_isObjectLike();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  module.exports = isArguments;
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports, module) => {
  var isArray = Array.isArray;
  module.exports = isArray;
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS((exports, module) => {
  function stubFalse() {
    return false;
  }
  module.exports = stubFalse;
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS((exports, module) => {
  var root = require__root();
  var stubFalse = require_stubFalse();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined;
  var isBuffer = nativeIsBuffer || stubFalse;
  module.exports = isBuffer;
});

// node_modules/lodash/_baseIsTypedArray.js
var require__baseIsTypedArray = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag();
  var isLength = require_isLength();
  var isObjectLike = require_isObjectLike();
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  module.exports = baseIsTypedArray;
});

// node_modules/lodash/_baseUnary.js
var require__baseUnary = __commonJS((exports, module) => {
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  module.exports = baseUnary;
});

// node_modules/lodash/_nodeUtil.js
var require__nodeUtil = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil;
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS((exports, module) => {
  var baseIsTypedArray = require__baseIsTypedArray();
  var baseUnary = require__baseUnary();
  var nodeUtil = require__nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  module.exports = isTypedArray;
});

// node_modules/lodash/_arrayLikeKeys.js
var require__arrayLikeKeys = __commonJS((exports, module) => {
  var baseTimes = require__baseTimes();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var isBuffer = require_isBuffer();
  var isIndex = require__isIndex();
  var isTypedArray = require_isTypedArray();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key12 in value) {
      if ((inherited || hasOwnProperty.call(value, key12)) && !(skipIndexes && (key12 == "length" || isBuff && (key12 == "offset" || key12 == "parent") || isType && (key12 == "buffer" || key12 == "byteLength" || key12 == "byteOffset") || isIndex(key12, length)))) {
        result.push(key12);
      }
    }
    return result;
  }
  module.exports = arrayLikeKeys;
});

// node_modules/lodash/_isPrototype.js
var require__isPrototype = __commonJS((exports, module) => {
  var objectProto = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto2;
  }
  module.exports = isPrototype;
});

// node_modules/lodash/_nativeKeysIn.js
var require__nativeKeysIn = __commonJS((exports, module) => {
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key12 in Object(object)) {
        result.push(key12);
      }
    }
    return result;
  }
  module.exports = nativeKeysIn;
});

// node_modules/lodash/_baseKeysIn.js
var require__baseKeysIn = __commonJS((exports, module) => {
  var isObject = require_isObject();
  var isPrototype = require__isPrototype();
  var nativeKeysIn = require__nativeKeysIn();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key12 in object) {
      if (!(key12 == "constructor" && (isProto || !hasOwnProperty.call(object, key12)))) {
        result.push(key12);
      }
    }
    return result;
  }
  module.exports = baseKeysIn;
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS((exports, module) => {
  var arrayLikeKeys = require__arrayLikeKeys();
  var baseKeysIn = require__baseKeysIn();
  var isArrayLike = require_isArrayLike2();
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  module.exports = keysIn;
});

// node_modules/lodash/defaults.js
var require_defaults = __commonJS((exports, module) => {
  var baseRest = require__baseRest();
  var eq = require_eq();
  var isIterateeCall = require__isIterateeCall();
  var keysIn = require_keysIn();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var defaults = baseRest(function(object, sources) {
    object = Object(object);
    var index = -1;
    var length = sources.length;
    var guard = length > 2 ? sources[2] : undefined;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      var props = keysIn(source);
      var propsIndex = -1;
      var propsLength = props.length;
      while (++propsIndex < propsLength) {
        var key12 = props[propsIndex];
        var value = object[key12];
        if (value === undefined || eq(value, objectProto[key12]) && !hasOwnProperty.call(object, key12)) {
          object[key12] = source[key12];
        }
      }
    }
    return object;
  });
  module.exports = defaults;
});

// node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS((exports, module) => {
  class AggregateError extends Error {
    constructor(errors12) {
      if (!Array.isArray(errors12)) {
        throw new TypeError(`Expected input to be an Array, got ${typeof errors12}`);
      }
      let message = "";
      for (let i = 0;i < errors12.length; i++) {
        message += `    ${errors12[i].stack}
`;
      }
      super(message);
      this.name = "AggregateError";
      this.errors = errors12;
    }
  }
  module.exports = {
    AggregateError,
    ArrayIsArray(self2) {
      return Array.isArray(self2);
    },
    ArrayPrototypeIncludes(self2, el) {
      return self2.includes(el);
    },
    ArrayPrototypeIndexOf(self2, el) {
      return self2.indexOf(el);
    },
    ArrayPrototypeJoin(self2, sep) {
      return self2.join(sep);
    },
    ArrayPrototypeMap(self2, fn) {
      return self2.map(fn);
    },
    ArrayPrototypePop(self2, el) {
      return self2.pop(el);
    },
    ArrayPrototypePush(self2, el) {
      return self2.push(el);
    },
    ArrayPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    },
    Error,
    FunctionPrototypeCall(fn, thisArgs, ...args) {
      return fn.call(thisArgs, ...args);
    },
    FunctionPrototypeSymbolHasInstance(self2, instance) {
      return Function.prototype[Symbol.hasInstance].call(self2, instance);
    },
    MathFloor: Math.floor,
    Number,
    NumberIsInteger: Number.isInteger,
    NumberIsNaN: Number.isNaN,
    NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
    NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
    NumberParseInt: Number.parseInt,
    ObjectDefineProperties(self2, props) {
      return Object.defineProperties(self2, props);
    },
    ObjectDefineProperty(self2, name, prop) {
      return Object.defineProperty(self2, name, prop);
    },
    ObjectGetOwnPropertyDescriptor(self2, name) {
      return Object.getOwnPropertyDescriptor(self2, name);
    },
    ObjectKeys(obj) {
      return Object.keys(obj);
    },
    ObjectSetPrototypeOf(target, proto2) {
      return Object.setPrototypeOf(target, proto2);
    },
    Promise,
    PromisePrototypeCatch(self2, fn) {
      return self2.catch(fn);
    },
    PromisePrototypeThen(self2, thenFn, catchFn) {
      return self2.then(thenFn, catchFn);
    },
    PromiseReject(err) {
      return Promise.reject(err);
    },
    PromiseResolve(val) {
      return Promise.resolve(val);
    },
    ReflectApply: Reflect.apply,
    RegExpPrototypeTest(self2, value) {
      return self2.test(value);
    },
    SafeSet: Set,
    String,
    StringPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    },
    StringPrototypeToLowerCase(self2) {
      return self2.toLowerCase();
    },
    StringPrototypeToUpperCase(self2) {
      return self2.toUpperCase();
    },
    StringPrototypeTrim(self2) {
      return self2.trim();
    },
    Symbol,
    SymbolFor: Symbol.for,
    SymbolAsyncIterator: Symbol.asyncIterator,
    SymbolHasInstance: Symbol.hasInstance,
    SymbolIterator: Symbol.iterator,
    SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
    SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
    TypedArrayPrototypeSet(self2, buf, len) {
      return self2.set(buf, len);
    },
    Boolean,
    Uint8Array
  };
});

// node_modules/readable-stream/lib/ours/util/inspect.js
var require_inspect = __commonJS((exports, module) => {
  module.exports = {
    format(format, ...args) {
      return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
        const replacement = args.shift();
        if (type === "f") {
          return replacement.toFixed(6);
        } else if (type === "j") {
          return JSON.stringify(replacement);
        } else if (type === "s" && typeof replacement === "object") {
          const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
          return `${ctor} {}`.trim();
        } else {
          return replacement.toString();
        }
      });
    },
    inspect(value) {
      switch (typeof value) {
        case "string":
          if (value.includes("'")) {
            if (!value.includes('"')) {
              return `"${value}"`;
            } else if (!value.includes("`") && !value.includes("${")) {
              return `\`${value}\``;
            }
          }
          return `'${value}'`;
        case "number":
          if (isNaN(value)) {
            return "NaN";
          } else if (Object.is(value, -0)) {
            return String(value);
          }
          return value;
        case "bigint":
          return `${String(value)}n`;
        case "boolean":
        case "undefined":
          return String(value);
        case "object":
          return "{}";
      }
    }
  };
});

// node_modules/readable-stream/lib/ours/errors.js
var require_errors = __commonJS((exports, module) => {
  var { format, inspect } = require_inspect();
  var { AggregateError: CustomAggregateError } = require_primordials();
  var AggregateError = globalThis.AggregateError || CustomAggregateError;
  var kIsNodeError = Symbol("kIsNodeError");
  var kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol"
  ];
  var classRegExp = /^([A-Z][a-z0-9]*)+$/;
  var nodeInternalPrefix = "__node_internal_";
  var codes = {};
  function assert(value, message) {
    if (!value) {
      throw new codes.ERR_INTERNAL_ASSERTION(message);
    }
  }
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (;i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function getMessage(key12, msg, args) {
    if (typeof msg === "function") {
      assert(msg.length <= args.length, `Code: ${key12}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`);
      return msg(...args);
    }
    const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
    assert(expectedLength === args.length, `Code: ${key12}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);
    if (args.length === 0) {
      return msg;
    }
    return format(msg, ...args);
  }
  function E(code, message, Base) {
    if (!Base) {
      Base = Error;
    }

    class NodeError extends Base {
      constructor(...args) {
        super(getMessage(code, message, args));
      }
      toString() {
        return `${this.name} [${code}]: ${this.message}`;
      }
    }
    Object.defineProperties(NodeError.prototype, {
      name: {
        value: Base.name,
        writable: true,
        enumerable: false,
        configurable: true
      },
      toString: {
        value() {
          return `${this.name} [${code}]: ${this.message}`;
        },
        writable: true,
        enumerable: false,
        configurable: true
      }
    });
    NodeError.prototype.code = code;
    NodeError.prototype[kIsNodeError] = true;
    codes[code] = NodeError;
  }
  function hideStackFrames(fn) {
    const hidden = nodeInternalPrefix + fn.name;
    Object.defineProperty(fn, "name", {
      value: hidden
    });
    return fn;
  }
  function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
      if (Array.isArray(outerError.errors)) {
        outerError.errors.push(innerError);
        return outerError;
      }
      const err = new AggregateError([outerError, innerError], outerError.message);
      err.code = outerError.code;
      return err;
    }
    return innerError || outerError;
  }

  class AbortError extends Error {
    constructor(message = "The operation was aborted", options = undefined) {
      if (options !== undefined && typeof options !== "object") {
        throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
      }
      super(message, options);
      this.code = "ABORT_ERR";
      this.name = "AbortError";
    }
  }
  E("ERR_ASSERTION", "%s", Error);
  E("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
    assert(typeof name === "string", "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }
    let msg = "The ";
    if (name.endsWith(" argument")) {
      msg += `${name} `;
    } else {
      msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected) {
      assert(typeof value === "string", "All expected entries have to be of type string");
      if (kTypes.includes(value)) {
        types.push(value.toLowerCase());
      } else if (classRegExp.test(value)) {
        instances.push(value);
      } else {
        assert(value !== "object", 'The value "object" should be written as "Object"');
        other.push(value);
      }
    }
    if (instances.length > 0) {
      const pos = types.indexOf("object");
      if (pos !== -1) {
        types.splice(types, pos, 1);
        instances.push("Object");
      }
    }
    if (types.length > 0) {
      switch (types.length) {
        case 1:
          msg += `of type ${types[0]}`;
          break;
        case 2:
          msg += `one of type ${types[0]} or ${types[1]}`;
          break;
        default: {
          const last = types.pop();
          msg += `one of type ${types.join(", ")}, or ${last}`;
        }
      }
      if (instances.length > 0 || other.length > 0) {
        msg += " or ";
      }
    }
    if (instances.length > 0) {
      switch (instances.length) {
        case 1:
          msg += `an instance of ${instances[0]}`;
          break;
        case 2:
          msg += `an instance of ${instances[0]} or ${instances[1]}`;
          break;
        default: {
          const last = instances.pop();
          msg += `an instance of ${instances.join(", ")}, or ${last}`;
        }
      }
      if (other.length > 0) {
        msg += " or ";
      }
    }
    switch (other.length) {
      case 0:
        break;
      case 1:
        if (other[0].toLowerCase() !== other[0]) {
          msg += "an ";
        }
        msg += `${other[0]}`;
        break;
      case 2:
        msg += `one of ${other[0]} or ${other[1]}`;
        break;
      default: {
        const last = other.pop();
        msg += `one of ${other.join(", ")}, or ${last}`;
      }
    }
    if (actual == null) {
      msg += `. Received ${actual}`;
    } else if (typeof actual === "function" && actual.name) {
      msg += `. Received function ${actual.name}`;
    } else if (typeof actual === "object") {
      var _actual$constructor;
      if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== undefined && _actual$constructor.name) {
        msg += `. Received an instance of ${actual.constructor.name}`;
      } else {
        const inspected = inspect(actual, {
          depth: -1
        });
        msg += `. Received ${inspected}`;
      }
    } else {
      let inspected = inspect(actual, {
        colors: false
      });
      if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
      }
      msg += `. Received type ${typeof actual} (${inspected})`;
    }
    return msg;
  }, TypeError);
  E("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
    let inspected = inspect(value);
    if (inspected.length > 128) {
      inspected = inspected.slice(0, 128) + "...";
    }
    const type = name.includes(".") ? "property" : "argument";
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
  }, TypeError);
  E("ERR_INVALID_RETURN_VALUE", (input, name, value) => {
    var _value$constructor;
    const type = value !== null && value !== undefined && (_value$constructor = value.constructor) !== null && _value$constructor !== undefined && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
    return `Expected ${input} to be returned from the "${name}"` + ` function but got ${type}.`;
  }, TypeError);
  E("ERR_MISSING_ARGS", (...args) => {
    assert(args.length > 0, "At least one arg needs to be specified");
    let msg;
    const len = args.length;
    args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
    switch (len) {
      case 1:
        msg += `The ${args[0]} argument`;
        break;
      case 2:
        msg += `The ${args[0]} and ${args[1]} arguments`;
        break;
      default:
        {
          const last = args.pop();
          msg += `The ${args.join(", ")}, and ${last} arguments`;
        }
        break;
    }
    return `${msg} must be specified`;
  }, TypeError);
  E("ERR_OUT_OF_RANGE", (str, range, input) => {
    assert(range, 'Missing "range" argument');
    let received;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      const limit = BigInt(2) ** BigInt(32);
      if (input > limit || input < -limit) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    } else {
      received = inspect(input);
    }
    return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
  }, RangeError);
  E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
  E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
  E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
  E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
  E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
  E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
  E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
  E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
  E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
  E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
  module.exports = {
    AbortError,
    aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
    hideStackFrames,
    codes
  };
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var privateData = new WeakMap;
  var wrappers = new WeakMap;
  function pd(event) {
    const retv = privateData.get(event);
    console.assert(retv != null, "'this' is expected an Event object, but got", event);
    return retv;
  }
  function setCancelFlag(data) {
    if (data.passiveListener != null) {
      if (typeof console !== "undefined" && typeof console.error === "function") {
        console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
      }
      return;
    }
    if (!data.event.cancelable) {
      return;
    }
    data.canceled = true;
    if (typeof data.event.preventDefault === "function") {
      data.event.preventDefault();
    }
  }
  function Event(eventTarget, event) {
    privateData.set(this, {
      eventTarget,
      event,
      eventPhase: 2,
      currentTarget: eventTarget,
      canceled: false,
      stopped: false,
      immediateStopped: false,
      passiveListener: null,
      timeStamp: event.timeStamp || Date.now()
    });
    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
    const keys = Object.keys(event);
    for (let i = 0;i < keys.length; ++i) {
      const key12 = keys[i];
      if (!(key12 in this)) {
        Object.defineProperty(this, key12, defineRedirectDescriptor(key12));
      }
    }
  }
  Event.prototype = {
    get type() {
      return pd(this).event.type;
    },
    get target() {
      return pd(this).eventTarget;
    },
    get currentTarget() {
      return pd(this).currentTarget;
    },
    composedPath() {
      const currentTarget = pd(this).currentTarget;
      if (currentTarget == null) {
        return [];
      }
      return [currentTarget];
    },
    get NONE() {
      return 0;
    },
    get CAPTURING_PHASE() {
      return 1;
    },
    get AT_TARGET() {
      return 2;
    },
    get BUBBLING_PHASE() {
      return 3;
    },
    get eventPhase() {
      return pd(this).eventPhase;
    },
    stopPropagation() {
      const data = pd(this);
      data.stopped = true;
      if (typeof data.event.stopPropagation === "function") {
        data.event.stopPropagation();
      }
    },
    stopImmediatePropagation() {
      const data = pd(this);
      data.stopped = true;
      data.immediateStopped = true;
      if (typeof data.event.stopImmediatePropagation === "function") {
        data.event.stopImmediatePropagation();
      }
    },
    get bubbles() {
      return Boolean(pd(this).event.bubbles);
    },
    get cancelable() {
      return Boolean(pd(this).event.cancelable);
    },
    preventDefault() {
      setCancelFlag(pd(this));
    },
    get defaultPrevented() {
      return pd(this).canceled;
    },
    get composed() {
      return Boolean(pd(this).event.composed);
    },
    get timeStamp() {
      return pd(this).timeStamp;
    },
    get srcElement() {
      return pd(this).eventTarget;
    },
    get cancelBubble() {
      return pd(this).stopped;
    },
    set cancelBubble(value) {
      if (!value) {
        return;
      }
      const data = pd(this);
      data.stopped = true;
      if (typeof data.event.cancelBubble === "boolean") {
        data.event.cancelBubble = true;
      }
    },
    get returnValue() {
      return !pd(this).canceled;
    },
    set returnValue(value) {
      if (!value) {
        setCancelFlag(pd(this));
      }
    },
    initEvent() {
    }
  };
  Object.defineProperty(Event.prototype, "constructor", {
    value: Event,
    configurable: true,
    writable: true
  });
  if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);
    wrappers.set(window.Event.prototype, Event);
  }
  function defineRedirectDescriptor(key12) {
    return {
      get() {
        return pd(this).event[key12];
      },
      set(value) {
        pd(this).event[key12] = value;
      },
      configurable: true,
      enumerable: true
    };
  }
  function defineCallDescriptor(key12) {
    return {
      value() {
        const event = pd(this).event;
        return event[key12].apply(event, arguments);
      },
      configurable: true,
      enumerable: true
    };
  }
  function defineWrapper(BaseEvent, proto2) {
    const keys = Object.keys(proto2);
    if (keys.length === 0) {
      return BaseEvent;
    }
    function CustomEvent(eventTarget, event) {
      BaseEvent.call(this, eventTarget, event);
    }
    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
      constructor: { value: CustomEvent, configurable: true, writable: true }
    });
    for (let i = 0;i < keys.length; ++i) {
      const key12 = keys[i];
      if (!(key12 in BaseEvent.prototype)) {
        const descriptor = Object.getOwnPropertyDescriptor(proto2, key12);
        const isFunc = typeof descriptor.value === "function";
        Object.defineProperty(CustomEvent.prototype, key12, isFunc ? defineCallDescriptor(key12) : defineRedirectDescriptor(key12));
      }
    }
    return CustomEvent;
  }
  function getWrapper(proto2) {
    if (proto2 == null || proto2 === Object.prototype) {
      return Event;
    }
    let wrapper = wrappers.get(proto2);
    if (wrapper == null) {
      wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto2)), proto2);
      wrappers.set(proto2, wrapper);
    }
    return wrapper;
  }
  function wrapEvent(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event);
  }
  function isStopped(event) {
    return pd(event).immediateStopped;
  }
  function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
  }
  function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
  }
  function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
  }
  var listenersMap = new WeakMap;
  var CAPTURE = 1;
  var BUBBLE = 2;
  var ATTRIBUTE = 3;
  function isObject(x) {
    return x !== null && typeof x === "object";
  }
  function getListeners(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
      throw new TypeError("'this' is expected an EventTarget object, but got another value.");
    }
    return listeners;
  }
  function defineEventAttributeDescriptor(eventName) {
    return {
      get() {
        const listeners = getListeners(this);
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE) {
            return node.listener;
          }
          node = node.next;
        }
        return null;
      },
      set(listener) {
        if (typeof listener !== "function" && !isObject(listener)) {
          listener = null;
        }
        const listeners = getListeners(this);
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          node = node.next;
        }
        if (listener !== null) {
          const newNode = {
            listener,
            listenerType: ATTRIBUTE,
            passive: false,
            once: false,
            next: null
          };
          if (prev === null) {
            listeners.set(eventName, newNode);
          } else {
            prev.next = newNode;
          }
        }
      },
      configurable: true,
      enumerable: true
    };
  }
  function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
  }
  function defineCustomEventTarget(eventNames) {
    function CustomEventTarget() {
      EventTarget.call(this);
    }
    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
      constructor: {
        value: CustomEventTarget,
        configurable: true,
        writable: true
      }
    });
    for (let i = 0;i < eventNames.length; ++i) {
      defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    }
    return CustomEventTarget;
  }
  function EventTarget() {
    if (this instanceof EventTarget) {
      listenersMap.set(this, new Map);
      return;
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
      return defineCustomEventTarget(arguments[0]);
    }
    if (arguments.length > 0) {
      const types = new Array(arguments.length);
      for (let i = 0;i < arguments.length; ++i) {
        types[i] = arguments[i];
      }
      return defineCustomEventTarget(types);
    }
    throw new TypeError("Cannot call a class as a function");
  }
  EventTarget.prototype = {
    addEventListener(eventName, listener, options) {
      if (listener == null) {
        return;
      }
      if (typeof listener !== "function" && !isObject(listener)) {
        throw new TypeError("'listener' should be a function or an object.");
      }
      const listeners = getListeners(this);
      const optionsIsObj = isObject(options);
      const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
      const listenerType = capture ? CAPTURE : BUBBLE;
      const newNode = {
        listener,
        listenerType,
        passive: optionsIsObj && Boolean(options.passive),
        once: optionsIsObj && Boolean(options.once),
        next: null
      };
      let node = listeners.get(eventName);
      if (node === undefined) {
        listeners.set(eventName, newNode);
        return;
      }
      let prev = null;
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          return;
        }
        prev = node;
        node = node.next;
      }
      prev.next = newNode;
    },
    removeEventListener(eventName, listener, options) {
      if (listener == null) {
        return;
      }
      const listeners = getListeners(this);
      const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
      const listenerType = capture ? CAPTURE : BUBBLE;
      let prev = null;
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
          return;
        }
        prev = node;
        node = node.next;
      }
    },
    dispatchEvent(event) {
      if (event == null || typeof event.type !== "string") {
        throw new TypeError('"event.type" should be a string.');
      }
      const listeners = getListeners(this);
      const eventName = event.type;
      let node = listeners.get(eventName);
      if (node == null) {
        return true;
      }
      const wrappedEvent = wrapEvent(this, event);
      let prev = null;
      while (node != null) {
        if (node.once) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
        } else {
          prev = node;
        }
        setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
        if (typeof node.listener === "function") {
          try {
            node.listener.call(this, wrappedEvent);
          } catch (err) {
            if (typeof console !== "undefined" && typeof console.error === "function") {
              console.error(err);
            }
          }
        } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
          node.listener.handleEvent(wrappedEvent);
        }
        if (isStopped(wrappedEvent)) {
          break;
        }
        node = node.next;
      }
      setPassiveListener(wrappedEvent, null);
      setEventPhase(wrappedEvent, 0);
      setCurrentTarget(wrappedEvent, null);
      return !wrappedEvent.defaultPrevented;
    }
  };
  Object.defineProperty(EventTarget.prototype, "constructor", {
    value: EventTarget,
    configurable: true,
    writable: true
  });
  if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
  }
  exports.defineEventAttribute = defineEventAttribute;
  exports.EventTarget = EventTarget;
  exports.default = EventTarget;
  module.exports = EventTarget;
  module.exports.EventTarget = module.exports["default"] = EventTarget;
  module.exports.defineEventAttribute = defineEventAttribute;
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var eventTargetShim = require_event_target_shim();

  class AbortSignal extends eventTargetShim.EventTarget {
    constructor() {
      super();
      throw new TypeError("AbortSignal cannot be constructed directly");
    }
    get aborted() {
      const aborted = abortedFlags.get(this);
      if (typeof aborted !== "boolean") {
        throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
      }
      return aborted;
    }
  }
  eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
  function createAbortSignal() {
    const signal = Object.create(AbortSignal.prototype);
    eventTargetShim.EventTarget.call(signal);
    abortedFlags.set(signal, false);
    return signal;
  }
  function abortSignal(signal) {
    if (abortedFlags.get(signal) !== false) {
      return;
    }
    abortedFlags.set(signal, true);
    signal.dispatchEvent({ type: "abort" });
  }
  var abortedFlags = new WeakMap;
  Object.defineProperties(AbortSignal.prototype, {
    aborted: { enumerable: true }
  });
  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
      configurable: true,
      value: "AbortSignal"
    });
  }

  class AbortController2 {
    constructor() {
      signals2.set(this, createAbortSignal());
    }
    get signal() {
      return getSignal(this);
    }
    abort() {
      abortSignal(getSignal(this));
    }
  }
  var signals2 = new WeakMap;
  function getSignal(controller) {
    const signal = signals2.get(controller);
    if (signal == null) {
      throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
    }
    return signal;
  }
  Object.defineProperties(AbortController2.prototype, {
    signal: { enumerable: true },
    abort: { enumerable: true }
  });
  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
      configurable: true,
      value: "AbortController"
    });
  }
  exports.AbortController = AbortController2;
  exports.AbortSignal = AbortSignal;
  exports.default = AbortController2;
  module.exports = AbortController2;
  module.exports.AbortController = module.exports["default"] = AbortController2;
  module.exports.AbortSignal = AbortSignal;
});

// node_modules/readable-stream/lib/ours/util.js
var require_util2 = __commonJS((exports, module) => {
  var bufferModule = __require("buffer");
  var { format, inspect } = require_inspect();
  var {
    codes: { ERR_INVALID_ARG_TYPE }
  } = require_errors();
  var { kResistStopPropagation, AggregateError, SymbolDispose } = require_primordials();
  var AbortSignal = globalThis.AbortSignal || require_abort_controller().AbortSignal;
  var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
  var AsyncFunction = Object.getPrototypeOf(async function() {
  }).constructor;
  var Blob = globalThis.Blob || bufferModule.Blob;
  var isBlob = typeof Blob !== "undefined" ? function isBlob(b) {
    return b instanceof Blob;
  } : function isBlob(b) {
    return false;
  };
  var validateAbortSignal = (signal, name) => {
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
      throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
  };
  var validateFunction = (value, name) => {
    if (typeof value !== "function") {
      throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
  };
  module.exports = {
    AggregateError,
    kEmptyObject: Object.freeze({}),
    once(callback) {
      let called = false;
      return function(...args) {
        if (called) {
          return;
        }
        called = true;
        callback.apply(this, args);
      };
    },
    createDeferredPromise: function() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return {
        promise,
        resolve,
        reject
      };
    },
    promisify(fn) {
      return new Promise((resolve, reject) => {
        fn((err, ...args) => {
          if (err) {
            return reject(err);
          }
          return resolve(...args);
        });
      });
    },
    debuglog() {
      return function() {
      };
    },
    format,
    inspect,
    types: {
      isAsyncFunction(fn) {
        return fn instanceof AsyncFunction;
      },
      isArrayBufferView(arr) {
        return ArrayBuffer.isView(arr);
      }
    },
    isBlob,
    deprecate(fn, message) {
      return fn;
    },
    addAbortListener: __require("events").addAbortListener || function addAbortListener(signal, listener) {
      if (signal === undefined) {
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
      }
      validateAbortSignal(signal, "signal");
      validateFunction(listener, "listener");
      let removeEventListener;
      if (signal.aborted) {
        queueMicrotask(() => listener());
      } else {
        signal.addEventListener("abort", listener, {
          __proto__: null,
          once: true,
          [kResistStopPropagation]: true
        });
        removeEventListener = () => {
          signal.removeEventListener("abort", listener);
        };
      }
      return {
        __proto__: null,
        [SymbolDispose]() {
          var _removeEventListener;
          (_removeEventListener = removeEventListener) === null || _removeEventListener === undefined || _removeEventListener();
        }
      };
    },
    AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals2) {
      if (signals2.length === 1) {
        return signals2[0];
      }
      const ac = new AbortController2;
      const abort = () => ac.abort();
      signals2.forEach((signal) => {
        validateAbortSignal(signal, "signals");
        signal.addEventListener("abort", abort, {
          once: true
        });
      });
      ac.signal.addEventListener("abort", () => {
        signals2.forEach((signal) => signal.removeEventListener("abort", abort));
      }, {
        once: true
      });
      return ac.signal;
    }
  };
  module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
});

// node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS((exports, module) => {
  var {
    ArrayIsArray,
    ArrayPrototypeIncludes,
    ArrayPrototypeJoin,
    ArrayPrototypeMap,
    NumberIsInteger,
    NumberIsNaN,
    NumberMAX_SAFE_INTEGER,
    NumberMIN_SAFE_INTEGER,
    NumberParseInt,
    ObjectPrototypeHasOwnProperty,
    RegExpPrototypeExec,
    String: String2,
    StringPrototypeToUpperCase,
    StringPrototypeTrim
  } = require_primordials();
  var {
    hideStackFrames,
    codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
  } = require_errors();
  var { normalizeEncoding } = require_util2();
  var { isAsyncFunction, isArrayBufferView } = require_util2().types;
  var signals2 = {};
  function isInt32(value) {
    return value === (value | 0);
  }
  function isUint32(value) {
    return value === value >>> 0;
  }
  var octalReg = /^[0-7]+$/;
  var modeDesc = "must be a 32-bit unsigned integer or an octal string";
  function parseFileMode(value, name, def) {
    if (typeof value === "undefined") {
      value = def;
    }
    if (typeof value === "string") {
      if (RegExpPrototypeExec(octalReg, value) === null) {
        throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
      }
      value = NumberParseInt(value, 8);
    }
    validateUint32(value, name);
    return value;
  }
  var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
    if (typeof value !== "number")
      throw new ERR_INVALID_ARG_TYPE(name, "number", value);
    if (!NumberIsInteger(value))
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    if (value < min || value > max)
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
  });
  var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
    if (typeof value !== "number") {
      throw new ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!NumberIsInteger(value)) {
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
  });
  var validateUint32 = hideStackFrames((value, name, positive = false) => {
    if (typeof value !== "number") {
      throw new ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!NumberIsInteger(value)) {
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min = positive ? 1 : 0;
    const max = 4294967295;
    if (value < min || value > max) {
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
  });
  function validateString(value, name) {
    if (typeof value !== "string")
      throw new ERR_INVALID_ARG_TYPE(name, "string", value);
  }
  function validateNumber2(value, name, min = undefined, max) {
    if (typeof value !== "number")
      throw new ERR_INVALID_ARG_TYPE(name, "number", value);
    if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
      throw new ERR_OUT_OF_RANGE(name, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value);
    }
  }
  var validateOneOf = hideStackFrames((value, name, oneOf) => {
    if (!ArrayPrototypeIncludes(oneOf, value)) {
      const allowed = ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)), ", ");
      const reason = "must be one of: " + allowed;
      throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
  });
  function validateBoolean(value, name) {
    if (typeof value !== "boolean")
      throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
  }
  function getOwnPropertyValueOrDefault(options, key12, defaultValue) {
    return options == null || !ObjectPrototypeHasOwnProperty(options, key12) ? defaultValue : options[key12];
  }
  var validateObject = hideStackFrames((value, name, options = null) => {
    const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
    const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
    const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
    if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
      throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
  });
  var validateDictionary = hideStackFrames((value, name) => {
    if (value != null && typeof value !== "object" && typeof value !== "function") {
      throw new ERR_INVALID_ARG_TYPE(name, "a dictionary", value);
    }
  });
  var validateArray = hideStackFrames((value, name, minLength = 0) => {
    if (!ArrayIsArray(value)) {
      throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
      const reason = `must be longer than ${minLength}`;
      throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
  });
  function validateStringArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++) {
      validateString(value[i], `${name}[${i}]`);
    }
  }
  function validateBooleanArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++) {
      validateBoolean(value[i], `${name}[${i}]`);
    }
  }
  function validateAbortSignalArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++) {
      const signal = value[i];
      const indexedName = `${name}[${i}]`;
      if (signal == null) {
        throw new ERR_INVALID_ARG_TYPE(indexedName, "AbortSignal", signal);
      }
      validateAbortSignal(signal, indexedName);
    }
  }
  function validateSignalName(signal, name = "signal") {
    validateString(signal, name);
    if (signals2[signal] === undefined) {
      if (signals2[StringPrototypeToUpperCase(signal)] !== undefined) {
        throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
      }
      throw new ERR_UNKNOWN_SIGNAL(signal);
    }
  }
  var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
    if (!isArrayBufferView(buffer)) {
      throw new ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
    }
  });
  function validateEncoding(data, encoding) {
    const normalizedEncoding = normalizeEncoding(encoding);
    const length = data.length;
    if (normalizedEncoding === "hex" && length % 2 !== 0) {
      throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
  }
  function validatePort(port, name = "Port", allowZero = true) {
    if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
      throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
    }
    return port | 0;
  }
  var validateAbortSignal = hideStackFrames((signal, name) => {
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
      throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
  });
  var validateFunction = hideStackFrames((value, name) => {
    if (typeof value !== "function")
      throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
  });
  var validatePlainFunction = hideStackFrames((value, name) => {
    if (typeof value !== "function" || isAsyncFunction(value))
      throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
  });
  var validateUndefined = hideStackFrames((value, name) => {
    if (value !== undefined)
      throw new ERR_INVALID_ARG_TYPE(name, "undefined", value);
  });
  function validateUnion(value, name, union) {
    if (!ArrayPrototypeIncludes(union, value)) {
      throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
    }
  }
  var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
  function validateLinkHeaderFormat(value, name) {
    if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
      throw new ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
  }
  function validateLinkHeaderValue(hints) {
    if (typeof hints === "string") {
      validateLinkHeaderFormat(hints, "hints");
      return hints;
    } else if (ArrayIsArray(hints)) {
      const hintsLength = hints.length;
      let result = "";
      if (hintsLength === 0) {
        return result;
      }
      for (let i = 0;i < hintsLength; i++) {
        const link = hints[i];
        validateLinkHeaderFormat(link, "hints");
        result += link;
        if (i !== hintsLength - 1) {
          result += ", ";
        }
      }
      return result;
    }
    throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
  }
  module.exports = {
    isInt32,
    isUint32,
    parseFileMode,
    validateArray,
    validateStringArray,
    validateBooleanArray,
    validateAbortSignalArray,
    validateBoolean,
    validateBuffer,
    validateDictionary,
    validateEncoding,
    validateFunction,
    validateInt32,
    validateInteger,
    validateNumber: validateNumber2,
    validateObject,
    validateOneOf,
    validatePlainFunction,
    validatePort,
    validateSignalName,
    validateString,
    validateUint32,
    validateUndefined,
    validateUnion,
    validateAbortSignal,
    validateLinkHeaderValue
  };
});

// node_modules/process/index.js
var require_process = __commonJS((exports, module) => {
  module.exports = global.process;
});

// node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils3 = __commonJS((exports, module) => {
  var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
  var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
  var kIsErrored = SymbolFor("nodejs.stream.errored");
  var kIsReadable = SymbolFor("nodejs.stream.readable");
  var kIsWritable = SymbolFor("nodejs.stream.writable");
  var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
  var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
  var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
  function isReadableNodeStream(obj, strict = false) {
    var _obj$_readableState;
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined ? undefined : _obj$_readableState.readable) !== false) && (!obj._writableState || obj._readableState));
  }
  function isWritableNodeStream(obj) {
    var _obj$_writableState;
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined ? undefined : _obj$_writableState.writable) !== false));
  }
  function isDuplexNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
  }
  function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
  }
  function isReadableStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
  }
  function isWritableStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
  }
  function isTransformStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
  }
  function isWebStream(obj) {
    return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
  }
  function isIterable(obj, isAsync) {
    if (obj == null)
      return false;
    if (isAsync === true)
      return typeof obj[SymbolAsyncIterator] === "function";
    if (isAsync === false)
      return typeof obj[SymbolIterator] === "function";
    return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
  }
  function isDestroyed(stream) {
    if (!isNodeStream(stream))
      return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== undefined && state.destroyed);
  }
  function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream))
      return null;
    if (stream.writableEnded === true)
      return true;
    const wState = stream._writableState;
    if (wState !== null && wState !== undefined && wState.errored)
      return false;
    if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== "boolean")
      return null;
    return wState.ended;
  }
  function isWritableFinished(stream, strict) {
    if (!isWritableNodeStream(stream))
      return null;
    if (stream.writableFinished === true)
      return true;
    const wState = stream._writableState;
    if (wState !== null && wState !== undefined && wState.errored)
      return false;
    if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== "boolean")
      return null;
    return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
  }
  function isReadableEnded(stream) {
    if (!isReadableNodeStream(stream))
      return null;
    if (stream.readableEnded === true)
      return true;
    const rState = stream._readableState;
    if (!rState || rState.errored)
      return false;
    if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== "boolean")
      return null;
    return rState.ended;
  }
  function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream))
      return null;
    const rState = stream._readableState;
    if (rState !== null && rState !== undefined && rState.errored)
      return false;
    if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== "boolean")
      return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
  }
  function isReadable(stream) {
    if (stream && stream[kIsReadable] != null)
      return stream[kIsReadable];
    if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== "boolean")
      return null;
    if (isDestroyed(stream))
      return false;
    return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
  }
  function isWritable(stream) {
    if (stream && stream[kIsWritable] != null)
      return stream[kIsWritable];
    if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== "boolean")
      return null;
    if (isDestroyed(stream))
      return false;
    return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
  }
  function isFinished(stream, opts) {
    if (!isNodeStream(stream)) {
      return null;
    }
    if (isDestroyed(stream)) {
      return true;
    }
    if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {
      return false;
    }
    if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {
      return false;
    }
    return true;
  }
  function isWritableErrored(stream) {
    var _stream$_writableStat, _stream$_writableStat2;
    if (!isNodeStream(stream)) {
      return null;
    }
    if (stream.writableErrored) {
      return stream.writableErrored;
    }
    return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined ? undefined : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined ? _stream$_writableStat : null;
  }
  function isReadableErrored(stream) {
    var _stream$_readableStat, _stream$_readableStat2;
    if (!isNodeStream(stream)) {
      return null;
    }
    if (stream.readableErrored) {
      return stream.readableErrored;
    }
    return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined ? undefined : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined ? _stream$_readableStat : null;
  }
  function isClosed(stream) {
    if (!isNodeStream(stream)) {
      return null;
    }
    if (typeof stream.closed === "boolean") {
      return stream.closed;
    }
    const wState = stream._writableState;
    const rState = stream._readableState;
    if (typeof (wState === null || wState === undefined ? undefined : wState.closed) === "boolean" || typeof (rState === null || rState === undefined ? undefined : rState.closed) === "boolean") {
      return (wState === null || wState === undefined ? undefined : wState.closed) || (rState === null || rState === undefined ? undefined : rState.closed);
    }
    if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
      return stream._closed;
    }
    return null;
  }
  function isOutgoingMessage(stream) {
    return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
  }
  function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
  }
  function isServerRequest(stream) {
    var _stream$req;
    return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) === undefined;
  }
  function willEmitClose(stream) {
    if (!isNodeStream(stream))
      return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
  }
  function isDisturbed(stream) {
    var _stream$kIsDisturbed;
    return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
  }
  function isErrored(stream) {
    var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
    return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== undefined ? _ref5 : stream.writableErrored) !== null && _ref4 !== undefined ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined ? undefined : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined ? undefined : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined ? undefined : _stream$_readableStat4.errored) !== null && _ref !== undefined ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined ? undefined : _stream$_writableStat4.errored));
  }
  module.exports = {
    isDestroyed,
    kIsDestroyed,
    isDisturbed,
    kIsDisturbed,
    isErrored,
    kIsErrored,
    isReadable,
    kIsReadable,
    kIsClosedPromise,
    kControllerErrorFunction,
    kIsWritable,
    isClosed,
    isDuplexNodeStream,
    isFinished,
    isIterable,
    isReadableNodeStream,
    isReadableStream,
    isReadableEnded,
    isReadableFinished,
    isReadableErrored,
    isNodeStream,
    isWebStream,
    isWritable,
    isWritableNodeStream,
    isWritableStream,
    isWritableEnded,
    isWritableFinished,
    isWritableErrored,
    isServerRequest,
    isServerResponse,
    willEmitClose,
    isTransformStream
  };
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports, module) => {
  var process20 = require_process();
  var { AbortError, codes } = require_errors();
  var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
  var { kEmptyObject, once } = require_util2();
  var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
  var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
  var {
    isClosed,
    isReadable,
    isReadableNodeStream,
    isReadableStream,
    isReadableFinished,
    isReadableErrored,
    isWritable,
    isWritableNodeStream,
    isWritableStream,
    isWritableFinished,
    isWritableErrored,
    isNodeStream,
    willEmitClose: _willEmitClose,
    kIsClosedPromise
  } = require_utils3();
  var addAbortListener;
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  var nop = () => {
  };
  function eos(stream, options, callback) {
    var _options$readable, _options$writable;
    if (arguments.length === 2) {
      callback = options;
      options = kEmptyObject;
    } else if (options == null) {
      options = kEmptyObject;
    } else {
      validateObject(options, "options");
    }
    validateFunction(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once(callback);
    if (isReadableStream(stream) || isWritableStream(stream)) {
      return eosWeb(stream, options, callback);
    }
    if (!isNodeStream(stream)) {
      throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
    }
    const readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream);
    const writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const onlegacyfinish = () => {
      if (!stream.writable) {
        onfinish();
      }
    };
    let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
    let writableFinished = isWritableFinished(stream, false);
    const onfinish = () => {
      writableFinished = true;
      if (stream.destroyed) {
        willEmitClose = false;
      }
      if (willEmitClose && (!stream.readable || readable)) {
        return;
      }
      if (!readable || readableFinished) {
        callback.call(stream);
      }
    };
    let readableFinished = isReadableFinished(stream, false);
    const onend = () => {
      readableFinished = true;
      if (stream.destroyed) {
        willEmitClose = false;
      }
      if (willEmitClose && (!stream.writable || writable)) {
        return;
      }
      if (!writable || writableFinished) {
        callback.call(stream);
      }
    };
    const onerror = (err) => {
      callback.call(stream, err);
    };
    let closed = isClosed(stream);
    const onclose = () => {
      closed = true;
      const errored = isWritableErrored(stream) || isReadableErrored(stream);
      if (errored && typeof errored !== "boolean") {
        return callback.call(stream, errored);
      }
      if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
        if (!isReadableFinished(stream, false))
          return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
      }
      if (writable && !writableFinished) {
        if (!isWritableFinished(stream, false))
          return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
      }
      callback.call(stream);
    };
    const onclosed = () => {
      closed = true;
      const errored = isWritableErrored(stream) || isReadableErrored(stream);
      if (errored && typeof errored !== "boolean") {
        return callback.call(stream, errored);
      }
      callback.call(stream);
    };
    const onrequest = () => {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      if (!willEmitClose) {
        stream.on("abort", onclose);
      }
      if (stream.req) {
        onrequest();
      } else {
        stream.on("request", onrequest);
      }
    } else if (writable && !wState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
      stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) {
      stream.on("error", onerror);
    }
    stream.on("close", onclose);
    if (closed) {
      process20.nextTick(onclose);
    } else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {
      if (!willEmitClose) {
        process20.nextTick(onclosed);
      }
    } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
      process20.nextTick(onclosed);
    } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
      process20.nextTick(onclosed);
    } else if (rState && stream.req && stream.aborted) {
      process20.nextTick(onclosed);
    }
    const cleanup = () => {
      callback = nop;
      stream.removeListener("aborted", onclose);
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
      const abort = () => {
        const endCallback = callback;
        cleanup();
        endCallback.call(stream, new AbortError(undefined, {
          cause: options.signal.reason
        }));
      };
      if (options.signal.aborted) {
        process20.nextTick(abort);
      } else {
        addAbortListener = addAbortListener || require_util2().addAbortListener;
        const disposable = addAbortListener(options.signal, abort);
        const originalCallback = callback;
        callback = once((...args) => {
          disposable[SymbolDispose]();
          originalCallback.apply(stream, args);
        });
      }
    }
    return cleanup;
  }
  function eosWeb(stream, options, callback) {
    let isAborted = false;
    let abort = nop;
    if (options.signal) {
      abort = () => {
        isAborted = true;
        callback.call(stream, new AbortError(undefined, {
          cause: options.signal.reason
        }));
      };
      if (options.signal.aborted) {
        process20.nextTick(abort);
      } else {
        addAbortListener = addAbortListener || require_util2().addAbortListener;
        const disposable = addAbortListener(options.signal, abort);
        const originalCallback = callback;
        callback = once((...args) => {
          disposable[SymbolDispose]();
          originalCallback.apply(stream, args);
        });
      }
    }
    const resolverFn = (...args) => {
      if (!isAborted) {
        process20.nextTick(() => callback.apply(stream, args));
      }
    };
    PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
    return nop;
  }
  function finished(stream, opts) {
    var _opts;
    let autoCleanup = false;
    if (opts === null) {
      opts = kEmptyObject;
    }
    if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {
      validateBoolean(opts.cleanup, "cleanup");
      autoCleanup = opts.cleanup;
    }
    return new Promise2((resolve, reject) => {
      const cleanup = eos(stream, opts, (err) => {
        if (autoCleanup) {
          cleanup();
        }
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  module.exports = eos;
  module.exports.finished = finished;
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS((exports, module) => {
  var process20 = require_process();
  var {
    aggregateTwoErrors,
    codes: { ERR_MULTIPLE_CALLBACK },
    AbortError
  } = require_errors();
  var { Symbol: Symbol2 } = require_primordials();
  var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils3();
  var kDestroy = Symbol2("kDestroy");
  var kConstruct = Symbol2("kConstruct");
  function checkError(err, w, r) {
    if (err) {
      err.stack;
      if (w && !w.errored) {
        w.errored = err;
      }
      if (r && !r.errored) {
        r.errored = err;
      }
    }
  }
  function destroy(err, cb) {
    const r = this._readableState;
    const w = this._writableState;
    const s = w || r;
    if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed) {
      if (typeof cb === "function") {
        cb();
      }
      return this;
    }
    checkError(err, w, r);
    if (w) {
      w.destroyed = true;
    }
    if (r) {
      r.destroyed = true;
    }
    if (!s.constructed) {
      this.once(kDestroy, function(er) {
        _destroy(this, aggregateTwoErrors(er, err), cb);
      });
    } else {
      _destroy(this, err, cb);
    }
    return this;
  }
  function _destroy(self2, err, cb) {
    let called = false;
    function onDestroy(err2) {
      if (called) {
        return;
      }
      called = true;
      const r = self2._readableState;
      const w = self2._writableState;
      checkError(err2, w, r);
      if (w) {
        w.closed = true;
      }
      if (r) {
        r.closed = true;
      }
      if (typeof cb === "function") {
        cb(err2);
      }
      if (err2) {
        process20.nextTick(emitErrorCloseNT, self2, err2);
      } else {
        process20.nextTick(emitCloseNT, self2);
      }
    }
    try {
      self2._destroy(err || null, onDestroy);
    } catch (err2) {
      onDestroy(err2);
    }
  }
  function emitErrorCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    const r = self2._readableState;
    const w = self2._writableState;
    if (w) {
      w.closeEmitted = true;
    }
    if (r) {
      r.closeEmitted = true;
    }
    if (w !== null && w !== undefined && w.emitClose || r !== null && r !== undefined && r.emitClose) {
      self2.emit("close");
    }
  }
  function emitErrorNT(self2, err) {
    const r = self2._readableState;
    const w = self2._writableState;
    if (w !== null && w !== undefined && w.errorEmitted || r !== null && r !== undefined && r.errorEmitted) {
      return;
    }
    if (w) {
      w.errorEmitted = true;
    }
    if (r) {
      r.errorEmitted = true;
    }
    self2.emit("error", err);
  }
  function undestroy() {
    const r = this._readableState;
    const w = this._writableState;
    if (r) {
      r.constructed = true;
      r.closed = false;
      r.closeEmitted = false;
      r.destroyed = false;
      r.errored = null;
      r.errorEmitted = false;
      r.reading = false;
      r.ended = r.readable === false;
      r.endEmitted = r.readable === false;
    }
    if (w) {
      w.constructed = true;
      w.destroyed = false;
      w.closed = false;
      w.closeEmitted = false;
      w.errored = null;
      w.errorEmitted = false;
      w.finalCalled = false;
      w.prefinished = false;
      w.ended = w.writable === false;
      w.ending = w.writable === false;
      w.finished = w.writable === false;
    }
  }
  function errorOrDestroy(stream, err, sync) {
    const r = stream._readableState;
    const w = stream._writableState;
    if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed) {
      return this;
    }
    if (r !== null && r !== undefined && r.autoDestroy || w !== null && w !== undefined && w.autoDestroy)
      stream.destroy(err);
    else if (err) {
      err.stack;
      if (w && !w.errored) {
        w.errored = err;
      }
      if (r && !r.errored) {
        r.errored = err;
      }
      if (sync) {
        process20.nextTick(emitErrorNT, stream, err);
      } else {
        emitErrorNT(stream, err);
      }
    }
  }
  function construct(stream, cb) {
    if (typeof stream._construct !== "function") {
      return;
    }
    const r = stream._readableState;
    const w = stream._writableState;
    if (r) {
      r.constructed = false;
    }
    if (w) {
      w.constructed = false;
    }
    stream.once(kConstruct, cb);
    if (stream.listenerCount(kConstruct) > 1) {
      return;
    }
    process20.nextTick(constructNT, stream);
  }
  function constructNT(stream) {
    let called = false;
    function onConstruct(err) {
      if (called) {
        errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK);
        return;
      }
      called = true;
      const r = stream._readableState;
      const w = stream._writableState;
      const s = w || r;
      if (r) {
        r.constructed = true;
      }
      if (w) {
        w.constructed = true;
      }
      if (s.destroyed) {
        stream.emit(kDestroy, err);
      } else if (err) {
        errorOrDestroy(stream, err, true);
      } else {
        process20.nextTick(emitConstructNT, stream);
      }
    }
    try {
      stream._construct((err) => {
        process20.nextTick(onConstruct, err);
      });
    } catch (err) {
      process20.nextTick(onConstruct, err);
    }
  }
  function emitConstructNT(stream) {
    stream.emit(kConstruct);
  }
  function isRequest(stream) {
    return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === "function";
  }
  function emitCloseLegacy(stream) {
    stream.emit("close");
  }
  function emitErrorCloseLegacy(stream, err) {
    stream.emit("error", err);
    process20.nextTick(emitCloseLegacy, stream);
  }
  function destroyer(stream, err) {
    if (!stream || isDestroyed(stream)) {
      return;
    }
    if (!err && !isFinished(stream)) {
      err = new AbortError;
    }
    if (isServerRequest(stream)) {
      stream.socket = null;
      stream.destroy(err);
    } else if (isRequest(stream)) {
      stream.abort();
    } else if (isRequest(stream.req)) {
      stream.req.abort();
    } else if (typeof stream.destroy === "function") {
      stream.destroy(err);
    } else if (typeof stream.close === "function") {
      stream.close();
    } else if (err) {
      process20.nextTick(emitErrorCloseLegacy, stream, err);
    } else {
      process20.nextTick(emitCloseLegacy, stream);
    }
    if (!stream.destroyed) {
      stream[kIsDestroyed] = true;
    }
  }
  module.exports = {
    construct,
    destroyer,
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS((exports, module) => {
  var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
  var { EventEmitter: EE } = __require("events");
  function Stream(opts) {
    EE.call(this, opts);
  }
  ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
  ObjectSetPrototypeOf(Stream, EE);
  Stream.prototype.pipe = function(dest, options) {
    const source = this;
    function ondata(chunk) {
      if (dest.writable && dest.write(chunk) === false && source.pause) {
        source.pause();
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    let didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === "function")
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        this.emit("error", er);
      }
    }
    prependListener(source, "error", onerror);
    prependListener(dest, "error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (ArrayIsArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  module.exports = {
    Stream,
    prependListener
  };
});

// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS((exports, module) => {
  var { SymbolDispose } = require_primordials();
  var { AbortError, codes } = require_errors();
  var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils3();
  var eos = require_end_of_stream();
  var { ERR_INVALID_ARG_TYPE } = codes;
  var addAbortListener;
  var validateAbortSignal = (signal, name) => {
    if (typeof signal !== "object" || !("aborted" in signal)) {
      throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
  };
  exports.addAbortSignal = function addAbortSignal(signal, stream) {
    validateAbortSignal(signal, "signal");
    if (!isNodeStream(stream) && !isWebStream(stream)) {
      throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
    }
    return exports.addAbortSignalNoValidate(signal, stream);
  };
  exports.addAbortSignalNoValidate = function(signal, stream) {
    if (typeof signal !== "object" || !("aborted" in signal)) {
      return stream;
    }
    const onAbort = isNodeStream(stream) ? () => {
      stream.destroy(new AbortError(undefined, {
        cause: signal.reason
      }));
    } : () => {
      stream[kControllerErrorFunction](new AbortError(undefined, {
        cause: signal.reason
      }));
    };
    if (signal.aborted) {
      onAbort();
    } else {
      addAbortListener = addAbortListener || require_util2().addAbortListener;
      const disposable = addAbortListener(signal, onAbort);
      eos(stream, disposable[SymbolDispose]);
    }
    return stream;
  };
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports, module) => {
  var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
  var { Buffer: Buffer2 } = __require("buffer");
  var { inspect } = require_util2();
  module.exports = class BufferList {
    constructor() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    push(v) {
      const entry = {
        data: v,
        next: null
      };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    }
    unshift(v) {
      const entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    }
    shift() {
      if (this.length === 0)
        return;
      const ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    }
    clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
    join(s) {
      if (this.length === 0)
        return "";
      let p = this.head;
      let ret = "" + p.data;
      while ((p = p.next) !== null)
        ret += s + p.data;
      return ret;
    }
    concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      const ret = Buffer2.allocUnsafe(n >>> 0);
      let p = this.head;
      let i = 0;
      while (p) {
        TypedArrayPrototypeSet(ret, p.data, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }
    consume(n, hasStrings) {
      const data = this.head.data;
      if (n < data.length) {
        const slice = data.slice(0, n);
        this.head.data = data.slice(n);
        return slice;
      }
      if (n === data.length) {
        return this.shift();
      }
      return hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    first() {
      return this.head.data;
    }
    *[SymbolIterator]() {
      for (let p = this.head;p; p = p.next) {
        yield p.data;
      }
    }
    _getString(n) {
      let ret = "";
      let p = this.head;
      let c = 0;
      do {
        const str = p.data;
        if (n > str.length) {
          ret += str;
          n -= str.length;
        } else {
          if (n === str.length) {
            ret += str;
            ++c;
            if (p.next)
              this.head = p.next;
            else
              this.head = this.tail = null;
          } else {
            ret += StringPrototypeSlice(str, 0, n);
            this.head = p;
            p.data = StringPrototypeSlice(str, n);
          }
          break;
        }
        ++c;
      } while ((p = p.next) !== null);
      this.length -= c;
      return ret;
    }
    _getBuffer(n) {
      const ret = Buffer2.allocUnsafe(n);
      const retLen = n;
      let p = this.head;
      let c = 0;
      do {
        const buf = p.data;
        if (n > buf.length) {
          TypedArrayPrototypeSet(ret, buf, retLen - n);
          n -= buf.length;
        } else {
          if (n === buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            ++c;
            if (p.next)
              this.head = p.next;
            else
              this.head = this.tail = null;
          } else {
            TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
            this.head = p;
            p.data = buf.slice(n);
          }
          break;
        }
        ++c;
      } while ((p = p.next) !== null);
      this.length -= c;
      return ret;
    }
    [Symbol.for("nodejs.util.inspect.custom")](_3, options) {
      return inspect(this, {
        ...options,
        depth: 0,
        customInspect: false
      });
    }
  };
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS((exports, module) => {
  var { MathFloor, NumberIsInteger } = require_primordials();
  var { validateInteger } = require_validators();
  var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
  var defaultHighWaterMarkBytes = 16 * 1024;
  var defaultHighWaterMarkObjectMode = 16;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getDefaultHighWaterMark(objectMode) {
    return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
  }
  function setDefaultHighWaterMark(objectMode, value) {
    validateInteger(value, "value", 0);
    if (objectMode) {
      defaultHighWaterMarkObjectMode = value;
    } else {
      defaultHighWaterMarkBytes = value;
    }
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!NumberIsInteger(hwm) || hwm < 0) {
        const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
        throw new ERR_INVALID_ARG_VALUE(name, hwm);
      }
      return MathFloor(hwm);
    }
    return getDefaultHighWaterMark(state.objectMode);
  }
  module.exports = {
    getHighWaterMark,
    getDefaultHighWaterMark,
    setDefaultHighWaterMark
  };
});

// node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key12 in src) {
      dst[key12] = src[key12];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder2 = __commonJS((exports) => {
  var Buffer2 = require_safe_buffer2().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from2 = __commonJS((exports, module) => {
  var process20 = require_process();
  var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
  var { Buffer: Buffer2 } = __require("buffer");
  var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;
  function from2(Readable, iterable, opts) {
    let iterator;
    if (typeof iterable === "string" || iterable instanceof Buffer2) {
      return new Readable({
        objectMode: true,
        ...opts,
        read() {
          this.push(iterable);
          this.push(null);
        }
      });
    }
    let isAsync;
    if (iterable && iterable[SymbolAsyncIterator]) {
      isAsync = true;
      iterator = iterable[SymbolAsyncIterator]();
    } else if (iterable && iterable[SymbolIterator]) {
      isAsync = false;
      iterator = iterable[SymbolIterator]();
    } else {
      throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    }
    const readable = new Readable({
      objectMode: true,
      highWaterMark: 1,
      ...opts
    });
    let reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    readable._destroy = function(error, cb) {
      PromisePrototypeThen(close(error), () => process20.nextTick(cb, error), (e) => process20.nextTick(cb, e || error));
    };
    async function close(error) {
      const hadError = error !== undefined && error !== null;
      const hasThrow = typeof iterator.throw === "function";
      if (hadError && hasThrow) {
        const { value, done } = await iterator.throw(error);
        await value;
        if (done) {
          return;
        }
      }
      if (typeof iterator.return === "function") {
        const { value } = await iterator.return();
        await value;
      }
    }
    async function next() {
      for (;; ) {
        try {
          const { value, done } = isAsync ? await iterator.next() : iterator.next();
          if (done) {
            readable.push(null);
          } else {
            const res = value && typeof value.then === "function" ? await value : value;
            if (res === null) {
              reading = false;
              throw new ERR_STREAM_NULL_VALUES;
            } else if (readable.push(res)) {
              continue;
            } else {
              reading = false;
            }
          }
        } catch (err) {
          readable.destroy(err);
        }
        break;
      }
    }
    return readable;
  }
  module.exports = from2;
});

// node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable2 = __commonJS((exports, module) => {
  var process20 = require_process();
  var {
    ArrayPrototypeIndexOf,
    NumberIsInteger,
    NumberIsNaN,
    NumberParseInt,
    ObjectDefineProperties,
    ObjectKeys,
    ObjectSetPrototypeOf,
    Promise: Promise2,
    SafeSet,
    SymbolAsyncDispose,
    SymbolAsyncIterator,
    Symbol: Symbol2
  } = require_primordials();
  module.exports = Readable;
  Readable.ReadableState = ReadableState;
  var { EventEmitter: EE } = __require("events");
  var { Stream, prependListener } = require_legacy();
  var { Buffer: Buffer2 } = __require("buffer");
  var { addAbortSignal } = require_add_abort_signal();
  var eos = require_end_of_stream();
  var debug = require_util2().debuglog("stream", (fn) => {
    debug = fn;
  });
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy2();
  var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
  var {
    aggregateTwoErrors,
    codes: {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_OUT_OF_RANGE,
      ERR_STREAM_PUSH_AFTER_EOF,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT
    },
    AbortError
  } = require_errors();
  var { validateObject } = require_validators();
  var kPaused = Symbol2("kPaused");
  var { StringDecoder } = require_string_decoder2();
  var from2 = require_from2();
  ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
  ObjectSetPrototypeOf(Readable, Stream);
  var nop = () => {
  };
  var { errorOrDestroy } = destroyImpl;
  var kObjectMode = 1 << 0;
  var kEnded = 1 << 1;
  var kEndEmitted = 1 << 2;
  var kReading = 1 << 3;
  var kConstructed = 1 << 4;
  var kSync = 1 << 5;
  var kNeedReadable = 1 << 6;
  var kEmittedReadable = 1 << 7;
  var kReadableListening = 1 << 8;
  var kResumeScheduled = 1 << 9;
  var kErrorEmitted = 1 << 10;
  var kEmitClose = 1 << 11;
  var kAutoDestroy = 1 << 12;
  var kDestroyed = 1 << 13;
  var kClosed = 1 << 14;
  var kCloseEmitted = 1 << 15;
  var kMultiAwaitDrain = 1 << 16;
  var kReadingMore = 1 << 17;
  var kDataEmitted = 1 << 18;
  function makeBitMapDescriptor(bit) {
    return {
      enumerable: false,
      get() {
        return (this.state & bit) !== 0;
      },
      set(value) {
        if (value)
          this.state |= bit;
        else
          this.state &= ~bit;
      }
    };
  }
  ObjectDefineProperties(ReadableState.prototype, {
    objectMode: makeBitMapDescriptor(kObjectMode),
    ended: makeBitMapDescriptor(kEnded),
    endEmitted: makeBitMapDescriptor(kEndEmitted),
    reading: makeBitMapDescriptor(kReading),
    constructed: makeBitMapDescriptor(kConstructed),
    sync: makeBitMapDescriptor(kSync),
    needReadable: makeBitMapDescriptor(kNeedReadable),
    emittedReadable: makeBitMapDescriptor(kEmittedReadable),
    readableListening: makeBitMapDescriptor(kReadableListening),
    resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
    errorEmitted: makeBitMapDescriptor(kErrorEmitted),
    emitClose: makeBitMapDescriptor(kEmitClose),
    autoDestroy: makeBitMapDescriptor(kAutoDestroy),
    destroyed: makeBitMapDescriptor(kDestroyed),
    closed: makeBitMapDescriptor(kClosed),
    closeEmitted: makeBitMapDescriptor(kCloseEmitted),
    multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
    readingMore: makeBitMapDescriptor(kReadingMore),
    dataEmitted: makeBitMapDescriptor(kDataEmitted)
  });
  function ReadableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof require_duplex();
    this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
    if (options && options.objectMode)
      this.state |= kObjectMode;
    if (isDuplex && options && options.readableObjectMode)
      this.state |= kObjectMode;
    this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this[kPaused] = null;
    if (options && options.emitClose === false)
      this.state &= ~kEmitClose;
    if (options && options.autoDestroy === false)
      this.state &= ~kAutoDestroy;
    this.errored = null;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.awaitDrainWriters = null;
    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    if (!(this instanceof Readable))
      return new Readable(options);
    const isDuplex = this instanceof require_duplex();
    this._readableState = new ReadableState(options, this, isDuplex);
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.construct === "function")
        this._construct = options.construct;
      if (options.signal && !isDuplex)
        addAbortSignal(options.signal, this);
    }
    Stream.call(this, options);
    destroyImpl.construct(this, () => {
      if (this._readableState.needReadable) {
        maybeReadMore(this, this._readableState);
      }
    });
  }
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype[EE.captureRejectionSymbol] = function(err) {
    this.destroy(err);
  };
  Readable.prototype[SymbolAsyncDispose] = function() {
    let error;
    if (!this.destroyed) {
      error = this.readableEnded ? null : new AbortError;
      this.destroy(error);
    }
    return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
  };
  Readable.prototype.push = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, false);
  };
  Readable.prototype.unshift = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, true);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront) {
    debug("readableAddChunk", chunk);
    const state = stream._readableState;
    let err;
    if ((state.state & kObjectMode) === 0) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (state.encoding !== encoding) {
          if (addToFront && state.encoding) {
            chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
          } else {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
        }
      } else if (chunk instanceof Buffer2) {
        encoding = "";
      } else if (Stream._isUint8Array(chunk)) {
        chunk = Stream._uint8ArrayToBuffer(chunk);
        encoding = "";
      } else if (chunk != null) {
        err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
    }
    if (err) {
      errorOrDestroy(stream, err);
    } else if (chunk === null) {
      state.state &= ~kReading;
      onEofChunk(stream, state);
    } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
      if (addToFront) {
        if ((state.state & kEndEmitted) !== 0)
          errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
        else if (state.destroyed || state.errored)
          return false;
        else
          addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
      } else if (state.destroyed || state.errored) {
        return false;
      } else {
        state.state &= ~kReading;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0)
            addChunk(stream, state, chunk, false);
          else
            maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.state &= ~kReading;
      maybeReadMore(stream, state);
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
      if ((state.state & kMultiAwaitDrain) !== 0) {
        state.awaitDrainWriters.clear();
      } else {
        state.awaitDrainWriters = null;
      }
      state.dataEmitted = true;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if ((state.state & kNeedReadable) !== 0)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  Readable.prototype.isPaused = function() {
    const state = this._readableState;
    return state[kPaused] === true || state.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    const decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    const buffer = this._readableState.buffer;
    let content = "";
    for (const data of buffer) {
      content += decoder.write(data);
    }
    buffer.clear();
    if (content !== "")
      buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n > MAX_HWM) {
      throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if ((state.state & kObjectMode) !== 0)
      return 1;
    if (NumberIsNaN(n)) {
      if (state.flowing && state.length)
        return state.buffer.first().length;
      return state.length;
    }
    if (n <= state.length)
      return n;
    return state.ended ? state.length : 0;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    if (n === undefined) {
      n = NaN;
    } else if (!NumberIsInteger(n)) {
      n = NumberParseInt(n, 10);
    }
    const state = this._readableState;
    const nOrig = n;
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n !== 0)
      state.state &= ~kEmittedReadable;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    let doRead = (state.state & kNeedReadable) !== 0;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
      doRead = false;
      debug("reading, ended or constructing", doRead);
    } else if (doRead) {
      debug("do read");
      state.state |= kReading | kSync;
      if (state.length === 0)
        state.state |= kNeedReadable;
      try {
        this._read(state.highWaterMark);
      } catch (err) {
        errorOrDestroy(this, err);
      }
      state.state &= ~kSync;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    let ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      if (state.multiAwaitDrain) {
        state.awaitDrainWriters.clear();
      } else {
        state.awaitDrainWriters = null;
      }
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
      state.dataEmitted = true;
      this.emit("data", ret);
    }
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      const chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
  function emitReadable(stream) {
    const state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process20.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    const state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && !state.errored && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore && state.constructed) {
      state.readingMore = true;
      process20.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      const len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    const src = this;
    const state = this._readableState;
    if (state.pipes.length === 1) {
      if (!state.multiAwaitDrain) {
        state.multiAwaitDrain = true;
        state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
      }
    }
    state.pipes.push(dest);
    debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process20.stdout && dest !== process20.stderr;
    const endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process20.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    let ondrain;
    let cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      if (ondrain) {
        dest.removeListener("drain", ondrain);
      }
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    function pause() {
      if (!cleanedUp) {
        if (state.pipes.length === 1 && state.pipes[0] === dest) {
          debug("false write response, pause", 0);
          state.awaitDrainWriters = dest;
          state.multiAwaitDrain = false;
        } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
          debug("false write response, pause", state.awaitDrainWriters.size);
          state.awaitDrainWriters.add(dest);
        }
        src.pause();
      }
      if (!ondrain) {
        ondrain = pipeOnDrain(src, dest);
        dest.on("drain", ondrain);
      }
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      const ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (dest.listenerCount("error") === 0) {
        const s = dest._writableState || dest._readableState;
        if (s && !s.errorEmitted) {
          errorOrDestroy(dest, er);
        } else {
          dest.emit("error", er);
        }
      }
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (dest.writableNeedDrain === true) {
      pause();
    } else if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src, dest) {
    return function pipeOnDrainFunctionResult() {
      const state = src._readableState;
      if (state.awaitDrainWriters === dest) {
        debug("pipeOnDrain", 1);
        state.awaitDrainWriters = null;
      } else if (state.multiAwaitDrain) {
        debug("pipeOnDrain", state.awaitDrainWriters.size);
        state.awaitDrainWriters.delete(dest);
      }
      if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
        src.resume();
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    const state = this._readableState;
    const unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipes.length === 0)
      return this;
    if (!dest) {
      const dests = state.pipes;
      state.pipes = [];
      this.pause();
      for (let i = 0;i < dests.length; i++)
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    const index = ArrayPrototypeIndexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    if (state.pipes.length === 0)
      this.pause();
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    const res = Stream.prototype.on.call(this, ev, fn);
    const state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process20.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    const res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process20.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.off = Readable.prototype.removeListener;
  Readable.prototype.removeAllListeners = function(ev) {
    const res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
      process20.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    const state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && state[kPaused] === false) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    } else if (!state.readableListening) {
      state.flowing = null;
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    const state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state[kPaused] = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process20.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState[kPaused] = true;
    return this;
  };
  function flow(stream) {
    const state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null)
      ;
  }
  Readable.prototype.wrap = function(stream) {
    let paused = false;
    stream.on("data", (chunk) => {
      if (!this.push(chunk) && stream.pause) {
        paused = true;
        stream.pause();
      }
    });
    stream.on("end", () => {
      this.push(null);
    });
    stream.on("error", (err) => {
      errorOrDestroy(this, err);
    });
    stream.on("close", () => {
      this.destroy();
    });
    stream.on("destroy", () => {
      this.destroy();
    });
    this._read = () => {
      if (paused && stream.resume) {
        paused = false;
        stream.resume();
      }
    };
    const streamKeys = ObjectKeys(stream);
    for (let j = 1;j < streamKeys.length; j++) {
      const i = streamKeys[j];
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = stream[i].bind(stream);
      }
    }
    return this;
  };
  Readable.prototype[SymbolAsyncIterator] = function() {
    return streamToAsyncIterator(this);
  };
  Readable.prototype.iterator = function(options) {
    if (options !== undefined) {
      validateObject(options, "options");
    }
    return streamToAsyncIterator(this, options);
  };
  function streamToAsyncIterator(stream, options) {
    if (typeof stream.read !== "function") {
      stream = Readable.wrap(stream, {
        objectMode: true
      });
    }
    const iter = createAsyncIterator(stream, options);
    iter.stream = stream;
    return iter;
  }
  async function* createAsyncIterator(stream, options) {
    let callback = nop;
    function next(resolve) {
      if (this === stream) {
        callback();
        callback = nop;
      } else {
        callback = resolve;
      }
    }
    stream.on("readable", next);
    let error;
    const cleanup = eos(stream, {
      writable: false
    }, (err) => {
      error = err ? aggregateTwoErrors(error, err) : null;
      callback();
      callback = nop;
    });
    try {
      while (true) {
        const chunk = stream.destroyed ? null : stream.read();
        if (chunk !== null) {
          yield chunk;
        } else if (error) {
          throw error;
        } else if (error === null) {
          return;
        } else {
          await new Promise2(next);
        }
      }
    } catch (err) {
      error = aggregateTwoErrors(error, err);
      throw error;
    } finally {
      if ((error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) && (error === undefined || stream._readableState.autoDestroy)) {
        destroyImpl.destroyer(stream, null);
      } else {
        stream.off("readable", next);
        cleanup();
      }
    }
  }
  ObjectDefineProperties(Readable.prototype, {
    readable: {
      __proto__: null,
      get() {
        const r = this._readableState;
        return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
      },
      set(val) {
        if (this._readableState) {
          this._readableState.readable = !!val;
        }
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.objectMode : false;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : false;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.destroyed : false;
      },
      set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._readableState ? this._readableState.endEmitted : false;
      }
    }
  });
  ObjectDefineProperties(ReadableState.prototype, {
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    paused: {
      __proto__: null,
      get() {
        return this[kPaused] !== false;
      },
      set(value) {
        this[kPaused] = !!value;
      }
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    let ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    const state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process20.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.emit("end");
      if (stream.writable && stream.allowHalfOpen === false) {
        process20.nextTick(endWritableNT, stream);
      } else if (state.autoDestroy) {
        const wState = stream._writableState;
        const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
  }
  function endWritableNT(stream) {
    const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
    if (writable) {
      stream.end();
    }
  }
  Readable.from = function(iterable, opts) {
    return from2(Readable, iterable, opts);
  };
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === undefined)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Readable.fromWeb = function(readableStream, options) {
    return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
  };
  Readable.toWeb = function(streamReadable, options) {
    return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
  };
  Readable.wrap = function(src, options) {
    var _ref, _src$readableObjectMo;
    return new Readable({
      objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined ? _src$readableObjectMo : src.objectMode) !== null && _ref !== undefined ? _ref : true,
      ...options,
      destroy(err, callback) {
        destroyImpl.destroyer(src, err);
        callback(err);
      }
    }).wrap(src);
  };
});

// node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS((exports, module) => {
  var process20 = require_process();
  var {
    ArrayPrototypeSlice,
    Error: Error2,
    FunctionPrototypeSymbolHasInstance,
    ObjectDefineProperty: ObjectDefineProperty2,
    ObjectDefineProperties,
    ObjectSetPrototypeOf,
    StringPrototypeToLowerCase,
    Symbol: Symbol2,
    SymbolHasInstance
  } = require_primordials();
  module.exports = Writable;
  Writable.WritableState = WritableState;
  var { EventEmitter: EE } = __require("events");
  var Stream = require_legacy().Stream;
  var { Buffer: Buffer2 } = __require("buffer");
  var destroyImpl = require_destroy2();
  var { addAbortSignal } = require_add_abort_signal();
  var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
  var {
    ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED,
    ERR_STREAM_ALREADY_FINISHED,
    ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING
  } = require_errors().codes;
  var { errorOrDestroy } = destroyImpl;
  ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
  ObjectSetPrototypeOf(Writable, Stream);
  function nop() {
  }
  var kOnFinished = Symbol2("kOnFinished");
  function WritableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof require_duplex();
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex)
      this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
    this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = onwrite.bind(undefined, stream);
    this.writecb = null;
    this.writelen = 0;
    this.afterWriteTickInfo = null;
    resetBuffer(this);
    this.pendingcb = 0;
    this.constructed = true;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this[kOnFinished] = [];
  }
  function resetBuffer(state) {
    state.buffered = [];
    state.bufferedIndex = 0;
    state.allBuffers = true;
    state.allNoop = true;
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
  };
  ObjectDefineProperty2(WritableState.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Writable(options) {
    const isDuplex = this instanceof require_duplex();
    if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
      if (typeof options.construct === "function")
        this._construct = options.construct;
      if (options.signal)
        addAbortSignal(options.signal, this);
    }
    Stream.call(this, options);
    destroyImpl.construct(this, () => {
      const state = this._writableState;
      if (!state.writing) {
        clearBuffer(this, state);
      }
      finishMaybe(this, state);
    });
  }
  ObjectDefineProperty2(Writable, SymbolHasInstance, {
    __proto__: null,
    value: function(object) {
      if (FunctionPrototypeSymbolHasInstance(this, object))
        return true;
      if (this !== Writable)
        return false;
      return object && object._writableState instanceof WritableState;
    }
  });
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  function _write(stream, chunk, encoding, cb) {
    const state = stream._writableState;
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = state.defaultEncoding;
    } else {
      if (!encoding)
        encoding = state.defaultEncoding;
      else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      if (typeof cb !== "function")
        cb = nop;
    }
    if (chunk === null) {
      throw new ERR_STREAM_NULL_VALUES;
    } else if (!state.objectMode) {
      if (typeof chunk === "string") {
        if (state.decodeStrings !== false) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "buffer";
        }
      } else if (chunk instanceof Buffer2) {
        encoding = "buffer";
      } else if (Stream._isUint8Array(chunk)) {
        chunk = Stream._uint8ArrayToBuffer(chunk);
        encoding = "buffer";
      } else {
        throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
    }
    let err;
    if (state.ending) {
      err = new ERR_STREAM_WRITE_AFTER_END;
    } else if (state.destroyed) {
      err = new ERR_STREAM_DESTROYED("write");
    }
    if (err) {
      process20.nextTick(cb, err);
      errorOrDestroy(stream, err, true);
      return err;
    }
    state.pendingcb++;
    return writeOrBuffer(stream, state, chunk, encoding, cb);
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === true;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    const state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = StringPrototypeToLowerCase(encoding);
    if (!Buffer2.isEncoding(encoding))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function writeOrBuffer(stream, state, chunk, encoding, callback) {
    const len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    const ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked || state.errored || !state.constructed) {
      state.buffered.push({
        chunk,
        encoding,
        callback
      });
      if (state.allBuffers && encoding !== "buffer") {
        state.allBuffers = false;
      }
      if (state.allNoop && callback !== nop) {
        state.allNoop = false;
      }
    } else {
      state.writelen = len;
      state.writecb = callback;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    return ret && !state.errored && !state.destroyed;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, er, cb) {
    --state.pendingcb;
    cb(er);
    errorBuffer(state);
    errorOrDestroy(stream, er);
  }
  function onwrite(stream, er) {
    const state = stream._writableState;
    const sync = state.sync;
    const cb = state.writecb;
    if (typeof cb !== "function") {
      errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK);
      return;
    }
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
    if (er) {
      er.stack;
      if (!state.errored) {
        state.errored = er;
      }
      if (stream._readableState && !stream._readableState.errored) {
        stream._readableState.errored = er;
      }
      if (sync) {
        process20.nextTick(onwriteError, stream, state, er, cb);
      } else {
        onwriteError(stream, state, er, cb);
      }
    } else {
      if (state.buffered.length > state.bufferedIndex) {
        clearBuffer(stream, state);
      }
      if (sync) {
        if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
          state.afterWriteTickInfo.count++;
        } else {
          state.afterWriteTickInfo = {
            count: 1,
            cb,
            stream,
            state
          };
          process20.nextTick(afterWriteTick, state.afterWriteTickInfo);
        }
      } else {
        afterWrite(stream, state, 1, cb);
      }
    }
  }
  function afterWriteTick({ stream, state, count, cb }) {
    state.afterWriteTickInfo = null;
    return afterWrite(stream, state, count, cb);
  }
  function afterWrite(stream, state, count, cb) {
    const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
    if (needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
    while (count-- > 0) {
      state.pendingcb--;
      cb();
    }
    if (state.destroyed) {
      errorBuffer(state);
    }
    finishMaybe(stream, state);
  }
  function errorBuffer(state) {
    if (state.writing) {
      return;
    }
    for (let n = state.bufferedIndex;n < state.buffered.length; ++n) {
      var _state$errored;
      const { chunk, callback } = state.buffered[n];
      const len = state.objectMode ? 1 : chunk.length;
      state.length -= len;
      callback((_state$errored = state.errored) !== null && _state$errored !== undefined ? _state$errored : new ERR_STREAM_DESTROYED("write"));
    }
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0;i < onfinishCallbacks.length; i++) {
      var _state$errored2;
      onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== undefined ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
    }
    resetBuffer(state);
  }
  function clearBuffer(stream, state) {
    if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
      return;
    }
    const { buffered, bufferedIndex, objectMode } = state;
    const bufferedLength = buffered.length - bufferedIndex;
    if (!bufferedLength) {
      return;
    }
    let i = bufferedIndex;
    state.bufferProcessing = true;
    if (bufferedLength > 1 && stream._writev) {
      state.pendingcb -= bufferedLength - 1;
      const callback = state.allNoop ? nop : (err) => {
        for (let n = i;n < buffered.length; ++n) {
          buffered[n].callback(err);
        }
      };
      const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
      chunks.allBuffers = state.allBuffers;
      doWrite(stream, state, true, state.length, chunks, "", callback);
      resetBuffer(state);
    } else {
      do {
        const { chunk, encoding, callback } = buffered[i];
        buffered[i++] = null;
        const len = objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, callback);
      } while (i < buffered.length && !state.writing);
      if (i === buffered.length) {
        resetBuffer(state);
      } else if (i > 256) {
        buffered.splice(0, i);
        state.bufferedIndex = 0;
      } else {
        state.bufferedIndex = i;
      }
    }
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    if (this._writev) {
      this._writev([
        {
          chunk,
          encoding
        }
      ], cb);
    } else {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    }
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    const state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    let err;
    if (chunk !== null && chunk !== undefined) {
      const ret = _write(this, chunk, encoding);
      if (ret instanceof Error2) {
        err = ret;
      }
    }
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (err) {
    } else if (!state.errored && !state.ending) {
      state.ending = true;
      finishMaybe(this, state, true);
      state.ended = true;
    } else if (state.finished) {
      err = new ERR_STREAM_ALREADY_FINISHED("end");
    } else if (state.destroyed) {
      err = new ERR_STREAM_DESTROYED("end");
    }
    if (typeof cb === "function") {
      if (err || state.finished) {
        process20.nextTick(cb, err);
      } else {
        state[kOnFinished].push(cb);
      }
    }
    return this;
  };
  function needFinish(state) {
    return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
  }
  function callFinal(stream, state) {
    let called = false;
    function onFinish(err) {
      if (called) {
        errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK());
        return;
      }
      called = true;
      state.pendingcb--;
      if (err) {
        const onfinishCallbacks = state[kOnFinished].splice(0);
        for (let i = 0;i < onfinishCallbacks.length; i++) {
          onfinishCallbacks[i](err);
        }
        errorOrDestroy(stream, err, state.sync);
      } else if (needFinish(state)) {
        state.prefinished = true;
        stream.emit("prefinish");
        state.pendingcb++;
        process20.nextTick(finish, stream, state);
      }
    }
    state.sync = true;
    state.pendingcb++;
    try {
      stream._final(onFinish);
    } catch (err) {
      onFinish(err);
    }
    state.sync = false;
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.finalCalled = true;
        callFinal(stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state, sync) {
    if (needFinish(state)) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        if (sync) {
          state.pendingcb++;
          process20.nextTick((stream2, state2) => {
            if (needFinish(state2)) {
              finish(stream2, state2);
            } else {
              state2.pendingcb--;
            }
          }, stream, state);
        } else if (needFinish(state)) {
          state.pendingcb++;
          finish(stream, state);
        }
      }
    }
  }
  function finish(stream, state) {
    state.pendingcb--;
    state.finished = true;
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0;i < onfinishCallbacks.length; i++) {
      onfinishCallbacks[i]();
    }
    stream.emit("finish");
    if (state.autoDestroy) {
      const rState = stream._readableState;
      const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
      if (autoDestroy) {
        stream.destroy();
      }
    }
  }
  ObjectDefineProperties(Writable.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : false;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : false;
      },
      set(value) {
        if (this._writableState) {
          this._writableState.destroyed = value;
        }
      }
    },
    writable: {
      __proto__: null,
      get() {
        const w = this._writableState;
        return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
      },
      set(val) {
        if (this._writableState) {
          this._writableState.writable = !!val;
        }
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : false;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : false;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : false;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const wState = this._writableState;
        if (!wState)
          return false;
        return !wState.destroyed && !wState.ending && wState.needDrain;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: false,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: false,
      get: function() {
        return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  var destroy = destroyImpl.destroy;
  Writable.prototype.destroy = function(err, cb) {
    const state = this._writableState;
    if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
      process20.nextTick(errorBuffer, state);
    }
    destroy.call(this, err, cb);
    return this;
  };
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Writable.prototype[EE.captureRejectionSymbol] = function(err) {
    this.destroy(err);
  };
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === undefined)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Writable.fromWeb = function(writableStream, options) {
    return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
  };
  Writable.toWeb = function(streamWritable) {
    return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
  };
});

// node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS((exports, module) => {
  var process20 = require_process();
  var bufferModule = __require("buffer");
  var {
    isReadable,
    isWritable,
    isIterable,
    isNodeStream,
    isReadableNodeStream,
    isWritableNodeStream,
    isDuplexNodeStream,
    isReadableStream,
    isWritableStream
  } = require_utils3();
  var eos = require_end_of_stream();
  var {
    AbortError,
    codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
  } = require_errors();
  var { destroyer } = require_destroy2();
  var Duplex = require_duplex();
  var Readable = require_readable2();
  var Writable = require_writable();
  var { createDeferredPromise } = require_util2();
  var from2 = require_from2();
  var Blob = globalThis.Blob || bufferModule.Blob;
  var isBlob = typeof Blob !== "undefined" ? function isBlob(b) {
    return b instanceof Blob;
  } : function isBlob(b) {
    return false;
  };
  var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
  var { FunctionPrototypeCall } = require_primordials();

  class Duplexify extends Duplex {
    constructor(options) {
      super(options);
      if ((options === null || options === undefined ? undefined : options.readable) === false) {
        this._readableState.readable = false;
        this._readableState.ended = true;
        this._readableState.endEmitted = true;
      }
      if ((options === null || options === undefined ? undefined : options.writable) === false) {
        this._writableState.writable = false;
        this._writableState.ending = true;
        this._writableState.ended = true;
        this._writableState.finished = true;
      }
    }
  }
  module.exports = function duplexify(body, name) {
    if (isDuplexNodeStream(body)) {
      return body;
    }
    if (isReadableNodeStream(body)) {
      return _duplexify({
        readable: body
      });
    }
    if (isWritableNodeStream(body)) {
      return _duplexify({
        writable: body
      });
    }
    if (isNodeStream(body)) {
      return _duplexify({
        writable: false,
        readable: false
      });
    }
    if (isReadableStream(body)) {
      return _duplexify({
        readable: Readable.fromWeb(body)
      });
    }
    if (isWritableStream(body)) {
      return _duplexify({
        writable: Writable.fromWeb(body)
      });
    }
    if (typeof body === "function") {
      const { value, write, final, destroy } = fromAsyncGen(body);
      if (isIterable(value)) {
        return from2(Duplexify, value, {
          objectMode: true,
          write,
          final,
          destroy
        });
      }
      const then2 = value === null || value === undefined ? undefined : value.then;
      if (typeof then2 === "function") {
        let d;
        const promise = FunctionPrototypeCall(then2, value, (val) => {
          if (val != null) {
            throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
          }
        }, (err) => {
          destroyer(d, err);
        });
        return d = new Duplexify({
          objectMode: true,
          readable: false,
          write,
          final(cb) {
            final(async () => {
              try {
                await promise;
                process20.nextTick(cb, null);
              } catch (err) {
                process20.nextTick(cb, err);
              }
            });
          },
          destroy
        });
      }
      throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
    }
    if (isBlob(body)) {
      return duplexify(body.arrayBuffer());
    }
    if (isIterable(body)) {
      return from2(Duplexify, body, {
        objectMode: true,
        writable: false
      });
    }
    if (isReadableStream(body === null || body === undefined ? undefined : body.readable) && isWritableStream(body === null || body === undefined ? undefined : body.writable)) {
      return Duplexify.fromWeb(body);
    }
    if (typeof (body === null || body === undefined ? undefined : body.writable) === "object" || typeof (body === null || body === undefined ? undefined : body.readable) === "object") {
      const readable = body !== null && body !== undefined && body.readable ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable) ? body === null || body === undefined ? undefined : body.readable : duplexify(body.readable) : undefined;
      const writable = body !== null && body !== undefined && body.writable ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable) ? body === null || body === undefined ? undefined : body.writable : duplexify(body.writable) : undefined;
      return _duplexify({
        readable,
        writable
      });
    }
    const then = body === null || body === undefined ? undefined : body.then;
    if (typeof then === "function") {
      let d;
      FunctionPrototypeCall(then, body, (val) => {
        if (val != null) {
          d.push(val);
        }
        d.push(null);
      }, (err) => {
        destroyer(d, err);
      });
      return d = new Duplexify({
        objectMode: true,
        writable: false,
        read() {
        }
      });
    }
    throw new ERR_INVALID_ARG_TYPE(name, [
      "Blob",
      "ReadableStream",
      "WritableStream",
      "Stream",
      "Iterable",
      "AsyncIterable",
      "Function",
      "{ readable, writable } pair",
      "Promise"
    ], body);
  };
  function fromAsyncGen(fn) {
    let { promise, resolve } = createDeferredPromise();
    const ac = new AbortController2;
    const signal = ac.signal;
    const value = fn(async function* () {
      while (true) {
        const _promise = promise;
        promise = null;
        const { chunk, done, cb } = await _promise;
        process20.nextTick(cb);
        if (done)
          return;
        if (signal.aborted)
          throw new AbortError(undefined, {
            cause: signal.reason
          });
        ({ promise, resolve } = createDeferredPromise());
        yield chunk;
      }
    }(), {
      signal
    });
    return {
      value,
      write(chunk, encoding, cb) {
        const _resolve = resolve;
        resolve = null;
        _resolve({
          chunk,
          done: false,
          cb
        });
      },
      final(cb) {
        const _resolve = resolve;
        resolve = null;
        _resolve({
          done: true,
          cb
        });
      },
      destroy(err, cb) {
        ac.abort();
        cb(err);
      }
    };
  }
  function _duplexify(pair) {
    const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
    const w = pair.writable;
    let readable = !!isReadable(r);
    let writable = !!isWritable(w);
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
      const cb = onclose;
      onclose = null;
      if (cb) {
        cb(err);
      } else if (err) {
        d.destroy(err);
      }
    }
    d = new Duplexify({
      readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),
      writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),
      readable,
      writable
    });
    if (writable) {
      eos(w, (err) => {
        writable = false;
        if (err) {
          destroyer(r, err);
        }
        onfinished(err);
      });
      d._write = function(chunk, encoding, callback) {
        if (w.write(chunk, encoding)) {
          callback();
        } else {
          ondrain = callback;
        }
      };
      d._final = function(callback) {
        w.end();
        onfinish = callback;
      };
      w.on("drain", function() {
        if (ondrain) {
          const cb = ondrain;
          ondrain = null;
          cb();
        }
      });
      w.on("finish", function() {
        if (onfinish) {
          const cb = onfinish;
          onfinish = null;
          cb();
        }
      });
    }
    if (readable) {
      eos(r, (err) => {
        readable = false;
        if (err) {
          destroyer(r, err);
        }
        onfinished(err);
      });
      r.on("readable", function() {
        if (onreadable) {
          const cb = onreadable;
          onreadable = null;
          cb();
        }
      });
      r.on("end", function() {
        d.push(null);
      });
      d._read = function() {
        while (true) {
          const buf = r.read();
          if (buf === null) {
            onreadable = d._read;
            return;
          }
          if (!d.push(buf)) {
            return;
          }
        }
      };
    }
    d._destroy = function(err, callback) {
      if (!err && onclose !== null) {
        err = new AbortError;
      }
      onreadable = null;
      ondrain = null;
      onfinish = null;
      if (onclose === null) {
        callback(err);
      } else {
        onclose = callback;
        destroyer(w, err);
        destroyer(r, err);
      }
    };
    return d;
  }
});

// node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS((exports, module) => {
  var {
    ObjectDefineProperties,
    ObjectGetOwnPropertyDescriptor,
    ObjectKeys,
    ObjectSetPrototypeOf
  } = require_primordials();
  module.exports = Duplex;
  var Readable = require_readable2();
  var Writable = require_writable();
  ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
  ObjectSetPrototypeOf(Duplex, Readable);
  {
    const keys = ObjectKeys(Writable.prototype);
    for (let i = 0;i < keys.length; i++) {
      const method = keys[i];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options) {
      this.allowHalfOpen = options.allowHalfOpen !== false;
      if (options.readable === false) {
        this._readableState.readable = false;
        this._readableState.ended = true;
        this._readableState.endEmitted = true;
      }
      if (options.writable === false) {
        this._writableState.writable = false;
        this._writableState.ending = true;
        this._writableState.ended = true;
        this._writableState.finished = true;
      }
    } else {
      this.allowHalfOpen = true;
    }
  }
  ObjectDefineProperties(Duplex.prototype, {
    writable: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        if (this._readableState === undefined || this._writableState === undefined) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set(value) {
        if (this._readableState && this._writableState) {
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      }
    }
  });
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === undefined)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Duplex.fromWeb = function(pair, options) {
    return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
  };
  Duplex.toWeb = function(duplex) {
    return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
  };
  var duplexify;
  Duplex.from = function(body) {
    if (!duplexify) {
      duplexify = require_duplexify();
    }
    return duplexify(body, "body");
  };
});

// node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS((exports, module) => {
  var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
  module.exports = Transform;
  var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
  var Duplex = require_duplex();
  var { getHighWaterMark } = require_state();
  ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
  ObjectSetPrototypeOf(Transform, Duplex);
  var kCallback = Symbol2("kCallback");
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
    if (readableHighWaterMark === 0) {
      options = {
        ...options,
        highWaterMark: null,
        readableHighWaterMark,
        writableHighWaterMark: options.writableHighWaterMark || 0
      };
    }
    Duplex.call(this, options);
    this._readableState.sync = false;
    this[kCallback] = null;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function final(cb) {
    if (typeof this._flush === "function" && !this.destroyed) {
      this._flush((er, data) => {
        if (er) {
          if (cb) {
            cb(er);
          } else {
            this.destroy(er);
          }
          return;
        }
        if (data != null) {
          this.push(data);
        }
        this.push(null);
        if (cb) {
          cb();
        }
      });
    } else {
      this.push(null);
      if (cb) {
        cb();
      }
    }
  }
  function prefinish() {
    if (this._final !== final) {
      final.call(this);
    }
  }
  Transform.prototype._final = final;
  Transform.prototype._transform = function(chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
  };
  Transform.prototype._write = function(chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;
    this._transform(chunk, encoding, (err, val) => {
      if (err) {
        callback(err);
        return;
      }
      if (val != null) {
        this.push(val);
      }
      if (wState.ended || length === rState.length || rState.length < rState.highWaterMark) {
        callback();
      } else {
        this[kCallback] = callback;
      }
    });
  };
  Transform.prototype._read = function() {
    if (this[kCallback]) {
      const callback = this[kCallback];
      this[kCallback] = null;
      callback();
    }
  };
});

// node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough2 = __commonJS((exports, module) => {
  var { ObjectSetPrototypeOf } = require_primordials();
  module.exports = PassThrough;
  var Transform = require_transform();
  ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
  ObjectSetPrototypeOf(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS((exports, module) => {
  var process20 = require_process();
  var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
  var eos = require_end_of_stream();
  var { once } = require_util2();
  var destroyImpl = require_destroy2();
  var Duplex = require_duplex();
  var {
    aggregateTwoErrors,
    codes: {
      ERR_INVALID_ARG_TYPE,
      ERR_INVALID_RETURN_VALUE,
      ERR_MISSING_ARGS,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_PREMATURE_CLOSE
    },
    AbortError
  } = require_errors();
  var { validateFunction, validateAbortSignal } = require_validators();
  var {
    isIterable,
    isReadable,
    isReadableNodeStream,
    isNodeStream,
    isTransformStream,
    isWebStream,
    isReadableStream,
    isReadableFinished
  } = require_utils3();
  var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
  var PassThrough;
  var Readable;
  var addAbortListener;
  function destroyer(stream, reading, writing) {
    let finished = false;
    stream.on("close", () => {
      finished = true;
    });
    const cleanup = eos(stream, {
      readable: reading,
      writable: writing
    }, (err) => {
      finished = !err;
    });
    return {
      destroy: (err) => {
        if (finished)
          return;
        finished = true;
        destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
      },
      cleanup
    };
  }
  function popCallback(streams) {
    validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
    return streams.pop();
  }
  function makeAsyncIterable(val) {
    if (isIterable(val)) {
      return val;
    } else if (isReadableNodeStream(val)) {
      return fromReadable(val);
    }
    throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
  }
  async function* fromReadable(val) {
    if (!Readable) {
      Readable = require_readable2();
    }
    yield* Readable.prototype[SymbolAsyncIterator].call(val);
  }
  async function pumpToNode(iterable, writable, finish, { end }) {
    let error;
    let onresolve = null;
    const resume = (err) => {
      if (err) {
        error = err;
      }
      if (onresolve) {
        const callback = onresolve;
        onresolve = null;
        callback();
      }
    };
    const wait = () => new Promise2((resolve, reject) => {
      if (error) {
        reject(error);
      } else {
        onresolve = () => {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        };
      }
    });
    writable.on("drain", resume);
    const cleanup = eos(writable, {
      readable: false
    }, resume);
    try {
      if (writable.writableNeedDrain) {
        await wait();
      }
      for await (const chunk of iterable) {
        if (!writable.write(chunk)) {
          await wait();
        }
      }
      if (end) {
        writable.end();
        await wait();
      }
      finish();
    } catch (err) {
      finish(error !== err ? aggregateTwoErrors(error, err) : err);
    } finally {
      cleanup();
      writable.off("drain", resume);
    }
  }
  async function pumpToWeb(readable, writable, finish, { end }) {
    if (isTransformStream(writable)) {
      writable = writable.writable;
    }
    const writer = writable.getWriter();
    try {
      for await (const chunk of readable) {
        await writer.ready;
        writer.write(chunk).catch(() => {
        });
      }
      await writer.ready;
      if (end) {
        await writer.close();
      }
      finish();
    } catch (err) {
      try {
        await writer.abort(err);
        finish(err);
      } catch (err2) {
        finish(err2);
      }
    }
  }
  function pipeline(...streams) {
    return pipelineImpl(streams, once(popCallback(streams)));
  }
  function pipelineImpl(streams, callback, opts) {
    if (streams.length === 1 && ArrayIsArray(streams[0])) {
      streams = streams[0];
    }
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    const ac = new AbortController2;
    const signal = ac.signal;
    const outerSignal = opts === null || opts === undefined ? undefined : opts.signal;
    const lastStreamCleanup = [];
    validateAbortSignal(outerSignal, "options.signal");
    function abort() {
      finishImpl(new AbortError);
    }
    addAbortListener = addAbortListener || require_util2().addAbortListener;
    let disposable;
    if (outerSignal) {
      disposable = addAbortListener(outerSignal, abort);
    }
    let error;
    let value;
    const destroys = [];
    let finishCount = 0;
    function finish(err) {
      finishImpl(err, --finishCount === 0);
    }
    function finishImpl(err, final) {
      var _disposable;
      if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
        error = err;
      }
      if (!error && !final) {
        return;
      }
      while (destroys.length) {
        destroys.shift()(error);
      }
      (_disposable = disposable) === null || _disposable === undefined || _disposable[SymbolDispose]();
      ac.abort();
      if (final) {
        if (!error) {
          lastStreamCleanup.forEach((fn) => fn());
        }
        process20.nextTick(callback, error, value);
      }
    }
    let ret;
    for (let i = 0;i < streams.length; i++) {
      const stream = streams[i];
      const reading = i < streams.length - 1;
      const writing = i > 0;
      const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false;
      const isLastStream = i === streams.length - 1;
      if (isNodeStream(stream)) {
        let onError2 = function(err) {
          if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            finish(err);
          }
        };
        var onError = onError2;
        if (end) {
          const { destroy, cleanup } = destroyer(stream, reading, writing);
          destroys.push(destroy);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        }
        stream.on("error", onError2);
        if (isReadable(stream) && isLastStream) {
          lastStreamCleanup.push(() => {
            stream.removeListener("error", onError2);
          });
        }
      }
      if (i === 0) {
        if (typeof stream === "function") {
          ret = stream({
            signal
          });
          if (!isIterable(ret)) {
            throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
          }
        } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      } else if (typeof stream === "function") {
        if (isTransformStream(ret)) {
          var _ret;
          ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);
        } else {
          ret = makeAsyncIterable(ret);
        }
        ret = stream(ret, {
          signal
        });
        if (reading) {
          if (!isIterable(ret, true)) {
            throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
          }
        } else {
          var _ret2;
          if (!PassThrough) {
            PassThrough = require_passthrough2();
          }
          const pt = new PassThrough({
            objectMode: true
          });
          const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;
          if (typeof then === "function") {
            finishCount++;
            then.call(ret, (val) => {
              value = val;
              if (val != null) {
                pt.write(val);
              }
              if (end) {
                pt.end();
              }
              process20.nextTick(finish);
            }, (err) => {
              pt.destroy(err);
              process20.nextTick(finish, err);
            });
          } else if (isIterable(ret, true)) {
            finishCount++;
            pumpToNode(ret, pt, finish, {
              end
            });
          } else if (isReadableStream(ret) || isTransformStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, pt, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
          }
          ret = pt;
          const { destroy, cleanup } = destroyer(ret, false, true);
          destroys.push(destroy);
          if (isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        }
      } else if (isNodeStream(stream)) {
        if (isReadableNodeStream(ret)) {
          finishCount += 2;
          const cleanup = pipe(ret, stream, finish, {
            end
          });
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(cleanup);
          }
        } else if (isTransformStream(ret) || isReadableStream(ret)) {
          const toRead = ret.readable || ret;
          finishCount++;
          pumpToNode(toRead, stream, finish, {
            end
          });
        } else if (isIterable(ret)) {
          finishCount++;
          pumpToNode(ret, stream, finish, {
            end
          });
        } else {
          throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
        }
        ret = stream;
      } else if (isWebStream(stream)) {
        if (isReadableNodeStream(ret)) {
          finishCount++;
          pumpToWeb(makeAsyncIterable(ret), stream, finish, {
            end
          });
        } else if (isReadableStream(ret) || isIterable(ret)) {
          finishCount++;
          pumpToWeb(ret, stream, finish, {
            end
          });
        } else if (isTransformStream(ret)) {
          finishCount++;
          pumpToWeb(ret.readable, stream, finish, {
            end
          });
        } else {
          throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
        }
        ret = stream;
      } else {
        ret = Duplex.from(stream);
      }
    }
    if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted) {
      process20.nextTick(abort);
    }
    return ret;
  }
  function pipe(src, dst, finish, { end }) {
    let ended = false;
    dst.on("close", () => {
      if (!ended) {
        finish(new ERR_STREAM_PREMATURE_CLOSE);
      }
    });
    src.pipe(dst, {
      end: false
    });
    if (end) {
      let endFn2 = function() {
        ended = true;
        dst.end();
      };
      var endFn = endFn2;
      if (isReadableFinished(src)) {
        process20.nextTick(endFn2);
      } else {
        src.once("end", endFn2);
      }
    } else {
      finish();
    }
    eos(src, {
      readable: true,
      writable: false
    }, (err) => {
      const rState = src._readableState;
      if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
        src.once("end", finish).once("error", finish);
      } else {
        finish(err);
      }
    });
    return eos(dst, {
      readable: false,
      writable: true
    }, finish);
  }
  module.exports = {
    pipelineImpl,
    pipeline
  };
});

// node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS((exports, module) => {
  var { pipeline } = require_pipeline();
  var Duplex = require_duplex();
  var { destroyer } = require_destroy2();
  var {
    isNodeStream,
    isReadable,
    isWritable,
    isWebStream,
    isTransformStream,
    isWritableStream,
    isReadableStream
  } = require_utils3();
  var {
    AbortError,
    codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
  } = require_errors();
  var eos = require_end_of_stream();
  module.exports = function compose(...streams) {
    if (streams.length === 0) {
      throw new ERR_MISSING_ARGS("streams");
    }
    if (streams.length === 1) {
      return Duplex.from(streams[0]);
    }
    const orgStreams = [...streams];
    if (typeof streams[0] === "function") {
      streams[0] = Duplex.from(streams[0]);
    }
    if (typeof streams[streams.length - 1] === "function") {
      const idx = streams.length - 1;
      streams[idx] = Duplex.from(streams[idx]);
    }
    for (let n = 0;n < streams.length; ++n) {
      if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
        continue;
      }
      if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
        throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
      }
      if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
        throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
      }
    }
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
      const cb = onclose;
      onclose = null;
      if (cb) {
        cb(err);
      } else if (err) {
        d.destroy(err);
      } else if (!readable && !writable) {
        d.destroy();
      }
    }
    const head = streams[0];
    const tail = pipeline(streams, onfinished);
    const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
    const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
    d = new Duplex({
      writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),
      readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),
      writable,
      readable
    });
    if (writable) {
      if (isNodeStream(head)) {
        d._write = function(chunk, encoding, callback) {
          if (head.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          head.end();
          onfinish = callback;
        };
        head.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
      } else if (isWebStream(head)) {
        const writable2 = isTransformStream(head) ? head.writable : head;
        const writer = writable2.getWriter();
        d._write = async function(chunk, encoding, callback) {
          try {
            await writer.ready;
            writer.write(chunk).catch(() => {
            });
            callback();
          } catch (err) {
            callback(err);
          }
        };
        d._final = async function(callback) {
          try {
            await writer.ready;
            writer.close().catch(() => {
            });
            onfinish = callback;
          } catch (err) {
            callback(err);
          }
        };
      }
      const toRead = isTransformStream(tail) ? tail.readable : tail;
      eos(toRead, () => {
        if (onfinish) {
          const cb = onfinish;
          onfinish = null;
          cb();
        }
      });
    }
    if (readable) {
      if (isNodeStream(tail)) {
        tail.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        tail.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = tail.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      } else if (isWebStream(tail)) {
        const readable2 = isTransformStream(tail) ? tail.readable : tail;
        const reader = readable2.getReader();
        d._read = async function() {
          while (true) {
            try {
              const { value, done } = await reader.read();
              if (!d.push(value)) {
                return;
              }
              if (done) {
                d.push(null);
                return;
              }
            } catch {
              return;
            }
          }
        };
      }
    }
    d._destroy = function(err, callback) {
      if (!err && onclose !== null) {
        err = new AbortError;
      }
      onreadable = null;
      ondrain = null;
      onfinish = null;
      if (onclose === null) {
        callback(err);
      } else {
        onclose = callback;
        if (isNodeStream(tail)) {
          destroyer(tail, err);
        }
      }
    };
    return d;
  };
});

// node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS((exports, module) => {
  var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
  var {
    codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
    AbortError
  } = require_errors();
  var { validateAbortSignal, validateInteger, validateObject } = require_validators();
  var kWeakHandler = require_primordials().Symbol("kWeak");
  var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
  var { finished } = require_end_of_stream();
  var staticCompose = require_compose();
  var { addAbortSignalNoValidate } = require_add_abort_signal();
  var { isWritable, isNodeStream } = require_utils3();
  var { deprecate } = require_util2();
  var {
    ArrayPrototypePush,
    Boolean: Boolean2,
    MathFloor,
    Number: Number2,
    NumberIsNaN,
    Promise: Promise2,
    PromiseReject,
    PromiseResolve,
    PromisePrototypeThen,
    Symbol: Symbol2
  } = require_primordials();
  var kEmpty = Symbol2("kEmpty");
  var kEof = Symbol2("kEof");
  function compose(stream, options) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    if (isNodeStream(stream) && !isWritable(stream)) {
      throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
    }
    const composedStream = staticCompose(this, stream);
    if (options !== null && options !== undefined && options.signal) {
      addAbortSignalNoValidate(options.signal, composedStream);
    }
    return composedStream;
  }
  function map(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
    }
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    let concurrency = 1;
    if ((options === null || options === undefined ? undefined : options.concurrency) != null) {
      concurrency = MathFloor(options.concurrency);
    }
    let highWaterMark = concurrency - 1;
    if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {
      highWaterMark = MathFloor(options.highWaterMark);
    }
    validateInteger(concurrency, "options.concurrency", 1);
    validateInteger(highWaterMark, "options.highWaterMark", 0);
    highWaterMark += concurrency;
    return async function* map() {
      const signal = require_util2().AbortSignalAny([options === null || options === undefined ? undefined : options.signal].filter(Boolean2));
      const stream = this;
      const queue = [];
      const signalOpt = {
        signal
      };
      let next;
      let resume;
      let done = false;
      let cnt = 0;
      function onCatch() {
        done = true;
        afterItemProcessed();
      }
      function afterItemProcessed() {
        cnt -= 1;
        maybeResume();
      }
      function maybeResume() {
        if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
          resume();
          resume = null;
        }
      }
      async function pump() {
        try {
          for await (let val of stream) {
            if (done) {
              return;
            }
            if (signal.aborted) {
              throw new AbortError;
            }
            try {
              val = fn(val, signalOpt);
              if (val === kEmpty) {
                continue;
              }
              val = PromiseResolve(val);
            } catch (err) {
              val = PromiseReject(err);
            }
            cnt += 1;
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
            if (next) {
              next();
              next = null;
            }
            if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
              await new Promise2((resolve) => {
                resume = resolve;
              });
            }
          }
          queue.push(kEof);
        } catch (err) {
          const val = PromiseReject(err);
          PromisePrototypeThen(val, afterItemProcessed, onCatch);
          queue.push(val);
        } finally {
          done = true;
          if (next) {
            next();
            next = null;
          }
        }
      }
      pump();
      try {
        while (true) {
          while (queue.length > 0) {
            const val = await queue[0];
            if (val === kEof) {
              return;
            }
            if (signal.aborted) {
              throw new AbortError;
            }
            if (val !== kEmpty) {
              yield val;
            }
            queue.shift();
            maybeResume();
          }
          await new Promise2((resolve) => {
            next = resolve;
          });
        }
      } finally {
        done = true;
        if (resume) {
          resume();
          resume = null;
        }
      }
    }.call(this);
  }
  function asIndexedPairs(options = undefined) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    return async function* asIndexedPairs() {
      let index = 0;
      for await (const val of this) {
        var _options$signal;
        if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted) {
          throw new AbortError({
            cause: options.signal.reason
          });
        }
        yield [index++, val];
      }
    }.call(this);
  }
  async function some(fn, options = undefined) {
    for await (const unused of filter2.call(this, fn, options)) {
      return true;
    }
    return false;
  }
  async function every(fn, options = undefined) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
    }
    return !await some.call(this, async (...args) => {
      return !await fn(...args);
    }, options);
  }
  async function find(fn, options) {
    for await (const result of filter2.call(this, fn, options)) {
      return result;
    }
    return;
  }
  async function forEach(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
    }
    async function forEachFn(value, options2) {
      await fn(value, options2);
      return kEmpty;
    }
    for await (const unused of map.call(this, forEachFn, options))
      ;
  }
  function filter2(fn, options) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
    }
    async function filterFn(value, options2) {
      if (await fn(value, options2)) {
        return value;
      }
      return kEmpty;
    }
    return map.call(this, filterFn, options);
  }

  class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
    constructor() {
      super("reduce");
      this.message = "Reduce of an empty stream requires an initial value";
    }
  }
  async function reduce2(reducer, initialValue, options) {
    var _options$signal2;
    if (typeof reducer !== "function") {
      throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
    }
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    let hasInitialValue = arguments.length > 1;
    if (options !== null && options !== undefined && (_options$signal2 = options.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {
      const err = new AbortError(undefined, {
        cause: options.signal.reason
      });
      this.once("error", () => {
      });
      await finished(this.destroy(err));
      throw err;
    }
    const ac = new AbortController2;
    const signal = ac.signal;
    if (options !== null && options !== undefined && options.signal) {
      const opts = {
        once: true,
        [kWeakHandler]: this,
        [kResistStopPropagation]: true
      };
      options.signal.addEventListener("abort", () => ac.abort(), opts);
    }
    let gotAnyItemFromStream = false;
    try {
      for await (const value of this) {
        var _options$signal3;
        gotAnyItemFromStream = true;
        if (options !== null && options !== undefined && (_options$signal3 = options.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted) {
          throw new AbortError;
        }
        if (!hasInitialValue) {
          initialValue = value;
          hasInitialValue = true;
        } else {
          initialValue = await reducer(initialValue, value, {
            signal
          });
        }
      }
      if (!gotAnyItemFromStream && !hasInitialValue) {
        throw new ReduceAwareErrMissingArgs;
      }
    } finally {
      ac.abort();
    }
    return initialValue;
  }
  async function toArray(options) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    const result = [];
    for await (const val of this) {
      var _options$signal4;
      if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted) {
        throw new AbortError(undefined, {
          cause: options.signal.reason
        });
      }
      ArrayPrototypePush(result, val);
    }
    return result;
  }
  function flatMap(fn, options) {
    const values = map.call(this, fn, options);
    return async function* flatMap() {
      for await (const val of values) {
        yield* val;
      }
    }.call(this);
  }
  function toIntegerOrInfinity(number2) {
    number2 = Number2(number2);
    if (NumberIsNaN(number2)) {
      return 0;
    }
    if (number2 < 0) {
      throw new ERR_OUT_OF_RANGE("number", ">= 0", number2);
    }
    return number2;
  }
  function drop(number2, options = undefined) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    number2 = toIntegerOrInfinity(number2);
    return async function* drop() {
      var _options$signal5;
      if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted) {
        throw new AbortError;
      }
      for await (const val of this) {
        var _options$signal6;
        if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted) {
          throw new AbortError;
        }
        if (number2-- <= 0) {
          yield val;
        }
      }
    }.call(this);
  }
  function take(number2, options = undefined) {
    if (options != null) {
      validateObject(options, "options");
    }
    if ((options === null || options === undefined ? undefined : options.signal) != null) {
      validateAbortSignal(options.signal, "options.signal");
    }
    number2 = toIntegerOrInfinity(number2);
    return async function* take() {
      var _options$signal7;
      if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted) {
        throw new AbortError;
      }
      for await (const val of this) {
        var _options$signal8;
        if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted) {
          throw new AbortError;
        }
        if (number2-- > 0) {
          yield val;
        }
        if (number2 <= 0) {
          return;
        }
      }
    }.call(this);
  }
  exports.streamReturningOperators = {
    asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
    drop,
    filter: filter2,
    flatMap,
    map,
    take,
    compose
  };
  exports.promiseReturningOperators = {
    every,
    forEach,
    reduce: reduce2,
    toArray,
    some,
    find
  };
});

// node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS((exports, module) => {
  var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
  var { isIterable, isNodeStream, isWebStream } = require_utils3();
  var { pipelineImpl: pl } = require_pipeline();
  var { finished } = require_end_of_stream();
  require_stream();
  function pipeline(...streams) {
    return new Promise2((resolve, reject) => {
      let signal;
      let end;
      const lastArg = streams[streams.length - 1];
      if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
        const options = ArrayPrototypePop(streams);
        signal = options.signal;
        end = options.end;
      }
      pl(streams, (err, value) => {
        if (err) {
          reject(err);
        } else {
          resolve(value);
        }
      }, {
        signal,
        end
      });
    });
  }
  module.exports = {
    finished,
    pipeline
  };
});

// node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("buffer");
  var { ObjectDefineProperty: ObjectDefineProperty2, ObjectKeys, ReflectApply } = require_primordials();
  var {
    promisify: { custom: customPromisify }
  } = require_util2();
  var { streamReturningOperators, promiseReturningOperators } = require_operators();
  var {
    codes: { ERR_ILLEGAL_CONSTRUCTOR }
  } = require_errors();
  var compose = require_compose();
  var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
  var { pipeline } = require_pipeline();
  var { destroyer } = require_destroy2();
  var eos = require_end_of_stream();
  var promises = require_promises();
  var utils = require_utils3();
  var Stream = module.exports = require_legacy().Stream;
  Stream.isDestroyed = utils.isDestroyed;
  Stream.isDisturbed = utils.isDisturbed;
  Stream.isErrored = utils.isErrored;
  Stream.isReadable = utils.isReadable;
  Stream.isWritable = utils.isWritable;
  Stream.Readable = require_readable2();
  for (const key12 of ObjectKeys(streamReturningOperators)) {
    let fn = function(...args) {
      if (new.target) {
        throw ERR_ILLEGAL_CONSTRUCTOR();
      }
      return Stream.Readable.from(ReflectApply(op, this, args));
    };
    const op = streamReturningOperators[key12];
    ObjectDefineProperty2(fn, "name", {
      __proto__: null,
      value: op.name
    });
    ObjectDefineProperty2(fn, "length", {
      __proto__: null,
      value: op.length
    });
    ObjectDefineProperty2(Stream.Readable.prototype, key12, {
      __proto__: null,
      value: fn,
      enumerable: false,
      configurable: true,
      writable: true
    });
  }
  for (const key12 of ObjectKeys(promiseReturningOperators)) {
    let fn = function(...args) {
      if (new.target) {
        throw ERR_ILLEGAL_CONSTRUCTOR();
      }
      return ReflectApply(op, this, args);
    };
    const op = promiseReturningOperators[key12];
    ObjectDefineProperty2(fn, "name", {
      __proto__: null,
      value: op.name
    });
    ObjectDefineProperty2(fn, "length", {
      __proto__: null,
      value: op.length
    });
    ObjectDefineProperty2(Stream.Readable.prototype, key12, {
      __proto__: null,
      value: fn,
      enumerable: false,
      configurable: true,
      writable: true
    });
  }
  Stream.Writable = require_writable();
  Stream.Duplex = require_duplex();
  Stream.Transform = require_transform();
  Stream.PassThrough = require_passthrough2();
  Stream.pipeline = pipeline;
  var { addAbortSignal } = require_add_abort_signal();
  Stream.addAbortSignal = addAbortSignal;
  Stream.finished = eos;
  Stream.destroy = destroyer;
  Stream.compose = compose;
  Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
  Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
  ObjectDefineProperty2(Stream, "promises", {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get() {
      return promises;
    }
  });
  ObjectDefineProperty2(pipeline, customPromisify, {
    __proto__: null,
    enumerable: true,
    get() {
      return promises.pipeline;
    }
  });
  ObjectDefineProperty2(eos, customPromisify, {
    __proto__: null,
    enumerable: true,
    get() {
      return promises.finished;
    }
  });
  Stream.Stream = Stream;
  Stream._isUint8Array = function isUint8Array(value) {
    return value instanceof Uint8Array;
  };
  Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  };
});

// node_modules/readable-stream/lib/ours/index.js
var require_ours = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (Stream && process.env.READABLE_STREAM === "disable") {
    const promises = Stream.promises;
    module.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer;
    module.exports._isUint8Array = Stream._isUint8Array;
    module.exports.isDisturbed = Stream.isDisturbed;
    module.exports.isErrored = Stream.isErrored;
    module.exports.isReadable = Stream.isReadable;
    module.exports.Readable = Stream.Readable;
    module.exports.Writable = Stream.Writable;
    module.exports.Duplex = Stream.Duplex;
    module.exports.Transform = Stream.Transform;
    module.exports.PassThrough = Stream.PassThrough;
    module.exports.addAbortSignal = Stream.addAbortSignal;
    module.exports.finished = Stream.finished;
    module.exports.destroy = Stream.destroy;
    module.exports.pipeline = Stream.pipeline;
    module.exports.compose = Stream.compose;
    Object.defineProperty(Stream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module.exports.Stream = Stream.Stream;
  } else {
    const CustomStream = require_stream();
    const promises = require_promises();
    const originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable;
    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module.exports._isUint8Array = CustomStream._isUint8Array;
    module.exports.isDisturbed = CustomStream.isDisturbed;
    module.exports.isErrored = CustomStream.isErrored;
    module.exports.isReadable = CustomStream.isReadable;
    module.exports.Readable = CustomStream.Readable;
    module.exports.Writable = CustomStream.Writable;
    module.exports.Duplex = CustomStream.Duplex;
    module.exports.Transform = CustomStream.Transform;
    module.exports.PassThrough = CustomStream.PassThrough;
    module.exports.addAbortSignal = CustomStream.addAbortSignal;
    module.exports.finished = CustomStream.finished;
    module.exports.destroy = CustomStream.destroy;
    module.exports.destroy = originalDestroy;
    module.exports.pipeline = CustomStream.pipeline;
    module.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module.exports.Stream = CustomStream.Stream;
  }
  module.exports.default = module.exports;
});

// node_modules/lodash/_arrayPush.js
var require__arrayPush = __commonJS((exports, module) => {
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  module.exports = arrayPush;
});

// node_modules/lodash/_isFlattenable.js
var require__isFlattenable = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined;
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  module.exports = isFlattenable;
});

// node_modules/lodash/_baseFlatten.js
var require__baseFlatten = __commonJS((exports, module) => {
  var arrayPush = require__arrayPush();
  var isFlattenable = require__isFlattenable();
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  module.exports = baseFlatten;
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS((exports, module) => {
  var baseFlatten = require__baseFlatten();
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }
  module.exports = flatten;
});

// node_modules/lodash/_nativeCreate.js
var require__nativeCreate = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var nativeCreate = getNative(Object, "create");
  module.exports = nativeCreate;
});

// node_modules/lodash/_hashClear.js
var require__hashClear = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  module.exports = hashClear;
});

// node_modules/lodash/_hashDelete.js
var require__hashDelete = __commonJS((exports, module) => {
  function hashDelete(key12) {
    var result = this.has(key12) && delete this.__data__[key12];
    this.size -= result ? 1 : 0;
    return result;
  }
  module.exports = hashDelete;
});

// node_modules/lodash/_hashGet.js
var require__hashGet = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashGet(key12) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key12];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key12) ? data[key12] : undefined;
  }
  module.exports = hashGet;
});

// node_modules/lodash/_hashHas.js
var require__hashHas = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashHas(key12) {
    var data = this.__data__;
    return nativeCreate ? data[key12] !== undefined : hasOwnProperty.call(data, key12);
  }
  module.exports = hashHas;
});

// node_modules/lodash/_hashSet.js
var require__hashSet = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key12, value) {
    var data = this.__data__;
    this.size += this.has(key12) ? 0 : 1;
    data[key12] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }
  module.exports = hashSet;
});

// node_modules/lodash/_Hash.js
var require__Hash = __commonJS((exports, module) => {
  var hashClear = require__hashClear();
  var hashDelete = require__hashDelete();
  var hashGet = require__hashGet();
  var hashHas = require__hashHas();
  var hashSet = require__hashSet();
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  module.exports = Hash;
});

// node_modules/lodash/_listCacheClear.js
var require__listCacheClear = __commonJS((exports, module) => {
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  module.exports = listCacheClear;
});

// node_modules/lodash/_assocIndexOf.js
var require__assocIndexOf = __commonJS((exports, module) => {
  var eq = require_eq();
  function assocIndexOf(array, key12) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key12)) {
        return length;
      }
    }
    return -1;
  }
  module.exports = assocIndexOf;
});

// node_modules/lodash/_listCacheDelete.js
var require__listCacheDelete = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key12) {
    var data = this.__data__, index = assocIndexOf(data, key12);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  module.exports = listCacheDelete;
});

// node_modules/lodash/_listCacheGet.js
var require__listCacheGet = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheGet(key12) {
    var data = this.__data__, index = assocIndexOf(data, key12);
    return index < 0 ? undefined : data[index][1];
  }
  module.exports = listCacheGet;
});

// node_modules/lodash/_listCacheHas.js
var require__listCacheHas = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheHas(key12) {
    return assocIndexOf(this.__data__, key12) > -1;
  }
  module.exports = listCacheHas;
});

// node_modules/lodash/_listCacheSet.js
var require__listCacheSet = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheSet(key12, value) {
    var data = this.__data__, index = assocIndexOf(data, key12);
    if (index < 0) {
      ++this.size;
      data.push([key12, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  module.exports = listCacheSet;
});

// node_modules/lodash/_ListCache.js
var require__ListCache = __commonJS((exports, module) => {
  var listCacheClear = require__listCacheClear();
  var listCacheDelete = require__listCacheDelete();
  var listCacheGet = require__listCacheGet();
  var listCacheHas = require__listCacheHas();
  var listCacheSet = require__listCacheSet();
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  module.exports = ListCache;
});

// node_modules/lodash/_Map.js
var require__Map = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Map2 = getNative(root, "Map");
  module.exports = Map2;
});

// node_modules/lodash/_mapCacheClear.js
var require__mapCacheClear = __commonJS((exports, module) => {
  var Hash = require__Hash();
  var ListCache = require__ListCache();
  var Map2 = require__Map();
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  }
  module.exports = mapCacheClear;
});

// node_modules/lodash/_isKeyable.js
var require__isKeyable = __commonJS((exports, module) => {
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  module.exports = isKeyable;
});

// node_modules/lodash/_getMapData.js
var require__getMapData = __commonJS((exports, module) => {
  var isKeyable = require__isKeyable();
  function getMapData(map, key12) {
    var data = map.__data__;
    return isKeyable(key12) ? data[typeof key12 == "string" ? "string" : "hash"] : data.map;
  }
  module.exports = getMapData;
});

// node_modules/lodash/_mapCacheDelete.js
var require__mapCacheDelete = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheDelete(key12) {
    var result = getMapData(this, key12)["delete"](key12);
    this.size -= result ? 1 : 0;
    return result;
  }
  module.exports = mapCacheDelete;
});

// node_modules/lodash/_mapCacheGet.js
var require__mapCacheGet = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheGet(key12) {
    return getMapData(this, key12).get(key12);
  }
  module.exports = mapCacheGet;
});

// node_modules/lodash/_mapCacheHas.js
var require__mapCacheHas = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheHas(key12) {
    return getMapData(this, key12).has(key12);
  }
  module.exports = mapCacheHas;
});

// node_modules/lodash/_mapCacheSet.js
var require__mapCacheSet = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheSet(key12, value) {
    var data = getMapData(this, key12), size = data.size;
    data.set(key12, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  module.exports = mapCacheSet;
});

// node_modules/lodash/_MapCache.js
var require__MapCache = __commonJS((exports, module) => {
  var mapCacheClear = require__mapCacheClear();
  var mapCacheDelete = require__mapCacheDelete();
  var mapCacheGet = require__mapCacheGet();
  var mapCacheHas = require__mapCacheHas();
  var mapCacheSet = require__mapCacheSet();
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  module.exports = MapCache;
});

// node_modules/lodash/_setCacheAdd.js
var require__setCacheAdd = __commonJS((exports, module) => {
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  module.exports = setCacheAdd;
});

// node_modules/lodash/_setCacheHas.js
var require__setCacheHas = __commonJS((exports, module) => {
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  module.exports = setCacheHas;
});

// node_modules/lodash/_SetCache.js
var require__SetCache = __commonJS((exports, module) => {
  var MapCache = require__MapCache();
  var setCacheAdd = require__setCacheAdd();
  var setCacheHas = require__setCacheHas();
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  module.exports = SetCache;
});

// node_modules/lodash/_baseFindIndex.js
var require__baseFindIndex = __commonJS((exports, module) => {
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  module.exports = baseFindIndex;
});

// node_modules/lodash/_baseIsNaN.js
var require__baseIsNaN = __commonJS((exports, module) => {
  function baseIsNaN(value) {
    return value !== value;
  }
  module.exports = baseIsNaN;
});

// node_modules/lodash/_strictIndexOf.js
var require__strictIndexOf = __commonJS((exports, module) => {
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  module.exports = strictIndexOf;
});

// node_modules/lodash/_baseIndexOf.js
var require__baseIndexOf = __commonJS((exports, module) => {
  var baseFindIndex = require__baseFindIndex();
  var baseIsNaN = require__baseIsNaN();
  var strictIndexOf = require__strictIndexOf();
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  module.exports = baseIndexOf;
});

// node_modules/lodash/_arrayIncludes.js
var require__arrayIncludes = __commonJS((exports, module) => {
  var baseIndexOf = require__baseIndexOf();
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  module.exports = arrayIncludes;
});

// node_modules/lodash/_arrayIncludesWith.js
var require__arrayIncludesWith = __commonJS((exports, module) => {
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  module.exports = arrayIncludesWith;
});

// node_modules/lodash/_arrayMap.js
var require__arrayMap = __commonJS((exports, module) => {
  function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  module.exports = arrayMap;
});

// node_modules/lodash/_cacheHas.js
var require__cacheHas = __commonJS((exports, module) => {
  function cacheHas(cache, key12) {
    return cache.has(key12);
  }
  module.exports = cacheHas;
});

// node_modules/lodash/_baseDifference.js
var require__baseDifference = __commonJS((exports, module) => {
  var SetCache = require__SetCache();
  var arrayIncludes = require__arrayIncludes();
  var arrayIncludesWith = require__arrayIncludesWith();
  var arrayMap = require__arrayMap();
  var baseUnary = require__baseUnary();
  var cacheHas = require__cacheHas();
  var LARGE_ARRAY_SIZE = 200;
  function baseDifference(array, values, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
    if (!length) {
      return result;
    }
    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }
    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee == null ? value : iteratee(value);
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
    return result;
  }
  module.exports = baseDifference;
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS((exports, module) => {
  var isArrayLike = require_isArrayLike2();
  var isObjectLike = require_isObjectLike();
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  module.exports = isArrayLikeObject;
});

// node_modules/lodash/difference.js
var require_difference = __commonJS((exports, module) => {
  var baseDifference = require__baseDifference();
  var baseFlatten = require__baseFlatten();
  var baseRest = require__baseRest();
  var isArrayLikeObject = require_isArrayLikeObject();
  var difference = baseRest(function(array, values) {
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
  });
  module.exports = difference;
});

// node_modules/lodash/_Set.js
var require__Set = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Set2 = getNative(root, "Set");
  module.exports = Set2;
});

// node_modules/lodash/noop.js
var require_noop2 = __commonJS((exports, module) => {
  function noop() {
  }
  module.exports = noop;
});

// node_modules/lodash/_setToArray.js
var require__setToArray = __commonJS((exports, module) => {
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  module.exports = setToArray;
});

// node_modules/lodash/_createSet.js
var require__createSet = __commonJS((exports, module) => {
  var Set2 = require__Set();
  var noop = require_noop2();
  var setToArray = require__setToArray();
  var INFINITY = 1 / 0;
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
    return new Set2(values);
  };
  module.exports = createSet;
});

// node_modules/lodash/_baseUniq.js
var require__baseUniq = __commonJS((exports, module) => {
  var SetCache = require__SetCache();
  var arrayIncludes = require__arrayIncludes();
  var arrayIncludesWith = require__arrayIncludesWith();
  var cacheHas = require__cacheHas();
  var createSet = require__createSet();
  var setToArray = require__setToArray();
  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache;
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  module.exports = baseUniq;
});

// node_modules/lodash/union.js
var require_union = __commonJS((exports, module) => {
  var baseFlatten = require__baseFlatten();
  var baseRest = require__baseRest();
  var baseUniq = require__baseUniq();
  var isArrayLikeObject = require_isArrayLikeObject();
  var union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
  });
  module.exports = union;
});

// node_modules/lodash/_overArg.js
var require__overArg = __commonJS((exports, module) => {
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  module.exports = overArg;
});

// node_modules/lodash/_getPrototype.js
var require__getPrototype = __commonJS((exports, module) => {
  var overArg = require__overArg();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  module.exports = getPrototype;
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag();
  var getPrototype = require__getPrototype();
  var isObjectLike = require_isObjectLike();
  var objectTag = "[object Object]";
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject11(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto2 = getPrototype(value);
    if (proto2 === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  module.exports = isPlainObject11;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js
var require_assert_valid_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertValidPattern = undefined;
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = (pattern) => {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  exports.assertValidPattern = assertValidPattern;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/brace-expressions.js
var require_brace_expressions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseClass = undefined;
  var posixClasses = {
    "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
    "[:alpha:]": ["\\p{L}\\p{Nl}", true],
    "[:ascii:]": ["\\x" + "00-\\x" + "7f", false],
    "[:blank:]": ["\\p{Zs}\\t", true],
    "[:cntrl:]": ["\\p{Cc}", true],
    "[:digit:]": ["\\p{Nd}", true],
    "[:graph:]": ["\\p{Z}\\p{C}", true, true],
    "[:lower:]": ["\\p{Ll}", true],
    "[:print:]": ["\\p{C}", true],
    "[:punct:]": ["\\p{P}", true],
    "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
    "[:upper:]": ["\\p{Lu}", true],
    "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
    "[:xdigit:]": ["A-Fa-f0-9", false]
  };
  var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
  var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var rangesToString = (ranges) => ranges.join("");
  var parseClass = (glob, position) => {
    const pos = position;
    if (glob.charAt(pos) !== "[") {
      throw new Error("not in a brace expression");
    }
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = "";
    WHILE:
      while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = true;
          i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        sawStart = true;
        if (c === "\\") {
          if (!escaping) {
            escaping = true;
            i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob.startsWith(cls, i)) {
              if (rangeStart) {
                return ["$.", false, glob.length - pos, true];
              }
              i += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          } else if (c === rangeStart) {
            ranges.push(braceEscape(c));
          }
          rangeStart = "";
          i++;
          continue;
        }
        if (glob.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-"));
          i += 2;
          continue;
        }
        if (glob.startsWith("-", i + 1)) {
          rangeStart = c;
          i += 2;
          continue;
        }
        ranges.push(braceEscape(c));
        i++;
      }
    if (endPos < i) {
      return ["", false, 0, false];
    }
    if (!ranges.length && !negs.length) {
      return ["$.", false, glob.length - pos, true];
    }
    if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
      const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
      return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
    const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
    const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
    return [comb, uflag, endPos - pos, true];
  };
  exports.parseClass = parseClass;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/unescape.js
var require_unescape = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unescape = undefined;
  var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
    return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  };
  exports.unescape = unescape;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/ast.js
var require_ast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AST = undefined;
  var brace_expressions_js_1 = require_brace_expressions();
  var unescape_js_1 = require_unescape();
  var types = new Set(["!", "?", "+", "*", "@"]);
  var isExtglobType = (c) => types.has(c);
  var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
  var startNoDot = "(?!\\.)";
  var addPatternStart = new Set(["[", "."]);
  var justDots = new Set(["..", "."]);
  var reSpecials = new Set("().*{}+?[]^$\\!");
  var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var qmark = "[^/]";
  var star = qmark + "*?";
  var starNoEmpty = qmark + "+?";

  class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    #emptyExt = false;
    constructor(type, parent, options = {}) {
      this.type = type;
      if (type)
        this.#hasMagic = true;
      this.#parent = parent;
      this.#root = this.#parent ? this.#parent.#root : this;
      this.#options = this.#root === this ? options : this.#root.#options;
      this.#negs = this.#root === this ? [] : this.#root.#negs;
      if (type === "!" && !this.#root.#filledNegs)
        this.#negs.push(this);
      this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
      if (this.#hasMagic !== undefined)
        return this.#hasMagic;
      for (const p of this.#parts) {
        if (typeof p === "string")
          continue;
        if (p.type || p.hasMagic)
          return this.#hasMagic = true;
      }
      return this.#hasMagic;
    }
    toString() {
      if (this.#toString !== undefined)
        return this.#toString;
      if (!this.type) {
        return this.#toString = this.#parts.map((p) => String(p)).join("");
      } else {
        return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
      }
    }
    #fillNegs() {
      if (this !== this.#root)
        throw new Error("should only call on root");
      if (this.#filledNegs)
        return this;
      this.toString();
      this.#filledNegs = true;
      let n;
      while (n = this.#negs.pop()) {
        if (n.type !== "!")
          continue;
        let p = n;
        let pp = p.#parent;
        while (pp) {
          for (let i = p.#parentIndex + 1;!pp.type && i < pp.#parts.length; i++) {
            for (const part of n.#parts) {
              if (typeof part === "string") {
                throw new Error("string part in extglob AST??");
              }
              part.copyIn(pp.#parts[i]);
            }
          }
          p = pp;
          pp = p.#parent;
        }
      }
      return this;
    }
    push(...parts) {
      for (const p of parts) {
        if (p === "")
          continue;
        if (typeof p !== "string" && !(p instanceof AST && p.#parent === this)) {
          throw new Error("invalid part: " + p);
        }
        this.#parts.push(p);
      }
    }
    toJSON() {
      const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
      if (this.isStart() && !this.type)
        ret.unshift([]);
      if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
        ret.push({});
      }
      return ret;
    }
    isStart() {
      if (this.#root === this)
        return true;
      if (!this.#parent?.isStart())
        return false;
      if (this.#parentIndex === 0)
        return true;
      const p = this.#parent;
      for (let i = 0;i < this.#parentIndex; i++) {
        const pp = p.#parts[i];
        if (!(pp instanceof AST && pp.type === "!")) {
          return false;
        }
      }
      return true;
    }
    isEnd() {
      if (this.#root === this)
        return true;
      if (this.#parent?.type === "!")
        return true;
      if (!this.#parent?.isEnd())
        return false;
      if (!this.type)
        return this.#parent?.isEnd();
      const pl = this.#parent ? this.#parent.#parts.length : 0;
      return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
      if (typeof part === "string")
        this.push(part);
      else
        this.push(part.clone(this));
    }
    clone(parent) {
      const c = new AST(this.type, parent);
      for (const p of this.#parts) {
        c.copyIn(p);
      }
      return c;
    }
    static #parseAST(str, ast, pos, opt) {
      let escaping = false;
      let inBrace = false;
      let braceStart = -1;
      let braceNeg = false;
      if (ast.type === null) {
        let i2 = pos;
        let acc2 = "";
        while (i2 < str.length) {
          const c = str.charAt(i2++);
          if (escaping || c === "\\") {
            escaping = !escaping;
            acc2 += c;
            continue;
          }
          if (inBrace) {
            if (i2 === braceStart + 1) {
              if (c === "^" || c === "!") {
                braceNeg = true;
              }
            } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
              inBrace = false;
            }
            acc2 += c;
            continue;
          } else if (c === "[") {
            inBrace = true;
            braceStart = i2;
            braceNeg = false;
            acc2 += c;
            continue;
          }
          if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
            ast.push(acc2);
            acc2 = "";
            const ext = new AST(c, ast);
            i2 = AST.#parseAST(str, ext, i2, opt);
            ast.push(ext);
            continue;
          }
          acc2 += c;
        }
        ast.push(acc2);
        return i2;
      }
      let i = pos + 1;
      let part = new AST(null, ast);
      const parts = [];
      let acc = "";
      while (i < str.length) {
        const c = str.charAt(i++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc += c;
          continue;
        }
        if (inBrace) {
          if (i === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i;
          braceNeg = false;
          acc += c;
          continue;
        }
        if (isExtglobType(c) && str.charAt(i) === "(") {
          part.push(acc);
          acc = "";
          const ext = new AST(c, part);
          part.push(ext);
          i = AST.#parseAST(str, ext, i, opt);
          continue;
        }
        if (c === "|") {
          part.push(acc);
          acc = "";
          parts.push(part);
          part = new AST(null, ast);
          continue;
        }
        if (c === ")") {
          if (acc === "" && ast.#parts.length === 0) {
            ast.#emptyExt = true;
          }
          part.push(acc);
          acc = "";
          ast.push(...parts, part);
          return i;
        }
        acc += c;
      }
      ast.type = null;
      ast.#hasMagic = undefined;
      ast.#parts = [str.substring(pos - 1)];
      return i;
    }
    static fromGlob(pattern, options = {}) {
      const ast = new AST(null, undefined, options);
      AST.#parseAST(pattern, ast, 0, options);
      return ast;
    }
    toMMPattern() {
      if (this !== this.#root)
        return this.#root.toMMPattern();
      const glob = this.toString();
      const [re, body, hasMagic, uflag] = this.toRegExpSource();
      const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
      if (!anyMagic) {
        return body;
      }
      const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
      return Object.assign(new RegExp(`^${re}$`, flags), {
        _src: re,
        _glob: glob
      });
    }
    get options() {
      return this.#options;
    }
    toRegExpSource(allowDot) {
      const dot = allowDot ?? !!this.#options.dot;
      if (this.#root === this)
        this.#fillNegs();
      if (!this.type) {
        const noEmpty = this.isStart() && this.isEnd();
        const src = this.#parts.map((p) => {
          const [re, _3, hasMagic, uflag] = typeof p === "string" ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
          this.#hasMagic = this.#hasMagic || hasMagic;
          this.#uflag = this.#uflag || uflag;
          return re;
        }).join("");
        let start2 = "";
        if (this.isStart()) {
          if (typeof this.#parts[0] === "string") {
            const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
            if (!dotTravAllowed) {
              const aps = addPatternStart;
              const needNoTrav = dot && aps.has(src.charAt(0)) || src.startsWith("\\.") && aps.has(src.charAt(2)) || src.startsWith("\\.\\.") && aps.has(src.charAt(4));
              const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
              start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
            }
          }
        }
        let end = "";
        if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
          end = "(?:$|\\/)";
        }
        const final2 = start2 + src + end;
        return [
          final2,
          (0, unescape_js_1.unescape)(src),
          this.#hasMagic = !!this.#hasMagic,
          this.#uflag
        ];
      }
      const repeated = this.type === "*" || this.type === "+";
      const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
      let body = this.#partsToRegExp(dot);
      if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
        const s = this.toString();
        this.#parts = [s];
        this.type = null;
        this.#hasMagic = undefined;
        return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
      }
      let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
      if (bodyDotAllowed === body) {
        bodyDotAllowed = "";
      }
      if (bodyDotAllowed) {
        body = `(?:${body})(?:${bodyDotAllowed})*?`;
      }
      let final = "";
      if (this.type === "!" && this.#emptyExt) {
        final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
      } else {
        const close = this.type === "!" ? "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")" : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
        final = start + body + close;
      }
      return [
        final,
        (0, unescape_js_1.unescape)(body),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    #partsToRegExp(dot) {
      return this.#parts.map((p) => {
        if (typeof p === "string") {
          throw new Error("string type in extglob ast??");
        }
        const [re, _3, _hasMagic, uflag] = p.toRegExpSource(dot);
        this.#uflag = this.#uflag || uflag;
        return re;
      }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
      let escaping = false;
      let re = "";
      let uflag = false;
      for (let i = 0;i < glob.length; i++) {
        const c = glob.charAt(i);
        if (escaping) {
          escaping = false;
          re += (reSpecials.has(c) ? "\\" : "") + c;
          continue;
        }
        if (c === "\\") {
          if (i === glob.length - 1) {
            re += "\\\\";
          } else {
            escaping = true;
          }
          continue;
        }
        if (c === "[") {
          const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
          if (consumed) {
            re += src;
            uflag = uflag || needUflag;
            i += consumed - 1;
            hasMagic = hasMagic || magic;
            continue;
          }
        }
        if (c === "*") {
          if (noEmpty && glob === "*")
            re += starNoEmpty;
          else
            re += star;
          hasMagic = true;
          continue;
        }
        if (c === "?") {
          re += qmark;
          hasMagic = true;
          continue;
        }
        re += regExpEscape(c);
      }
      return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
    }
  }
  exports.AST = AST;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/escape.js
var require_escape = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escape = undefined;
  var escape = (s, { windowsPathsNoEscape = false } = {}) => {
    return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
  };
  exports.escape = escape;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/index.js
var require_commonjs = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = undefined;
  var brace_expansion_1 = __importDefault(require_brace_expansion());
  var assert_valid_pattern_js_1 = require_assert_valid_pattern();
  var ast_js_1 = require_ast();
  var escape_js_1 = require_escape();
  var unescape_js_1 = require_unescape();
  var minimatch = (p, pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  };
  exports.minimatch = minimatch;
  var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
  var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
  var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
  var starDotExtTestNocase = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
  };
  var starDotExtTestNocaseDot = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext2);
  };
  var starDotStarRE = /^\*+\.\*+$/;
  var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
  var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
  var dotStarRE = /^\.\*+$/;
  var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
  var starRE = /^\*+$/;
  var starTest = (f) => f.length !== 0 && !f.startsWith(".");
  var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
  var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
  var qmarksTestNocase = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext2)
      return noext;
    ext2 = ext2.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
  };
  var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext2)
      return noext;
    ext2 = ext2.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
  };
  var qmarksTestDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
  };
  var qmarksTest = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
  };
  var qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith(".");
  };
  var qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== "." && f !== "..";
  };
  var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
  var path3 = {
    win32: { sep: "\\" },
    posix: { sep: "/" }
  };
  exports.sep = defaultPlatform === "win32" ? path3.win32.sep : path3.posix.sep;
  exports.minimatch.sep = exports.sep;
  exports.GLOBSTAR = Symbol("globstar **");
  exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var filter2 = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
  exports.filter = filter2;
  exports.minimatch.filter = exports.filter;
  var ext = (a, b = {}) => Object.assign({}, a, b);
  var defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return exports.minimatch;
    }
    const orig = exports.minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
      Minimatch: class Minimatch2 extends orig.Minimatch {
        constructor(pattern, options = {}) {
          super(pattern, ext(def, options));
        }
        static defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        }
      },
      AST: class AST extends orig.AST {
        constructor(type, parent, options = {}) {
          super(type, parent, ext(def, options));
        }
        static fromGlob(pattern, options = {}) {
          return orig.AST.fromGlob(pattern, ext(def, options));
        }
      },
      unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
      escape: (s, options = {}) => orig.escape(s, ext(def, options)),
      filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
      defaults: (options) => orig.defaults(ext(def, options)),
      makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
      braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
      match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
      sep: orig.sep,
      GLOBSTAR: exports.GLOBSTAR
    });
  };
  exports.defaults = defaults;
  exports.minimatch.defaults = exports.defaults;
  var braceExpand = (pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return (0, brace_expansion_1.default)(pattern);
  };
  exports.braceExpand = braceExpand;
  exports.minimatch.braceExpand = exports.braceExpand;
  var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
  exports.makeRe = makeRe;
  exports.minimatch.makeRe = exports.makeRe;
  var match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter((f) => mm.match(f));
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  exports.match = match;
  exports.minimatch.match = exports.match;
  var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
  var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");

  class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      options = options || {};
      this.options = options;
      this.pattern = pattern;
      this.platform = options.platform || defaultPlatform;
      this.isWindows = this.platform === "win32";
      this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        this.pattern = this.pattern.replace(/\\/g, "/");
      }
      this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
      this.regexp = null;
      this.negate = false;
      this.nonegate = !!options.nonegate;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.nocase = !!this.options.nocase;
      this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
      this.globSet = [];
      this.globParts = [];
      this.set = [];
      this.make();
    }
    hasMagic() {
      if (this.options.magicalBraces && this.set.length > 1) {
        return true;
      }
      for (const pattern of this.set) {
        for (const part of pattern) {
          if (typeof part !== "string")
            return true;
        }
      }
      return false;
    }
    debug(..._3) {
    }
    make() {
      const pattern = this.pattern;
      const options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      this.globSet = [...new Set(this.braceExpand())];
      if (options.debug) {
        this.debug = (...args) => console.error(...args);
      }
      this.debug(this.pattern, this.globSet);
      const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
      this.globParts = this.preprocess(rawGlobParts);
      this.debug(this.pattern, this.globParts);
      let set = this.globParts.map((s, _3, __) => {
        if (this.isWindows && this.windowsNoMagicRoot) {
          const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
          const isDrive = /^[a-z]:/i.test(s[0]);
          if (isUNC) {
            return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
          } else if (isDrive) {
            return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
          }
        }
        return s.map((ss) => this.parse(ss));
      });
      this.debug(this.pattern, set);
      this.set = set.filter((s) => s.indexOf(false) === -1);
      if (this.isWindows) {
        for (let i = 0;i < this.set.length; i++) {
          const p = this.set[i];
          if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
            p[2] = "?";
          }
        }
      }
      this.debug(this.pattern, this.set);
    }
    preprocess(globParts) {
      if (this.options.noglobstar) {
        for (let i = 0;i < globParts.length; i++) {
          for (let j = 0;j < globParts[i].length; j++) {
            if (globParts[i][j] === "**") {
              globParts[i][j] = "*";
            }
          }
        }
      }
      const { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2) {
        globParts = this.firstPhasePreProcess(globParts);
        globParts = this.secondPhasePreProcess(globParts);
      } else if (optimizationLevel >= 1) {
        globParts = this.levelOneOptimize(globParts);
      } else {
        globParts = this.adjascentGlobstarOptimize(globParts);
      }
      return globParts;
    }
    adjascentGlobstarOptimize(globParts) {
      return globParts.map((parts) => {
        let gs = -1;
        while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
          let i = gs;
          while (parts[i + 1] === "**") {
            i++;
          }
          if (i !== gs) {
            parts.splice(gs, i - gs);
          }
        }
        return parts;
      });
    }
    levelOneOptimize(globParts) {
      return globParts.map((parts) => {
        parts = parts.reduce((set, part) => {
          const prev = set[set.length - 1];
          if (part === "**" && prev === "**") {
            return set;
          }
          if (part === "..") {
            if (prev && prev !== ".." && prev !== "." && prev !== "**") {
              set.pop();
              return set;
            }
          }
          set.push(part);
          return set;
        }, []);
        return parts.length === 0 ? [""] : parts;
      });
    }
    levelTwoFileOptimize(parts) {
      if (!Array.isArray(parts)) {
        parts = this.slashSplit(parts);
      }
      let didSomething = false;
      do {
        didSomething = false;
        if (!this.preserveMultipleSlashes) {
          for (let i = 1;i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            parts.splice(dd - 1, 2);
            dd -= 2;
          }
        }
      } while (didSomething);
      return parts.length === 0 ? [""] : parts;
    }
    firstPhasePreProcess(globParts) {
      let didSomething = false;
      do {
        didSomething = false;
        for (let parts of globParts) {
          let gs = -1;
          while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
            let gss = gs;
            while (parts[gss + 1] === "**") {
              gss++;
            }
            if (gss > gs) {
              parts.splice(gs + 1, gss - gs);
            }
            let next = parts[gs + 1];
            const p = parts[gs + 2];
            const p2 = parts[gs + 3];
            if (next !== "..")
              continue;
            if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
              continue;
            }
            didSomething = true;
            parts.splice(gs, 1);
            const other = parts.slice(0);
            other[gs] = "**";
            globParts.push(other);
            gs--;
          }
          if (!this.preserveMultipleSlashes) {
            for (let i = 1;i < parts.length - 1; i++) {
              const p = parts[i];
              if (i === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "") {
                didSomething = true;
                parts.splice(i, 1);
                i--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd = 0;
          while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
            const p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = true;
              const needDot = dd === 1 && parts[dd + 1] === "**";
              const splin = needDot ? ["."] : [];
              parts.splice(dd - 1, 2, ...splin);
              if (parts.length === 0)
                parts.push("");
              dd -= 2;
            }
          }
        }
      } while (didSomething);
      return globParts;
    }
    secondPhasePreProcess(globParts) {
      for (let i = 0;i < globParts.length - 1; i++) {
        for (let j = i + 1;j < globParts.length; j++) {
          const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
          if (matched) {
            globParts[i] = [];
            globParts[j] = matched;
            break;
          }
        }
      }
      return globParts.filter((gs) => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
      let ai = 0;
      let bi = 0;
      let result = [];
      let which = "";
      while (ai < a.length && bi < b.length) {
        if (a[ai] === b[bi]) {
          result.push(which === "b" ? b[bi] : a[ai]);
          ai++;
          bi++;
        } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
          result.push(a[ai]);
          ai++;
        } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
          result.push(b[bi]);
          bi++;
        } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
          if (which === "b")
            return false;
          which = "a";
          result.push(a[ai]);
          ai++;
          bi++;
        } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
          if (which === "a")
            return false;
          which = "b";
          result.push(b[bi]);
          ai++;
          bi++;
        } else {
          return false;
        }
      }
      return a.length === b.length && result;
    }
    parseNegate() {
      if (this.nonegate)
        return;
      const pattern = this.pattern;
      let negate = false;
      let negateOffset = 0;
      for (let i = 0;i < pattern.length && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.slice(negateOffset);
      this.negate = negate;
    }
    matchOne(file, pattern, partial = false) {
      const options = this.options;
      if (this.isWindows) {
        const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
        const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
        const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
        const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
        const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
        const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
        if (typeof fdi === "number" && typeof pdi === "number") {
          const [fd, pd] = [file[fdi], pattern[pdi]];
          if (fd.toLowerCase() === pd.toLowerCase()) {
            pattern[pdi] = fd;
            if (pdi > fdi) {
              pattern = pattern.slice(pdi);
            } else if (fdi > pdi) {
              file = file.slice(fdi);
            }
          }
        }
      }
      const { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2) {
        file = this.levelTwoFileOptimize(file);
      }
      this.debug("matchOne", this, { file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false) {
          return false;
        }
        if (p === exports.GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (;fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug(`
globstar while`, file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug(`
>>> no match, partial?`, file, fr, pattern, pr);
            if (fr === fl) {
              return true;
            }
          }
          return false;
        }
        let hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = p.test(f);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      } else {
        throw new Error("wtf?");
      }
    }
    braceExpand() {
      return (0, exports.braceExpand)(this.pattern, this.options);
    }
    parse(pattern) {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      const options = this.options;
      if (pattern === "**")
        return exports.GLOBSTAR;
      if (pattern === "")
        return "";
      let m;
      let fastTest = null;
      if (m = pattern.match(starRE)) {
        fastTest = options.dot ? starTestDot : starTest;
      } else if (m = pattern.match(starDotExtRE)) {
        fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
      } else if (m = pattern.match(qmarksRE)) {
        fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
      } else if (m = pattern.match(starDotStarRE)) {
        fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
      } else if (m = pattern.match(dotStarRE)) {
        fastTest = dotStarTest;
      }
      const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
      if (fastTest && typeof re === "object") {
        Reflect.defineProperty(re, "test", { value: fastTest });
      }
      return re;
    }
    makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      const set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      const options = this.options;
      const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      const flags = new Set(options.nocase ? ["i"] : []);
      let re = set.map((pattern) => {
        const pp = pattern.map((p) => {
          if (p instanceof RegExp) {
            for (const f of p.flags.split(""))
              flags.add(f);
          }
          return typeof p === "string" ? regExpEscape(p) : p === exports.GLOBSTAR ? exports.GLOBSTAR : p._src;
        });
        pp.forEach((p, i) => {
          const next = pp[i + 1];
          const prev = pp[i - 1];
          if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
            return;
          }
          if (prev === undefined) {
            if (next !== undefined && next !== exports.GLOBSTAR) {
              pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
            } else {
              pp[i] = twoStar;
            }
          } else if (next === undefined) {
            pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
          } else if (next !== exports.GLOBSTAR) {
            pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
            pp[i + 1] = exports.GLOBSTAR;
          }
        });
        return pp.filter((p) => p !== exports.GLOBSTAR).join("/");
      }).join("|");
      const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
      re = "^" + open + re + close + "$";
      if (this.negate)
        re = "^(?!" + re + ").+$";
      try {
        this.regexp = new RegExp(re, [...flags].join(""));
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    slashSplit(p) {
      if (this.preserveMultipleSlashes) {
        return p.split("/");
      } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
        return ["", ...p.split(/\/+/)];
      } else {
        return p.split(/\/+/);
      }
    }
    match(f, partial = this.partial) {
      this.debug("match", f, this.pattern);
      if (this.comment) {
        return false;
      }
      if (this.empty) {
        return f === "";
      }
      if (f === "/" && partial) {
        return true;
      }
      const options = this.options;
      if (this.isWindows) {
        f = f.split("\\").join("/");
      }
      const ff = this.slashSplit(f);
      this.debug(this.pattern, "split", ff);
      const set = this.set;
      this.debug(this.pattern, "set", set);
      let filename = ff[ff.length - 1];
      if (!filename) {
        for (let i = ff.length - 2;!filename && i >= 0; i--) {
          filename = ff[i];
        }
      }
      for (let i = 0;i < set.length; i++) {
        const pattern = set[i];
        let file = ff;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        const hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate) {
            return true;
          }
          return !this.negate;
        }
      }
      if (options.flipNegate) {
        return false;
      }
      return this.negate;
    }
    static defaults(def) {
      return exports.minimatch.defaults(def).Minimatch;
    }
  }
  exports.Minimatch = Minimatch;
  var ast_js_2 = require_ast();
  Object.defineProperty(exports, "AST", { enumerable: true, get: function() {
    return ast_js_2.AST;
  } });
  var escape_js_2 = require_escape();
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  var unescape_js_2 = require_unescape();
  Object.defineProperty(exports, "unescape", { enumerable: true, get: function() {
    return unescape_js_2.unescape;
  } });
  exports.minimatch.AST = ast_js_1.AST;
  exports.minimatch.Minimatch = Minimatch;
  exports.minimatch.escape = escape_js_1.escape;
  exports.minimatch.unescape = unescape_js_1.unescape;
});

// node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LRUCache = undefined;
  var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
  var warned = new Set;
  var PROCESS = typeof process === "object" && !!process ? process : {};
  var emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
  };
  var AC = globalThis.AbortController;
  var AS = globalThis.AbortSignal;
  if (typeof AC === "undefined") {
    AS = class AbortSignal {
      onabort;
      _onabort = [];
      reason;
      aborted = false;
      addEventListener(_3, fn) {
        this._onabort.push(fn);
      }
    };
    AC = class AbortController2 {
      constructor() {
        warnACPolyfill();
      }
      signal = new AS;
      abort(reason) {
        if (this.signal.aborted)
          return;
        this.signal.reason = reason;
        this.signal.aborted = true;
        for (const fn of this.signal._onabort) {
          fn(reason);
        }
        this.signal.onabort?.(reason);
      }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
    const warnACPolyfill = () => {
      if (!printACPolyfillWarning)
        return;
      printACPolyfillWarning = false;
      emitWarning("AbortController is not defined. If using lru-cache in " + "node 14, load an AbortController polyfill from the " + "`node-abort-controller` package. A minimal polyfill is " + "provided for use by LRUCache.fetch(), but it should not be " + "relied upon in other contexts (eg, passing it to other APIs that " + "use AbortController/AbortSignal might have undesirable effects). " + "You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
    };
  }
  var shouldWarn = (code) => !warned.has(code);
  var TYPE = Symbol("type");
  var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
  var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

  class ZeroArray extends Array {
    constructor(size) {
      super(size);
      this.fill(0);
    }
  }

  class Stack {
    heap;
    length;
    static #constructing = false;
    static create(max) {
      const HeapCls = getUintArray(max);
      if (!HeapCls)
        return [];
      Stack.#constructing = true;
      const s = new Stack(max, HeapCls);
      Stack.#constructing = false;
      return s;
    }
    constructor(max, HeapCls) {
      if (!Stack.#constructing) {
        throw new TypeError("instantiate Stack using Stack.create(n)");
      }
      this.heap = new HeapCls(max);
      this.length = 0;
    }
    push(n) {
      this.heap[this.length++] = n;
    }
    pop() {
      return this.heap[--this.length];
    }
  }

  class LRUCache {
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    ttl;
    ttlResolution;
    ttlAutopurge;
    updateAgeOnGet;
    updateAgeOnHas;
    allowStale;
    noDisposeOnSet;
    noUpdateTTL;
    maxEntrySize;
    sizeCalculation;
    noDeleteOnFetchRejection;
    noDeleteOnStaleGet;
    allowStaleOnFetchAbort;
    allowStaleOnFetchRejection;
    ignoreFetchAbort;
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    static unsafeExposeInternals(c) {
      return {
        starts: c.#starts,
        ttls: c.#ttls,
        sizes: c.#sizes,
        keyMap: c.#keyMap,
        keyList: c.#keyList,
        valList: c.#valList,
        next: c.#next,
        prev: c.#prev,
        get head() {
          return c.#head;
        },
        get tail() {
          return c.#tail;
        },
        free: c.#free,
        isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
        backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
        moveToTail: (index) => c.#moveToTail(index),
        indexes: (options) => c.#indexes(options),
        rindexes: (options) => c.#rindexes(options),
        isStale: (index) => c.#isStale(index)
      };
    }
    get max() {
      return this.#max;
    }
    get maxSize() {
      return this.#maxSize;
    }
    get calculatedSize() {
      return this.#calculatedSize;
    }
    get size() {
      return this.#size;
    }
    get fetchMethod() {
      return this.#fetchMethod;
    }
    get memoMethod() {
      return this.#memoMethod;
    }
    get dispose() {
      return this.#dispose;
    }
    get disposeAfter() {
      return this.#disposeAfter;
    }
    constructor(options) {
      const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
      if (max !== 0 && !isPosInt(max)) {
        throw new TypeError("max option must be a nonnegative integer");
      }
      const UintArray = max ? getUintArray(max) : Array;
      if (!UintArray) {
        throw new Error("invalid max value: " + max);
      }
      this.#max = max;
      this.#maxSize = maxSize;
      this.maxEntrySize = maxEntrySize || this.#maxSize;
      this.sizeCalculation = sizeCalculation;
      if (this.sizeCalculation) {
        if (!this.#maxSize && !this.maxEntrySize) {
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        }
        if (typeof this.sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation set to non-function");
        }
      }
      if (memoMethod !== undefined && typeof memoMethod !== "function") {
        throw new TypeError("memoMethod must be a function if defined");
      }
      this.#memoMethod = memoMethod;
      if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
        throw new TypeError("fetchMethod must be a function if specified");
      }
      this.#fetchMethod = fetchMethod;
      this.#hasFetchMethod = !!fetchMethod;
      this.#keyMap = new Map;
      this.#keyList = new Array(max).fill(undefined);
      this.#valList = new Array(max).fill(undefined);
      this.#next = new UintArray(max);
      this.#prev = new UintArray(max);
      this.#head = 0;
      this.#tail = 0;
      this.#free = Stack.create(max);
      this.#size = 0;
      this.#calculatedSize = 0;
      if (typeof dispose === "function") {
        this.#dispose = dispose;
      }
      if (typeof disposeAfter === "function") {
        this.#disposeAfter = disposeAfter;
        this.#disposed = [];
      } else {
        this.#disposeAfter = undefined;
        this.#disposed = undefined;
      }
      this.#hasDispose = !!this.#dispose;
      this.#hasDisposeAfter = !!this.#disposeAfter;
      this.noDisposeOnSet = !!noDisposeOnSet;
      this.noUpdateTTL = !!noUpdateTTL;
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
      this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
      this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
      this.ignoreFetchAbort = !!ignoreFetchAbort;
      if (this.maxEntrySize !== 0) {
        if (this.#maxSize !== 0) {
          if (!isPosInt(this.#maxSize)) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        }
        this.#initializeSizeTracking();
      }
      this.allowStale = !!allowStale;
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
      this.updateAgeOnGet = !!updateAgeOnGet;
      this.updateAgeOnHas = !!updateAgeOnHas;
      this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
      this.ttlAutopurge = !!ttlAutopurge;
      this.ttl = ttl || 0;
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError("ttl must be a positive integer if specified");
        }
        this.#initializeTTLTracking();
      }
      if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      }
      if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
        const code = "LRU_CACHE_UNBOUNDED";
        if (shouldWarn(code)) {
          warned.add(code);
          const msg = "TTL caching without ttlAutopurge, max, or maxSize can " + "result in unbounded memory consumption.";
          emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
        }
      }
    }
    getRemainingTTL(key12) {
      return this.#keyMap.has(key12) ? Infinity : 0;
    }
    #initializeTTLTracking() {
      const ttls = new ZeroArray(this.#max);
      const starts = new ZeroArray(this.#max);
      this.#ttls = ttls;
      this.#starts = starts;
      this.#setItemTTL = (index, ttl, start = perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (this.#isStale(index)) {
              this.#delete(this.#keyList[index], "expire");
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      };
      this.#updateItemAge = (index) => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
      };
      this.#statusTTL = (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start)
            return;
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      };
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key12) => {
        const index = this.#keyMap.get(key12);
        if (index === undefined) {
          return 0;
        }
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      this.#isStale = (index) => {
        const s = starts[index];
        const t = ttls[index];
        return !!t && !!s && (cachedNow || getNow()) - s > t;
      };
    }
    #updateItemAge = () => {
    };
    #statusTTL = () => {
    };
    #setItemTTL = () => {
    };
    #isStale = () => false;
    #initializeSizeTracking() {
      const sizes = new ZeroArray(this.#max);
      this.#calculatedSize = 0;
      this.#sizes = sizes;
      this.#removeItemSize = (index) => {
        this.#calculatedSize -= sizes[index];
        sizes[index] = 0;
      };
      this.#requireSize = (k, v, size, sizeCalculation) => {
        if (this.#isBackgroundFetch(v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). " + "When maxSize or maxEntrySize is used, sizeCalculation " + "or size must be set.");
          }
        }
        return size;
      };
      this.#addItemSize = (index, size, status) => {
        sizes[index] = size;
        if (this.#maxSize) {
          const maxSize = this.#maxSize - sizes[index];
          while (this.#calculatedSize > maxSize) {
            this.#evict(true);
          }
        }
        this.#calculatedSize += sizes[index];
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = this.#calculatedSize;
        }
      };
    }
    #removeItemSize = (_i) => {
    };
    #addItemSize = (_i, _s, _st) => {
    };
    #requireSize = (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#tail;; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#head) {
            break;
          } else {
            i = this.#prev[i];
          }
        }
      }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#head;; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#tail) {
            break;
          } else {
            i = this.#next[i];
          }
        }
      }
    }
    #isValidIndex(index) {
      return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
    }
    *entries() {
      for (const i of this.#indexes()) {
        if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    *rentries() {
      for (const i of this.#rindexes()) {
        if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    *keys() {
      for (const i of this.#indexes()) {
        const k = this.#keyList[i];
        if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    *rkeys() {
      for (const i of this.#rindexes()) {
        const k = this.#keyList[i];
        if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    *values() {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    *rvalues() {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    [Symbol.toStringTag] = "LRUCache";
    find(fn, getOptions = {}) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        if (fn(value, this.#keyList[i], this)) {
          return this.get(this.#keyList[i], getOptions);
        }
      }
    }
    forEach(fn, thisp = this) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    rforEach(fn, thisp = this) {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    purgeStale() {
      let deleted = false;
      for (const i of this.#rindexes({ allowStale: true })) {
        if (this.#isStale(i)) {
          this.#delete(this.#keyList[i], "expire");
          deleted = true;
        }
      }
      return deleted;
    }
    info(key12) {
      const i = this.#keyMap.get(key12);
      if (i === undefined)
        return;
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        return;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        const ttl = this.#ttls[i];
        const start = this.#starts[i];
        if (ttl && start) {
          const remain = ttl - (perf.now() - start);
          entry.ttl = remain;
          entry.start = Date.now();
        }
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      return entry;
    }
    dump() {
      const arr = [];
      for (const i of this.#indexes({ allowStale: true })) {
        const key12 = this.#keyList[i];
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined || key12 === undefined)
          continue;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          entry.ttl = this.#ttls[i];
          const age = perf.now() - this.#starts[i];
          entry.start = Math.floor(Date.now() - age);
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        arr.unshift([key12, entry]);
      }
      return arr;
    }
    load(arr) {
      this.clear();
      for (const [key12, entry] of arr) {
        if (entry.start) {
          const age = Date.now() - entry.start;
          entry.start = perf.now() - age;
        }
        this.set(key12, entry.value, entry);
      }
    }
    set(k, v, setOptions = {}) {
      if (v === undefined) {
        this.delete(k);
        return this;
      }
      const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
      let { noUpdateTTL = this.noUpdateTTL } = setOptions;
      const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status) {
          status.set = "miss";
          status.maxEntrySizeExceeded = true;
        }
        this.#delete(k, "set");
        return this;
      }
      let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
      if (index === undefined) {
        index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
        this.#keyList[index] = k;
        this.#valList[index] = v;
        this.#keyMap.set(k, index);
        this.#next[this.#tail] = index;
        this.#prev[index] = this.#tail;
        this.#tail = index;
        this.#size++;
        this.#addItemSize(index, size, status);
        if (status)
          status.set = "add";
        noUpdateTTL = false;
      } else {
        this.#moveToTail(index);
        const oldVal = this.#valList[index];
        if (v !== oldVal) {
          if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort(new Error("replaced"));
            const { __staleWhileFetching: s } = oldVal;
            if (s !== undefined && !noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(s, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([s, k, "set"]);
              }
            }
          } else if (!noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(oldVal, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([oldVal, k, "set"]);
            }
          }
          this.#removeItemSize(index);
          this.#addItemSize(index, size, status);
          this.#valList[index] = v;
          if (status) {
            status.set = "replace";
            const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
            if (oldValue !== undefined)
              status.oldValue = oldValue;
          }
        } else if (status) {
          status.set = "update";
        }
      }
      if (ttl !== 0 && !this.#ttls) {
        this.#initializeTTLTracking();
      }
      if (this.#ttls) {
        if (!noUpdateTTL) {
          this.#setItemTTL(index, ttl, start);
        }
        if (status)
          this.#statusTTL(status, index);
      }
      if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return this;
    }
    pop() {
      try {
        while (this.#size) {
          const val = this.#valList[this.#head];
          this.#evict(true);
          if (this.#isBackgroundFetch(val)) {
            if (val.__staleWhileFetching) {
              return val.__staleWhileFetching;
            }
          } else if (val !== undefined) {
            return val;
          }
        }
      } finally {
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    }
    #evict(free) {
      const head = this.#head;
      const k = this.#keyList[head];
      const v = this.#valList[head];
      if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if (this.#hasDispose || this.#hasDisposeAfter) {
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "evict");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "evict"]);
        }
      }
      this.#removeItemSize(head);
      if (free) {
        this.#keyList[head] = undefined;
        this.#valList[head] = undefined;
        this.#free.push(head);
      }
      if (this.#size === 1) {
        this.#head = this.#tail = 0;
        this.#free.length = 0;
      } else {
        this.#head = this.#next[head];
      }
      this.#keyMap.delete(k);
      this.#size--;
      return head;
    }
    has(k, hasOptions = {}) {
      const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
          return false;
        }
        if (!this.#isStale(index)) {
          if (updateAgeOnHas) {
            this.#updateItemAge(index);
          }
          if (status) {
            status.has = "hit";
            this.#statusTTL(status, index);
          }
          return true;
        } else if (status) {
          status.has = "stale";
          this.#statusTTL(status, index);
        }
      } else if (status) {
        status.has = "miss";
      }
      return false;
    }
    peek(k, peekOptions = {}) {
      const { allowStale = this.allowStale } = peekOptions;
      const index = this.#keyMap.get(k);
      if (index === undefined || !allowStale && this.#isStale(index)) {
        return;
      }
      const v = this.#valList[index];
      return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
      const v = index === undefined ? undefined : this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        return v;
      }
      const ac = new AC;
      const { signal } = options;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options,
        context
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v2 !== undefined;
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        if (this.#valList[index] === p) {
          if (v2 === undefined) {
            if (bf2.__staleWhileFetching) {
              this.#valList[index] = bf2.__staleWhileFetching;
            } else {
              this.#delete(k, "fetch");
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        const bf2 = p;
        if (this.#valList[index] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === undefined;
          if (del) {
            this.#delete(k, "fetch");
          } else if (!allowStaleAborted) {
            this.#valList[index] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== undefined) {
            options.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        const fmp = this.#fetchMethod?.(k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2 === undefined ? undefined : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(undefined);
            if (options.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: undefined
      });
      if (index === undefined) {
        this.set(k, bf, { ...fetchOpts.options, status: undefined });
        index = this.#keyMap.get(k);
      } else {
        this.#valList[index] = bf;
      }
      return bf;
    }
    #isBackgroundFetch(p) {
      if (!this.#hasFetchMethod)
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    }
    async fetch(k, fetchOptions = {}) {
      const {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        context,
        forceRefresh = false,
        status,
        signal
      } = fetchOptions;
      if (!this.#hasFetchMethod) {
        if (status)
          status.fetch = "get";
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          status
        });
      }
      const options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort,
        status,
        signal
      };
      let index = this.#keyMap.get(k);
      if (index === undefined) {
        if (status)
          status.fetch = "miss";
        const p = this.#backgroundFetch(k, index, options, context);
        return p.__returned = p;
      } else {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          const stale = allowStale && v.__staleWhileFetching !== undefined;
          if (status) {
            status.fetch = "inflight";
            if (stale)
              status.returnedStale = true;
          }
          return stale ? v.__staleWhileFetching : v.__returned = v;
        }
        const isStale = this.#isStale(index);
        if (!forceRefresh && !isStale) {
          if (status)
            status.fetch = "hit";
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          if (status)
            this.#statusTTL(status, index);
          return v;
        }
        const p = this.#backgroundFetch(k, index, options, context);
        const hasStale = p.__staleWhileFetching !== undefined;
        const staleVal = hasStale && allowStale;
        if (status) {
          status.fetch = isStale ? "stale" : "refresh";
          if (staleVal && isStale)
            status.returnedStale = true;
        }
        return staleVal ? p.__staleWhileFetching : p.__returned = p;
      }
    }
    async forceFetch(k, fetchOptions = {}) {
      const v = await this.fetch(k, fetchOptions);
      if (v === undefined)
        throw new Error("fetch() returned undefined");
      return v;
    }
    memo(k, memoOptions = {}) {
      const memoMethod = this.#memoMethod;
      if (!memoMethod) {
        throw new Error("no memoMethod provided to constructor");
      }
      const { context, forceRefresh, ...options } = memoOptions;
      const v = this.get(k, options);
      if (!forceRefresh && v !== undefined)
        return v;
      const vv = memoMethod(k, v, {
        options,
        context
      });
      this.set(k, vv, options);
      return vv;
    }
    get(k, getOptions = {}) {
      const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        const value = this.#valList[index];
        const fetching = this.#isBackgroundFetch(value);
        if (status)
          this.#statusTTL(status, index);
        if (this.#isStale(index)) {
          if (status)
            status.get = "stale";
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.#delete(k, "expire");
            }
            if (status && allowStale)
              status.returnedStale = true;
            return allowStale ? value : undefined;
          } else {
            if (status && allowStale && value.__staleWhileFetching !== undefined) {
              status.returnedStale = true;
            }
            return allowStale ? value.__staleWhileFetching : undefined;
          }
        } else {
          if (status)
            status.get = "hit";
          if (fetching) {
            return value.__staleWhileFetching;
          }
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          return value;
        }
      } else if (status) {
        status.get = "miss";
      }
    }
    #connect(p, n) {
      this.#prev[n] = p;
      this.#next[p] = n;
    }
    #moveToTail(index) {
      if (index !== this.#tail) {
        if (index === this.#head) {
          this.#head = this.#next[index];
        } else {
          this.#connect(this.#prev[index], this.#next[index]);
        }
        this.#connect(this.#tail, index);
        this.#tail = index;
      }
    }
    delete(k) {
      return this.#delete(k, "delete");
    }
    #delete(k, reason) {
      let deleted = false;
      if (this.#size !== 0) {
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
          deleted = true;
          if (this.#size === 1) {
            this.#clear(reason);
          } else {
            this.#removeItemSize(index);
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
              v.__abortController.abort(new Error("deleted"));
            } else if (this.#hasDispose || this.#hasDisposeAfter) {
              if (this.#hasDispose) {
                this.#dispose?.(v, k, reason);
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, reason]);
              }
            }
            this.#keyMap.delete(k);
            this.#keyList[index] = undefined;
            this.#valList[index] = undefined;
            if (index === this.#tail) {
              this.#tail = this.#prev[index];
            } else if (index === this.#head) {
              this.#head = this.#next[index];
            } else {
              const pi = this.#prev[index];
              this.#next[pi] = this.#next[index];
              const ni = this.#next[index];
              this.#prev[ni] = this.#prev[index];
            }
            this.#size--;
            this.#free.push(index);
          }
        }
      }
      if (this.#hasDisposeAfter && this.#disposed?.length) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return deleted;
    }
    clear() {
      return this.#clear("delete");
    }
    #clear(reason) {
      for (const index of this.#rindexes({ allowStale: true })) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("deleted"));
        } else {
          const k = this.#keyList[index];
          if (this.#hasDispose) {
            this.#dispose?.(v, k, reason);
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, reason]);
          }
        }
      }
      this.#keyMap.clear();
      this.#valList.fill(undefined);
      this.#keyList.fill(undefined);
      if (this.#ttls && this.#starts) {
        this.#ttls.fill(0);
        this.#starts.fill(0);
      }
      if (this.#sizes) {
        this.#sizes.fill(0);
      }
      this.#head = 0;
      this.#tail = 0;
      this.#free.length = 0;
      this.#calculatedSize = 0;
      this.#size = 0;
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  exports.LRUCache = LRUCache;
});

// node_modules/minipass/dist/commonjs/index.js
var require_commonjs3 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = undefined;
  var proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  var node_events_1 = __require("node:events");
  var node_stream_1 = __importDefault(__require("node:stream"));
  var node_string_decoder_1 = __require("node:string_decoder");
  var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof node_stream_1.default || (0, exports.isReadable)(s) || (0, exports.isWritable)(s));
  exports.isStream = isStream;
  var isReadable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.pipe === "function" && s.pipe !== node_stream_1.default.Writable.prototype.pipe;
  exports.isReadable = isReadable;
  var isWritable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
  exports.isWritable = isWritable;
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var EMITTED_ERROR = Symbol("emittedError");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFER = Symbol("buffer");
  var PIPES = Symbol("pipes");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var ERROR = Symbol("error");
  var EMITDATA = Symbol("emitData");
  var EMITEND = Symbol("emitEnd");
  var EMITEND2 = Symbol("emitEnd2");
  var ASYNC = Symbol("async");
  var ABORT = Symbol("abort");
  var ABORTED = Symbol("aborted");
  var SIGNAL = Symbol("signal");
  var DATALISTENERS = Symbol("dataListeners");
  var DISCARDED = Symbol("discarded");
  var defer2 = (fn) => Promise.resolve().then(fn);
  var nodefer = (fn) => fn();
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

  class Pipe {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
      this.src = src;
      this.dest = dest;
      this.opts = opts;
      this.ondrain = () => src[RESUME]();
      this.dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    proxyErrors(_er) {
    }
    end() {
      this.unpipe();
      if (this.opts.end)
        this.dest.end();
    }
  }

  class PipeProxyErrors extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  }
  var isObjectModeOptions = (o) => !!o.objectMode;
  var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";

  class Minipass extends node_events_1.EventEmitter {
    [FLOWING] = false;
    [PAUSED] = false;
    [PIPES] = [];
    [BUFFER] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF] = false;
    [EMITTED_END] = false;
    [EMITTING_END] = false;
    [CLOSED] = false;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = false;
    [SIGNAL];
    [ABORTED] = false;
    [DATALISTENERS] = 0;
    [DISCARDED] = false;
    writable = true;
    readable = true;
    constructor(...args) {
      const options = args[0] || {};
      super();
      if (options.objectMode && typeof options.encoding === "string") {
        throw new TypeError("Encoding and objectMode may not be used together");
      }
      if (isObjectModeOptions(options)) {
        this[OBJECTMODE] = true;
        this[ENCODING] = null;
      } else if (isEncodingOptions(options)) {
        this[ENCODING] = options.encoding;
        this[OBJECTMODE] = false;
      } else {
        this[OBJECTMODE] = false;
        this[ENCODING] = null;
      }
      this[ASYNC] = !!options.async;
      this[DECODER] = this[ENCODING] ? new node_string_decoder_1.StringDecoder(this[ENCODING]) : null;
      if (options && options.debugExposeBuffer === true) {
        Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
      }
      if (options && options.debugExposePipes === true) {
        Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
      }
      const { signal } = options;
      if (signal) {
        this[SIGNAL] = signal;
        if (signal.aborted) {
          this[ABORT]();
        } else {
          signal.addEventListener("abort", () => this[ABORT]());
        }
      }
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    setEncoding(_enc) {
      throw new Error("Encoding must be set at instantiation time");
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(_om) {
      throw new Error("objectMode must be set at instantiation time");
    }
    get ["async"]() {
      return this[ASYNC];
    }
    set ["async"](a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
    [ABORT]() {
      this[ABORTED] = true;
      this.emit("abort", this[SIGNAL]?.reason);
      this.destroy(this[SIGNAL]?.reason);
    }
    get aborted() {
      return this[ABORTED];
    }
    set aborted(_3) {
    }
    write(chunk, encoding, cb) {
      if (this[ABORTED])
        return false;
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
        return true;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC] ? defer2 : nodefer;
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk)) {
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        } else if (isArrayBufferLike(chunk)) {
          chunk = Buffer.from(chunk);
        } else if (typeof chunk !== "string") {
          throw new Error("Non-contiguous data written to non-objectMode stream");
        }
      }
      if (this[OBJECTMODE]) {
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (typeof chunk === "string" && !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING]) {
        chunk = this[DECODER].write(chunk);
      }
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      this[DISCARDED] = false;
      if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }
      if (this[OBJECTMODE])
        n = null;
      if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
        this[BUFFER] = [
          this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
        ];
      }
      const ret = this[READ](n || null, this[BUFFER][0]);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [READ](n, chunk) {
      if (this[OBJECTMODE])
        this[BUFFERSHIFT]();
      else {
        const c = chunk;
        if (n === c.length || n === null)
          this[BUFFERSHIFT]();
        else if (typeof c === "string") {
          this[BUFFER][0] = c.slice(n);
          chunk = c.slice(0, n);
          this[BUFFERLENGTH] -= n;
        } else {
          this[BUFFER][0] = c.subarray(n);
          chunk = c.subarray(0, n);
          this[BUFFERLENGTH] -= n;
        }
      }
      this.emit("data", chunk);
      if (!this[BUFFER].length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = undefined;
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = "utf8";
      }
      if (chunk !== undefined)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this[FLOWING] || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    [RESUME]() {
      if (this[DESTROYED])
        return;
      if (!this[DATALISTENERS] && !this[PIPES].length) {
        this[DISCARDED] = true;
      }
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this[BUFFER].length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
      this[DISCARDED] = false;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1;
      else
        this[BUFFERLENGTH] -= this[BUFFER][0].length;
      return this[BUFFER].shift();
    }
    [FLUSH](noDrain = false) {
      do {
      } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
      if (!noDrain && !this[BUFFER].length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      this.emit("data", chunk);
      return this[FLOWING];
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return dest;
      this[DISCARDED] = false;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
        if (this[ASYNC])
          defer2(() => this[RESUME]());
        else
          this[RESUME]();
      }
      return dest;
    }
    unpipe(dest) {
      const p = this[PIPES].find((p2) => p2.dest === dest);
      if (p) {
        if (this[PIPES].length === 1) {
          if (this[FLOWING] && this[DATALISTENERS] === 0) {
            this[FLOWING] = false;
          }
          this[PIPES] = [];
        } else
          this[PIPES].splice(this[PIPES].indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, handler) {
      return this.on(ev, handler);
    }
    on(ev, handler) {
      const ret = super.on(ev, handler);
      if (ev === "data") {
        this[DISCARDED] = false;
        this[DATALISTENERS]++;
        if (!this[PIPES].length && !this[FLOWING]) {
          this[RESUME]();
        }
      } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
        super.emit("readable");
      } else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR]) {
        const h = handler;
        if (this[ASYNC])
          defer2(() => h.call(this, this[EMITTED_ERROR]));
        else
          h.call(this, this[EMITTED_ERROR]);
      }
      return ret;
    }
    removeListener(ev, handler) {
      return this.off(ev, handler);
    }
    off(ev, handler) {
      const ret = super.off(ev, handler);
      if (ev === "data") {
        this[DATALISTENERS] = this.listeners("data").length;
        if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
          this[FLOWING] = false;
        }
      }
      return ret;
    }
    removeAllListeners(ev) {
      const ret = super.removeAllListeners(ev);
      if (ev === "data" || ev === undefined) {
        this[DATALISTENERS] = 0;
        if (!this[DISCARDED] && !this[PIPES].length) {
          this[FLOWING] = false;
        }
      }
      return ret;
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, ...args) {
      const data = args[0];
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
        return false;
      } else if (ev === "data") {
        return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer2(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
      } else if (ev === "end") {
        return this[EMITEND]();
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return false;
        const ret2 = super.emit("close");
        this.removeAllListeners("close");
        return ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data;
        super.emit(ERROR, data);
        const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret2;
      }
      const ret = super.emit(ev, ...args);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITDATA](data) {
      for (const p of this[PIPES]) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret = this[DISCARDED] ? false : super.emit("data", data);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return false;
      this[EMITTED_END] = true;
      this.readable = false;
      return this[ASYNC] ? (defer2(() => this[EMITEND2]()), true) : this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        const data = this[DECODER].end();
        if (data) {
          for (const p of this[PIPES]) {
            p.dest.write(data);
          }
          if (!this[DISCARDED])
            super.emit("data", data);
        }
      }
      for (const p of this[PIPES]) {
        p.end();
      }
      const ret = super.emit("end");
      this.removeAllListeners("end");
      return ret;
    }
    async collect() {
      const buf = Object.assign([], {
        dataLength: 0
      });
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      await p;
      return buf;
    }
    async concat() {
      if (this[OBJECTMODE]) {
        throw new Error("cannot concat in objectMode");
      }
      const buf = await this.collect();
      return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
    }
    async promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve());
      });
    }
    [Symbol.asyncIterator]() {
      this[DISCARDED] = false;
      let stopped = false;
      const stop = async () => {
        this.pause();
        stopped = true;
        return { value: undefined, done: true };
      };
      const next = () => {
        if (stopped)
          return stop();
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF])
          return stop();
        let resolve;
        let reject;
        const onerr = (er) => {
          this.off("data", ondata);
          this.off("end", onend);
          this.off(DESTROYED, ondestroy);
          stop();
          reject(er);
        };
        const ondata = (value) => {
          this.off("error", onerr);
          this.off("end", onend);
          this.off(DESTROYED, ondestroy);
          this.pause();
          resolve({ value, done: !!this[EOF] });
        };
        const onend = () => {
          this.off("error", onerr);
          this.off("data", ondata);
          this.off(DESTROYED, ondestroy);
          stop();
          resolve({ done: true, value: undefined });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    [Symbol.iterator]() {
      this[DISCARDED] = false;
      let stopped = false;
      const stop = () => {
        this.pause();
        this.off(ERROR, stop);
        this.off(DESTROYED, stop);
        this.off("end", stop);
        stopped = true;
        return { done: true, value: undefined };
      };
      const next = () => {
        if (stopped)
          return stop();
        const value = this.read();
        return value === null ? stop() : { done: false, value };
      };
      this.once("end", stop);
      this.once(ERROR, stop);
      this.once(DESTROYED, stop);
      return {
        next,
        throw: stop,
        return: stop,
        [Symbol.iterator]() {
          return this;
        }
      };
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this[DISCARDED] = true;
      this[BUFFER].length = 0;
      this[BUFFERLENGTH] = 0;
      const wc = this;
      if (typeof wc.close === "function" && !this[CLOSED])
        wc.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static get isStream() {
      return exports.isStream;
    }
  }
  exports.Minipass = Minipass;
});

// node_modules/path-scurry/dist/commonjs/index.js
var require_commonjs4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = undefined;
  var lru_cache_1 = require_commonjs2();
  var node_path_1 = __require("node:path");
  var node_url_1 = __require("node:url");
  var fs_1 = __require("fs");
  var actualFS = __importStar(__require("node:fs"));
  var realpathSync = fs_1.realpathSync.native;
  var promises_1 = __require("node:fs/promises");
  var minipass_1 = require_commonjs3();
  var defaultFS = {
    lstatSync: fs_1.lstatSync,
    readdir: fs_1.readdir,
    readdirSync: fs_1.readdirSync,
    readlinkSync: fs_1.readlinkSync,
    realpathSync,
    promises: {
      lstat: promises_1.lstat,
      readdir: promises_1.readdir,
      readlink: promises_1.readlink,
      realpath: promises_1.realpath
    }
  };
  var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
    ...defaultFS,
    ...fsOption,
    promises: {
      ...defaultFS.promises,
      ...fsOption.promises || {}
    }
  };
  var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
  var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
  var eitherSep = /[\\\/]/;
  var UNKNOWN = 0;
  var IFIFO = 1;
  var IFCHR = 2;
  var IFDIR = 4;
  var IFBLK = 6;
  var IFREG = 8;
  var IFLNK = 10;
  var IFSOCK = 12;
  var IFMT = 15;
  var IFMT_UNKNOWN = ~IFMT;
  var READDIR_CALLED = 16;
  var LSTAT_CALLED = 32;
  var ENOTDIR = 64;
  var ENOENT = 128;
  var ENOREADLINK = 256;
  var ENOREALPATH = 512;
  var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
  var TYPEMASK = 1023;
  var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
  var normalizeCache = new Map;
  var normalize = (s) => {
    const c = normalizeCache.get(s);
    if (c)
      return c;
    const n = s.normalize("NFKD");
    normalizeCache.set(s, n);
    return n;
  };
  var normalizeNocaseCache = new Map;
  var normalizeNocase = (s) => {
    const c = normalizeNocaseCache.get(s);
    if (c)
      return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
  };

  class ResolveCache extends lru_cache_1.LRUCache {
    constructor() {
      super({ max: 256 });
    }
  }
  exports.ResolveCache = ResolveCache;

  class ChildrenCache extends lru_cache_1.LRUCache {
    constructor(maxSize = 16 * 1024) {
      super({
        maxSize,
        sizeCalculation: (a) => a.length + 1
      });
    }
  }
  exports.ChildrenCache = ChildrenCache;
  var setAsCwd = Symbol("PathScurry setAsCwd");

  class PathBase {
    name;
    root;
    roots;
    parent;
    nocase;
    isCWD = false;
    #fs;
    #dev;
    get dev() {
      return this.#dev;
    }
    #mode;
    get mode() {
      return this.#mode;
    }
    #nlink;
    get nlink() {
      return this.#nlink;
    }
    #uid;
    get uid() {
      return this.#uid;
    }
    #gid;
    get gid() {
      return this.#gid;
    }
    #rdev;
    get rdev() {
      return this.#rdev;
    }
    #blksize;
    get blksize() {
      return this.#blksize;
    }
    #ino;
    get ino() {
      return this.#ino;
    }
    #size;
    get size() {
      return this.#size;
    }
    #blocks;
    get blocks() {
      return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
      return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
      return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
      return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
      return this.#birthtimeMs;
    }
    #atime;
    get atime() {
      return this.#atime;
    }
    #mtime;
    get mtime() {
      return this.#mtime;
    }
    #ctime;
    get ctime() {
      return this.#ctime;
    }
    #birthtime;
    get birthtime() {
      return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    get parentPath() {
      return (this.parent || this).fullpath();
    }
    get path() {
      return this.parentPath;
    }
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
      this.name = name;
      this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
      this.#type = type & TYPEMASK;
      this.nocase = nocase;
      this.roots = roots;
      this.root = root || this;
      this.#children = children;
      this.#fullpath = opts.fullpath;
      this.#relative = opts.relative;
      this.#relativePosix = opts.relativePosix;
      this.parent = opts.parent;
      if (this.parent) {
        this.#fs = this.parent.#fs;
      } else {
        this.#fs = fsFromOption(opts.fs);
      }
    }
    depth() {
      if (this.#depth !== undefined)
        return this.#depth;
      if (!this.parent)
        return this.#depth = 0;
      return this.#depth = this.parent.depth() + 1;
    }
    childrenCache() {
      return this.#children;
    }
    resolve(path3) {
      if (!path3) {
        return this;
      }
      const rootPath = this.getRootString(path3);
      const dir = path3.substring(rootPath.length);
      const dirParts = dir.split(this.splitSep);
      const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
      return result;
    }
    #resolveParts(dirParts) {
      let p = this;
      for (const part of dirParts) {
        p = p.child(part);
      }
      return p;
    }
    children() {
      const cached = this.#children.get(this);
      if (cached) {
        return cached;
      }
      const children = Object.assign([], { provisional: 0 });
      this.#children.set(this, children);
      this.#type &= ~READDIR_CALLED;
      return children;
    }
    child(pathPart, opts) {
      if (pathPart === "" || pathPart === ".") {
        return this;
      }
      if (pathPart === "..") {
        return this.parent || this;
      }
      const children = this.children();
      const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
      for (const p of children) {
        if (p.#matchName === name) {
          return p;
        }
      }
      const s = this.parent ? this.sep : "";
      const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;
      const pchild = this.newChild(pathPart, UNKNOWN, {
        ...opts,
        parent: this,
        fullpath
      });
      if (!this.canReaddir()) {
        pchild.#type |= ENOENT;
      }
      children.push(pchild);
      return pchild;
    }
    relative() {
      if (this.isCWD)
        return "";
      if (this.#relative !== undefined) {
        return this.#relative;
      }
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#relative = this.name;
      }
      const pv = p.relative();
      return pv + (!pv || !p.parent ? "" : this.sep) + name;
    }
    relativePosix() {
      if (this.sep === "/")
        return this.relative();
      if (this.isCWD)
        return "";
      if (this.#relativePosix !== undefined)
        return this.#relativePosix;
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#relativePosix = this.fullpathPosix();
      }
      const pv = p.relativePosix();
      return pv + (!pv || !p.parent ? "" : "/") + name;
    }
    fullpath() {
      if (this.#fullpath !== undefined) {
        return this.#fullpath;
      }
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#fullpath = this.name;
      }
      const pv = p.fullpath();
      const fp = pv + (!p.parent ? "" : this.sep) + name;
      return this.#fullpath = fp;
    }
    fullpathPosix() {
      if (this.#fullpathPosix !== undefined)
        return this.#fullpathPosix;
      if (this.sep === "/")
        return this.#fullpathPosix = this.fullpath();
      if (!this.parent) {
        const p2 = this.fullpath().replace(/\\/g, "/");
        if (/^[a-z]:\//i.test(p2)) {
          return this.#fullpathPosix = `//?/${p2}`;
        } else {
          return this.#fullpathPosix = p2;
        }
      }
      const p = this.parent;
      const pfpp = p.fullpathPosix();
      const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
      return this.#fullpathPosix = fpp;
    }
    isUnknown() {
      return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type) {
      return this[`is${type}`]();
    }
    getType() {
      return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : this.isSocket() ? "Socket" : "Unknown";
    }
    isFile() {
      return (this.#type & IFMT) === IFREG;
    }
    isDirectory() {
      return (this.#type & IFMT) === IFDIR;
    }
    isCharacterDevice() {
      return (this.#type & IFMT) === IFCHR;
    }
    isBlockDevice() {
      return (this.#type & IFMT) === IFBLK;
    }
    isFIFO() {
      return (this.#type & IFMT) === IFIFO;
    }
    isSocket() {
      return (this.#type & IFMT) === IFSOCK;
    }
    isSymbolicLink() {
      return (this.#type & IFLNK) === IFLNK;
    }
    lstatCached() {
      return this.#type & LSTAT_CALLED ? this : undefined;
    }
    readlinkCached() {
      return this.#linkTarget;
    }
    realpathCached() {
      return this.#realpath;
    }
    readdirCached() {
      const children = this.children();
      return children.slice(0, children.provisional);
    }
    canReadlink() {
      if (this.#linkTarget)
        return true;
      if (!this.parent)
        return false;
      const ifmt = this.#type & IFMT;
      return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
    }
    calledReaddir() {
      return !!(this.#type & READDIR_CALLED);
    }
    isENOENT() {
      return !!(this.#type & ENOENT);
    }
    isNamed(n) {
      return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
    }
    async readlink() {
      const target = this.#linkTarget;
      if (target) {
        return target;
      }
      if (!this.canReadlink()) {
        return;
      }
      if (!this.parent) {
        return;
      }
      try {
        const read = await this.#fs.promises.readlink(this.fullpath());
        const linkTarget = (await this.parent.realpath())?.resolve(read);
        if (linkTarget) {
          return this.#linkTarget = linkTarget;
        }
      } catch (er) {
        this.#readlinkFail(er.code);
        return;
      }
    }
    readlinkSync() {
      const target = this.#linkTarget;
      if (target) {
        return target;
      }
      if (!this.canReadlink()) {
        return;
      }
      if (!this.parent) {
        return;
      }
      try {
        const read = this.#fs.readlinkSync(this.fullpath());
        const linkTarget = this.parent.realpathSync()?.resolve(read);
        if (linkTarget) {
          return this.#linkTarget = linkTarget;
        }
      } catch (er) {
        this.#readlinkFail(er.code);
        return;
      }
    }
    #readdirSuccess(children) {
      this.#type |= READDIR_CALLED;
      for (let p = children.provisional;p < children.length; p++) {
        const c = children[p];
        if (c)
          c.#markENOENT();
      }
    }
    #markENOENT() {
      if (this.#type & ENOENT)
        return;
      this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
      this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
      const children = this.children();
      children.provisional = 0;
      for (const p of children) {
        p.#markENOENT();
      }
    }
    #markENOREALPATH() {
      this.#type |= ENOREALPATH;
      this.#markENOTDIR();
    }
    #markENOTDIR() {
      if (this.#type & ENOTDIR)
        return;
      let t = this.#type;
      if ((t & IFMT) === IFDIR)
        t &= IFMT_UNKNOWN;
      this.#type = t | ENOTDIR;
      this.#markChildrenENOENT();
    }
    #readdirFail(code = "") {
      if (code === "ENOTDIR" || code === "EPERM") {
        this.#markENOTDIR();
      } else if (code === "ENOENT") {
        this.#markENOENT();
      } else {
        this.children().provisional = 0;
      }
    }
    #lstatFail(code = "") {
      if (code === "ENOTDIR") {
        const p = this.parent;
        p.#markENOTDIR();
      } else if (code === "ENOENT") {
        this.#markENOENT();
      }
    }
    #readlinkFail(code = "") {
      let ter = this.#type;
      ter |= ENOREADLINK;
      if (code === "ENOENT")
        ter |= ENOENT;
      if (code === "EINVAL" || code === "UNKNOWN") {
        ter &= IFMT_UNKNOWN;
      }
      this.#type = ter;
      if (code === "ENOTDIR" && this.parent) {
        this.parent.#markENOTDIR();
      }
    }
    #readdirAddChild(e, c) {
      return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
    }
    #readdirAddNewChild(e, c) {
      const type = entToType(e);
      const child = this.newChild(e.name, type, { parent: this });
      const ifmt = child.#type & IFMT;
      if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
        child.#type |= ENOTDIR;
      }
      c.unshift(child);
      c.provisional++;
      return child;
    }
    #readdirMaybePromoteChild(e, c) {
      for (let p = c.provisional;p < c.length; p++) {
        const pchild = c[p];
        const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
        if (name !== pchild.#matchName) {
          continue;
        }
        return this.#readdirPromoteChild(e, pchild, p, c);
      }
    }
    #readdirPromoteChild(e, p, index, c) {
      const v = p.name;
      p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
      if (v !== e.name)
        p.name = e.name;
      if (index !== c.provisional) {
        if (index === c.length - 1)
          c.pop();
        else
          c.splice(index, 1);
        c.unshift(p);
      }
      c.provisional++;
      return p;
    }
    async lstat() {
      if ((this.#type & ENOENT) === 0) {
        try {
          this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
          return this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
      }
    }
    lstatSync() {
      if ((this.#type & ENOENT) === 0) {
        try {
          this.#applyStat(this.#fs.lstatSync(this.fullpath()));
          return this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
      }
    }
    #applyStat(st) {
      const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
      this.#atime = atime;
      this.#atimeMs = atimeMs;
      this.#birthtime = birthtime;
      this.#birthtimeMs = birthtimeMs;
      this.#blksize = blksize;
      this.#blocks = blocks;
      this.#ctime = ctime;
      this.#ctimeMs = ctimeMs;
      this.#dev = dev;
      this.#gid = gid;
      this.#ino = ino;
      this.#mode = mode;
      this.#mtime = mtime;
      this.#mtimeMs = mtimeMs;
      this.#nlink = nlink;
      this.#rdev = rdev;
      this.#size = size;
      this.#uid = uid;
      const ifmt = entToType(st);
      this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
      if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
        this.#type |= ENOTDIR;
      }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
      this.#readdirCBInFlight = false;
      const cbs = this.#onReaddirCB.slice();
      this.#onReaddirCB.length = 0;
      cbs.forEach((cb) => cb(null, children));
    }
    readdirCB(cb, allowZalgo = false) {
      if (!this.canReaddir()) {
        if (allowZalgo)
          cb(null, []);
        else
          queueMicrotask(() => cb(null, []));
        return;
      }
      const children = this.children();
      if (this.calledReaddir()) {
        const c = children.slice(0, children.provisional);
        if (allowZalgo)
          cb(null, c);
        else
          queueMicrotask(() => cb(null, c));
        return;
      }
      this.#onReaddirCB.push(cb);
      if (this.#readdirCBInFlight) {
        return;
      }
      this.#readdirCBInFlight = true;
      const fullpath = this.fullpath();
      this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
        if (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        } else {
          for (const e of entries) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        }
        this.#callOnReaddirCB(children.slice(0, children.provisional));
        return;
      });
    }
    #asyncReaddirInFlight;
    async readdir() {
      if (!this.canReaddir()) {
        return [];
      }
      const children = this.children();
      if (this.calledReaddir()) {
        return children.slice(0, children.provisional);
      }
      const fullpath = this.fullpath();
      if (this.#asyncReaddirInFlight) {
        await this.#asyncReaddirInFlight;
      } else {
        let resolve = () => {
        };
        this.#asyncReaddirInFlight = new Promise((res) => resolve = res);
        try {
          for (const e of await this.#fs.promises.readdir(fullpath, {
            withFileTypes: true
          })) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        } catch (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        }
        this.#asyncReaddirInFlight = undefined;
        resolve();
      }
      return children.slice(0, children.provisional);
    }
    readdirSync() {
      if (!this.canReaddir()) {
        return [];
      }
      const children = this.children();
      if (this.calledReaddir()) {
        return children.slice(0, children.provisional);
      }
      const fullpath = this.fullpath();
      try {
        for (const e of this.#fs.readdirSync(fullpath, {
          withFileTypes: true
        })) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      }
      return children.slice(0, children.provisional);
    }
    canReaddir() {
      if (this.#type & ENOCHILD)
        return false;
      const ifmt = IFMT & this.#type;
      if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
        return false;
      }
      return true;
    }
    shouldWalk(dirs, walkFilter) {
      return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
    }
    async realpath() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return;
      try {
        const rp = await this.#fs.promises.realpath(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_3) {
        this.#markENOREALPATH();
      }
    }
    realpathSync() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return;
      try {
        const rp = this.#fs.realpathSync(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_3) {
        this.#markENOREALPATH();
      }
    }
    [setAsCwd](oldCwd) {
      if (oldCwd === this)
        return;
      oldCwd.isCWD = false;
      this.isCWD = true;
      const changed = new Set([]);
      let rp = [];
      let p = this;
      while (p && p.parent) {
        changed.add(p);
        p.#relative = rp.join(this.sep);
        p.#relativePosix = rp.join("/");
        p = p.parent;
        rp.push("..");
      }
      p = oldCwd;
      while (p && p.parent && !changed.has(p)) {
        p.#relative = undefined;
        p.#relativePosix = undefined;
        p = p.parent;
      }
    }
  }
  exports.PathBase = PathBase;

  class PathWin32 extends PathBase {
    sep = "\\";
    splitSep = eitherSep;
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type, root, roots, nocase, children, opts);
    }
    newChild(name, type = UNKNOWN, opts = {}) {
      return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    getRootString(path3) {
      return node_path_1.win32.parse(path3).root;
    }
    getRoot(rootPath) {
      rootPath = uncToDrive(rootPath.toUpperCase());
      if (rootPath === this.root.name) {
        return this.root;
      }
      for (const [compare, root] of Object.entries(this.roots)) {
        if (this.sameRoot(rootPath, compare)) {
          return this.roots[rootPath] = root;
        }
      }
      return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
    }
    sameRoot(rootPath, compare = this.root.name) {
      rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
      return rootPath === compare;
    }
  }
  exports.PathWin32 = PathWin32;

  class PathPosix extends PathBase {
    splitSep = "/";
    sep = "/";
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type, root, roots, nocase, children, opts);
    }
    getRootString(path3) {
      return path3.startsWith("/") ? "/" : "";
    }
    getRoot(_rootPath) {
      return this.root;
    }
    newChild(name, type = UNKNOWN, opts = {}) {
      return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
  }
  exports.PathPosix = PathPosix;

  class PathScurryBase {
    root;
    rootPath;
    roots;
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    nocase;
    #fs;
    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs: fs3 = defaultFS } = {}) {
      this.#fs = fsFromOption(fs3);
      if (cwd instanceof URL || cwd.startsWith("file://")) {
        cwd = (0, node_url_1.fileURLToPath)(cwd);
      }
      const cwdPath = pathImpl.resolve(cwd);
      this.roots = Object.create(null);
      this.rootPath = this.parseRootPath(cwdPath);
      this.#resolveCache = new ResolveCache;
      this.#resolvePosixCache = new ResolveCache;
      this.#children = new ChildrenCache(childrenCacheSize);
      const split4 = cwdPath.substring(this.rootPath.length).split(sep);
      if (split4.length === 1 && !split4[0]) {
        split4.pop();
      }
      if (nocase === undefined) {
        throw new TypeError("must provide nocase setting to PathScurryBase ctor");
      }
      this.nocase = nocase;
      this.root = this.newRoot(this.#fs);
      this.roots[this.rootPath] = this.root;
      let prev = this.root;
      let len = split4.length - 1;
      const joinSep = pathImpl.sep;
      let abs = this.rootPath;
      let sawFirst = false;
      for (const part of split4) {
        const l = len--;
        prev = prev.child(part, {
          relative: new Array(l).fill("..").join(joinSep),
          relativePosix: new Array(l).fill("..").join("/"),
          fullpath: abs += (sawFirst ? "" : joinSep) + part
        });
        sawFirst = true;
      }
      this.cwd = prev;
    }
    depth(path3 = this.cwd) {
      if (typeof path3 === "string") {
        path3 = this.cwd.resolve(path3);
      }
      return path3.depth();
    }
    childrenCache() {
      return this.#children;
    }
    resolve(...paths) {
      let r = "";
      for (let i = paths.length - 1;i >= 0; i--) {
        const p = paths[i];
        if (!p || p === ".")
          continue;
        r = r ? `${p}/${r}` : p;
        if (this.isAbsolute(p)) {
          break;
        }
      }
      const cached = this.#resolveCache.get(r);
      if (cached !== undefined) {
        return cached;
      }
      const result = this.cwd.resolve(r).fullpath();
      this.#resolveCache.set(r, result);
      return result;
    }
    resolvePosix(...paths) {
      let r = "";
      for (let i = paths.length - 1;i >= 0; i--) {
        const p = paths[i];
        if (!p || p === ".")
          continue;
        r = r ? `${p}/${r}` : p;
        if (this.isAbsolute(p)) {
          break;
        }
      }
      const cached = this.#resolvePosixCache.get(r);
      if (cached !== undefined) {
        return cached;
      }
      const result = this.cwd.resolve(r).fullpathPosix();
      this.#resolvePosixCache.set(r, result);
      return result;
    }
    relative(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.relative();
    }
    relativePosix(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.relativePosix();
    }
    basename(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.name;
    }
    dirname(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
      withFileTypes: true
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes } = opts;
      if (!entry.canReaddir()) {
        return [];
      } else {
        const p = await entry.readdir();
        return withFileTypes ? p : p.map((e) => e.name);
      }
    }
    readdirSync(entry = this.cwd, opts = {
      withFileTypes: true
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true } = opts;
      if (!entry.canReaddir()) {
        return [];
      } else if (withFileTypes) {
        return entry.readdirSync();
      } else {
        return entry.readdirSync().map((e) => e.name);
      }
    }
    async lstat(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.lstat();
    }
    lstatSync(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = await entry.readlink();
      return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = entry.readlinkSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = await entry.realpath();
      return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = entry.realpathSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = [];
      if (!filter2 || filter2(entry)) {
        results.push(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = new Set;
      const walk = (dir, cb) => {
        dirs.add(dir);
        dir.readdirCB((er, entries) => {
          if (er) {
            return cb(er);
          }
          let len = entries.length;
          if (!len)
            return cb();
          const next = () => {
            if (--len === 0) {
              cb();
            }
          };
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              results.push(withFileTypes ? e : e.fullpath());
            }
            if (follow && e.isSymbolicLink()) {
              e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
            } else {
              if (e.shouldWalk(dirs, walkFilter)) {
                walk(e, next);
              } else {
                next();
              }
            }
          }
        }, true);
      };
      const start = entry;
      return new Promise((res, rej) => {
        walk(start, (er) => {
          if (er)
            return rej(er);
          res(results);
        });
      });
    }
    walkSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = [];
      if (!filter2 || filter2(entry)) {
        results.push(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = new Set([entry]);
      for (const dir of dirs) {
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            dirs.add(r);
          }
        }
      }
      return results;
    }
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        options = entry;
        entry = this.cwd;
      }
      return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      if (!filter2 || filter2(entry)) {
        yield withFileTypes ? entry : entry.fullpath();
      }
      const dirs = new Set([entry]);
      for (const dir of dirs) {
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            yield withFileTypes ? e : e.fullpath();
          }
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            dirs.add(r);
          }
        }
      }
    }
    stream(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = new minipass_1.Minipass({ objectMode: true });
      if (!filter2 || filter2(entry)) {
        results.write(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = new Set;
      const queue = [entry];
      let processing = 0;
      const process20 = () => {
        let paused = false;
        while (!paused) {
          const dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++;
          dirs.add(dir);
          const onReaddir = (er, entries, didRealpaths = false) => {
            if (er)
              return results.emit("error", er);
            if (follow && !didRealpaths) {
              const promises = [];
              for (const e of entries) {
                if (e.isSymbolicLink()) {
                  promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
                }
              }
              if (promises.length) {
                Promise.all(promises).then(() => onReaddir(null, entries, true));
                return;
              }
            }
            for (const e of entries) {
              if (e && (!filter2 || filter2(e))) {
                if (!results.write(withFileTypes ? e : e.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e of entries) {
              const r = e.realpathCached() || e;
              if (r.shouldWalk(dirs, walkFilter)) {
                queue.push(r);
              }
            }
            if (paused && !results.flowing) {
              results.once("drain", process20);
            } else if (!sync) {
              process20();
            }
          };
          let sync = true;
          dir.readdirCB(onReaddir, true);
          sync = false;
        }
      };
      process20();
      return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = new minipass_1.Minipass({ objectMode: true });
      const dirs = new Set;
      if (!filter2 || filter2(entry)) {
        results.write(withFileTypes ? entry : entry.fullpath());
      }
      const queue = [entry];
      let processing = 0;
      const process20 = () => {
        let paused = false;
        while (!paused) {
          const dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++;
          dirs.add(dir);
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing--;
          for (const e of entries) {
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
        }
        if (paused && !results.flowing)
          results.once("drain", process20);
      };
      process20();
      return results;
    }
    chdir(path3 = this.cwd) {
      const oldCwd = this.cwd;
      this.cwd = typeof path3 === "string" ? this.cwd.resolve(path3) : path3;
      this.cwd[setAsCwd](oldCwd);
    }
  }
  exports.PathScurryBase = PathScurryBase;

  class PathScurryWin32 extends PathScurryBase {
    sep = "\\";
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = true } = opts;
      super(cwd, node_path_1.win32, "\\", { ...opts, nocase });
      this.nocase = nocase;
      for (let p = this.cwd;p; p = p.parent) {
        p.nocase = this.nocase;
      }
    }
    parseRootPath(dir) {
      return node_path_1.win32.parse(dir).root.toUpperCase();
    }
    newRoot(fs3) {
      return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs: fs3 });
    }
    isAbsolute(p) {
      return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
    }
  }
  exports.PathScurryWin32 = PathScurryWin32;

  class PathScurryPosix extends PathScurryBase {
    sep = "/";
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = false } = opts;
      super(cwd, node_path_1.posix, "/", { ...opts, nocase });
      this.nocase = nocase;
    }
    parseRootPath(_dir) {
      return "/";
    }
    newRoot(fs3) {
      return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs: fs3 });
    }
    isAbsolute(p) {
      return p.startsWith("/");
    }
  }
  exports.PathScurryPosix = PathScurryPosix;

  class PathScurryDarwin extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = true } = opts;
      super(cwd, { ...opts, nocase });
    }
  }
  exports.PathScurryDarwin = PathScurryDarwin;
  exports.Path = process.platform === "win32" ? PathWin32 : PathPosix;
  exports.PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;
});

// node_modules/glob/dist/commonjs/pattern.js
var require_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Pattern = undefined;
  var minimatch_1 = require_commonjs();
  var isPatternList = (pl) => pl.length >= 1;
  var isGlobList = (gl) => gl.length >= 1;

  class Pattern {
    #patternList;
    #globList;
    #index;
    length;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar = true;
    constructor(patternList, globList, index, platform) {
      if (!isPatternList(patternList)) {
        throw new TypeError("empty pattern list");
      }
      if (!isGlobList(globList)) {
        throw new TypeError("empty glob list");
      }
      if (globList.length !== patternList.length) {
        throw new TypeError("mismatched pattern list and glob list lengths");
      }
      this.length = patternList.length;
      if (index < 0 || index >= this.length) {
        throw new TypeError("index out of range");
      }
      this.#patternList = patternList;
      this.#globList = globList;
      this.#index = index;
      this.#platform = platform;
      if (this.#index === 0) {
        if (this.isUNC()) {
          const [p0, p1, p2, p3, ...prest] = this.#patternList;
          const [g0, g1, g2, g3, ...grest] = this.#globList;
          if (prest[0] === "") {
            prest.shift();
            grest.shift();
          }
          const p = [p0, p1, p2, p3, ""].join("/");
          const g = [g0, g1, g2, g3, ""].join("/");
          this.#patternList = [p, ...prest];
          this.#globList = [g, ...grest];
          this.length = this.#patternList.length;
        } else if (this.isDrive() || this.isAbsolute()) {
          const [p1, ...prest] = this.#patternList;
          const [g1, ...grest] = this.#globList;
          if (prest[0] === "") {
            prest.shift();
            grest.shift();
          }
          const p = p1 + "/";
          const g = g1 + "/";
          this.#patternList = [p, ...prest];
          this.#globList = [g, ...grest];
          this.length = this.#patternList.length;
        }
      }
    }
    pattern() {
      return this.#patternList[this.#index];
    }
    isString() {
      return typeof this.#patternList[this.#index] === "string";
    }
    isGlobstar() {
      return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;
    }
    isRegExp() {
      return this.#patternList[this.#index] instanceof RegExp;
    }
    globString() {
      return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
    }
    hasMore() {
      return this.length > this.#index + 1;
    }
    rest() {
      if (this.#rest !== undefined)
        return this.#rest;
      if (!this.hasMore())
        return this.#rest = null;
      this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
      this.#rest.#isAbsolute = this.#isAbsolute;
      this.#rest.#isUNC = this.#isUNC;
      this.#rest.#isDrive = this.#isDrive;
      return this.#rest;
    }
    isUNC() {
      const pl = this.#patternList;
      return this.#isUNC !== undefined ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
    }
    isDrive() {
      const pl = this.#patternList;
      return this.#isDrive !== undefined ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
    }
    isAbsolute() {
      const pl = this.#patternList;
      return this.#isAbsolute !== undefined ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
    }
    root() {
      const p = this.#patternList[0];
      return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
    }
    checkFollowGlobstar() {
      return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
    }
    markFollowGlobstar() {
      if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
        return false;
      this.#followGlobstar = false;
      return true;
    }
  }
  exports.Pattern = Pattern;
});

// node_modules/glob/dist/commonjs/ignore.js
var require_ignore = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Ignore = undefined;
  var minimatch_1 = require_commonjs();
  var pattern_js_1 = require_pattern();
  var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";

  class Ignore {
    relative;
    relativeChildren;
    absolute;
    absoluteChildren;
    platform;
    mmopts;
    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform }) {
      this.relative = [];
      this.absolute = [];
      this.relativeChildren = [];
      this.absoluteChildren = [];
      this.platform = platform;
      this.mmopts = {
        dot: true,
        nobrace,
        nocase,
        noext,
        noglobstar,
        optimizationLevel: 2,
        platform,
        nocomment: true,
        nonegate: true
      };
      for (const ign of ignored)
        this.add(ign);
    }
    add(ign) {
      const mm = new minimatch_1.Minimatch(ign, this.mmopts);
      for (let i = 0;i < mm.set.length; i++) {
        const parsed = mm.set[i];
        const globParts = mm.globParts[i];
        if (!parsed || !globParts) {
          throw new Error("invalid pattern object");
        }
        while (parsed[0] === "." && globParts[0] === ".") {
          parsed.shift();
          globParts.shift();
        }
        const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);
        const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);
        const children = globParts[globParts.length - 1] === "**";
        const absolute = p.isAbsolute();
        if (absolute)
          this.absolute.push(m);
        else
          this.relative.push(m);
        if (children) {
          if (absolute)
            this.absoluteChildren.push(m);
          else
            this.relativeChildren.push(m);
        }
      }
    }
    ignored(p) {
      const fullpath = p.fullpath();
      const fullpaths = `${fullpath}/`;
      const relative = p.relative() || ".";
      const relatives = `${relative}/`;
      for (const m of this.relative) {
        if (m.match(relative) || m.match(relatives))
          return true;
      }
      for (const m of this.absolute) {
        if (m.match(fullpath) || m.match(fullpaths))
          return true;
      }
      return false;
    }
    childrenIgnored(p) {
      const fullpath = p.fullpath() + "/";
      const relative = (p.relative() || ".") + "/";
      for (const m of this.relativeChildren) {
        if (m.match(relative))
          return true;
      }
      for (const m of this.absoluteChildren) {
        if (m.match(fullpath))
          return true;
      }
      return false;
    }
  }
  exports.Ignore = Ignore;
});

// node_modules/glob/dist/commonjs/processor.js
var require_processor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = undefined;
  var minimatch_1 = require_commonjs();

  class HasWalkedCache {
    store;
    constructor(store = new Map) {
      this.store = store;
    }
    copy() {
      return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
      return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
      const fullpath = target.fullpath();
      const cached = this.store.get(fullpath);
      if (cached)
        cached.add(pattern.globString());
      else
        this.store.set(fullpath, new Set([pattern.globString()]));
    }
  }
  exports.HasWalkedCache = HasWalkedCache;

  class MatchRecord {
    store = new Map;
    add(target, absolute, ifDir) {
      const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
      const current = this.store.get(target);
      this.store.set(target, current === undefined ? n : n & current);
    }
    entries() {
      return [...this.store.entries()].map(([path3, n]) => [
        path3,
        !!(n & 2),
        !!(n & 1)
      ]);
    }
  }
  exports.MatchRecord = MatchRecord;

  class SubWalks {
    store = new Map;
    add(target, pattern) {
      if (!target.canReaddir()) {
        return;
      }
      const subs = this.store.get(target);
      if (subs) {
        if (!subs.find((p) => p.globString() === pattern.globString())) {
          subs.push(pattern);
        }
      } else
        this.store.set(target, [pattern]);
    }
    get(target) {
      const subs = this.store.get(target);
      if (!subs) {
        throw new Error("attempting to walk unknown path");
      }
      return subs;
    }
    entries() {
      return this.keys().map((k) => [k, this.store.get(k)]);
    }
    keys() {
      return [...this.store.keys()].filter((t) => t.canReaddir());
    }
  }
  exports.SubWalks = SubWalks;

  class Processor {
    hasWalkedCache;
    matches = new MatchRecord;
    subwalks = new SubWalks;
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
      this.opts = opts;
      this.follow = !!opts.follow;
      this.dot = !!opts.dot;
      this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache;
    }
    processPatterns(target, patterns) {
      this.patterns = patterns;
      const processingSet = patterns.map((p) => [target, p]);
      for (let [t, pattern] of processingSet) {
        this.hasWalkedCache.storeWalked(t, pattern);
        const root = pattern.root();
        const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
        if (root) {
          t = t.resolve(root === "/" && this.opts.root !== undefined ? this.opts.root : root);
          const rest2 = pattern.rest();
          if (!rest2) {
            this.matches.add(t, true, false);
            continue;
          } else {
            pattern = rest2;
          }
        }
        if (t.isENOENT())
          continue;
        let p;
        let rest;
        let changed = false;
        while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
          const c = t.resolve(p);
          t = c;
          pattern = rest;
          changed = true;
        }
        p = pattern.pattern();
        rest = pattern.rest();
        if (changed) {
          if (this.hasWalkedCache.hasWalked(t, pattern))
            continue;
          this.hasWalkedCache.storeWalked(t, pattern);
        }
        if (typeof p === "string") {
          const ifDir = p === ".." || p === "" || p === ".";
          this.matches.add(t.resolve(p), absolute, ifDir);
          continue;
        } else if (p === minimatch_1.GLOBSTAR) {
          if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
            this.subwalks.add(t, pattern);
          }
          const rp = rest?.pattern();
          const rrest = rest?.rest();
          if (!rest || (rp === "" || rp === ".") && !rrest) {
            this.matches.add(t, absolute, rp === "" || rp === ".");
          } else {
            if (rp === "..") {
              const tp = t.parent || t;
              if (!rrest)
                this.matches.add(tp, absolute, true);
              else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                this.subwalks.add(tp, rrest);
              }
            }
          }
        } else if (p instanceof RegExp) {
          this.subwalks.add(t, pattern);
        }
      }
      return this;
    }
    subwalkTargets() {
      return this.subwalks.keys();
    }
    child() {
      return new Processor(this.opts, this.hasWalkedCache);
    }
    filterEntries(parent, entries) {
      const patterns = this.subwalks.get(parent);
      const results = this.child();
      for (const e of entries) {
        for (const pattern of patterns) {
          const absolute = pattern.isAbsolute();
          const p = pattern.pattern();
          const rest = pattern.rest();
          if (p === minimatch_1.GLOBSTAR) {
            results.testGlobstar(e, pattern, rest, absolute);
          } else if (p instanceof RegExp) {
            results.testRegExp(e, p, rest, absolute);
          } else {
            results.testString(e, p, rest, absolute);
          }
        }
      }
      return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
      if (this.dot || !e.name.startsWith(".")) {
        if (!pattern.hasMore()) {
          this.matches.add(e, absolute, false);
        }
        if (e.canReaddir()) {
          if (this.follow || !e.isSymbolicLink()) {
            this.subwalks.add(e, pattern);
          } else if (e.isSymbolicLink()) {
            if (rest && pattern.checkFollowGlobstar()) {
              this.subwalks.add(e, rest);
            } else if (pattern.markFollowGlobstar()) {
              this.subwalks.add(e, pattern);
            }
          }
        }
      }
      if (rest) {
        const rp = rest.pattern();
        if (typeof rp === "string" && rp !== ".." && rp !== "" && rp !== ".") {
          this.testString(e, rp, rest.rest(), absolute);
        } else if (rp === "..") {
          const ep = e.parent || e;
          this.subwalks.add(ep, rest);
        } else if (rp instanceof RegExp) {
          this.testRegExp(e, rp, rest.rest(), absolute);
        }
      }
    }
    testRegExp(e, p, rest, absolute) {
      if (!p.test(e.name))
        return;
      if (!rest) {
        this.matches.add(e, absolute, false);
      } else {
        this.subwalks.add(e, rest);
      }
    }
    testString(e, p, rest, absolute) {
      if (!e.isNamed(p))
        return;
      if (!rest) {
        this.matches.add(e, absolute, false);
      } else {
        this.subwalks.add(e, rest);
      }
    }
  }
  exports.Processor = Processor;
});

// node_modules/glob/dist/commonjs/walker.js
var require_walker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GlobStream = exports.GlobWalker = exports.GlobUtil = undefined;
  var minipass_1 = require_commonjs3();
  var ignore_js_1 = require_ignore();
  var processor_js_1 = require_processor();
  var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new ignore_js_1.Ignore([ignore], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;

  class GlobUtil {
    path;
    patterns;
    opts;
    seen = new Set;
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    includeChildMatches;
    constructor(patterns, path3, opts) {
      this.patterns = patterns;
      this.path = path3;
      this.opts = opts;
      this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
      this.includeChildMatches = opts.includeChildMatches !== false;
      if (opts.ignore || !this.includeChildMatches) {
        this.#ignore = makeIgnore(opts.ignore ?? [], opts);
        if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
          const m = "cannot ignore child matches, ignore lacks add() method.";
          throw new Error(m);
        }
      }
      this.maxDepth = opts.maxDepth || Infinity;
      if (opts.signal) {
        this.signal = opts.signal;
        this.signal.addEventListener("abort", () => {
          this.#onResume.length = 0;
        });
      }
    }
    #ignored(path3) {
      return this.seen.has(path3) || !!this.#ignore?.ignored?.(path3);
    }
    #childrenIgnored(path3) {
      return !!this.#ignore?.childrenIgnored?.(path3);
    }
    pause() {
      this.paused = true;
    }
    resume() {
      if (this.signal?.aborted)
        return;
      this.paused = false;
      let fn = undefined;
      while (!this.paused && (fn = this.#onResume.shift())) {
        fn();
      }
    }
    onResume(fn) {
      if (this.signal?.aborted)
        return;
      if (!this.paused) {
        fn();
      } else {
        this.#onResume.push(fn);
      }
    }
    async matchCheck(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return;
      let rpc;
      if (this.opts.realpath) {
        rpc = e.realpathCached() || await e.realpath();
        if (!rpc)
          return;
        e = rpc;
      }
      const needStat = e.isUnknown() || this.opts.stat;
      const s = needStat ? await e.lstat() : e;
      if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
        const target = await s.realpath();
        if (target && (target.isUnknown() || this.opts.stat)) {
          await target.lstat();
        }
      }
      return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
      return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : undefined;
    }
    matchCheckSync(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return;
      let rpc;
      if (this.opts.realpath) {
        rpc = e.realpathCached() || e.realpathSync();
        if (!rpc)
          return;
        e = rpc;
      }
      const needStat = e.isUnknown() || this.opts.stat;
      const s = needStat ? e.lstatSync() : e;
      if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
        const target = s.realpathSync();
        if (target && (target?.isUnknown() || this.opts.stat)) {
          target.lstatSync();
        }
      }
      return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
      if (this.#ignored(e))
        return;
      if (!this.includeChildMatches && this.#ignore?.add) {
        const ign = `${e.relativePosix()}/**`;
        this.#ignore.add(ign);
      }
      const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
      this.seen.add(e);
      const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
      if (this.opts.withFileTypes) {
        this.matchEmit(e);
      } else if (abs) {
        const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
        this.matchEmit(abs2 + mark);
      } else {
        const rel = this.opts.posix ? e.relativePosix() : e.relative();
        const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
        this.matchEmit(!rel ? "." + mark : pre + rel + mark);
      }
    }
    async match(e, absolute, ifDir) {
      const p = await this.matchCheck(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
      const p = this.matchCheckSync(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++;
        this.match(m, absolute, ifDir).then(() => next());
      }
      for (const t of processor.subwalkTargets()) {
        if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
          continue;
        }
        tasks++;
        const childrenCached = t.readdirCached();
        if (t.calledReaddir())
          this.walkCB3(t, childrenCached, processor, next);
        else {
          t.readdirCB((_3, entries) => this.walkCB3(t, entries, processor, next), true);
        }
      }
      next();
    }
    walkCB3(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++;
        this.match(m, absolute, ifDir).then(() => next());
      }
      for (const [target2, patterns] of processor.subwalks.entries()) {
        tasks++;
        this.walkCB2(target2, patterns, processor.child(), next);
      }
      next();
    }
    walkCBSync(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (const t of processor.subwalkTargets()) {
        if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
          continue;
        }
        tasks++;
        const children = t.readdirSync();
        this.walkCB3Sync(t, children, processor, next);
      }
      next();
    }
    walkCB3Sync(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (const [target2, patterns] of processor.subwalks.entries()) {
        tasks++;
        this.walkCB2Sync(target2, patterns, processor.child(), next);
      }
      next();
    }
  }
  exports.GlobUtil = GlobUtil;

  class GlobWalker extends GlobUtil {
    matches = new Set;
    constructor(patterns, path3, opts) {
      super(patterns, path3, opts);
    }
    matchEmit(e) {
      this.matches.add(e);
    }
    async walk() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown()) {
        await this.path.lstat();
      }
      await new Promise((res, rej) => {
        this.walkCB(this.path, this.patterns, () => {
          if (this.signal?.aborted) {
            rej(this.signal.reason);
          } else {
            res(this.matches);
          }
        });
      });
      return this.matches;
    }
    walkSync() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown()) {
        this.path.lstatSync();
      }
      this.walkCBSync(this.path, this.patterns, () => {
        if (this.signal?.aborted)
          throw this.signal.reason;
      });
      return this.matches;
    }
  }
  exports.GlobWalker = GlobWalker;

  class GlobStream extends GlobUtil {
    results;
    constructor(patterns, path3, opts) {
      super(patterns, path3, opts);
      this.results = new minipass_1.Minipass({
        signal: this.signal,
        objectMode: true
      });
      this.results.on("drain", () => this.resume());
      this.results.on("resume", () => this.resume());
    }
    matchEmit(e) {
      this.results.write(e);
      if (!this.results.flowing)
        this.pause();
    }
    stream() {
      const target = this.path;
      if (target.isUnknown()) {
        target.lstat().then(() => {
          this.walkCB(target, this.patterns, () => this.results.end());
        });
      } else {
        this.walkCB(target, this.patterns, () => this.results.end());
      }
      return this.results;
    }
    streamSync() {
      if (this.path.isUnknown()) {
        this.path.lstatSync();
      }
      this.walkCBSync(this.path, this.patterns, () => this.results.end());
      return this.results;
    }
  }
  exports.GlobStream = GlobStream;
});

// node_modules/glob/dist/commonjs/glob.js
var require_glob = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Glob = undefined;
  var minimatch_1 = require_commonjs();
  var node_url_1 = __require("node:url");
  var path_scurry_1 = require_commonjs4();
  var pattern_js_1 = require_pattern();
  var walker_js_1 = require_walker();
  var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";

  class Glob {
    absolute;
    cwd;
    root;
    dot;
    dotRelative;
    follow;
    ignore;
    magicalBraces;
    mark;
    matchBase;
    maxDepth;
    nobrace;
    nocase;
    nodir;
    noext;
    noglobstar;
    pattern;
    platform;
    realpath;
    scurry;
    stat;
    signal;
    windowsPathsNoEscape;
    withFileTypes;
    includeChildMatches;
    opts;
    patterns;
    constructor(pattern, opts) {
      if (!opts)
        throw new TypeError("glob options required");
      this.withFileTypes = !!opts.withFileTypes;
      this.signal = opts.signal;
      this.follow = !!opts.follow;
      this.dot = !!opts.dot;
      this.dotRelative = !!opts.dotRelative;
      this.nodir = !!opts.nodir;
      this.mark = !!opts.mark;
      if (!opts.cwd) {
        this.cwd = "";
      } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
        opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);
      }
      this.cwd = opts.cwd || "";
      this.root = opts.root;
      this.magicalBraces = !!opts.magicalBraces;
      this.nobrace = !!opts.nobrace;
      this.noext = !!opts.noext;
      this.realpath = !!opts.realpath;
      this.absolute = opts.absolute;
      this.includeChildMatches = opts.includeChildMatches !== false;
      this.noglobstar = !!opts.noglobstar;
      this.matchBase = !!opts.matchBase;
      this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
      this.stat = !!opts.stat;
      this.ignore = opts.ignore;
      if (this.withFileTypes && this.absolute !== undefined) {
        throw new Error("cannot set absolute and withFileTypes:true");
      }
      if (typeof pattern === "string") {
        pattern = [pattern];
      }
      this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        pattern = pattern.map((p) => p.replace(/\\/g, "/"));
      }
      if (this.matchBase) {
        if (opts.noglobstar) {
          throw new TypeError("base matching requires globstar");
        }
        pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
      }
      this.pattern = pattern;
      this.platform = opts.platform || defaultPlatform;
      this.opts = { ...opts, platform: this.platform };
      if (opts.scurry) {
        this.scurry = opts.scurry;
        if (opts.nocase !== undefined && opts.nocase !== opts.scurry.nocase) {
          throw new Error("nocase option contradicts provided scurry option");
        }
      } else {
        const Scurry = opts.platform === "win32" ? path_scurry_1.PathScurryWin32 : opts.platform === "darwin" ? path_scurry_1.PathScurryDarwin : opts.platform ? path_scurry_1.PathScurryPosix : path_scurry_1.PathScurry;
        this.scurry = new Scurry(this.cwd, {
          nocase: opts.nocase,
          fs: opts.fs
        });
      }
      this.nocase = this.scurry.nocase;
      const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
      const mmo = {
        ...opts,
        dot: this.dot,
        matchBase: this.matchBase,
        nobrace: this.nobrace,
        nocase: this.nocase,
        nocaseMagicOnly,
        nocomment: true,
        noext: this.noext,
        nonegate: true,
        optimizationLevel: 2,
        platform: this.platform,
        windowsPathsNoEscape: this.windowsPathsNoEscape,
        debug: !!this.opts.debug
      };
      const mms = this.pattern.map((p) => new minimatch_1.Minimatch(p, mmo));
      const [matchSet, globParts] = mms.reduce((set, m) => {
        set[0].push(...m.set);
        set[1].push(...m.globParts);
        return set;
      }, [[], []]);
      this.patterns = matchSet.map((set, i) => {
        const g = globParts[i];
        if (!g)
          throw new Error("invalid pattern object");
        return new pattern_js_1.Pattern(set, g, 0, this.platform);
      });
    }
    async walk() {
      return [
        ...await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).walk()
      ];
    }
    walkSync() {
      return [
        ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).walkSync()
      ];
    }
    stream() {
      return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).stream();
    }
    streamSync() {
      return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).streamSync();
    }
    iterateSync() {
      return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    iterate() {
      return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
  }
  exports.Glob = Glob;
});

// node_modules/glob/dist/commonjs/has-magic.js
var require_has_magic = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasMagic = undefined;
  var minimatch_1 = require_commonjs();
  var hasMagic = (pattern, options = {}) => {
    if (!Array.isArray(pattern)) {
      pattern = [pattern];
    }
    for (const p of pattern) {
      if (new minimatch_1.Minimatch(p, options).hasMagic())
        return true;
    }
    return false;
  };
  exports.hasMagic = hasMagic;
});

// node_modules/glob/dist/commonjs/index.js
var require_commonjs5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.glob = exports.sync = exports.iterate = exports.iterateSync = exports.stream = exports.streamSync = exports.Ignore = exports.hasMagic = exports.Glob = exports.unescape = exports.escape = undefined;
  exports.globStreamSync = globStreamSync;
  exports.globStream = globStream;
  exports.globSync = globSync;
  exports.globIterateSync = globIterateSync;
  exports.globIterate = globIterate;
  var minimatch_1 = require_commonjs();
  var glob_js_1 = require_glob();
  var has_magic_js_1 = require_has_magic();
  var minimatch_2 = require_commonjs();
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return minimatch_2.escape;
  } });
  Object.defineProperty(exports, "unescape", { enumerable: true, get: function() {
    return minimatch_2.unescape;
  } });
  var glob_js_2 = require_glob();
  Object.defineProperty(exports, "Glob", { enumerable: true, get: function() {
    return glob_js_2.Glob;
  } });
  var has_magic_js_2 = require_has_magic();
  Object.defineProperty(exports, "hasMagic", { enumerable: true, get: function() {
    return has_magic_js_2.hasMagic;
  } });
  var ignore_js_1 = require_ignore();
  Object.defineProperty(exports, "Ignore", { enumerable: true, get: function() {
    return ignore_js_1.Ignore;
  } });
  function globStreamSync(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).streamSync();
  }
  function globStream(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).stream();
  }
  function globSync(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).walkSync();
  }
  async function glob_(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).walk();
  }
  function globIterateSync(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).iterateSync();
  }
  function globIterate(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).iterate();
  }
  exports.streamSync = globStreamSync;
  exports.stream = Object.assign(globStream, { sync: globStreamSync });
  exports.iterateSync = globIterateSync;
  exports.iterate = Object.assign(globIterate, {
    sync: globIterateSync
  });
  exports.sync = Object.assign(globSync, {
    stream: globStreamSync,
    iterate: globIterateSync
  });
  exports.glob = Object.assign(glob_, {
    glob: glob_,
    globSync,
    sync: exports.sync,
    globStream,
    stream: exports.stream,
    globStreamSync,
    streamSync: exports.streamSync,
    globIterate,
    iterate: exports.iterate,
    globIterateSync,
    iterateSync: exports.iterateSync,
    Glob: glob_js_1.Glob,
    hasMagic: has_magic_js_1.hasMagic,
    escape: minimatch_1.escape,
    unescape: minimatch_1.unescape
  });
  exports.glob.glob = exports.glob;
});

// node_modules/archiver-utils/file.js
var require_file2 = __commonJS((exports, module) => {
  var fs3 = require_graceful_fs();
  var path3 = __require("path");
  var flatten = require_flatten();
  var difference = require_difference();
  var union = require_union();
  var isPlainObject11 = require_isPlainObject();
  var glob = require_commonjs5();
  var file = module.exports = {};
  var pathSeparatorRe = /[\/\\]/g;
  var processPatterns = function(patterns, fn) {
    var result = [];
    flatten(patterns).forEach(function(pattern) {
      var exclusion = pattern.indexOf("!") === 0;
      if (exclusion) {
        pattern = pattern.slice(1);
      }
      var matches = fn(pattern);
      if (exclusion) {
        result = difference(result, matches);
      } else {
        result = union(result, matches);
      }
    });
    return result;
  };
  file.exists = function() {
    var filepath = path3.join.apply(path3, arguments);
    return fs3.existsSync(filepath);
  };
  file.expand = function(...args) {
    var options = isPlainObject11(args[0]) ? args.shift() : {};
    var patterns = Array.isArray(args[0]) ? args[0] : args;
    if (patterns.length === 0) {
      return [];
    }
    var matches = processPatterns(patterns, function(pattern) {
      return glob.sync(pattern, options);
    });
    if (options.filter) {
      matches = matches.filter(function(filepath) {
        filepath = path3.join(options.cwd || "", filepath);
        try {
          if (typeof options.filter === "function") {
            return options.filter(filepath);
          } else {
            return fs3.statSync(filepath)[options.filter]();
          }
        } catch (e) {
          return false;
        }
      });
    }
    return matches;
  };
  file.expandMapping = function(patterns, destBase, options) {
    options = Object.assign({
      rename: function(destBase2, destPath) {
        return path3.join(destBase2 || "", destPath);
      }
    }, options);
    var files = [];
    var fileByDest = {};
    file.expand(options, patterns).forEach(function(src) {
      var destPath = src;
      if (options.flatten) {
        destPath = path3.basename(destPath);
      }
      if (options.ext) {
        destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
      }
      var dest = options.rename(destBase, destPath, options);
      if (options.cwd) {
        src = path3.join(options.cwd, src);
      }
      dest = dest.replace(pathSeparatorRe, "/");
      src = src.replace(pathSeparatorRe, "/");
      if (fileByDest[dest]) {
        fileByDest[dest].src.push(src);
      } else {
        files.push({
          src: [src],
          dest
        });
        fileByDest[dest] = files[files.length - 1];
      }
    });
    return files;
  };
  file.normalizeFilesArray = function(data) {
    var files = [];
    data.forEach(function(obj) {
      var prop;
      if ("src" in obj || "dest" in obj) {
        files.push(obj);
      }
    });
    if (files.length === 0) {
      return [];
    }
    files = _(files).chain().forEach(function(obj) {
      if (!("src" in obj) || !obj.src) {
        return;
      }
      if (Array.isArray(obj.src)) {
        obj.src = flatten(obj.src);
      } else {
        obj.src = [obj.src];
      }
    }).map(function(obj) {
      var expandOptions = Object.assign({}, obj);
      delete expandOptions.src;
      delete expandOptions.dest;
      if (obj.expand) {
        return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
          var result2 = Object.assign({}, obj);
          result2.orig = Object.assign({}, obj);
          result2.src = mapObj.src;
          result2.dest = mapObj.dest;
          ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
            delete result2[prop];
          });
          return result2;
        });
      }
      var result = Object.assign({}, obj);
      result.orig = Object.assign({}, obj);
      if ("src" in result) {
        Object.defineProperty(result, "src", {
          enumerable: true,
          get: function fn() {
            var src;
            if (!("result" in fn)) {
              src = obj.src;
              src = Array.isArray(src) ? flatten(src) : [src];
              fn.result = file.expand(expandOptions, src);
            }
            return fn.result;
          }
        });
      }
      if ("dest" in result) {
        result.dest = obj.dest;
      }
      return result;
    }).flatten().value();
    return files;
  };
});

// node_modules/archiver-utils/index.js
var require_archiver_utils = __commonJS((exports, module) => {
  var fs3 = require_graceful_fs();
  var path3 = __require("path");
  var isStream = require_is_stream();
  var lazystream = require_lazystream();
  var normalizePath = require_normalize_path();
  var defaults = require_defaults();
  var Stream = __require("stream").Stream;
  var PassThrough = require_ours().PassThrough;
  var utils = module.exports = {};
  utils.file = require_file2();
  utils.collectStream = function(source, callback) {
    var collection = [];
    var size = 0;
    source.on("error", callback);
    source.on("data", function(chunk) {
      collection.push(chunk);
      size += chunk.length;
    });
    source.on("end", function() {
      var buf = Buffer.alloc(size);
      var offset = 0;
      collection.forEach(function(data) {
        data.copy(buf, offset);
        offset += data.length;
      });
      callback(null, buf);
    });
  };
  utils.dateify = function(dateish) {
    dateish = dateish || new Date;
    if (dateish instanceof Date) {
      dateish = dateish;
    } else if (typeof dateish === "string") {
      dateish = new Date(dateish);
    } else {
      dateish = new Date;
    }
    return dateish;
  };
  utils.defaults = function(object, source, guard) {
    var args = arguments;
    args[0] = args[0] || {};
    return defaults(...args);
  };
  utils.isStream = function(source) {
    return isStream(source);
  };
  utils.lazyReadStream = function(filepath) {
    return new lazystream.Readable(function() {
      return fs3.createReadStream(filepath);
    });
  };
  utils.normalizeInputSource = function(source) {
    if (source === null) {
      return Buffer.alloc(0);
    } else if (typeof source === "string") {
      return Buffer.from(source);
    } else if (utils.isStream(source)) {
      return source.pipe(new PassThrough);
    }
    return source;
  };
  utils.sanitizePath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
  };
  utils.trailingSlashIt = function(str) {
    return str.slice(-1) !== "/" ? str + "/" : str;
  };
  utils.unixifyPath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "");
  };
  utils.walkdir = function(dirpath, base, callback) {
    var results = [];
    if (typeof base === "function") {
      callback = base;
      base = dirpath;
    }
    fs3.readdir(dirpath, function(err, list) {
      var i = 0;
      var file;
      var filepath;
      if (err) {
        return callback(err);
      }
      (function next() {
        file = list[i++];
        if (!file) {
          return callback(null, results);
        }
        filepath = path3.join(dirpath, file);
        fs3.stat(filepath, function(err2, stats) {
          results.push({
            path: filepath,
            relative: path3.relative(base, filepath).replace(/\\/g, "/"),
            stats
          });
          if (stats && stats.isDirectory()) {
            utils.walkdir(filepath, base, function(err3, res) {
              if (err3) {
                return callback(err3);
              }
              res.forEach(function(dirEntry) {
                results.push(dirEntry);
              });
              next();
            });
          } else {
            next();
          }
        });
      })();
    });
  };
});

// node_modules/archiver/lib/error.js
var require_error = __commonJS((exports, module) => {
  var util = __require("util");
  var ERROR_CODES = {
    ABORTED: "archive was aborted",
    DIRECTORYDIRPATHREQUIRED: "diretory dirpath argument must be a non-empty string value",
    DIRECTORYFUNCTIONINVALIDDATA: "invalid data returned by directory custom data function",
    ENTRYNAMEREQUIRED: "entry name must be a non-empty string value",
    FILEFILEPATHREQUIRED: "file filepath argument must be a non-empty string value",
    FINALIZING: "archive already finalizing",
    QUEUECLOSED: "queue closed",
    NOENDMETHOD: "no suitable finalize/end method defined by module",
    DIRECTORYNOTSUPPORTED: "support for directory entries not defined by module",
    FORMATSET: "archive format already set",
    INPUTSTEAMBUFFERREQUIRED: "input source must be valid Stream or Buffer instance",
    MODULESET: "module already set",
    SYMLINKNOTSUPPORTED: "support for symlink entries not defined by module",
    SYMLINKFILEPATHREQUIRED: "symlink filepath argument must be a non-empty string value",
    SYMLINKTARGETREQUIRED: "symlink target argument must be a non-empty string value",
    ENTRYNOTSUPPORTED: "entry not supported"
  };
  function ArchiverError(code, data) {
    Error.captureStackTrace(this, this.constructor);
    this.message = ERROR_CODES[code] || code;
    this.code = code;
    this.data = data;
  }
  util.inherits(ArchiverError, Error);
  exports = module.exports = ArchiverError;
});

// node_modules/archiver/lib/core.js
var require_core = __commonJS((exports, module) => {
  var fs3 = __require("fs");
  var glob = require_readdir_glob();
  var async = require_async2();
  var path3 = __require("path");
  var util = require_archiver_utils();
  var inherits = __require("util").inherits;
  var ArchiverError = require_error();
  var Transform = require_ours().Transform;
  var win32 = process.platform === "win32";
  var Archiver = function(format, options) {
    if (!(this instanceof Archiver)) {
      return new Archiver(format, options);
    }
    if (typeof format !== "string") {
      options = format;
      format = "zip";
    }
    options = this.options = util.defaults(options, {
      highWaterMark: 1024 * 1024,
      statConcurrency: 4
    });
    Transform.call(this, options);
    this._format = false;
    this._module = false;
    this._pending = 0;
    this._pointer = 0;
    this._entriesCount = 0;
    this._entriesProcessedCount = 0;
    this._fsEntriesTotalBytes = 0;
    this._fsEntriesProcessedBytes = 0;
    this._queue = async.queue(this._onQueueTask.bind(this), 1);
    this._queue.drain(this._onQueueDrain.bind(this));
    this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);
    this._statQueue.drain(this._onQueueDrain.bind(this));
    this._state = {
      aborted: false,
      finalize: false,
      finalizing: false,
      finalized: false,
      modulePiped: false
    };
    this._streams = [];
  };
  inherits(Archiver, Transform);
  Archiver.prototype._abort = function() {
    this._state.aborted = true;
    this._queue.kill();
    this._statQueue.kill();
    if (this._queue.idle()) {
      this._shutdown();
    }
  };
  Archiver.prototype._append = function(filepath, data) {
    data = data || {};
    var task = {
      source: null,
      filepath
    };
    if (!data.name) {
      data.name = filepath;
    }
    data.sourcePath = filepath;
    task.data = data;
    this._entriesCount++;
    if (data.stats && data.stats instanceof fs3.Stats) {
      task = this._updateQueueTaskWithStats(task, data.stats);
      if (task) {
        if (data.stats.size) {
          this._fsEntriesTotalBytes += data.stats.size;
        }
        this._queue.push(task);
      }
    } else {
      this._statQueue.push(task);
    }
  };
  Archiver.prototype._finalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return;
    }
    this._state.finalizing = true;
    this._moduleFinalize();
    this._state.finalizing = false;
    this._state.finalized = true;
  };
  Archiver.prototype._maybeFinalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return false;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
      return true;
    }
    return false;
  };
  Archiver.prototype._moduleAppend = function(source, data, callback) {
    if (this._state.aborted) {
      callback();
      return;
    }
    this._module.append(source, data, function(err) {
      this._task = null;
      if (this._state.aborted) {
        this._shutdown();
        return;
      }
      if (err) {
        this.emit("error", err);
        setImmediate(callback);
        return;
      }
      this.emit("entry", data);
      this._entriesProcessedCount++;
      if (data.stats && data.stats.size) {
        this._fsEntriesProcessedBytes += data.stats.size;
      }
      this.emit("progress", {
        entries: {
          total: this._entriesCount,
          processed: this._entriesProcessedCount
        },
        fs: {
          totalBytes: this._fsEntriesTotalBytes,
          processedBytes: this._fsEntriesProcessedBytes
        }
      });
      setImmediate(callback);
    }.bind(this));
  };
  Archiver.prototype._moduleFinalize = function() {
    if (typeof this._module.finalize === "function") {
      this._module.finalize();
    } else if (typeof this._module.end === "function") {
      this._module.end();
    } else {
      this.emit("error", new ArchiverError("NOENDMETHOD"));
    }
  };
  Archiver.prototype._modulePipe = function() {
    this._module.on("error", this._onModuleError.bind(this));
    this._module.pipe(this);
    this._state.modulePiped = true;
  };
  Archiver.prototype._moduleSupports = function(key12) {
    if (!this._module.supports || !this._module.supports[key12]) {
      return false;
    }
    return this._module.supports[key12];
  };
  Archiver.prototype._moduleUnpipe = function() {
    this._module.unpipe(this);
    this._state.modulePiped = false;
  };
  Archiver.prototype._normalizeEntryData = function(data, stats) {
    data = util.defaults(data, {
      type: "file",
      name: null,
      date: null,
      mode: null,
      prefix: null,
      sourcePath: null,
      stats: false
    });
    if (stats && data.stats === false) {
      data.stats = stats;
    }
    var isDir = data.type === "directory";
    if (data.name) {
      if (typeof data.prefix === "string" && data.prefix !== "") {
        data.name = data.prefix + "/" + data.name;
        data.prefix = null;
      }
      data.name = util.sanitizePath(data.name);
      if (data.type !== "symlink" && data.name.slice(-1) === "/") {
        isDir = true;
        data.type = "directory";
      } else if (isDir) {
        data.name += "/";
      }
    }
    if (typeof data.mode === "number") {
      if (win32) {
        data.mode &= 511;
      } else {
        data.mode &= 4095;
      }
    } else if (data.stats && data.mode === null) {
      if (win32) {
        data.mode = data.stats.mode & 511;
      } else {
        data.mode = data.stats.mode & 4095;
      }
      if (win32 && isDir) {
        data.mode = 493;
      }
    } else if (data.mode === null) {
      data.mode = isDir ? 493 : 420;
    }
    if (data.stats && data.date === null) {
      data.date = data.stats.mtime;
    } else {
      data.date = util.dateify(data.date);
    }
    return data;
  };
  Archiver.prototype._onModuleError = function(err) {
    this.emit("error", err);
  };
  Archiver.prototype._onQueueDrain = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
    }
  };
  Archiver.prototype._onQueueTask = function(task, callback) {
    var fullCallback = () => {
      if (task.data.callback) {
        task.data.callback();
      }
      callback();
    };
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      fullCallback();
      return;
    }
    this._task = task;
    this._moduleAppend(task.source, task.data, fullCallback);
  };
  Archiver.prototype._onStatQueueTask = function(task, callback) {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      callback();
      return;
    }
    fs3.lstat(task.filepath, function(err, stats) {
      if (this._state.aborted) {
        setImmediate(callback);
        return;
      }
      if (err) {
        this._entriesCount--;
        this.emit("warning", err);
        setImmediate(callback);
        return;
      }
      task = this._updateQueueTaskWithStats(task, stats);
      if (task) {
        if (stats.size) {
          this._fsEntriesTotalBytes += stats.size;
        }
        this._queue.push(task);
      }
      setImmediate(callback);
    }.bind(this));
  };
  Archiver.prototype._shutdown = function() {
    this._moduleUnpipe();
    this.end();
  };
  Archiver.prototype._transform = function(chunk, encoding, callback) {
    if (chunk) {
      this._pointer += chunk.length;
    }
    callback(null, chunk);
  };
  Archiver.prototype._updateQueueTaskWithStats = function(task, stats) {
    if (stats.isFile()) {
      task.data.type = "file";
      task.data.sourceType = "stream";
      task.source = util.lazyReadStream(task.filepath);
    } else if (stats.isDirectory() && this._moduleSupports("directory")) {
      task.data.name = util.trailingSlashIt(task.data.name);
      task.data.type = "directory";
      task.data.sourcePath = util.trailingSlashIt(task.filepath);
      task.data.sourceType = "buffer";
      task.source = Buffer.concat([]);
    } else if (stats.isSymbolicLink() && this._moduleSupports("symlink")) {
      var linkPath = fs3.readlinkSync(task.filepath);
      var dirName = path3.dirname(task.filepath);
      task.data.type = "symlink";
      task.data.linkname = path3.relative(dirName, path3.resolve(dirName, linkPath));
      task.data.sourceType = "buffer";
      task.source = Buffer.concat([]);
    } else {
      if (stats.isDirectory()) {
        this.emit("warning", new ArchiverError("DIRECTORYNOTSUPPORTED", task.data));
      } else if (stats.isSymbolicLink()) {
        this.emit("warning", new ArchiverError("SYMLINKNOTSUPPORTED", task.data));
      } else {
        this.emit("warning", new ArchiverError("ENTRYNOTSUPPORTED", task.data));
      }
      return null;
    }
    task.data = this._normalizeEntryData(task.data, stats);
    return task;
  };
  Archiver.prototype.abort = function() {
    if (this._state.aborted || this._state.finalized) {
      return this;
    }
    this._abort();
    return this;
  };
  Archiver.prototype.append = function(source, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    data = this._normalizeEntryData(data);
    if (typeof data.name !== "string" || data.name.length === 0) {
      this.emit("error", new ArchiverError("ENTRYNAMEREQUIRED"));
      return this;
    }
    if (data.type === "directory" && !this._moduleSupports("directory")) {
      this.emit("error", new ArchiverError("DIRECTORYNOTSUPPORTED", { name: data.name }));
      return this;
    }
    source = util.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
      data.sourceType = "buffer";
    } else if (util.isStream(source)) {
      data.sourceType = "stream";
    } else {
      this.emit("error", new ArchiverError("INPUTSTEAMBUFFERREQUIRED", { name: data.name }));
      return this;
    }
    this._entriesCount++;
    this._queue.push({
      data,
      source
    });
    return this;
  };
  Archiver.prototype.directory = function(dirpath, destpath, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof dirpath !== "string" || dirpath.length === 0) {
      this.emit("error", new ArchiverError("DIRECTORYDIRPATHREQUIRED"));
      return this;
    }
    this._pending++;
    if (destpath === false) {
      destpath = "";
    } else if (typeof destpath !== "string") {
      destpath = dirpath;
    }
    var dataFunction = false;
    if (typeof data === "function") {
      dataFunction = data;
      data = {};
    } else if (typeof data !== "object") {
      data = {};
    }
    var globOptions = {
      stat: true,
      dot: true
    };
    function onGlobEnd() {
      this._pending--;
      this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      globber.pause();
      var ignoreMatch = false;
      var entryData = Object.assign({}, data);
      entryData.name = match.relative;
      entryData.prefix = destpath;
      entryData.stats = match.stat;
      entryData.callback = globber.resume.bind(globber);
      try {
        if (dataFunction) {
          entryData = dataFunction(entryData);
          if (entryData === false) {
            ignoreMatch = true;
          } else if (typeof entryData !== "object") {
            throw new ArchiverError("DIRECTORYFUNCTIONINVALIDDATA", { dirpath });
          }
        }
      } catch (e) {
        this.emit("error", e);
        return;
      }
      if (ignoreMatch) {
        globber.resume();
        return;
      }
      this._append(match.absolute, entryData);
    }
    var globber = glob(dirpath, globOptions);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
  };
  Archiver.prototype.file = function(filepath, data) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
      this.emit("error", new ArchiverError("FILEFILEPATHREQUIRED"));
      return this;
    }
    this._append(filepath, data);
    return this;
  };
  Archiver.prototype.glob = function(pattern, options, data) {
    this._pending++;
    options = util.defaults(options, {
      stat: true,
      pattern
    });
    function onGlobEnd() {
      this._pending--;
      this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      globber.pause();
      var entryData = Object.assign({}, data);
      entryData.callback = globber.resume.bind(globber);
      entryData.stats = match.stat;
      entryData.name = match.relative;
      this._append(match.absolute, entryData);
    }
    var globber = glob(options.cwd || ".", options);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
  };
  Archiver.prototype.finalize = function() {
    if (this._state.aborted) {
      var abortedError = new ArchiverError("ABORTED");
      this.emit("error", abortedError);
      return Promise.reject(abortedError);
    }
    if (this._state.finalize) {
      var finalizingError = new ArchiverError("FINALIZING");
      this.emit("error", finalizingError);
      return Promise.reject(finalizingError);
    }
    this._state.finalize = true;
    if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
    }
    var self2 = this;
    return new Promise(function(resolve, reject) {
      var errored;
      self2._module.on("end", function() {
        if (!errored) {
          resolve();
        }
      });
      self2._module.on("error", function(err) {
        errored = true;
        reject(err);
      });
    });
  };
  Archiver.prototype.setFormat = function(format) {
    if (this._format) {
      this.emit("error", new ArchiverError("FORMATSET"));
      return this;
    }
    this._format = format;
    return this;
  };
  Archiver.prototype.setModule = function(module2) {
    if (this._state.aborted) {
      this.emit("error", new ArchiverError("ABORTED"));
      return this;
    }
    if (this._state.module) {
      this.emit("error", new ArchiverError("MODULESET"));
      return this;
    }
    this._module = module2;
    this._modulePipe();
    return this;
  };
  Archiver.prototype.symlink = function(filepath, target, mode) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
      this.emit("error", new ArchiverError("SYMLINKFILEPATHREQUIRED"));
      return this;
    }
    if (typeof target !== "string" || target.length === 0) {
      this.emit("error", new ArchiverError("SYMLINKTARGETREQUIRED", { filepath }));
      return this;
    }
    if (!this._moduleSupports("symlink")) {
      this.emit("error", new ArchiverError("SYMLINKNOTSUPPORTED", { filepath }));
      return this;
    }
    var data = {};
    data.type = "symlink";
    data.name = filepath.replace(/\\/g, "/");
    data.linkname = target.replace(/\\/g, "/");
    data.sourceType = "buffer";
    if (typeof mode === "number") {
      data.mode = mode;
    }
    this._entriesCount++;
    this._queue.push({
      data,
      source: Buffer.concat([])
    });
    return this;
  };
  Archiver.prototype.pointer = function() {
    return this._pointer;
  };
  Archiver.prototype.use = function(plugin) {
    this._streams.push(plugin);
    return this;
  };
  module.exports = Archiver;
});

// node_modules/compress-commons/lib/archivers/archive-entry.js
var require_archive_entry = __commonJS((exports, module) => {
  var ArchiveEntry = module.exports = function() {
  };
  ArchiveEntry.prototype.getName = function() {
  };
  ArchiveEntry.prototype.getSize = function() {
  };
  ArchiveEntry.prototype.getLastModifiedDate = function() {
  };
  ArchiveEntry.prototype.isDirectory = function() {
  };
});

// node_modules/compress-commons/lib/archivers/zip/util.js
var require_util3 = __commonJS((exports, module) => {
  var util = module.exports = {};
  util.dateToDos = function(d, forceLocalTime) {
    forceLocalTime = forceLocalTime || false;
    var year = forceLocalTime ? d.getFullYear() : d.getUTCFullYear();
    if (year < 1980) {
      return 2162688;
    } else if (year >= 2044) {
      return 2141175677;
    }
    var val = {
      year,
      month: forceLocalTime ? d.getMonth() : d.getUTCMonth(),
      date: forceLocalTime ? d.getDate() : d.getUTCDate(),
      hours: forceLocalTime ? d.getHours() : d.getUTCHours(),
      minutes: forceLocalTime ? d.getMinutes() : d.getUTCMinutes(),
      seconds: forceLocalTime ? d.getSeconds() : d.getUTCSeconds()
    };
    return val.year - 1980 << 25 | val.month + 1 << 21 | val.date << 16 | val.hours << 11 | val.minutes << 5 | val.seconds / 2;
  };
  util.dosToDate = function(dos) {
    return new Date((dos >> 25 & 127) + 1980, (dos >> 21 & 15) - 1, dos >> 16 & 31, dos >> 11 & 31, dos >> 5 & 63, (dos & 31) << 1);
  };
  util.fromDosTime = function(buf) {
    return util.dosToDate(buf.readUInt32LE(0));
  };
  util.getEightBytes = function(v) {
    var buf = Buffer.alloc(8);
    buf.writeUInt32LE(v % 4294967296, 0);
    buf.writeUInt32LE(v / 4294967296 | 0, 4);
    return buf;
  };
  util.getShortBytes = function(v) {
    var buf = Buffer.alloc(2);
    buf.writeUInt16LE((v & 65535) >>> 0, 0);
    return buf;
  };
  util.getShortBytesValue = function(buf, offset) {
    return buf.readUInt16LE(offset);
  };
  util.getLongBytes = function(v) {
    var buf = Buffer.alloc(4);
    buf.writeUInt32LE((v & 4294967295) >>> 0, 0);
    return buf;
  };
  util.getLongBytesValue = function(buf, offset) {
    return buf.readUInt32LE(offset);
  };
  util.toDosTime = function(d) {
    return util.getLongBytes(util.dateToDos(d));
  };
});

// node_modules/compress-commons/lib/archivers/zip/general-purpose-bit.js
var require_general_purpose_bit = __commonJS((exports, module) => {
  var zipUtil = require_util3();
  var DATA_DESCRIPTOR_FLAG = 1 << 3;
  var ENCRYPTION_FLAG = 1 << 0;
  var NUMBER_OF_SHANNON_FANO_TREES_FLAG = 1 << 2;
  var SLIDING_DICTIONARY_SIZE_FLAG = 1 << 1;
  var STRONG_ENCRYPTION_FLAG = 1 << 6;
  var UFT8_NAMES_FLAG = 1 << 11;
  var GeneralPurposeBit = module.exports = function() {
    if (!(this instanceof GeneralPurposeBit)) {
      return new GeneralPurposeBit;
    }
    this.descriptor = false;
    this.encryption = false;
    this.utf8 = false;
    this.numberOfShannonFanoTrees = 0;
    this.strongEncryption = false;
    this.slidingDictionarySize = 0;
    return this;
  };
  GeneralPurposeBit.prototype.encode = function() {
    return zipUtil.getShortBytes((this.descriptor ? DATA_DESCRIPTOR_FLAG : 0) | (this.utf8 ? UFT8_NAMES_FLAG : 0) | (this.encryption ? ENCRYPTION_FLAG : 0) | (this.strongEncryption ? STRONG_ENCRYPTION_FLAG : 0));
  };
  GeneralPurposeBit.prototype.parse = function(buf, offset) {
    var flag = zipUtil.getShortBytesValue(buf, offset);
    var gbp = new GeneralPurposeBit;
    gbp.useDataDescriptor((flag & DATA_DESCRIPTOR_FLAG) !== 0);
    gbp.useUTF8ForNames((flag & UFT8_NAMES_FLAG) !== 0);
    gbp.useStrongEncryption((flag & STRONG_ENCRYPTION_FLAG) !== 0);
    gbp.useEncryption((flag & ENCRYPTION_FLAG) !== 0);
    gbp.setSlidingDictionarySize((flag & SLIDING_DICTIONARY_SIZE_FLAG) !== 0 ? 8192 : 4096);
    gbp.setNumberOfShannonFanoTrees((flag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) !== 0 ? 3 : 2);
    return gbp;
  };
  GeneralPurposeBit.prototype.setNumberOfShannonFanoTrees = function(n) {
    this.numberOfShannonFanoTrees = n;
  };
  GeneralPurposeBit.prototype.getNumberOfShannonFanoTrees = function() {
    return this.numberOfShannonFanoTrees;
  };
  GeneralPurposeBit.prototype.setSlidingDictionarySize = function(n) {
    this.slidingDictionarySize = n;
  };
  GeneralPurposeBit.prototype.getSlidingDictionarySize = function() {
    return this.slidingDictionarySize;
  };
  GeneralPurposeBit.prototype.useDataDescriptor = function(b) {
    this.descriptor = b;
  };
  GeneralPurposeBit.prototype.usesDataDescriptor = function() {
    return this.descriptor;
  };
  GeneralPurposeBit.prototype.useEncryption = function(b) {
    this.encryption = b;
  };
  GeneralPurposeBit.prototype.usesEncryption = function() {
    return this.encryption;
  };
  GeneralPurposeBit.prototype.useStrongEncryption = function(b) {
    this.strongEncryption = b;
  };
  GeneralPurposeBit.prototype.usesStrongEncryption = function() {
    return this.strongEncryption;
  };
  GeneralPurposeBit.prototype.useUTF8ForNames = function(b) {
    this.utf8 = b;
  };
  GeneralPurposeBit.prototype.usesUTF8ForNames = function() {
    return this.utf8;
  };
});

// node_modules/compress-commons/lib/archivers/zip/unix-stat.js
var require_unix_stat = __commonJS((exports, module) => {
  module.exports = {
    PERM_MASK: 4095,
    FILE_TYPE_FLAG: 61440,
    LINK_FLAG: 40960,
    FILE_FLAG: 32768,
    DIR_FLAG: 16384,
    DEFAULT_LINK_PERM: 511,
    DEFAULT_DIR_PERM: 493,
    DEFAULT_FILE_PERM: 420
  };
});

// node_modules/compress-commons/lib/archivers/zip/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    WORD: 4,
    DWORD: 8,
    EMPTY: Buffer.alloc(0),
    SHORT: 2,
    SHORT_MASK: 65535,
    SHORT_SHIFT: 16,
    SHORT_ZERO: Buffer.from(Array(2)),
    LONG: 4,
    LONG_ZERO: Buffer.from(Array(4)),
    MIN_VERSION_INITIAL: 10,
    MIN_VERSION_DATA_DESCRIPTOR: 20,
    MIN_VERSION_ZIP64: 45,
    VERSION_MADEBY: 45,
    METHOD_STORED: 0,
    METHOD_DEFLATED: 8,
    PLATFORM_UNIX: 3,
    PLATFORM_FAT: 0,
    SIG_LFH: 67324752,
    SIG_DD: 134695760,
    SIG_CFH: 33639248,
    SIG_EOCD: 101010256,
    SIG_ZIP64_EOCD: 101075792,
    SIG_ZIP64_EOCD_LOC: 117853008,
    ZIP64_MAGIC_SHORT: 65535,
    ZIP64_MAGIC: 4294967295,
    ZIP64_EXTRA_ID: 1,
    ZLIB_NO_COMPRESSION: 0,
    ZLIB_BEST_SPEED: 1,
    ZLIB_BEST_COMPRESSION: 9,
    ZLIB_DEFAULT_COMPRESSION: -1,
    MODE_MASK: 4095,
    DEFAULT_FILE_MODE: 33188,
    DEFAULT_DIR_MODE: 16877,
    EXT_FILE_ATTR_DIR: 1106051088,
    EXT_FILE_ATTR_FILE: 2175008800,
    S_IFMT: 61440,
    S_IFIFO: 4096,
    S_IFCHR: 8192,
    S_IFDIR: 16384,
    S_IFBLK: 24576,
    S_IFREG: 32768,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    S_DOS_A: 32,
    S_DOS_D: 16,
    S_DOS_V: 8,
    S_DOS_S: 4,
    S_DOS_H: 2,
    S_DOS_R: 1
  };
});

// node_modules/compress-commons/lib/archivers/zip/zip-archive-entry.js
var require_zip_archive_entry = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var normalizePath = require_normalize_path();
  var ArchiveEntry = require_archive_entry();
  var GeneralPurposeBit = require_general_purpose_bit();
  var UnixStat = require_unix_stat();
  var constants = require_constants();
  var zipUtil = require_util3();
  var ZipArchiveEntry = module.exports = function(name) {
    if (!(this instanceof ZipArchiveEntry)) {
      return new ZipArchiveEntry(name);
    }
    ArchiveEntry.call(this);
    this.platform = constants.PLATFORM_FAT;
    this.method = -1;
    this.name = null;
    this.size = 0;
    this.csize = 0;
    this.gpb = new GeneralPurposeBit;
    this.crc = 0;
    this.time = -1;
    this.minver = constants.MIN_VERSION_INITIAL;
    this.mode = -1;
    this.extra = null;
    this.exattr = 0;
    this.inattr = 0;
    this.comment = null;
    if (name) {
      this.setName(name);
    }
  };
  inherits(ZipArchiveEntry, ArchiveEntry);
  ZipArchiveEntry.prototype.getCentralDirectoryExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getComment = function() {
    return this.comment !== null ? this.comment : "";
  };
  ZipArchiveEntry.prototype.getCompressedSize = function() {
    return this.csize;
  };
  ZipArchiveEntry.prototype.getCrc = function() {
    return this.crc;
  };
  ZipArchiveEntry.prototype.getExternalAttributes = function() {
    return this.exattr;
  };
  ZipArchiveEntry.prototype.getExtra = function() {
    return this.extra !== null ? this.extra : constants.EMPTY;
  };
  ZipArchiveEntry.prototype.getGeneralPurposeBit = function() {
    return this.gpb;
  };
  ZipArchiveEntry.prototype.getInternalAttributes = function() {
    return this.inattr;
  };
  ZipArchiveEntry.prototype.getLastModifiedDate = function() {
    return this.getTime();
  };
  ZipArchiveEntry.prototype.getLocalFileDataExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getMethod = function() {
    return this.method;
  };
  ZipArchiveEntry.prototype.getName = function() {
    return this.name;
  };
  ZipArchiveEntry.prototype.getPlatform = function() {
    return this.platform;
  };
  ZipArchiveEntry.prototype.getSize = function() {
    return this.size;
  };
  ZipArchiveEntry.prototype.getTime = function() {
    return this.time !== -1 ? zipUtil.dosToDate(this.time) : -1;
  };
  ZipArchiveEntry.prototype.getTimeDos = function() {
    return this.time !== -1 ? this.time : 0;
  };
  ZipArchiveEntry.prototype.getUnixMode = function() {
    return this.platform !== constants.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> constants.SHORT_SHIFT & constants.SHORT_MASK;
  };
  ZipArchiveEntry.prototype.getVersionNeededToExtract = function() {
    return this.minver;
  };
  ZipArchiveEntry.prototype.setComment = function(comment) {
    if (Buffer.byteLength(comment) !== comment.length) {
      this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.comment = comment;
  };
  ZipArchiveEntry.prototype.setCompressedSize = function(size) {
    if (size < 0) {
      throw new Error("invalid entry compressed size");
    }
    this.csize = size;
  };
  ZipArchiveEntry.prototype.setCrc = function(crc) {
    if (crc < 0) {
      throw new Error("invalid entry crc32");
    }
    this.crc = crc;
  };
  ZipArchiveEntry.prototype.setExternalAttributes = function(attr) {
    this.exattr = attr >>> 0;
  };
  ZipArchiveEntry.prototype.setExtra = function(extra) {
    this.extra = extra;
  };
  ZipArchiveEntry.prototype.setGeneralPurposeBit = function(gpb) {
    if (!(gpb instanceof GeneralPurposeBit)) {
      throw new Error("invalid entry GeneralPurposeBit");
    }
    this.gpb = gpb;
  };
  ZipArchiveEntry.prototype.setInternalAttributes = function(attr) {
    this.inattr = attr;
  };
  ZipArchiveEntry.prototype.setMethod = function(method) {
    if (method < 0) {
      throw new Error("invalid entry compression method");
    }
    this.method = method;
  };
  ZipArchiveEntry.prototype.setName = function(name, prependSlash = false) {
    name = normalizePath(name, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
    if (prependSlash) {
      name = `/${name}`;
    }
    if (Buffer.byteLength(name) !== name.length) {
      this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.name = name;
  };
  ZipArchiveEntry.prototype.setPlatform = function(platform) {
    this.platform = platform;
  };
  ZipArchiveEntry.prototype.setSize = function(size) {
    if (size < 0) {
      throw new Error("invalid entry size");
    }
    this.size = size;
  };
  ZipArchiveEntry.prototype.setTime = function(time, forceLocalTime) {
    if (!(time instanceof Date)) {
      throw new Error("invalid entry time");
    }
    this.time = zipUtil.dateToDos(time, forceLocalTime);
  };
  ZipArchiveEntry.prototype.setUnixMode = function(mode) {
    mode |= this.isDirectory() ? constants.S_IFDIR : constants.S_IFREG;
    var extattr = 0;
    extattr |= mode << constants.SHORT_SHIFT | (this.isDirectory() ? constants.S_DOS_D : constants.S_DOS_A);
    this.setExternalAttributes(extattr);
    this.mode = mode & constants.MODE_MASK;
    this.platform = constants.PLATFORM_UNIX;
  };
  ZipArchiveEntry.prototype.setVersionNeededToExtract = function(minver) {
    this.minver = minver;
  };
  ZipArchiveEntry.prototype.isDirectory = function() {
    return this.getName().slice(-1) === "/";
  };
  ZipArchiveEntry.prototype.isUnixSymlink = function() {
    return (this.getUnixMode() & UnixStat.FILE_TYPE_FLAG) === UnixStat.LINK_FLAG;
  };
  ZipArchiveEntry.prototype.isZip64 = function() {
    return this.csize > constants.ZIP64_MAGIC || this.size > constants.ZIP64_MAGIC;
  };
});

// node_modules/compress-commons/node_modules/is-stream/index.js
var require_is_stream2 = __commonJS((exports, module) => {
  var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
  isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
  isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
  module.exports = isStream;
});

// node_modules/compress-commons/lib/util/index.js
var require_util4 = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream;
  var PassThrough = require_ours().PassThrough;
  var isStream = require_is_stream2();
  var util = module.exports = {};
  util.normalizeInputSource = function(source) {
    if (source === null) {
      return Buffer.alloc(0);
    } else if (typeof source === "string") {
      return Buffer.from(source);
    } else if (isStream(source) && !source._readableState) {
      var normalized = new PassThrough;
      source.pipe(normalized);
      return normalized;
    }
    return source;
  };
});

// node_modules/compress-commons/lib/archivers/archive-output-stream.js
var require_archive_output_stream = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var isStream = require_is_stream2();
  var Transform = require_ours().Transform;
  var ArchiveEntry = require_archive_entry();
  var util = require_util4();
  var ArchiveOutputStream = module.exports = function(options) {
    if (!(this instanceof ArchiveOutputStream)) {
      return new ArchiveOutputStream(options);
    }
    Transform.call(this, options);
    this.offset = 0;
    this._archive = {
      finish: false,
      finished: false,
      processing: false
    };
  };
  inherits(ArchiveOutputStream, Transform);
  ArchiveOutputStream.prototype._appendBuffer = function(zae, source, callback) {
  };
  ArchiveOutputStream.prototype._appendStream = function(zae, source, callback) {
  };
  ArchiveOutputStream.prototype._emitErrorCallback = function(err) {
    if (err) {
      this.emit("error", err);
    }
  };
  ArchiveOutputStream.prototype._finish = function(ae) {
  };
  ArchiveOutputStream.prototype._normalizeEntry = function(ae) {
  };
  ArchiveOutputStream.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  ArchiveOutputStream.prototype.entry = function(ae, source, callback) {
    source = source || null;
    if (typeof callback !== "function") {
      callback = this._emitErrorCallback.bind(this);
    }
    if (!(ae instanceof ArchiveEntry)) {
      callback(new Error("not a valid instance of ArchiveEntry"));
      return;
    }
    if (this._archive.finish || this._archive.finished) {
      callback(new Error("unacceptable entry after finish"));
      return;
    }
    if (this._archive.processing) {
      callback(new Error("already processing an entry"));
      return;
    }
    this._archive.processing = true;
    this._normalizeEntry(ae);
    this._entry = ae;
    source = util.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
      this._appendBuffer(ae, source, callback);
    } else if (isStream(source)) {
      this._appendStream(ae, source, callback);
    } else {
      this._archive.processing = false;
      callback(new Error("input source must be valid Stream or Buffer instance"));
      return;
    }
    return this;
  };
  ArchiveOutputStream.prototype.finish = function() {
    if (this._archive.processing) {
      this._archive.finish = true;
      return;
    }
    this._finish();
  };
  ArchiveOutputStream.prototype.getBytesWritten = function() {
    return this.offset;
  };
  ArchiveOutputStream.prototype.write = function(chunk, cb) {
    if (chunk) {
      this.offset += chunk.length;
    }
    return Transform.prototype.write.call(this, chunk, cb);
  };
});

// node_modules/crc-32/crc32.js
var require_crc32 = __commonJS((exports) => {
  /*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
  var CRC32;
  (function(factory) {
    if (typeof DO_NOT_EXPORT_CRC === "undefined") {
      if (typeof exports === "object") {
        factory(exports);
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          var module2 = {};
          factory(module2);
          return module2;
        });
      } else {
        factory(CRC32 = {});
      }
    } else {
      factory(CRC32 = {});
    }
  })(function(CRC322) {
    CRC322.version = "1.2.2";
    function signed_crc_table() {
      var c = 0, table = new Array(256);
      for (var n = 0;n != 256; ++n) {
        c = n;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        table[n] = c;
      }
      return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
    }
    var T0 = signed_crc_table();
    function slice_by_16_tables(T) {
      var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
      for (n = 0;n != 256; ++n)
        table[n] = T[n];
      for (n = 0;n != 256; ++n) {
        v = T[n];
        for (c = 256 + n;c < 4096; c += 256)
          v = table[c] = v >>> 8 ^ T[v & 255];
      }
      var out = [];
      for (n = 1;n != 16; ++n)
        out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
      return out;
    }
    var TT = slice_by_16_tables(T0);
    var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
    var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
    var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
    function crc32_bstr(bstr, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = bstr.length;i < L; )
        C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
      return ~C;
    }
    function crc32_buf(B, seed) {
      var C = seed ^ -1, L = B.length - 15, i = 0;
      for (;i < L; )
        C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
      L += 15;
      while (i < L)
        C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
      return ~C;
    }
    function crc32_str(str, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = str.length, c = 0, d = 0;i < L; ) {
        c = str.charCodeAt(i++);
        if (c < 128) {
          C = C >>> 8 ^ T0[(C ^ c) & 255];
        } else if (c < 2048) {
          C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        } else if (c >= 55296 && c < 57344) {
          c = (c & 1023) + 64;
          d = str.charCodeAt(i++) & 1023;
          C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
        } else {
          C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        }
      }
      return ~C;
    }
    CRC322.table = T0;
    CRC322.bstr = crc32_bstr;
    CRC322.buf = crc32_buf;
    CRC322.str = crc32_str;
  });
});

// node_modules/crc32-stream/lib/crc32-stream.js
var require_crc32_stream = __commonJS((exports, module) => {
  var { Transform } = require_ours();
  var crc32 = require_crc32();

  class CRC32Stream extends Transform {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4);
      this.checksum.writeInt32BE(0, 0);
      this.rawSize = 0;
    }
    _transform(chunk, encoding, callback) {
      if (chunk) {
        this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
        this.rawSize += chunk.length;
      }
      callback(null, chunk);
    }
    digest(encoding) {
      const checksum = Buffer.allocUnsafe(4);
      checksum.writeUInt32BE(this.checksum >>> 0, 0);
      return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size() {
      return this.rawSize;
    }
  }
  module.exports = CRC32Stream;
});

// node_modules/crc32-stream/lib/deflate-crc32-stream.js
var require_deflate_crc32_stream = __commonJS((exports, module) => {
  var { DeflateRaw } = __require("zlib");
  var crc32 = require_crc32();

  class DeflateCRC32Stream extends DeflateRaw {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4);
      this.checksum.writeInt32BE(0, 0);
      this.rawSize = 0;
      this.compressedSize = 0;
    }
    push(chunk, encoding) {
      if (chunk) {
        this.compressedSize += chunk.length;
      }
      return super.push(chunk, encoding);
    }
    _transform(chunk, encoding, callback) {
      if (chunk) {
        this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
        this.rawSize += chunk.length;
      }
      super._transform(chunk, encoding, callback);
    }
    digest(encoding) {
      const checksum = Buffer.allocUnsafe(4);
      checksum.writeUInt32BE(this.checksum >>> 0, 0);
      return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size(compressed = false) {
      if (compressed) {
        return this.compressedSize;
      } else {
        return this.rawSize;
      }
    }
  }
  module.exports = DeflateCRC32Stream;
});

// node_modules/crc32-stream/lib/index.js
var require_lib4 = __commonJS((exports, module) => {
  module.exports = {
    CRC32Stream: require_crc32_stream(),
    DeflateCRC32Stream: require_deflate_crc32_stream()
  };
});

// node_modules/compress-commons/lib/archivers/zip/zip-archive-output-stream.js
var require_zip_archive_output_stream = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var crc32 = require_crc32();
  var { CRC32Stream } = require_lib4();
  var { DeflateCRC32Stream } = require_lib4();
  var ArchiveOutputStream = require_archive_output_stream();
  var ZipArchiveEntry = require_zip_archive_entry();
  var GeneralPurposeBit = require_general_purpose_bit();
  var constants = require_constants();
  var util = require_util4();
  var zipUtil = require_util3();
  var ZipArchiveOutputStream = module.exports = function(options) {
    if (!(this instanceof ZipArchiveOutputStream)) {
      return new ZipArchiveOutputStream(options);
    }
    options = this.options = this._defaults(options);
    ArchiveOutputStream.call(this, options);
    this._entry = null;
    this._entries = [];
    this._archive = {
      centralLength: 0,
      centralOffset: 0,
      comment: "",
      finish: false,
      finished: false,
      processing: false,
      forceZip64: options.forceZip64,
      forceLocalTime: options.forceLocalTime
    };
  };
  inherits(ZipArchiveOutputStream, ArchiveOutputStream);
  ZipArchiveOutputStream.prototype._afterAppend = function(ae) {
    this._entries.push(ae);
    if (ae.getGeneralPurposeBit().usesDataDescriptor()) {
      this._writeDataDescriptor(ae);
    }
    this._archive.processing = false;
    this._entry = null;
    if (this._archive.finish && !this._archive.finished) {
      this._finish();
    }
  };
  ZipArchiveOutputStream.prototype._appendBuffer = function(ae, source, callback) {
    if (source.length === 0) {
      ae.setMethod(constants.METHOD_STORED);
    }
    var method = ae.getMethod();
    if (method === constants.METHOD_STORED) {
      ae.setSize(source.length);
      ae.setCompressedSize(source.length);
      ae.setCrc(crc32.buf(source) >>> 0);
    }
    this._writeLocalFileHeader(ae);
    if (method === constants.METHOD_STORED) {
      this.write(source);
      this._afterAppend(ae);
      callback(null, ae);
      return;
    } else if (method === constants.METHOD_DEFLATED) {
      this._smartStream(ae, callback).end(source);
      return;
    } else {
      callback(new Error("compression method " + method + " not implemented"));
      return;
    }
  };
  ZipArchiveOutputStream.prototype._appendStream = function(ae, source, callback) {
    ae.getGeneralPurposeBit().useDataDescriptor(true);
    ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
    this._writeLocalFileHeader(ae);
    var smart = this._smartStream(ae, callback);
    source.once("error", function(err) {
      smart.emit("error", err);
      smart.end();
    });
    source.pipe(smart);
  };
  ZipArchiveOutputStream.prototype._defaults = function(o) {
    if (typeof o !== "object") {
      o = {};
    }
    if (typeof o.zlib !== "object") {
      o.zlib = {};
    }
    if (typeof o.zlib.level !== "number") {
      o.zlib.level = constants.ZLIB_BEST_SPEED;
    }
    o.forceZip64 = !!o.forceZip64;
    o.forceLocalTime = !!o.forceLocalTime;
    return o;
  };
  ZipArchiveOutputStream.prototype._finish = function() {
    this._archive.centralOffset = this.offset;
    this._entries.forEach(function(ae) {
      this._writeCentralFileHeader(ae);
    }.bind(this));
    this._archive.centralLength = this.offset - this._archive.centralOffset;
    if (this.isZip64()) {
      this._writeCentralDirectoryZip64();
    }
    this._writeCentralDirectoryEnd();
    this._archive.processing = false;
    this._archive.finish = true;
    this._archive.finished = true;
    this.end();
  };
  ZipArchiveOutputStream.prototype._normalizeEntry = function(ae) {
    if (ae.getMethod() === -1) {
      ae.setMethod(constants.METHOD_DEFLATED);
    }
    if (ae.getMethod() === constants.METHOD_DEFLATED) {
      ae.getGeneralPurposeBit().useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
    }
    if (ae.getTime() === -1) {
      ae.setTime(new Date, this._archive.forceLocalTime);
    }
    ae._offsets = {
      file: 0,
      data: 0,
      contents: 0
    };
  };
  ZipArchiveOutputStream.prototype._smartStream = function(ae, callback) {
    var deflate = ae.getMethod() === constants.METHOD_DEFLATED;
    var process20 = deflate ? new DeflateCRC32Stream(this.options.zlib) : new CRC32Stream;
    var error = null;
    function handleStuff() {
      var digest = process20.digest().readUInt32BE(0);
      ae.setCrc(digest);
      ae.setSize(process20.size());
      ae.setCompressedSize(process20.size(true));
      this._afterAppend(ae);
      callback(error, ae);
    }
    process20.once("end", handleStuff.bind(this));
    process20.once("error", function(err) {
      error = err;
    });
    process20.pipe(this, { end: false });
    return process20;
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryEnd = function() {
    var records = this._entries.length;
    var size = this._archive.centralLength;
    var offset = this._archive.centralOffset;
    if (this.isZip64()) {
      records = constants.ZIP64_MAGIC_SHORT;
      size = constants.ZIP64_MAGIC;
      offset = constants.ZIP64_MAGIC;
    }
    this.write(zipUtil.getLongBytes(constants.SIG_EOCD));
    this.write(constants.SHORT_ZERO);
    this.write(constants.SHORT_ZERO);
    this.write(zipUtil.getShortBytes(records));
    this.write(zipUtil.getShortBytes(records));
    this.write(zipUtil.getLongBytes(size));
    this.write(zipUtil.getLongBytes(offset));
    var comment = this.getComment();
    var commentLength = Buffer.byteLength(comment);
    this.write(zipUtil.getShortBytes(commentLength));
    this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryZip64 = function() {
    this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD));
    this.write(zipUtil.getEightBytes(44));
    this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
    this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
    this.write(constants.LONG_ZERO);
    this.write(constants.LONG_ZERO);
    this.write(zipUtil.getEightBytes(this._entries.length));
    this.write(zipUtil.getEightBytes(this._entries.length));
    this.write(zipUtil.getEightBytes(this._archive.centralLength));
    this.write(zipUtil.getEightBytes(this._archive.centralOffset));
    this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD_LOC));
    this.write(constants.LONG_ZERO);
    this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength));
    this.write(zipUtil.getLongBytes(1));
  };
  ZipArchiveOutputStream.prototype._writeCentralFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method = ae.getMethod();
    var fileOffset = ae._offsets.file;
    var size = ae.getSize();
    var compressedSize = ae.getCompressedSize();
    if (ae.isZip64() || fileOffset > constants.ZIP64_MAGIC) {
      size = constants.ZIP64_MAGIC;
      compressedSize = constants.ZIP64_MAGIC;
      fileOffset = constants.ZIP64_MAGIC;
      ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
      var extraBuf = Buffer.concat([
        zipUtil.getShortBytes(constants.ZIP64_EXTRA_ID),
        zipUtil.getShortBytes(24),
        zipUtil.getEightBytes(ae.getSize()),
        zipUtil.getEightBytes(ae.getCompressedSize()),
        zipUtil.getEightBytes(ae._offsets.file)
      ], 28);
      ae.setExtra(extraBuf);
    }
    this.write(zipUtil.getLongBytes(constants.SIG_CFH));
    this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants.VERSION_MADEBY));
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    this.write(zipUtil.getShortBytes(method));
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    this.write(zipUtil.getLongBytes(compressedSize));
    this.write(zipUtil.getLongBytes(size));
    var name = ae.getName();
    var comment = ae.getComment();
    var extra = ae.getCentralDirectoryExtra();
    if (gpb.usesUTF8ForNames()) {
      name = Buffer.from(name);
      comment = Buffer.from(comment);
    }
    this.write(zipUtil.getShortBytes(name.length));
    this.write(zipUtil.getShortBytes(extra.length));
    this.write(zipUtil.getShortBytes(comment.length));
    this.write(constants.SHORT_ZERO);
    this.write(zipUtil.getShortBytes(ae.getInternalAttributes()));
    this.write(zipUtil.getLongBytes(ae.getExternalAttributes()));
    this.write(zipUtil.getLongBytes(fileOffset));
    this.write(name);
    this.write(extra);
    this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeDataDescriptor = function(ae) {
    this.write(zipUtil.getLongBytes(constants.SIG_DD));
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    if (ae.isZip64()) {
      this.write(zipUtil.getEightBytes(ae.getCompressedSize()));
      this.write(zipUtil.getEightBytes(ae.getSize()));
    } else {
      this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
      this.write(zipUtil.getLongBytes(ae.getSize()));
    }
  };
  ZipArchiveOutputStream.prototype._writeLocalFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method = ae.getMethod();
    var name = ae.getName();
    var extra = ae.getLocalFileDataExtra();
    if (ae.isZip64()) {
      gpb.useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
    }
    if (gpb.usesUTF8ForNames()) {
      name = Buffer.from(name);
    }
    ae._offsets.file = this.offset;
    this.write(zipUtil.getLongBytes(constants.SIG_LFH));
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    this.write(zipUtil.getShortBytes(method));
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    ae._offsets.data = this.offset;
    if (gpb.usesDataDescriptor()) {
      this.write(constants.LONG_ZERO);
      this.write(constants.LONG_ZERO);
      this.write(constants.LONG_ZERO);
    } else {
      this.write(zipUtil.getLongBytes(ae.getCrc()));
      this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
      this.write(zipUtil.getLongBytes(ae.getSize()));
    }
    this.write(zipUtil.getShortBytes(name.length));
    this.write(zipUtil.getShortBytes(extra.length));
    this.write(name);
    this.write(extra);
    ae._offsets.contents = this.offset;
  };
  ZipArchiveOutputStream.prototype.getComment = function(comment) {
    return this._archive.comment !== null ? this._archive.comment : "";
  };
  ZipArchiveOutputStream.prototype.isZip64 = function() {
    return this._archive.forceZip64 || this._entries.length > constants.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants.ZIP64_MAGIC || this._archive.centralOffset > constants.ZIP64_MAGIC;
  };
  ZipArchiveOutputStream.prototype.setComment = function(comment) {
    this._archive.comment = comment;
  };
});

// node_modules/compress-commons/lib/compress-commons.js
var require_compress_commons = __commonJS((exports, module) => {
  module.exports = {
    ArchiveEntry: require_archive_entry(),
    ZipArchiveEntry: require_zip_archive_entry(),
    ArchiveOutputStream: require_archive_output_stream(),
    ZipArchiveOutputStream: require_zip_archive_output_stream()
  };
});

// node_modules/zip-stream/index.js
var require_zip_stream = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var ZipArchiveOutputStream = require_compress_commons().ZipArchiveOutputStream;
  var ZipArchiveEntry = require_compress_commons().ZipArchiveEntry;
  var util = require_archiver_utils();
  var ZipStream = module.exports = function(options) {
    if (!(this instanceof ZipStream)) {
      return new ZipStream(options);
    }
    options = this.options = options || {};
    options.zlib = options.zlib || {};
    ZipArchiveOutputStream.call(this, options);
    if (typeof options.level === "number" && options.level >= 0) {
      options.zlib.level = options.level;
      delete options.level;
    }
    if (!options.forceZip64 && typeof options.zlib.level === "number" && options.zlib.level === 0) {
      options.store = true;
    }
    options.namePrependSlash = options.namePrependSlash || false;
    if (options.comment && options.comment.length > 0) {
      this.setComment(options.comment);
    }
  };
  inherits(ZipStream, ZipArchiveOutputStream);
  ZipStream.prototype._normalizeFileData = function(data) {
    data = util.defaults(data, {
      type: "file",
      name: null,
      namePrependSlash: this.options.namePrependSlash,
      linkname: null,
      date: null,
      mode: null,
      store: this.options.store,
      comment: ""
    });
    var isDir = data.type === "directory";
    var isSymlink = data.type === "symlink";
    if (data.name) {
      data.name = util.sanitizePath(data.name);
      if (!isSymlink && data.name.slice(-1) === "/") {
        isDir = true;
        data.type = "directory";
      } else if (isDir) {
        data.name += "/";
      }
    }
    if (isDir || isSymlink) {
      data.store = true;
    }
    data.date = util.dateify(data.date);
    return data;
  };
  ZipStream.prototype.entry = function(source, data, callback) {
    if (typeof callback !== "function") {
      callback = this._emitErrorCallback.bind(this);
    }
    data = this._normalizeFileData(data);
    if (data.type !== "file" && data.type !== "directory" && data.type !== "symlink") {
      callback(new Error(data.type + " entries not currently supported"));
      return;
    }
    if (typeof data.name !== "string" || data.name.length === 0) {
      callback(new Error("entry name must be a non-empty string value"));
      return;
    }
    if (data.type === "symlink" && typeof data.linkname !== "string") {
      callback(new Error("entry linkname must be a non-empty string value when type equals symlink"));
      return;
    }
    var entry = new ZipArchiveEntry(data.name);
    entry.setTime(data.date, this.options.forceLocalTime);
    if (data.namePrependSlash) {
      entry.setName(data.name, true);
    }
    if (data.store) {
      entry.setMethod(0);
    }
    if (data.comment.length > 0) {
      entry.setComment(data.comment);
    }
    if (data.type === "symlink" && typeof data.mode !== "number") {
      data.mode = 40960;
    }
    if (typeof data.mode === "number") {
      if (data.type === "symlink") {
        data.mode |= 40960;
      }
      entry.setUnixMode(data.mode);
    }
    if (data.type === "symlink" && typeof data.linkname === "string") {
      source = Buffer.from(data.linkname);
    }
    return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);
  };
  ZipStream.prototype.finalize = function() {
    this.finish();
  };
});

// node_modules/archiver/lib/plugins/zip.js
var require_zip3 = __commonJS((exports, module) => {
  var engine = require_zip_stream();
  var util = require_archiver_utils();
  var Zip = function(options) {
    if (!(this instanceof Zip)) {
      return new Zip(options);
    }
    options = this.options = util.defaults(options, {
      comment: "",
      forceUTC: false,
      namePrependSlash: false,
      store: false
    });
    this.supports = {
      directory: true,
      symlink: true
    };
    this.engine = new engine(options);
  };
  Zip.prototype.append = function(source, data, callback) {
    this.engine.entry(source, data, callback);
  };
  Zip.prototype.finalize = function() {
    this.engine.finalize();
  };
  Zip.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Zip.prototype.pipe = function() {
    return this.engine.pipe.apply(this.engine, arguments);
  };
  Zip.prototype.unpipe = function() {
    return this.engine.unpipe.apply(this.engine, arguments);
  };
  module.exports = Zip;
});

// node_modules/queue-tick/queue-microtask.js
var require_queue_microtask = __commonJS((exports, module) => {
  module.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
});

// node_modules/queue-tick/process-next-tick.js
var require_process_next_tick = __commonJS((exports, module) => {
  module.exports = typeof process !== "undefined" && typeof process.nextTick === "function" ? process.nextTick.bind(process) : require_queue_microtask();
});

// node_modules/fast-fifo/fixed-size.js
var require_fixed_size = __commonJS((exports, module) => {
  module.exports = class FixedFIFO {
    constructor(hwm) {
      if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
        throw new Error("Max size for a FixedFIFO should be a power of two");
      this.buffer = new Array(hwm);
      this.mask = hwm - 1;
      this.top = 0;
      this.btm = 0;
      this.next = null;
    }
    clear() {
      this.top = this.btm = 0;
      this.next = null;
      this.buffer.fill(undefined);
    }
    push(data) {
      if (this.buffer[this.top] !== undefined)
        return false;
      this.buffer[this.top] = data;
      this.top = this.top + 1 & this.mask;
      return true;
    }
    shift() {
      const last = this.buffer[this.btm];
      if (last === undefined)
        return;
      this.buffer[this.btm] = undefined;
      this.btm = this.btm + 1 & this.mask;
      return last;
    }
    peek() {
      return this.buffer[this.btm];
    }
    isEmpty() {
      return this.buffer[this.btm] === undefined;
    }
  };
});

// node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS((exports, module) => {
  var FixedFIFO = require_fixed_size();
  module.exports = class FastFIFO {
    constructor(hwm) {
      this.hwm = hwm || 16;
      this.head = new FixedFIFO(this.hwm);
      this.tail = this.head;
      this.length = 0;
    }
    clear() {
      this.head = this.tail;
      this.head.clear();
      this.length = 0;
    }
    push(val) {
      this.length++;
      if (!this.head.push(val)) {
        const prev = this.head;
        this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
        this.head.push(val);
      }
    }
    shift() {
      if (this.length !== 0)
        this.length--;
      const val = this.tail.shift();
      if (val === undefined && this.tail.next) {
        const next = this.tail.next;
        this.tail.next = null;
        this.tail = next;
        return this.tail.shift();
      }
      return val;
    }
    peek() {
      const val = this.tail.peek();
      if (val === undefined && this.tail.next)
        return this.tail.next.peek();
      return val;
    }
    isEmpty() {
      return this.length === 0;
    }
  };
});

// node_modules/b4a/index.js
var require_b4a = __commonJS((exports, module) => {
  function isBuffer(value) {
    return Buffer.isBuffer(value) || value instanceof Uint8Array;
  }
  function isEncoding(encoding) {
    return Buffer.isEncoding(encoding);
  }
  function alloc(size, fill2, encoding) {
    return Buffer.alloc(size, fill2, encoding);
  }
  function allocUnsafe(size) {
    return Buffer.allocUnsafe(size);
  }
  function allocUnsafeSlow(size) {
    return Buffer.allocUnsafeSlow(size);
  }
  function byteLength(string2, encoding) {
    return Buffer.byteLength(string2, encoding);
  }
  function compare(a, b) {
    return Buffer.compare(a, b);
  }
  function concat(buffers, totalLength) {
    return Buffer.concat(buffers, totalLength);
  }
  function copy(source, target, targetStart, start, end) {
    return toBuffer(source).copy(target, targetStart, start, end);
  }
  function equals(a, b) {
    return toBuffer(a).equals(b);
  }
  function fill(buffer, value, offset, end, encoding) {
    return toBuffer(buffer).fill(value, offset, end, encoding);
  }
  function from2(value, encodingOrOffset, length) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  function includes(buffer, value, byteOffset, encoding) {
    return toBuffer(buffer).includes(value, byteOffset, encoding);
  }
  function indexOf(buffer, value, byfeOffset, encoding) {
    return toBuffer(buffer).indexOf(value, byfeOffset, encoding);
  }
  function lastIndexOf(buffer, value, byteOffset, encoding) {
    return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding);
  }
  function swap16(buffer) {
    return toBuffer(buffer).swap16();
  }
  function swap32(buffer) {
    return toBuffer(buffer).swap32();
  }
  function swap64(buffer) {
    return toBuffer(buffer).swap64();
  }
  function toBuffer(buffer) {
    if (Buffer.isBuffer(buffer))
      return buffer;
    return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  }
  function toString(buffer, encoding, start, end) {
    return toBuffer(buffer).toString(encoding, start, end);
  }
  function write(buffer, string2, offset, length, encoding) {
    return toBuffer(buffer).write(string2, offset, length, encoding);
  }
  function writeDoubleLE(buffer, value, offset) {
    return toBuffer(buffer).writeDoubleLE(value, offset);
  }
  function writeFloatLE(buffer, value, offset) {
    return toBuffer(buffer).writeFloatLE(value, offset);
  }
  function writeUInt32LE(buffer, value, offset) {
    return toBuffer(buffer).writeUInt32LE(value, offset);
  }
  function writeInt32LE(buffer, value, offset) {
    return toBuffer(buffer).writeInt32LE(value, offset);
  }
  function readDoubleLE(buffer, offset) {
    return toBuffer(buffer).readDoubleLE(offset);
  }
  function readFloatLE(buffer, offset) {
    return toBuffer(buffer).readFloatLE(offset);
  }
  function readUInt32LE(buffer, offset) {
    return toBuffer(buffer).readUInt32LE(offset);
  }
  function readInt32LE(buffer, offset) {
    return toBuffer(buffer).readInt32LE(offset);
  }
  function writeDoubleBE(buffer, value, offset) {
    return toBuffer(buffer).writeDoubleBE(value, offset);
  }
  function writeFloatBE(buffer, value, offset) {
    return toBuffer(buffer).writeFloatBE(value, offset);
  }
  function writeUInt32BE(buffer, value, offset) {
    return toBuffer(buffer).writeUInt32BE(value, offset);
  }
  function writeInt32BE(buffer, value, offset) {
    return toBuffer(buffer).writeInt32BE(value, offset);
  }
  function readDoubleBE(buffer, offset) {
    return toBuffer(buffer).readDoubleBE(offset);
  }
  function readFloatBE(buffer, offset) {
    return toBuffer(buffer).readFloatBE(offset);
  }
  function readUInt32BE(buffer, offset) {
    return toBuffer(buffer).readUInt32BE(offset);
  }
  function readInt32BE(buffer, offset) {
    return toBuffer(buffer).readInt32BE(offset);
  }
  module.exports = {
    isBuffer,
    isEncoding,
    alloc,
    allocUnsafe,
    allocUnsafeSlow,
    byteLength,
    compare,
    concat,
    copy,
    equals,
    fill,
    from: from2,
    includes,
    indexOf,
    lastIndexOf,
    swap16,
    swap32,
    swap64,
    toBuffer,
    toString,
    write,
    writeDoubleLE,
    writeFloatLE,
    writeUInt32LE,
    writeInt32LE,
    readDoubleLE,
    readFloatLE,
    readUInt32LE,
    readInt32LE,
    writeDoubleBE,
    writeFloatBE,
    writeUInt32BE,
    writeInt32BE,
    readDoubleBE,
    readFloatBE,
    readUInt32BE,
    readInt32BE
  };
});

// node_modules/text-decoder/lib/pass-through-decoder.js
var require_pass_through_decoder = __commonJS((exports, module) => {
  var b4a = require_b4a();
  module.exports = class PassThroughDecoder {
    constructor(encoding) {
      this.encoding = encoding;
    }
    get remaining() {
      return 0;
    }
    decode(tail) {
      return b4a.toString(tail, this.encoding);
    }
    flush() {
      return "";
    }
  };
});

// node_modules/text-decoder/lib/utf8-decoder.js
var require_utf8_decoder = __commonJS((exports, module) => {
  var b4a = require_b4a();
  module.exports = class UTF8Decoder {
    constructor() {
      this.codePoint = 0;
      this.bytesSeen = 0;
      this.bytesNeeded = 0;
      this.lowerBoundary = 128;
      this.upperBoundary = 191;
    }
    get remaining() {
      return this.bytesSeen;
    }
    decode(data) {
      if (this.bytesNeeded === 0) {
        let isBoundary = true;
        for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength;i < n && isBoundary; i++) {
          isBoundary = data[i] <= 127;
        }
        if (isBoundary)
          return b4a.toString(data, "utf8");
      }
      let result = "";
      for (let i = 0, n = data.byteLength;i < n; i++) {
        const byte = data[i];
        if (this.bytesNeeded === 0) {
          if (byte <= 127) {
            result += String.fromCharCode(byte);
          } else {
            this.bytesSeen = 1;
            if (byte >= 194 && byte <= 223) {
              this.bytesNeeded = 2;
              this.codePoint = byte & 31;
            } else if (byte >= 224 && byte <= 239) {
              if (byte === 224)
                this.lowerBoundary = 160;
              else if (byte === 237)
                this.upperBoundary = 159;
              this.bytesNeeded = 3;
              this.codePoint = byte & 15;
            } else if (byte >= 240 && byte <= 244) {
              if (byte === 240)
                this.lowerBoundary = 144;
              if (byte === 244)
                this.upperBoundary = 143;
              this.bytesNeeded = 4;
              this.codePoint = byte & 7;
            } else {
              result += "";
            }
          }
          continue;
        }
        if (byte < this.lowerBoundary || byte > this.upperBoundary) {
          this.codePoint = 0;
          this.bytesNeeded = 0;
          this.bytesSeen = 0;
          this.lowerBoundary = 128;
          this.upperBoundary = 191;
          result += "";
          continue;
        }
        this.lowerBoundary = 128;
        this.upperBoundary = 191;
        this.codePoint = this.codePoint << 6 | byte & 63;
        this.bytesSeen++;
        if (this.bytesSeen !== this.bytesNeeded)
          continue;
        result += String.fromCodePoint(this.codePoint);
        this.codePoint = 0;
        this.bytesNeeded = 0;
        this.bytesSeen = 0;
      }
      return result;
    }
    flush() {
      const result = this.bytesNeeded > 0 ? "" : "";
      this.codePoint = 0;
      this.bytesNeeded = 0;
      this.bytesSeen = 0;
      this.lowerBoundary = 128;
      this.upperBoundary = 191;
      return result;
    }
  };
});

// node_modules/text-decoder/index.js
var require_text_decoder = __commonJS((exports, module) => {
  var PassThroughDecoder = require_pass_through_decoder();
  var UTF8Decoder = require_utf8_decoder();
  module.exports = class TextDecoder2 {
    constructor(encoding = "utf8") {
      this.encoding = normalizeEncoding(encoding);
      switch (this.encoding) {
        case "utf8":
          this.decoder = new UTF8Decoder;
          break;
        case "utf16le":
        case "base64":
          throw new Error("Unsupported encoding: " + this.encoding);
        default:
          this.decoder = new PassThroughDecoder(this.encoding);
      }
    }
    get remaining() {
      return this.decoder.remaining;
    }
    push(data) {
      if (typeof data === "string")
        return data;
      return this.decoder.decode(data);
    }
    write(data) {
      return this.push(data);
    }
    end(data) {
      let result = "";
      if (data)
        result = this.push(data);
      result += this.decoder.flush();
      return result;
    }
  };
  function normalizeEncoding(encoding) {
    encoding = encoding.toLowerCase();
    switch (encoding) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return encoding;
      default:
        throw new Error("Unknown encoding: " + encoding);
    }
  }
});

// node_modules/streamx/index.js
var require_streamx = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var STREAM_DESTROYED = new Error("Stream was destroyed");
  var PREMATURE_CLOSE = new Error("Premature close");
  var queueTick = require_process_next_tick();
  var FIFO = require_fast_fifo();
  var TextDecoder2 = require_text_decoder();
  var MAX = (1 << 29) - 1;
  var OPENING = 1;
  var PREDESTROYING = 2;
  var DESTROYING = 4;
  var DESTROYED = 8;
  var NOT_OPENING = MAX ^ OPENING;
  var NOT_PREDESTROYING = MAX ^ PREDESTROYING;
  var READ_ACTIVE = 1 << 4;
  var READ_UPDATING = 2 << 4;
  var READ_PRIMARY = 4 << 4;
  var READ_QUEUED = 8 << 4;
  var READ_RESUMED = 16 << 4;
  var READ_PIPE_DRAINED = 32 << 4;
  var READ_ENDING = 64 << 4;
  var READ_EMIT_DATA = 128 << 4;
  var READ_EMIT_READABLE = 256 << 4;
  var READ_EMITTED_READABLE = 512 << 4;
  var READ_DONE = 1024 << 4;
  var READ_NEXT_TICK = 2048 << 4;
  var READ_NEEDS_PUSH = 4096 << 4;
  var READ_READ_AHEAD = 8192 << 4;
  var READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
  var READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;
  var READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
  var READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
  var READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD;
  var READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
  var READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
  var READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
  var READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
  var READ_PAUSED = MAX ^ READ_RESUMED;
  var READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
  var READ_NOT_ENDING = MAX ^ READ_ENDING;
  var READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING;
  var READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;
  var READ_NOT_UPDATING = MAX ^ READ_UPDATING;
  var READ_NO_READ_AHEAD = MAX ^ READ_READ_AHEAD;
  var READ_PAUSED_NO_READ_AHEAD = MAX ^ READ_RESUMED_READ_AHEAD;
  var WRITE_ACTIVE = 1 << 18;
  var WRITE_UPDATING = 2 << 18;
  var WRITE_PRIMARY = 4 << 18;
  var WRITE_QUEUED = 8 << 18;
  var WRITE_UNDRAINED = 16 << 18;
  var WRITE_DONE = 32 << 18;
  var WRITE_EMIT_DRAIN = 64 << 18;
  var WRITE_NEXT_TICK = 128 << 18;
  var WRITE_WRITING = 256 << 18;
  var WRITE_FINISHING = 512 << 18;
  var WRITE_CORKED = 1024 << 18;
  var WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);
  var WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
  var WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING);
  var WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
  var WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
  var WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
  var WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING;
  var WRITE_NOT_CORKED = MAX ^ WRITE_CORKED;
  var ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
  var NOT_ACTIVE = MAX ^ ACTIVE;
  var DONE = READ_DONE | WRITE_DONE;
  var DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING;
  var OPEN_STATUS = DESTROY_STATUS | OPENING;
  var AUTO_DESTROY = DESTROY_STATUS | DONE;
  var NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
  var ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;
  var TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE;
  var IS_OPENING = OPEN_STATUS | TICKING;
  var READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
  var READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
  var READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
  var READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
  var SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD;
  var READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;
  var READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY;
  var READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING;
  var WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
  var WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
  var WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
  var WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
  var WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED;
  var WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
  var WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;
  var WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;
  var WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
  var WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY;
  var WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS;
  var asyncIterator = Symbol.asyncIterator || Symbol("asyncIterator");

  class WritableState {
    constructor(stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {
      this.stream = stream;
      this.queue = new FIFO;
      this.highWaterMark = highWaterMark;
      this.buffered = 0;
      this.error = null;
      this.pipeline = null;
      this.drains = null;
      this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
      this.map = mapWritable || map;
      this.afterWrite = afterWrite.bind(this);
      this.afterUpdateNextTick = updateWriteNT.bind(this);
    }
    get ended() {
      return (this.stream._duplexState & WRITE_DONE) !== 0;
    }
    push(data) {
      if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0)
        return false;
      if (this.map !== null)
        data = this.map(data);
      this.buffered += this.byteLength(data);
      this.queue.push(data);
      if (this.buffered < this.highWaterMark) {
        this.stream._duplexState |= WRITE_QUEUED;
        return true;
      }
      this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
      return false;
    }
    shift() {
      const data = this.queue.shift();
      this.buffered -= this.byteLength(data);
      if (this.buffered === 0)
        this.stream._duplexState &= WRITE_NOT_QUEUED;
      return data;
    }
    end(data) {
      if (typeof data === "function")
        this.stream.once("finish", data);
      else if (data !== undefined && data !== null)
        this.push(data);
      this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
    }
    autoBatch(data, cb) {
      const buffer = [];
      const stream = this.stream;
      buffer.push(data);
      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
        buffer.push(stream._writableState.shift());
      }
      if ((stream._duplexState & OPEN_STATUS) !== 0)
        return cb(null);
      stream._writev(buffer, cb);
    }
    update() {
      const stream = this.stream;
      stream._duplexState |= WRITE_UPDATING;
      do {
        while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
          const data = this.shift();
          stream._duplexState |= WRITE_ACTIVE_AND_WRITING;
          stream._write(data, this.afterWrite);
        }
        if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0)
          this.updateNonPrimary();
      } while (this.continueUpdate() === true);
      stream._duplexState &= WRITE_NOT_UPDATING;
    }
    updateNonPrimary() {
      const stream = this.stream;
      if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
        stream._duplexState = stream._duplexState | WRITE_ACTIVE;
        stream._final(afterFinal.bind(this));
        return;
      }
      if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
        if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
          stream._duplexState |= ACTIVE;
          stream._destroy(afterDestroy.bind(this));
        }
        return;
      }
      if ((stream._duplexState & IS_OPENING) === OPENING) {
        stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
        stream._open(afterOpen.bind(this));
      }
    }
    continueUpdate() {
      if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0)
        return false;
      this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
      return true;
    }
    updateCallback() {
      if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY)
        this.update();
      else
        this.updateNextTick();
    }
    updateNextTick() {
      if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0)
        return;
      this.stream._duplexState |= WRITE_NEXT_TICK;
      if ((this.stream._duplexState & WRITE_UPDATING) === 0)
        queueTick(this.afterUpdateNextTick);
    }
  }

  class ReadableState {
    constructor(stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {
      this.stream = stream;
      this.queue = new FIFO;
      this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;
      this.buffered = 0;
      this.readAhead = highWaterMark > 0;
      this.error = null;
      this.pipeline = null;
      this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
      this.map = mapReadable || map;
      this.pipeTo = null;
      this.afterRead = afterRead.bind(this);
      this.afterUpdateNextTick = updateReadNT.bind(this);
    }
    get ended() {
      return (this.stream._duplexState & READ_DONE) !== 0;
    }
    pipe(pipeTo, cb) {
      if (this.pipeTo !== null)
        throw new Error("Can only pipe to one destination");
      if (typeof cb !== "function")
        cb = null;
      this.stream._duplexState |= READ_PIPE_DRAINED;
      this.pipeTo = pipeTo;
      this.pipeline = new Pipeline(this.stream, pipeTo, cb);
      if (cb)
        this.stream.on("error", noop);
      if (isStreamx(pipeTo)) {
        pipeTo._writableState.pipeline = this.pipeline;
        if (cb)
          pipeTo.on("error", noop);
        pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
      } else {
        const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
        const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null);
        pipeTo.on("error", onerror);
        pipeTo.on("close", onclose);
        pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
      }
      pipeTo.on("drain", afterDrain.bind(this));
      this.stream.emit("piping", pipeTo);
      pipeTo.emit("pipe", this.stream);
    }
    push(data) {
      const stream = this.stream;
      if (data === null) {
        this.highWaterMark = 0;
        stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
        return false;
      }
      if (this.map !== null) {
        data = this.map(data);
        if (data === null) {
          stream._duplexState &= READ_PUSHED;
          return this.buffered < this.highWaterMark;
        }
      }
      this.buffered += this.byteLength(data);
      this.queue.push(data);
      stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
      return this.buffered < this.highWaterMark;
    }
    shift() {
      const data = this.queue.shift();
      this.buffered -= this.byteLength(data);
      if (this.buffered === 0)
        this.stream._duplexState &= READ_NOT_QUEUED;
      return data;
    }
    unshift(data) {
      const pending = [this.map !== null ? this.map(data) : data];
      while (this.buffered > 0)
        pending.push(this.shift());
      for (let i = 0;i < pending.length - 1; i++) {
        const data2 = pending[i];
        this.buffered += this.byteLength(data2);
        this.queue.push(data2);
      }
      this.push(pending[pending.length - 1]);
    }
    read() {
      const stream = this.stream;
      if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
        const data = this.shift();
        if (this.pipeTo !== null && this.pipeTo.write(data) === false)
          stream._duplexState &= READ_PIPE_NOT_DRAINED;
        if ((stream._duplexState & READ_EMIT_DATA) !== 0)
          stream.emit("data", data);
        return data;
      }
      if (this.readAhead === false) {
        stream._duplexState |= READ_READ_AHEAD;
        this.updateNextTick();
      }
      return null;
    }
    drain() {
      const stream = this.stream;
      while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
        const data = this.shift();
        if (this.pipeTo !== null && this.pipeTo.write(data) === false)
          stream._duplexState &= READ_PIPE_NOT_DRAINED;
        if ((stream._duplexState & READ_EMIT_DATA) !== 0)
          stream.emit("data", data);
      }
    }
    update() {
      const stream = this.stream;
      stream._duplexState |= READ_UPDATING;
      do {
        this.drain();
        while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {
          stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;
          stream._read(this.afterRead);
          this.drain();
        }
        if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
          stream._duplexState |= READ_EMITTED_READABLE;
          stream.emit("readable");
        }
        if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0)
          this.updateNonPrimary();
      } while (this.continueUpdate() === true);
      stream._duplexState &= READ_NOT_UPDATING;
    }
    updateNonPrimary() {
      const stream = this.stream;
      if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
        stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
        stream.emit("end");
        if ((stream._duplexState & AUTO_DESTROY) === DONE)
          stream._duplexState |= DESTROYING;
        if (this.pipeTo !== null)
          this.pipeTo.end();
      }
      if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
        if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
          stream._duplexState |= ACTIVE;
          stream._destroy(afterDestroy.bind(this));
        }
        return;
      }
      if ((stream._duplexState & IS_OPENING) === OPENING) {
        stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
        stream._open(afterOpen.bind(this));
      }
    }
    continueUpdate() {
      if ((this.stream._duplexState & READ_NEXT_TICK) === 0)
        return false;
      this.stream._duplexState &= READ_NOT_NEXT_TICK;
      return true;
    }
    updateCallback() {
      if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY)
        this.update();
      else
        this.updateNextTick();
    }
    updateNextTickIfOpen() {
      if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0)
        return;
      this.stream._duplexState |= READ_NEXT_TICK;
      if ((this.stream._duplexState & READ_UPDATING) === 0)
        queueTick(this.afterUpdateNextTick);
    }
    updateNextTick() {
      if ((this.stream._duplexState & READ_NEXT_TICK) !== 0)
        return;
      this.stream._duplexState |= READ_NEXT_TICK;
      if ((this.stream._duplexState & READ_UPDATING) === 0)
        queueTick(this.afterUpdateNextTick);
    }
  }

  class TransformState {
    constructor(stream) {
      this.data = null;
      this.afterTransform = afterTransform.bind(stream);
      this.afterFinal = null;
    }
  }

  class Pipeline {
    constructor(src, dst, cb) {
      this.from = src;
      this.to = dst;
      this.afterPipe = cb;
      this.error = null;
      this.pipeToFinished = false;
    }
    finished() {
      this.pipeToFinished = true;
    }
    done(stream, err) {
      if (err)
        this.error = err;
      if (stream === this.to) {
        this.to = null;
        if (this.from !== null) {
          if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
            this.from.destroy(this.error || new Error("Writable stream closed prematurely"));
          }
          return;
        }
      }
      if (stream === this.from) {
        this.from = null;
        if (this.to !== null) {
          if ((stream._duplexState & READ_DONE) === 0) {
            this.to.destroy(this.error || new Error("Readable stream closed before ending"));
          }
          return;
        }
      }
      if (this.afterPipe !== null)
        this.afterPipe(this.error);
      this.to = this.from = this.afterPipe = null;
    }
  }
  function afterDrain() {
    this.stream._duplexState |= READ_PIPE_DRAINED;
    this.updateCallback();
  }
  function afterFinal(err) {
    const stream = this.stream;
    if (err)
      stream.destroy(err);
    if ((stream._duplexState & DESTROY_STATUS) === 0) {
      stream._duplexState |= WRITE_DONE;
      stream.emit("finish");
    }
    if ((stream._duplexState & AUTO_DESTROY) === DONE) {
      stream._duplexState |= DESTROYING;
    }
    stream._duplexState &= WRITE_NOT_FINISHING;
    if ((stream._duplexState & WRITE_UPDATING) === 0)
      this.update();
    else
      this.updateNextTick();
  }
  function afterDestroy(err) {
    const stream = this.stream;
    if (!err && this.error !== STREAM_DESTROYED)
      err = this.error;
    if (err)
      stream.emit("error", err);
    stream._duplexState |= DESTROYED;
    stream.emit("close");
    const rs = stream._readableState;
    const ws = stream._writableState;
    if (rs !== null && rs.pipeline !== null)
      rs.pipeline.done(stream, err);
    if (ws !== null) {
      while (ws.drains !== null && ws.drains.length > 0)
        ws.drains.shift().resolve(false);
      if (ws.pipeline !== null)
        ws.pipeline.done(stream, err);
    }
  }
  function afterWrite(err) {
    const stream = this.stream;
    if (err)
      stream.destroy(err);
    stream._duplexState &= WRITE_NOT_ACTIVE;
    if (this.drains !== null)
      tickDrains(this.drains);
    if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
      stream._duplexState &= WRITE_DRAINED;
      if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
        stream.emit("drain");
      }
    }
    this.updateCallback();
  }
  function afterRead(err) {
    if (err)
      this.stream.destroy(err);
    this.stream._duplexState &= READ_NOT_ACTIVE;
    if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0)
      this.stream._duplexState &= READ_NO_READ_AHEAD;
    this.updateCallback();
  }
  function updateReadNT() {
    if ((this.stream._duplexState & READ_UPDATING) === 0) {
      this.stream._duplexState &= READ_NOT_NEXT_TICK;
      this.update();
    }
  }
  function updateWriteNT() {
    if ((this.stream._duplexState & WRITE_UPDATING) === 0) {
      this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
      this.update();
    }
  }
  function tickDrains(drains) {
    for (let i = 0;i < drains.length; i++) {
      if (--drains[i].writes === 0) {
        drains.shift().resolve(true);
        i--;
      }
    }
  }
  function afterOpen(err) {
    const stream = this.stream;
    if (err)
      stream.destroy(err);
    if ((stream._duplexState & DESTROYING) === 0) {
      if ((stream._duplexState & READ_PRIMARY_STATUS) === 0)
        stream._duplexState |= READ_PRIMARY;
      if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0)
        stream._duplexState |= WRITE_PRIMARY;
      stream.emit("open");
    }
    stream._duplexState &= NOT_ACTIVE;
    if (stream._writableState !== null) {
      stream._writableState.updateCallback();
    }
    if (stream._readableState !== null) {
      stream._readableState.updateCallback();
    }
  }
  function afterTransform(err, data) {
    if (data !== undefined && data !== null)
      this.push(data);
    this._writableState.afterWrite(err);
  }
  function newListener(name) {
    if (this._readableState !== null) {
      if (name === "data") {
        this._duplexState |= READ_EMIT_DATA | READ_RESUMED_READ_AHEAD;
        this._readableState.updateNextTick();
      }
      if (name === "readable") {
        this._duplexState |= READ_EMIT_READABLE;
        this._readableState.updateNextTick();
      }
    }
    if (this._writableState !== null) {
      if (name === "drain") {
        this._duplexState |= WRITE_EMIT_DRAIN;
        this._writableState.updateNextTick();
      }
    }
  }

  class Stream extends EventEmitter {
    constructor(opts) {
      super();
      this._duplexState = 0;
      this._readableState = null;
      this._writableState = null;
      if (opts) {
        if (opts.open)
          this._open = opts.open;
        if (opts.destroy)
          this._destroy = opts.destroy;
        if (opts.predestroy)
          this._predestroy = opts.predestroy;
        if (opts.signal) {
          opts.signal.addEventListener("abort", abort.bind(this));
        }
      }
      this.on("newListener", newListener);
    }
    _open(cb) {
      cb(null);
    }
    _destroy(cb) {
      cb(null);
    }
    _predestroy() {
    }
    get readable() {
      return this._readableState !== null ? true : undefined;
    }
    get writable() {
      return this._writableState !== null ? true : undefined;
    }
    get destroyed() {
      return (this._duplexState & DESTROYED) !== 0;
    }
    get destroying() {
      return (this._duplexState & DESTROY_STATUS) !== 0;
    }
    destroy(err) {
      if ((this._duplexState & DESTROY_STATUS) === 0) {
        if (!err)
          err = STREAM_DESTROYED;
        this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;
        if (this._readableState !== null) {
          this._readableState.highWaterMark = 0;
          this._readableState.error = err;
        }
        if (this._writableState !== null) {
          this._writableState.highWaterMark = 0;
          this._writableState.error = err;
        }
        this._duplexState |= PREDESTROYING;
        this._predestroy();
        this._duplexState &= NOT_PREDESTROYING;
        if (this._readableState !== null)
          this._readableState.updateNextTick();
        if (this._writableState !== null)
          this._writableState.updateNextTick();
      }
    }
  }

  class Readable extends Stream {
    constructor(opts) {
      super(opts);
      this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD;
      this._readableState = new ReadableState(this, opts);
      if (opts) {
        if (this._readableState.readAhead === false)
          this._duplexState &= READ_NO_READ_AHEAD;
        if (opts.read)
          this._read = opts.read;
        if (opts.eagerOpen)
          this._readableState.updateNextTick();
        if (opts.encoding)
          this.setEncoding(opts.encoding);
      }
    }
    setEncoding(encoding) {
      const dec = new TextDecoder2(encoding);
      const map = this._readableState.map || echo;
      this._readableState.map = mapOrSkip;
      return this;
      function mapOrSkip(data) {
        const next = dec.push(data);
        return next === "" && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next);
      }
    }
    _read(cb) {
      cb(null);
    }
    pipe(dest, cb) {
      this._readableState.updateNextTick();
      this._readableState.pipe(dest, cb);
      return dest;
    }
    read() {
      this._readableState.updateNextTick();
      return this._readableState.read();
    }
    push(data) {
      this._readableState.updateNextTickIfOpen();
      return this._readableState.push(data);
    }
    unshift(data) {
      this._readableState.updateNextTickIfOpen();
      return this._readableState.unshift(data);
    }
    resume() {
      this._duplexState |= READ_RESUMED_READ_AHEAD;
      this._readableState.updateNextTick();
      return this;
    }
    pause() {
      this._duplexState &= this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED;
      return this;
    }
    static _fromAsyncIterator(ite, opts) {
      let destroy;
      const rs = new Readable({
        ...opts,
        read(cb) {
          ite.next().then(push).then(cb.bind(null, null)).catch(cb);
        },
        predestroy() {
          destroy = ite.return();
        },
        destroy(cb) {
          if (!destroy)
            return cb(null);
          destroy.then(cb.bind(null, null)).catch(cb);
        }
      });
      return rs;
      function push(data) {
        if (data.done)
          rs.push(null);
        else
          rs.push(data.value);
      }
    }
    static from(data, opts) {
      if (isReadStreamx(data))
        return data;
      if (data[asyncIterator])
        return this._fromAsyncIterator(data[asyncIterator](), opts);
      if (!Array.isArray(data))
        data = data === undefined ? [] : [data];
      let i = 0;
      return new Readable({
        ...opts,
        read(cb) {
          this.push(i === data.length ? null : data[i++]);
          cb(null);
        }
      });
    }
    static isBackpressured(rs) {
      return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
    }
    static isPaused(rs) {
      return (rs._duplexState & READ_RESUMED) === 0;
    }
    [asyncIterator]() {
      const stream = this;
      let error = null;
      let promiseResolve = null;
      let promiseReject = null;
      this.on("error", (err) => {
        error = err;
      });
      this.on("readable", onreadable);
      this.on("close", onclose);
      return {
        [asyncIterator]() {
          return this;
        },
        next() {
          return new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
            const data = stream.read();
            if (data !== null)
              ondata(data);
            else if ((stream._duplexState & DESTROYED) !== 0)
              ondata(null);
          });
        },
        return() {
          return destroy(null);
        },
        throw(err) {
          return destroy(err);
        }
      };
      function onreadable() {
        if (promiseResolve !== null)
          ondata(stream.read());
      }
      function onclose() {
        if (promiseResolve !== null)
          ondata(null);
      }
      function ondata(data) {
        if (promiseReject === null)
          return;
        if (error)
          promiseReject(error);
        else if (data === null && (stream._duplexState & READ_DONE) === 0)
          promiseReject(STREAM_DESTROYED);
        else
          promiseResolve({ value: data, done: data === null });
        promiseReject = promiseResolve = null;
      }
      function destroy(err) {
        stream.destroy(err);
        return new Promise((resolve, reject) => {
          if (stream._duplexState & DESTROYED)
            return resolve({ value: undefined, done: true });
          stream.once("close", function() {
            if (err)
              reject(err);
            else
              resolve({ value: undefined, done: true });
          });
        });
      }
    }
  }

  class Writable extends Stream {
    constructor(opts) {
      super(opts);
      this._duplexState |= OPENING | READ_DONE;
      this._writableState = new WritableState(this, opts);
      if (opts) {
        if (opts.writev)
          this._writev = opts.writev;
        if (opts.write)
          this._write = opts.write;
        if (opts.final)
          this._final = opts.final;
        if (opts.eagerOpen)
          this._writableState.updateNextTick();
      }
    }
    cork() {
      this._duplexState |= WRITE_CORKED;
    }
    uncork() {
      this._duplexState &= WRITE_NOT_CORKED;
      this._writableState.updateNextTick();
    }
    _writev(batch, cb) {
      cb(null);
    }
    _write(data, cb) {
      this._writableState.autoBatch(data, cb);
    }
    _final(cb) {
      cb(null);
    }
    static isBackpressured(ws) {
      return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
    }
    static drained(ws) {
      if (ws.destroyed)
        return Promise.resolve(false);
      const state = ws._writableState;
      const pending = isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length;
      const writes = pending + (ws._duplexState & WRITE_WRITING ? 1 : 0);
      if (writes === 0)
        return Promise.resolve(true);
      if (state.drains === null)
        state.drains = [];
      return new Promise((resolve) => {
        state.drains.push({ writes, resolve });
      });
    }
    write(data) {
      this._writableState.updateNextTick();
      return this._writableState.push(data);
    }
    end(data) {
      this._writableState.updateNextTick();
      this._writableState.end(data);
      return this;
    }
  }

  class Duplex extends Readable {
    constructor(opts) {
      super(opts);
      this._duplexState = OPENING | this._duplexState & READ_READ_AHEAD;
      this._writableState = new WritableState(this, opts);
      if (opts) {
        if (opts.writev)
          this._writev = opts.writev;
        if (opts.write)
          this._write = opts.write;
        if (opts.final)
          this._final = opts.final;
      }
    }
    cork() {
      this._duplexState |= WRITE_CORKED;
    }
    uncork() {
      this._duplexState &= WRITE_NOT_CORKED;
      this._writableState.updateNextTick();
    }
    _writev(batch, cb) {
      cb(null);
    }
    _write(data, cb) {
      this._writableState.autoBatch(data, cb);
    }
    _final(cb) {
      cb(null);
    }
    write(data) {
      this._writableState.updateNextTick();
      return this._writableState.push(data);
    }
    end(data) {
      this._writableState.updateNextTick();
      this._writableState.end(data);
      return this;
    }
  }

  class Transform extends Duplex {
    constructor(opts) {
      super(opts);
      this._transformState = new TransformState(this);
      if (opts) {
        if (opts.transform)
          this._transform = opts.transform;
        if (opts.flush)
          this._flush = opts.flush;
      }
    }
    _write(data, cb) {
      if (this._readableState.buffered >= this._readableState.highWaterMark) {
        this._transformState.data = data;
      } else {
        this._transform(data, this._transformState.afterTransform);
      }
    }
    _read(cb) {
      if (this._transformState.data !== null) {
        const data = this._transformState.data;
        this._transformState.data = null;
        cb(null);
        this._transform(data, this._transformState.afterTransform);
      } else {
        cb(null);
      }
    }
    destroy(err) {
      super.destroy(err);
      if (this._transformState.data !== null) {
        this._transformState.data = null;
        this._transformState.afterTransform();
      }
    }
    _transform(data, cb) {
      cb(null, data);
    }
    _flush(cb) {
      cb(null);
    }
    _final(cb) {
      this._transformState.afterFinal = cb;
      this._flush(transformAfterFlush.bind(this));
    }
  }

  class PassThrough extends Transform {
  }
  function transformAfterFlush(err, data) {
    const cb = this._transformState.afterFinal;
    if (err)
      return cb(err);
    if (data !== null && data !== undefined)
      this.push(data);
    this.push(null);
    cb(null);
  }
  function pipelinePromise(...streams) {
    return new Promise((resolve, reject) => {
      return pipeline(...streams, (err) => {
        if (err)
          return reject(err);
        resolve();
      });
    });
  }
  function pipeline(stream, ...streams) {
    const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];
    const done = all.length && typeof all[all.length - 1] === "function" ? all.pop() : null;
    if (all.length < 2)
      throw new Error("Pipeline requires at least 2 streams");
    let src = all[0];
    let dest = null;
    let error = null;
    for (let i = 1;i < all.length; i++) {
      dest = all[i];
      if (isStreamx(src)) {
        src.pipe(dest, onerror);
      } else {
        errorHandle(src, true, i > 1, onerror);
        src.pipe(dest);
      }
      src = dest;
    }
    if (done) {
      let fin = false;
      const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);
      dest.on("error", (err) => {
        if (error === null)
          error = err;
      });
      dest.on("finish", () => {
        fin = true;
        if (!autoDestroy)
          done(error);
      });
      if (autoDestroy) {
        dest.on("close", () => done(error || (fin ? null : PREMATURE_CLOSE)));
      }
    }
    return dest;
    function errorHandle(s, rd, wr, onerror2) {
      s.on("error", onerror2);
      s.on("close", onclose);
      function onclose() {
        if (rd && s._readableState && !s._readableState.ended)
          return onerror2(PREMATURE_CLOSE);
        if (wr && s._writableState && !s._writableState.ended)
          return onerror2(PREMATURE_CLOSE);
      }
    }
    function onerror(err) {
      if (!err || error)
        return;
      error = err;
      for (const s of all) {
        s.destroy(err);
      }
    }
  }
  function echo(s) {
    return s;
  }
  function isStream(stream) {
    return !!stream._readableState || !!stream._writableState;
  }
  function isStreamx(stream) {
    return typeof stream._duplexState === "number" && isStream(stream);
  }
  function isEnded(stream) {
    return !!stream._readableState && stream._readableState.ended;
  }
  function isFinished(stream) {
    return !!stream._writableState && stream._writableState.ended;
  }
  function getStreamError(stream, opts = {}) {
    const err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;
    return !opts.all && err === STREAM_DESTROYED ? null : err;
  }
  function isReadStreamx(stream) {
    return isStreamx(stream) && stream.readable;
  }
  function isDisturbed(stream) {
    return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0;
  }
  function isTypedArray(data) {
    return typeof data === "object" && data !== null && typeof data.byteLength === "number";
  }
  function defaultByteLength(data) {
    return isTypedArray(data) ? data.byteLength : 1024;
  }
  function noop() {
  }
  function abort() {
    this.destroy(new Error("Stream aborted."));
  }
  function isWritev(s) {
    return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev;
  }
  module.exports = {
    pipeline,
    pipelinePromise,
    isStream,
    isStreamx,
    isEnded,
    isFinished,
    isDisturbed,
    getStreamError,
    Stream,
    Writable,
    Readable,
    Duplex,
    Transform,
    PassThrough
  };
});

// node_modules/tar-stream/headers.js
var require_headers = __commonJS((exports) => {
  var b4a = require_b4a();
  var ZEROS = "0000000000000000000";
  var SEVENS = "7777777777777777777";
  var ZERO_OFFSET = 48;
  var USTAR_MAGIC = b4a.from([117, 115, 116, 97, 114, 0]);
  var USTAR_VER = b4a.from([ZERO_OFFSET, ZERO_OFFSET]);
  var GNU_MAGIC = b4a.from([117, 115, 116, 97, 114, 32]);
  var GNU_VER = b4a.from([32, 0]);
  var MASK = 4095;
  var MAGIC_OFFSET = 257;
  var VERSION_OFFSET = 263;
  exports.decodeLongPath = function decodeLongPath(buf, encoding) {
    return decodeStr(buf, 0, buf.length, encoding);
  };
  exports.encodePax = function encodePax(opts) {
    let result = "";
    if (opts.name)
      result += addLength(" path=" + opts.name + `
`);
    if (opts.linkname)
      result += addLength(" linkpath=" + opts.linkname + `
`);
    const pax = opts.pax;
    if (pax) {
      for (const key12 in pax) {
        result += addLength(" " + key12 + "=" + pax[key12] + `
`);
      }
    }
    return b4a.from(result);
  };
  exports.decodePax = function decodePax(buf) {
    const result = {};
    while (buf.length) {
      let i = 0;
      while (i < buf.length && buf[i] !== 32)
        i++;
      const len = parseInt(b4a.toString(buf.subarray(0, i)), 10);
      if (!len)
        return result;
      const b = b4a.toString(buf.subarray(i + 1, len - 1));
      const keyIndex = b.indexOf("=");
      if (keyIndex === -1)
        return result;
      result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
      buf = buf.subarray(len);
    }
    return result;
  };
  exports.encode = function encode(opts) {
    const buf = b4a.alloc(512);
    let name = opts.name;
    let prefix = "";
    if (opts.typeflag === 5 && name[name.length - 1] !== "/")
      name += "/";
    if (b4a.byteLength(name) !== name.length)
      return null;
    while (b4a.byteLength(name) > 100) {
      const i = name.indexOf("/");
      if (i === -1)
        return null;
      prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
      name = name.slice(i + 1);
    }
    if (b4a.byteLength(name) > 100 || b4a.byteLength(prefix) > 155)
      return null;
    if (opts.linkname && b4a.byteLength(opts.linkname) > 100)
      return null;
    b4a.write(buf, name);
    b4a.write(buf, encodeOct(opts.mode & MASK, 6), 100);
    b4a.write(buf, encodeOct(opts.uid, 6), 108);
    b4a.write(buf, encodeOct(opts.gid, 6), 116);
    encodeSize(opts.size, buf, 124);
    b4a.write(buf, encodeOct(opts.mtime.getTime() / 1000 | 0, 11), 136);
    buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
    if (opts.linkname)
      b4a.write(buf, opts.linkname, 157);
    b4a.copy(USTAR_MAGIC, buf, MAGIC_OFFSET);
    b4a.copy(USTAR_VER, buf, VERSION_OFFSET);
    if (opts.uname)
      b4a.write(buf, opts.uname, 265);
    if (opts.gname)
      b4a.write(buf, opts.gname, 297);
    b4a.write(buf, encodeOct(opts.devmajor || 0, 6), 329);
    b4a.write(buf, encodeOct(opts.devminor || 0, 6), 337);
    if (prefix)
      b4a.write(buf, prefix, 345);
    b4a.write(buf, encodeOct(cksum(buf), 6), 148);
    return buf;
  };
  exports.decode = function decode(buf, filenameEncoding, allowUnknownFormat) {
    let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
    let name = decodeStr(buf, 0, 100, filenameEncoding);
    const mode = decodeOct(buf, 100, 8);
    const uid = decodeOct(buf, 108, 8);
    const gid = decodeOct(buf, 116, 8);
    const size = decodeOct(buf, 124, 12);
    const mtime = decodeOct(buf, 136, 12);
    const type = toType(typeflag);
    const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
    const uname = decodeStr(buf, 265, 32);
    const gname = decodeStr(buf, 297, 32);
    const devmajor = decodeOct(buf, 329, 8);
    const devminor = decodeOct(buf, 337, 8);
    const c = cksum(buf);
    if (c === 8 * 32)
      return null;
    if (c !== decodeOct(buf, 148, 8))
      throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
    if (isUSTAR(buf)) {
      if (buf[345])
        name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
    } else if (isGNU(buf)) {
    } else {
      if (!allowUnknownFormat) {
        throw new Error("Invalid tar header: unknown format.");
      }
    }
    if (typeflag === 0 && name && name[name.length - 1] === "/")
      typeflag = 5;
    return {
      name,
      mode,
      uid,
      gid,
      size,
      mtime: new Date(1000 * mtime),
      type,
      linkname,
      uname,
      gname,
      devmajor,
      devminor,
      pax: null
    };
  };
  function isUSTAR(buf) {
    return b4a.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6));
  }
  function isGNU(buf) {
    return b4a.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) && b4a.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2));
  }
  function clamp(index, len, defaultValue) {
    if (typeof index !== "number")
      return defaultValue;
    index = ~~index;
    if (index >= len)
      return len;
    if (index >= 0)
      return index;
    index += len;
    if (index >= 0)
      return index;
    return 0;
  }
  function toType(flag) {
    switch (flag) {
      case 0:
        return "file";
      case 1:
        return "link";
      case 2:
        return "symlink";
      case 3:
        return "character-device";
      case 4:
        return "block-device";
      case 5:
        return "directory";
      case 6:
        return "fifo";
      case 7:
        return "contiguous-file";
      case 72:
        return "pax-header";
      case 55:
        return "pax-global-header";
      case 27:
        return "gnu-long-link-path";
      case 28:
      case 30:
        return "gnu-long-path";
    }
    return null;
  }
  function toTypeflag(flag) {
    switch (flag) {
      case "file":
        return 0;
      case "link":
        return 1;
      case "symlink":
        return 2;
      case "character-device":
        return 3;
      case "block-device":
        return 4;
      case "directory":
        return 5;
      case "fifo":
        return 6;
      case "contiguous-file":
        return 7;
      case "pax-header":
        return 72;
    }
    return 0;
  }
  function indexOf(block, num, offset, end) {
    for (;offset < end; offset++) {
      if (block[offset] === num)
        return offset;
    }
    return end;
  }
  function cksum(block) {
    let sum = 8 * 32;
    for (let i = 0;i < 148; i++)
      sum += block[i];
    for (let j = 156;j < 512; j++)
      sum += block[j];
    return sum;
  }
  function encodeOct(val, n) {
    val = val.toString(8);
    if (val.length > n)
      return SEVENS.slice(0, n) + " ";
    return ZEROS.slice(0, n - val.length) + val + " ";
  }
  function encodeSizeBin(num, buf, off) {
    buf[off] = 128;
    for (let i = 11;i > 0; i--) {
      buf[off + i] = num & 255;
      num = Math.floor(num / 256);
    }
  }
  function encodeSize(num, buf, off) {
    if (num.toString(8).length > 11) {
      encodeSizeBin(num, buf, off);
    } else {
      b4a.write(buf, encodeOct(num, 11), off);
    }
  }
  function parse256(buf) {
    let positive;
    if (buf[0] === 128)
      positive = true;
    else if (buf[0] === 255)
      positive = false;
    else
      return null;
    const tuple = [];
    let i;
    for (i = buf.length - 1;i > 0; i--) {
      const byte = buf[i];
      if (positive)
        tuple.push(byte);
      else
        tuple.push(255 - byte);
    }
    let sum = 0;
    const l = tuple.length;
    for (i = 0;i < l; i++) {
      sum += tuple[i] * Math.pow(256, i);
    }
    return positive ? sum : -1 * sum;
  }
  function decodeOct(val, offset, length) {
    val = val.subarray(offset, offset + length);
    offset = 0;
    if (val[offset] & 128) {
      return parse256(val);
    } else {
      while (offset < val.length && val[offset] === 32)
        offset++;
      const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
      while (offset < end && val[offset] === 0)
        offset++;
      if (end === offset)
        return 0;
      return parseInt(b4a.toString(val.subarray(offset, end)), 8);
    }
  }
  function decodeStr(val, offset, length, encoding) {
    return b4a.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding);
  }
  function addLength(str) {
    const len = b4a.byteLength(str);
    let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
    if (len + digits >= Math.pow(10, digits))
      digits++;
    return len + digits + str;
  }
});

// node_modules/tar-stream/extract.js
var require_extract2 = __commonJS((exports, module) => {
  var { Writable, Readable, getStreamError } = require_streamx();
  var FIFO = require_fast_fifo();
  var b4a = require_b4a();
  var headers = require_headers();
  var EMPTY2 = b4a.alloc(0);

  class BufferList {
    constructor() {
      this.buffered = 0;
      this.shifted = 0;
      this.queue = new FIFO;
      this._offset = 0;
    }
    push(buffer) {
      this.buffered += buffer.byteLength;
      this.queue.push(buffer);
    }
    shiftFirst(size) {
      return this._buffered === 0 ? null : this._next(size);
    }
    shift(size) {
      if (size > this.buffered)
        return null;
      if (size === 0)
        return EMPTY2;
      let chunk = this._next(size);
      if (size === chunk.byteLength)
        return chunk;
      const chunks = [chunk];
      while ((size -= chunk.byteLength) > 0) {
        chunk = this._next(size);
        chunks.push(chunk);
      }
      return b4a.concat(chunks);
    }
    _next(size) {
      const buf = this.queue.peek();
      const rem = buf.byteLength - this._offset;
      if (size >= rem) {
        const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf;
        this.queue.shift();
        this._offset = 0;
        this.buffered -= rem;
        this.shifted += rem;
        return sub;
      }
      this.buffered -= size;
      this.shifted += size;
      return buf.subarray(this._offset, this._offset += size);
    }
  }

  class Source extends Readable {
    constructor(self2, header, offset) {
      super();
      this.header = header;
      this.offset = offset;
      this._parent = self2;
    }
    _read(cb) {
      if (this.header.size === 0) {
        this.push(null);
      }
      if (this._parent._stream === this) {
        this._parent._update();
      }
      cb(null);
    }
    _predestroy() {
      this._parent.destroy(getStreamError(this));
    }
    _detach() {
      if (this._parent._stream === this) {
        this._parent._stream = null;
        this._parent._missing = overflow(this.header.size);
        this._parent._update();
      }
    }
    _destroy(cb) {
      this._detach();
      cb(null);
    }
  }

  class Extract extends Writable {
    constructor(opts) {
      super(opts);
      if (!opts)
        opts = {};
      this._buffer = new BufferList;
      this._offset = 0;
      this._header = null;
      this._stream = null;
      this._missing = 0;
      this._longHeader = false;
      this._callback = noop;
      this._locked = false;
      this._finished = false;
      this._pax = null;
      this._paxGlobal = null;
      this._gnuLongPath = null;
      this._gnuLongLinkPath = null;
      this._filenameEncoding = opts.filenameEncoding || "utf-8";
      this._allowUnknownFormat = !!opts.allowUnknownFormat;
      this._unlockBound = this._unlock.bind(this);
    }
    _unlock(err) {
      this._locked = false;
      if (err) {
        this.destroy(err);
        this._continueWrite(err);
        return;
      }
      this._update();
    }
    _consumeHeader() {
      if (this._locked)
        return false;
      this._offset = this._buffer.shifted;
      try {
        this._header = headers.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat);
      } catch (err) {
        this._continueWrite(err);
        return false;
      }
      if (!this._header)
        return true;
      switch (this._header.type) {
        case "gnu-long-path":
        case "gnu-long-link-path":
        case "pax-global-header":
        case "pax-header":
          this._longHeader = true;
          this._missing = this._header.size;
          return true;
      }
      this._locked = true;
      this._applyLongHeaders();
      if (this._header.size === 0 || this._header.type === "directory") {
        this.emit("entry", this._header, this._createStream(), this._unlockBound);
        return true;
      }
      this._stream = this._createStream();
      this._missing = this._header.size;
      this.emit("entry", this._header, this._stream, this._unlockBound);
      return true;
    }
    _applyLongHeaders() {
      if (this._gnuLongPath) {
        this._header.name = this._gnuLongPath;
        this._gnuLongPath = null;
      }
      if (this._gnuLongLinkPath) {
        this._header.linkname = this._gnuLongLinkPath;
        this._gnuLongLinkPath = null;
      }
      if (this._pax) {
        if (this._pax.path)
          this._header.name = this._pax.path;
        if (this._pax.linkpath)
          this._header.linkname = this._pax.linkpath;
        if (this._pax.size)
          this._header.size = parseInt(this._pax.size, 10);
        this._header.pax = this._pax;
        this._pax = null;
      }
    }
    _decodeLongHeader(buf) {
      switch (this._header.type) {
        case "gnu-long-path":
          this._gnuLongPath = headers.decodeLongPath(buf, this._filenameEncoding);
          break;
        case "gnu-long-link-path":
          this._gnuLongLinkPath = headers.decodeLongPath(buf, this._filenameEncoding);
          break;
        case "pax-global-header":
          this._paxGlobal = headers.decodePax(buf);
          break;
        case "pax-header":
          this._pax = this._paxGlobal === null ? headers.decodePax(buf) : Object.assign({}, this._paxGlobal, headers.decodePax(buf));
          break;
      }
    }
    _consumeLongHeader() {
      this._longHeader = false;
      this._missing = overflow(this._header.size);
      const buf = this._buffer.shift(this._header.size);
      try {
        this._decodeLongHeader(buf);
      } catch (err) {
        this._continueWrite(err);
        return false;
      }
      return true;
    }
    _consumeStream() {
      const buf = this._buffer.shiftFirst(this._missing);
      if (buf === null)
        return false;
      this._missing -= buf.byteLength;
      const drained = this._stream.push(buf);
      if (this._missing === 0) {
        this._stream.push(null);
        if (drained)
          this._stream._detach();
        return drained && this._locked === false;
      }
      return drained;
    }
    _createStream() {
      return new Source(this, this._header, this._offset);
    }
    _update() {
      while (this._buffer.buffered > 0 && !this.destroying) {
        if (this._missing > 0) {
          if (this._stream !== null) {
            if (this._consumeStream() === false)
              return;
            continue;
          }
          if (this._longHeader === true) {
            if (this._missing > this._buffer.buffered)
              break;
            if (this._consumeLongHeader() === false)
              return false;
            continue;
          }
          const ignore = this._buffer.shiftFirst(this._missing);
          if (ignore !== null)
            this._missing -= ignore.byteLength;
          continue;
        }
        if (this._buffer.buffered < 512)
          break;
        if (this._stream !== null || this._consumeHeader() === false)
          return;
      }
      this._continueWrite(null);
    }
    _continueWrite(err) {
      const cb = this._callback;
      this._callback = noop;
      cb(err);
    }
    _write(data, cb) {
      this._callback = cb;
      this._buffer.push(data);
      this._update();
    }
    _final(cb) {
      this._finished = this._missing === 0 && this._buffer.buffered === 0;
      cb(this._finished ? null : new Error("Unexpected end of data"));
    }
    _predestroy() {
      this._continueWrite(null);
    }
    _destroy(cb) {
      if (this._stream)
        this._stream.destroy(getStreamError(this));
      cb(null);
    }
    [Symbol.asyncIterator]() {
      let error = null;
      let promiseResolve = null;
      let promiseReject = null;
      let entryStream = null;
      let entryCallback = null;
      const extract = this;
      this.on("entry", onentry);
      this.on("error", (err) => {
        error = err;
      });
      this.on("close", onclose);
      return {
        [Symbol.asyncIterator]() {
          return this;
        },
        next() {
          return new Promise(onnext);
        },
        return() {
          return destroy(null);
        },
        throw(err) {
          return destroy(err);
        }
      };
      function consumeCallback(err) {
        if (!entryCallback)
          return;
        const cb = entryCallback;
        entryCallback = null;
        cb(err);
      }
      function onnext(resolve, reject) {
        if (error) {
          return reject(error);
        }
        if (entryStream) {
          resolve({ value: entryStream, done: false });
          entryStream = null;
          return;
        }
        promiseResolve = resolve;
        promiseReject = reject;
        consumeCallback(null);
        if (extract._finished && promiseResolve) {
          promiseResolve({ value: undefined, done: true });
          promiseResolve = promiseReject = null;
        }
      }
      function onentry(header, stream, callback) {
        entryCallback = callback;
        stream.on("error", noop);
        if (promiseResolve) {
          promiseResolve({ value: stream, done: false });
          promiseResolve = promiseReject = null;
        } else {
          entryStream = stream;
        }
      }
      function onclose() {
        consumeCallback(error);
        if (!promiseResolve)
          return;
        if (error)
          promiseReject(error);
        else
          promiseResolve({ value: undefined, done: true });
        promiseResolve = promiseReject = null;
      }
      function destroy(err) {
        extract.destroy(err);
        consumeCallback(err);
        return new Promise((resolve, reject) => {
          if (extract.destroyed)
            return resolve({ value: undefined, done: true });
          extract.once("close", function() {
            if (err)
              reject(err);
            else
              resolve({ value: undefined, done: true });
          });
        });
      }
    }
  }
  module.exports = function extract(opts) {
    return new Extract(opts);
  };
  function noop() {
  }
  function overflow(size) {
    size &= 511;
    return size && 512 - size;
  }
});

// node_modules/tar-stream/constants.js
var require_constants2 = __commonJS((exports, module) => {
  var constants = {
    S_IFMT: 61440,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960
  };
  try {
    module.exports = __require("fs").constants || constants;
  } catch {
    module.exports = constants;
  }
});

// node_modules/tar-stream/pack.js
var require_pack = __commonJS((exports, module) => {
  var { Readable, Writable, getStreamError } = require_streamx();
  var b4a = require_b4a();
  var constants = require_constants2();
  var headers = require_headers();
  var DMODE = 493;
  var FMODE = 420;
  var END_OF_TAR = b4a.alloc(1024);

  class Sink extends Writable {
    constructor(pack, header, callback) {
      super({ mapWritable, eagerOpen: true });
      this.written = 0;
      this.header = header;
      this._callback = callback;
      this._linkname = null;
      this._isLinkname = header.type === "symlink" && !header.linkname;
      this._isVoid = header.type !== "file" && header.type !== "contiguous-file";
      this._finished = false;
      this._pack = pack;
      this._openCallback = null;
      if (this._pack._stream === null)
        this._pack._stream = this;
      else
        this._pack._pending.push(this);
    }
    _open(cb) {
      this._openCallback = cb;
      if (this._pack._stream === this)
        this._continueOpen();
    }
    _continuePack(err) {
      if (this._callback === null)
        return;
      const callback = this._callback;
      this._callback = null;
      callback(err);
    }
    _continueOpen() {
      if (this._pack._stream === null)
        this._pack._stream = this;
      const cb = this._openCallback;
      this._openCallback = null;
      if (cb === null)
        return;
      if (this._pack.destroying)
        return cb(new Error("pack stream destroyed"));
      if (this._pack._finalized)
        return cb(new Error("pack stream is already finalized"));
      this._pack._stream = this;
      if (!this._isLinkname) {
        this._pack._encode(this.header);
      }
      if (this._isVoid) {
        this._finish();
        this._continuePack(null);
      }
      cb(null);
    }
    _write(data, cb) {
      if (this._isLinkname) {
        this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data;
        return cb(null);
      }
      if (this._isVoid) {
        if (data.byteLength > 0) {
          return cb(new Error("No body allowed for this entry"));
        }
        return cb();
      }
      this.written += data.byteLength;
      if (this._pack.push(data))
        return cb();
      this._pack._drain = cb;
    }
    _finish() {
      if (this._finished)
        return;
      this._finished = true;
      if (this._isLinkname) {
        this.header.linkname = this._linkname ? b4a.toString(this._linkname, "utf-8") : "";
        this._pack._encode(this.header);
      }
      overflow(this._pack, this.header.size);
      this._pack._done(this);
    }
    _final(cb) {
      if (this.written !== this.header.size) {
        return cb(new Error("Size mismatch"));
      }
      this._finish();
      cb(null);
    }
    _getError() {
      return getStreamError(this) || new Error("tar entry destroyed");
    }
    _predestroy() {
      this._pack.destroy(this._getError());
    }
    _destroy(cb) {
      this._pack._done(this);
      this._continuePack(this._finished ? null : this._getError());
      cb();
    }
  }

  class Pack extends Readable {
    constructor(opts) {
      super(opts);
      this._drain = noop;
      this._finalized = false;
      this._finalizing = false;
      this._pending = [];
      this._stream = null;
    }
    entry(header, buffer, callback) {
      if (this._finalized || this.destroying)
        throw new Error("already finalized or destroyed");
      if (typeof buffer === "function") {
        callback = buffer;
        buffer = null;
      }
      if (!callback)
        callback = noop;
      if (!header.size || header.type === "symlink")
        header.size = 0;
      if (!header.type)
        header.type = modeToType(header.mode);
      if (!header.mode)
        header.mode = header.type === "directory" ? DMODE : FMODE;
      if (!header.uid)
        header.uid = 0;
      if (!header.gid)
        header.gid = 0;
      if (!header.mtime)
        header.mtime = new Date;
      if (typeof buffer === "string")
        buffer = b4a.from(buffer);
      const sink = new Sink(this, header, callback);
      if (b4a.isBuffer(buffer)) {
        header.size = buffer.byteLength;
        sink.write(buffer);
        sink.end();
        return sink;
      }
      if (sink._isVoid) {
        return sink;
      }
      return sink;
    }
    finalize() {
      if (this._stream || this._pending.length > 0) {
        this._finalizing = true;
        return;
      }
      if (this._finalized)
        return;
      this._finalized = true;
      this.push(END_OF_TAR);
      this.push(null);
    }
    _done(stream) {
      if (stream !== this._stream)
        return;
      this._stream = null;
      if (this._finalizing)
        this.finalize();
      if (this._pending.length)
        this._pending.shift()._continueOpen();
    }
    _encode(header) {
      if (!header.pax) {
        const buf = headers.encode(header);
        if (buf) {
          this.push(buf);
          return;
        }
      }
      this._encodePax(header);
    }
    _encodePax(header) {
      const paxHeader = headers.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
      });
      const newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.byteLength,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
      };
      this.push(headers.encode(newHeader));
      this.push(paxHeader);
      overflow(this, paxHeader.byteLength);
      newHeader.size = header.size;
      newHeader.type = header.type;
      this.push(headers.encode(newHeader));
    }
    _doDrain() {
      const drain = this._drain;
      this._drain = noop;
      drain();
    }
    _predestroy() {
      const err = getStreamError(this);
      if (this._stream)
        this._stream.destroy(err);
      while (this._pending.length) {
        const stream = this._pending.shift();
        stream.destroy(err);
        stream._continueOpen();
      }
      this._doDrain();
    }
    _read(cb) {
      this._doDrain();
      cb();
    }
  }
  module.exports = function pack(opts) {
    return new Pack(opts);
  };
  function modeToType(mode) {
    switch (mode & constants.S_IFMT) {
      case constants.S_IFBLK:
        return "block-device";
      case constants.S_IFCHR:
        return "character-device";
      case constants.S_IFDIR:
        return "directory";
      case constants.S_IFIFO:
        return "fifo";
      case constants.S_IFLNK:
        return "symlink";
    }
    return "file";
  }
  function noop() {
  }
  function overflow(self2, size) {
    size &= 511;
    if (size)
      self2.push(END_OF_TAR.subarray(0, 512 - size));
  }
  function mapWritable(buf) {
    return b4a.isBuffer(buf) ? buf : b4a.from(buf);
  }
});

// node_modules/tar-stream/index.js
var require_tar_stream = __commonJS((exports) => {
  exports.extract = require_extract2();
  exports.pack = require_pack();
});

// node_modules/archiver/lib/plugins/tar.js
var require_tar = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var engine = require_tar_stream();
  var util = require_archiver_utils();
  var Tar = function(options) {
    if (!(this instanceof Tar)) {
      return new Tar(options);
    }
    options = this.options = util.defaults(options, {
      gzip: false
    });
    if (typeof options.gzipOptions !== "object") {
      options.gzipOptions = {};
    }
    this.supports = {
      directory: true,
      symlink: true
    };
    this.engine = engine.pack(options);
    this.compressor = false;
    if (options.gzip) {
      this.compressor = zlib.createGzip(options.gzipOptions);
      this.compressor.on("error", this._onCompressorError.bind(this));
    }
  };
  Tar.prototype._onCompressorError = function(err) {
    this.engine.emit("error", err);
  };
  Tar.prototype.append = function(source, data, callback) {
    var self2 = this;
    data.mtime = data.date;
    function append(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      self2.engine.entry(data, sourceBuffer, function(err2) {
        callback(err2, data);
      });
    }
    if (data.sourceType === "buffer") {
      append(null, source);
    } else if (data.sourceType === "stream" && data.stats) {
      data.size = data.stats.size;
      var entry = self2.engine.entry(data, function(err) {
        callback(err, data);
      });
      source.pipe(entry);
    } else if (data.sourceType === "stream") {
      util.collectStream(source, append);
    }
  };
  Tar.prototype.finalize = function() {
    this.engine.finalize();
  };
  Tar.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Tar.prototype.pipe = function(destination, options) {
    if (this.compressor) {
      return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);
    } else {
      return this.engine.pipe.apply(this.engine, arguments);
    }
  };
  Tar.prototype.unpipe = function() {
    if (this.compressor) {
      return this.compressor.unpipe.apply(this.compressor, arguments);
    } else {
      return this.engine.unpipe.apply(this.engine, arguments);
    }
  };
  module.exports = Tar;
});

// node_modules/buffer-crc32/dist/index.cjs
var require_dist = __commonJS((exports, module) => {
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var CRC_TABLE = new Int32Array([
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ]);
  function ensureBuffer(input) {
    if (Buffer.isBuffer(input)) {
      return input;
    }
    if (typeof input === "number") {
      return Buffer.alloc(input);
    } else if (typeof input === "string") {
      return Buffer.from(input);
    } else {
      throw new Error("input must be buffer, number, or string, received " + typeof input);
    }
  }
  function bufferizeInt(num) {
    const tmp = ensureBuffer(4);
    tmp.writeInt32BE(num, 0);
    return tmp;
  }
  function _crc32(buf, previous) {
    buf = ensureBuffer(buf);
    if (Buffer.isBuffer(previous)) {
      previous = previous.readUInt32BE(0);
    }
    let crc = ~~previous ^ -1;
    for (var n = 0;n < buf.length; n++) {
      crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  }
  function crc32() {
    return bufferizeInt(_crc32.apply(null, arguments));
  }
  crc32.signed = function() {
    return _crc32.apply(null, arguments);
  };
  crc32.unsigned = function() {
    return _crc32.apply(null, arguments) >>> 0;
  };
  var bufferCrc32 = crc32;
  var index = /* @__PURE__ */ getDefaultExportFromCjs(bufferCrc32);
  module.exports = index;
});

// node_modules/archiver/lib/plugins/json.js
var require_json2 = __commonJS((exports, module) => {
  var inherits = __require("util").inherits;
  var Transform = require_ours().Transform;
  var crc32 = require_dist();
  var util = require_archiver_utils();
  var Json = function(options) {
    if (!(this instanceof Json)) {
      return new Json(options);
    }
    options = this.options = util.defaults(options, {});
    Transform.call(this, options);
    this.supports = {
      directory: true,
      symlink: true
    };
    this.files = [];
  };
  inherits(Json, Transform);
  Json.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  Json.prototype._writeStringified = function() {
    var fileString = JSON.stringify(this.files);
    this.write(fileString);
  };
  Json.prototype.append = function(source, data, callback) {
    var self2 = this;
    data.crc32 = 0;
    function onend(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      data.size = sourceBuffer.length || 0;
      data.crc32 = crc32.unsigned(sourceBuffer);
      self2.files.push(data);
      callback(null, data);
    }
    if (data.sourceType === "buffer") {
      onend(null, source);
    } else if (data.sourceType === "stream") {
      util.collectStream(source, onend);
    }
  };
  Json.prototype.finalize = function() {
    this._writeStringified();
    this.end();
  };
  module.exports = Json;
});

// node_modules/archiver/index.js
var require_archiver = __commonJS((exports, module) => {
  var Archiver = require_core();
  var formats = {};
  var vending = function(format, options) {
    return vending.create(format, options);
  };
  vending.create = function(format, options) {
    if (formats[format]) {
      var instance = new Archiver(format, options);
      instance.setFormat(format);
      instance.setModule(new formats[format](options));
      return instance;
    } else {
      throw new Error("create(" + format + "): format not registered");
    }
  };
  vending.registerFormat = function(format, module2) {
    if (formats[format]) {
      throw new Error("register(" + format + "): format already registered");
    }
    if (typeof module2 !== "function") {
      throw new Error("register(" + format + "): format module invalid");
    }
    if (typeof module2.prototype.append !== "function" || typeof module2.prototype.finalize !== "function") {
      throw new Error("register(" + format + "): format module missing methods");
    }
    formats[format] = module2;
  };
  vending.isRegisteredFormat = function(format) {
    if (formats[format]) {
      return true;
    }
    return false;
  };
  vending.registerFormat("zip", require_zip3());
  vending.registerFormat("tar", require_tar());
  vending.registerFormat("json", require_json2());
  module.exports = vending;
});

// node_modules/ignore/index.js
var require_ignore2 = __commonJS((exports, module) => {
  function makeArray(subject) {
    return Array.isArray(subject) ? subject : [subject];
  }
  var UNDEFINED = undefined;
  var EMPTY2 = "";
  var SPACE = " ";
  var ESCAPE = "\\";
  var REGEX_TEST_BLANK_LINE = /^\s+$/;
  var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
  var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
  var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
  var REGEX_SPLITALL_CRLF = /\r?\n/g;
  var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
  var REGEX_TEST_TRAILING_SLASH = /\/$/;
  var SLASH = "/";
  var TMP_KEY_IGNORE = "node-ignore";
  if (typeof Symbol !== "undefined") {
    TMP_KEY_IGNORE = Symbol.for("node-ignore");
  }
  var KEY_IGNORE = TMP_KEY_IGNORE;
  var define2 = (object, key12, value) => {
    Object.defineProperty(object, key12, { value });
    return value;
  };
  var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
  var RETURN_FALSE = () => false;
  var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from2, to) => from2.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY2);
  var cleanRangeBackSlash = (slashes) => {
    const { length } = slashes;
    return slashes.slice(0, length - length % 2);
  };
  var REPLACERS = [
    [
      /^\uFEFF/,
      () => EMPTY2
    ],
    [
      /((?:\\\\)*?)(\\?\s+)$/,
      (_3, m1, m2) => m1 + (m2.indexOf("\\") === 0 ? SPACE : EMPTY2)
    ],
    [
      /(\\+?)\s/g,
      (_3, m1) => {
        const { length } = m1;
        return m1.slice(0, length - length % 2) + SPACE;
      }
    ],
    [
      /[\\$.|*+(){^]/g,
      (match) => `\\${match}`
    ],
    [
      /(?!\\)\?/g,
      () => "[^/]"
    ],
    [
      /^\//,
      () => "^"
    ],
    [
      /\//g,
      () => "\\/"
    ],
    [
      /^\^*\\\*\\\*\\\//,
      () => "^(?:.*\\/)?"
    ],
    [
      /^(?=[^^])/,
      function startingReplacer() {
        return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
      }
    ],
    [
      /\\\/\\\*\\\*(?=\\\/|$)/g,
      (_3, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
    ],
    [
      /(^|[^\\]+)(\\\*)+(?=.+)/g,
      (_3, p1, p2) => {
        const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
        return p1 + unescaped;
      }
    ],
    [
      /\\\\\\(?=[$.|*+(){^])/g,
      () => ESCAPE
    ],
    [
      /\\\\/g,
      () => ESCAPE
    ],
    [
      /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
      (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
    ],
    [
      /(?:[^*])$/,
      (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
    ]
  ];
  var REGEX_REPLACE_TRAILING_WILDCARD = /(^|\\\/)?\\\*$/;
  var MODE_IGNORE = "regex";
  var MODE_CHECK_IGNORE = "checkRegex";
  var UNDERSCORE = "_";
  var TRAILING_WILD_CARD_REPLACERS = {
    [MODE_IGNORE](_3, p1) {
      const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
      return `${prefix}(?=$|\\/$)`;
    },
    [MODE_CHECK_IGNORE](_3, p1) {
      const prefix = p1 ? `${p1}[^/]*` : "[^/]*";
      return `${prefix}(?=$|\\/$)`;
    }
  };
  var makeRegexPrefix = (pattern) => REPLACERS.reduce((prev, [matcher, replacer]) => prev.replace(matcher, replacer.bind(pattern)), pattern);
  var isString = (subject) => typeof subject === "string";
  var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
  var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF).filter(Boolean);

  class IgnoreRule {
    constructor(pattern, mark, body, ignoreCase, negative, prefix) {
      this.pattern = pattern;
      this.mark = mark;
      this.negative = negative;
      define2(this, "body", body);
      define2(this, "ignoreCase", ignoreCase);
      define2(this, "regexPrefix", prefix);
    }
    get regex() {
      const key12 = UNDERSCORE + MODE_IGNORE;
      if (this[key12]) {
        return this[key12];
      }
      return this._make(MODE_IGNORE, key12);
    }
    get checkRegex() {
      const key12 = UNDERSCORE + MODE_CHECK_IGNORE;
      if (this[key12]) {
        return this[key12];
      }
      return this._make(MODE_CHECK_IGNORE, key12);
    }
    _make(mode, key12) {
      const str = this.regexPrefix.replace(REGEX_REPLACE_TRAILING_WILDCARD, TRAILING_WILD_CARD_REPLACERS[mode]);
      const regex2 = this.ignoreCase ? new RegExp(str, "i") : new RegExp(str);
      return define2(this, key12, regex2);
    }
  }
  var createRule = ({
    pattern,
    mark
  }, ignoreCase) => {
    let negative = false;
    let body = pattern;
    if (body.indexOf("!") === 0) {
      negative = true;
      body = body.substr(1);
    }
    body = body.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
    const regexPrefix = makeRegexPrefix(body);
    return new IgnoreRule(pattern, mark, body, ignoreCase, negative, regexPrefix);
  };

  class RuleManager {
    constructor(ignoreCase) {
      this._ignoreCase = ignoreCase;
      this._rules = [];
    }
    _add(pattern) {
      if (pattern && pattern[KEY_IGNORE]) {
        this._rules = this._rules.concat(pattern._rules._rules);
        this._added = true;
        return;
      }
      if (isString(pattern)) {
        pattern = {
          pattern
        };
      }
      if (checkPattern(pattern.pattern)) {
        const rule = createRule(pattern, this._ignoreCase);
        this._added = true;
        this._rules.push(rule);
      }
    }
    add(pattern) {
      this._added = false;
      makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._add, this);
      return this._added;
    }
    test(path3, checkUnignored, mode) {
      let ignored = false;
      let unignored = false;
      let matchedRule;
      this._rules.forEach((rule) => {
        const { negative } = rule;
        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
          return;
        }
        const matched = rule[mode].test(path3);
        if (!matched) {
          return;
        }
        ignored = !negative;
        unignored = negative;
        matchedRule = negative ? UNDEFINED : rule;
      });
      const ret = {
        ignored,
        unignored
      };
      if (matchedRule) {
        ret.rule = matchedRule;
      }
      return ret;
    }
  }
  var throwError = (message, Ctor) => {
    throw new Ctor(message);
  };
  var checkPath = (path3, originalPath, doThrow) => {
    if (!isString(path3)) {
      return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
    }
    if (!path3) {
      return doThrow(`path must not be empty`, TypeError);
    }
    if (checkPath.isNotRelative(path3)) {
      const r = "`path.relative()`d";
      return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
    }
    return true;
  };
  var isNotRelative = (path3) => REGEX_TEST_INVALID_PATH.test(path3);
  checkPath.isNotRelative = isNotRelative;
  checkPath.convert = (p) => p;

  class Ignore {
    constructor({
      ignorecase = true,
      ignoreCase = ignorecase,
      allowRelativePaths = false
    } = {}) {
      define2(this, KEY_IGNORE, true);
      this._rules = new RuleManager(ignoreCase);
      this._strictPathCheck = !allowRelativePaths;
      this._initCache();
    }
    _initCache() {
      this._ignoreCache = Object.create(null);
      this._testCache = Object.create(null);
    }
    add(pattern) {
      if (this._rules.add(pattern)) {
        this._initCache();
      }
      return this;
    }
    addPattern(pattern) {
      return this.add(pattern);
    }
    _test(originalPath, cache, checkUnignored, slices) {
      const path3 = originalPath && checkPath.convert(originalPath);
      checkPath(path3, originalPath, this._strictPathCheck ? throwError : RETURN_FALSE);
      return this._t(path3, cache, checkUnignored, slices);
    }
    checkIgnore(path3) {
      if (!REGEX_TEST_TRAILING_SLASH.test(path3)) {
        return this.test(path3);
      }
      const slices = path3.split(SLASH).filter(Boolean);
      slices.pop();
      if (slices.length) {
        const parent = this._t(slices.join(SLASH) + SLASH, this._testCache, true, slices);
        if (parent.ignored) {
          return parent;
        }
      }
      return this._rules.test(path3, false, MODE_CHECK_IGNORE);
    }
    _t(path3, cache, checkUnignored, slices) {
      if (path3 in cache) {
        return cache[path3];
      }
      if (!slices) {
        slices = path3.split(SLASH).filter(Boolean);
      }
      slices.pop();
      if (!slices.length) {
        return cache[path3] = this._rules.test(path3, checkUnignored, MODE_IGNORE);
      }
      const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
      return cache[path3] = parent.ignored ? parent : this._rules.test(path3, checkUnignored, MODE_IGNORE);
    }
    ignores(path3) {
      return this._test(path3, this._ignoreCache, false).ignored;
    }
    createFilter() {
      return (path3) => !this.ignores(path3);
    }
    filter(paths) {
      return makeArray(paths).filter(this.createFilter());
    }
    test(path3) {
      return this._test(path3, this._testCache, true);
    }
  }
  var factory = (options) => new Ignore(options);
  var isPathValid = (path3) => checkPath(path3 && checkPath.convert(path3), path3, RETURN_FALSE);
  if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
    const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
    checkPath.convert = makePosix;
    const REGEX_TEST_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
    checkPath.isNotRelative = (path3) => REGEX_TEST_WINDOWS_PATH_ABSOLUTE.test(path3) || isNotRelative(path3);
  }
  module.exports = factory;
  factory.default = factory;
  module.exports.isPathValid = isPathValid;
});

// node_modules/prompts/node_modules/kleur/index.js
var require_kleur = __commonJS((exports, module) => {
  var { FORCE_COLOR: FORCE_COLOR2, NODE_DISABLE_COLORS: NODE_DISABLE_COLORS2, TERM: TERM2 } = process.env;
  var $2 = {
    enabled: !NODE_DISABLE_COLORS2 && TERM2 !== "dumb" && FORCE_COLOR2 !== "0",
    reset: init2(0, 0),
    bold: init2(1, 22),
    dim: init2(2, 22),
    italic: init2(3, 23),
    underline: init2(4, 24),
    inverse: init2(7, 27),
    hidden: init2(8, 28),
    strikethrough: init2(9, 29),
    black: init2(30, 39),
    red: init2(31, 39),
    green: init2(32, 39),
    yellow: init2(33, 39),
    blue: init2(34, 39),
    magenta: init2(35, 39),
    cyan: init2(36, 39),
    white: init2(37, 39),
    gray: init2(90, 39),
    grey: init2(90, 39),
    bgBlack: init2(40, 49),
    bgRed: init2(41, 49),
    bgGreen: init2(42, 49),
    bgYellow: init2(43, 49),
    bgBlue: init2(44, 49),
    bgMagenta: init2(45, 49),
    bgCyan: init2(46, 49),
    bgWhite: init2(47, 49)
  };
  function run2(arr, str) {
    let i = 0, tmp, beg = "", end = "";
    for (;i < arr.length; i++) {
      tmp = arr[i];
      beg += tmp.open;
      end += tmp.close;
      if (str.includes(tmp.close)) {
        str = str.replace(tmp.rgx, tmp.close + tmp.open);
      }
    }
    return beg + str + end;
  }
  function chain(has, keys) {
    let ctx = { has, keys };
    ctx.reset = $2.reset.bind(ctx);
    ctx.bold = $2.bold.bind(ctx);
    ctx.dim = $2.dim.bind(ctx);
    ctx.italic = $2.italic.bind(ctx);
    ctx.underline = $2.underline.bind(ctx);
    ctx.inverse = $2.inverse.bind(ctx);
    ctx.hidden = $2.hidden.bind(ctx);
    ctx.strikethrough = $2.strikethrough.bind(ctx);
    ctx.black = $2.black.bind(ctx);
    ctx.red = $2.red.bind(ctx);
    ctx.green = $2.green.bind(ctx);
    ctx.yellow = $2.yellow.bind(ctx);
    ctx.blue = $2.blue.bind(ctx);
    ctx.magenta = $2.magenta.bind(ctx);
    ctx.cyan = $2.cyan.bind(ctx);
    ctx.white = $2.white.bind(ctx);
    ctx.gray = $2.gray.bind(ctx);
    ctx.grey = $2.grey.bind(ctx);
    ctx.bgBlack = $2.bgBlack.bind(ctx);
    ctx.bgRed = $2.bgRed.bind(ctx);
    ctx.bgGreen = $2.bgGreen.bind(ctx);
    ctx.bgYellow = $2.bgYellow.bind(ctx);
    ctx.bgBlue = $2.bgBlue.bind(ctx);
    ctx.bgMagenta = $2.bgMagenta.bind(ctx);
    ctx.bgCyan = $2.bgCyan.bind(ctx);
    ctx.bgWhite = $2.bgWhite.bind(ctx);
    return ctx;
  }
  function init2(open, close) {
    let blk = {
      open: `\x1B[${open}m`,
      close: `\x1B[${close}m`,
      rgx: new RegExp(`\\x1b\\[${close}m`, "g")
    };
    return function(txt) {
      if (this !== undefined && this.has !== undefined) {
        this.has.includes(open) || (this.has.push(open), this.keys.push(blk));
        return txt === undefined ? this : $2.enabled ? run2(this.keys, txt + "") : txt + "";
      }
      return txt === undefined ? chain([open], [blk]) : $2.enabled ? run2([blk], txt + "") : txt + "";
    };
  }
  module.exports = $2;
});

// node_modules/prompts/dist/util/action.js
var require_action = __commonJS((exports, module) => {
  module.exports = (key12, isSelect) => {
    if (key12.meta && key12.name !== "escape")
      return;
    if (key12.ctrl) {
      if (key12.name === "a")
        return "first";
      if (key12.name === "c")
        return "abort";
      if (key12.name === "d")
        return "abort";
      if (key12.name === "e")
        return "last";
      if (key12.name === "g")
        return "reset";
    }
    if (isSelect) {
      if (key12.name === "j")
        return "down";
      if (key12.name === "k")
        return "up";
    }
    if (key12.name === "return")
      return "submit";
    if (key12.name === "enter")
      return "submit";
    if (key12.name === "backspace")
      return "delete";
    if (key12.name === "delete")
      return "deleteForward";
    if (key12.name === "abort")
      return "abort";
    if (key12.name === "escape")
      return "exit";
    if (key12.name === "tab")
      return "next";
    if (key12.name === "pagedown")
      return "nextPage";
    if (key12.name === "pageup")
      return "prevPage";
    if (key12.name === "home")
      return "home";
    if (key12.name === "end")
      return "end";
    if (key12.name === "up")
      return "up";
    if (key12.name === "down")
      return "down";
    if (key12.name === "right")
      return "right";
    if (key12.name === "left")
      return "left";
    return false;
  };
});

// node_modules/prompts/dist/util/strip.js
var require_strip = __commonJS((exports, module) => {
  module.exports = (str) => {
    const pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|");
    const RGX = new RegExp(pattern, "g");
    return typeof str === "string" ? str.replace(RGX, "") : str;
  };
});

// node_modules/sisteransi/src/index.js
var require_src = __commonJS((exports, module) => {
  var ESC = "\x1B";
  var CSI = `${ESC}[`;
  var beep = "\x07";
  var cursor = {
    to(x, y) {
      if (!y)
        return `${CSI}${x + 1}G`;
      return `${CSI}${y + 1};${x + 1}H`;
    },
    move(x, y) {
      let ret = "";
      if (x < 0)
        ret += `${CSI}${-x}D`;
      else if (x > 0)
        ret += `${CSI}${x}C`;
      if (y < 0)
        ret += `${CSI}${-y}A`;
      else if (y > 0)
        ret += `${CSI}${y}B`;
      return ret;
    },
    up: (count = 1) => `${CSI}${count}A`,
    down: (count = 1) => `${CSI}${count}B`,
    forward: (count = 1) => `${CSI}${count}C`,
    backward: (count = 1) => `${CSI}${count}D`,
    nextLine: (count = 1) => `${CSI}E`.repeat(count),
    prevLine: (count = 1) => `${CSI}F`.repeat(count),
    left: `${CSI}G`,
    hide: `${CSI}?25l`,
    show: `${CSI}?25h`,
    save: `${ESC}7`,
    restore: `${ESC}8`
  };
  var scroll = {
    up: (count = 1) => `${CSI}S`.repeat(count),
    down: (count = 1) => `${CSI}T`.repeat(count)
  };
  var erase = {
    screen: `${CSI}2J`,
    up: (count = 1) => `${CSI}1J`.repeat(count),
    down: (count = 1) => `${CSI}J`.repeat(count),
    line: `${CSI}2K`,
    lineEnd: `${CSI}K`,
    lineStart: `${CSI}1K`,
    lines(count) {
      let clear = "";
      for (let i = 0;i < count; i++)
        clear += this.line + (i < count - 1 ? cursor.up() : "");
      if (count)
        clear += cursor.left;
      return clear;
    }
  };
  module.exports = { cursor, scroll, erase, beep };
});

// node_modules/prompts/dist/util/clear.js
var require_clear = __commonJS((exports, module) => {
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len);i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  var strip = require_strip();
  var _require = require_src();
  var erase = _require.erase;
  var cursor = _require.cursor;
  var width = (str) => [...strip(str)].length;
  module.exports = function(prompt2, perLine) {
    if (!perLine)
      return erase.line + cursor.to(0);
    let rows = 0;
    const lines4 = prompt2.split(/\r?\n/);
    var _iterator = _createForOfIteratorHelper(lines4), _step;
    try {
      for (_iterator.s();!(_step = _iterator.n()).done; ) {
        let line = _step.value;
        rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return erase.lines(rows);
  };
});

// node_modules/prompts/dist/util/figures.js
var require_figures = __commonJS((exports, module) => {
  var main2 = {
    arrowUp: "",
    arrowDown: "",
    arrowLeft: "",
    arrowRight: "",
    radioOn: "",
    radioOff: "",
    tick: "",
    cross: "",
    ellipsis: "",
    pointerSmall: "",
    line: "",
    pointer: ""
  };
  var win = {
    arrowUp: main2.arrowUp,
    arrowDown: main2.arrowDown,
    arrowLeft: main2.arrowLeft,
    arrowRight: main2.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "",
    cross: "",
    ellipsis: "...",
    pointerSmall: "",
    line: "",
    pointer: ">"
  };
  var figures11 = process.platform === "win32" ? win : main2;
  module.exports = figures11;
});

// node_modules/prompts/dist/util/style.js
var require_style = __commonJS((exports, module) => {
  var c = require_kleur();
  var figures11 = require_figures();
  var styles3 = Object.freeze({
    password: {
      scale: 1,
      render: (input) => "*".repeat(input.length)
    },
    emoji: {
      scale: 2,
      render: (input) => "\uD83D\uDE03".repeat(input.length)
    },
    invisible: {
      scale: 0,
      render: (input) => ""
    },
    default: {
      scale: 1,
      render: (input) => `${input}`
    }
  });
  var render = (type) => styles3[type] || styles3.default;
  var symbols2 = Object.freeze({
    aborted: c.red(figures11.cross),
    done: c.green(figures11.tick),
    exited: c.yellow(figures11.cross),
    default: c.cyan("?")
  });
  var symbol = (done, aborted, exited) => aborted ? symbols2.aborted : exited ? symbols2.exited : done ? symbols2.done : symbols2.default;
  var delimiter = (completing) => c.gray(completing ? figures11.ellipsis : figures11.pointerSmall);
  var item = (expandable, expanded) => c.gray(expandable ? expanded ? figures11.pointerSmall : "+" : figures11.line);
  module.exports = {
    styles: styles3,
    render,
    symbols: symbols2,
    symbol,
    delimiter,
    item
  };
});

// node_modules/prompts/dist/util/lines.js
var require_lines = __commonJS((exports, module) => {
  var strip = require_strip();
  module.exports = function(msg, perLine) {
    let lines4 = String(strip(msg) || "").split(/\r?\n/);
    if (!perLine)
      return lines4.length;
    return lines4.map((l) => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
  };
});

// node_modules/prompts/dist/util/wrap.js
var require_wrap = __commonJS((exports, module) => {
  module.exports = (msg, opts = {}) => {
    const tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(" ").join("") : opts.margin || "";
    const width = opts.width;
    return (msg || "").split(/\r?\n/g).map((line) => line.split(/\s+/g).reduce((arr, w) => {
      if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width)
        arr[arr.length - 1] += ` ${w}`;
      else
        arr.push(`${tab}${w}`);
      return arr;
    }, [tab]).join(`
`)).join(`
`);
  };
});

// node_modules/prompts/dist/util/entriesToDisplay.js
var require_entriesToDisplay = __commonJS((exports, module) => {
  module.exports = (cursor, total, maxVisible) => {
    maxVisible = maxVisible || total;
    let startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
    if (startIndex < 0)
      startIndex = 0;
    let endIndex = Math.min(startIndex + maxVisible, total);
    return {
      startIndex,
      endIndex
    };
  };
});

// node_modules/prompts/dist/util/index.js
var require_util5 = __commonJS((exports, module) => {
  module.exports = {
    action: require_action(),
    clear: require_clear(),
    style: require_style(),
    strip: require_strip(),
    figures: require_figures(),
    lines: require_lines(),
    wrap: require_wrap(),
    entriesToDisplay: require_entriesToDisplay()
  };
});

// node_modules/prompts/dist/elements/prompt.js
var require_prompt = __commonJS((exports, module) => {
  var readline22 = __require("readline");
  var _require = require_util5();
  var action = _require.action;
  var EventEmitter = __require("events");
  var _require2 = require_src();
  var beep = _require2.beep;
  var cursor = _require2.cursor;
  var color = require_kleur();

  class Prompt extends EventEmitter {
    constructor(opts = {}) {
      super();
      this.firstRender = true;
      this.in = opts.stdin || process.stdin;
      this.out = opts.stdout || process.stdout;
      this.onRender = (opts.onRender || (() => {
        return;
      })).bind(this);
      const rl = readline22.createInterface({
        input: this.in,
        escapeCodeTimeout: 50
      });
      readline22.emitKeypressEvents(this.in, rl);
      if (this.in.isTTY)
        this.in.setRawMode(true);
      const isSelect = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1;
      const keypress = (str, key12) => {
        let a = action(key12, isSelect);
        if (a === false) {
          this._ && this._(str, key12);
        } else if (typeof this[a] === "function") {
          this[a](key12);
        } else {
          this.bell();
        }
      };
      this.close = () => {
        this.out.write(cursor.show);
        this.in.removeListener("keypress", keypress);
        if (this.in.isTTY)
          this.in.setRawMode(false);
        rl.close();
        this.emit(this.aborted ? "abort" : this.exited ? "exit" : "submit", this.value);
        this.closed = true;
      };
      this.in.on("keypress", keypress);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(beep);
    }
    render() {
      this.onRender(color);
      if (this.firstRender)
        this.firstRender = false;
    }
  }
  module.exports = Prompt;
});

// node_modules/prompts/dist/elements/text.js
var require_text = __commonJS((exports, module) => {
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key12, arg) {
    try {
      var info = gen[key12](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_src();
  var erase = _require.erase;
  var cursor = _require.cursor;
  var _require2 = require_util5();
  var style = _require2.style;
  var clear = _require2.clear;
  var lines4 = _require2.lines;
  var figures11 = _require2.figures;

  class TextPrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.transform = style.render(opts.style);
      this.scale = this.transform.scale;
      this.msg = opts.message;
      this.initial = opts.initial || ``;
      this.validator = opts.validate || (() => true);
      this.value = ``;
      this.errorMsg = opts.error || `Please Enter A Valid Value`;
      this.cursor = Number(!!this.initial);
      this.cursorOffset = 0;
      this.clear = clear(``, this.out.columns);
      this.render();
    }
    set value(v) {
      if (!v && this.initial) {
        this.placeholder = true;
        this.rendered = color.gray(this.transform.render(this.initial));
      } else {
        this.placeholder = false;
        this.rendered = this.transform.render(v);
      }
      this._value = v;
      this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = ``;
      this.cursor = Number(!!this.initial);
      this.cursorOffset = 0;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial;
      this.done = this.aborted = true;
      this.error = false;
      this.red = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    validate() {
      var _this = this;
      return _asyncToGenerator(function* () {
        let valid = yield _this.validator(_this.value);
        if (typeof valid === `string`) {
          _this.errorMsg = valid;
          valid = false;
        }
        _this.error = !valid;
      })();
    }
    submit() {
      var _this2 = this;
      return _asyncToGenerator(function* () {
        _this2.value = _this2.value || _this2.initial;
        _this2.cursorOffset = 0;
        _this2.cursor = _this2.rendered.length;
        yield _this2.validate();
        if (_this2.error) {
          _this2.red = true;
          _this2.fire();
          _this2.render();
          return;
        }
        _this2.done = true;
        _this2.aborted = false;
        _this2.fire();
        _this2.render();
        _this2.out.write(`
`);
        _this2.close();
      })();
    }
    next() {
      if (!this.placeholder)
        return this.bell();
      this.value = this.initial;
      this.cursor = this.rendered.length;
      this.fire();
      this.render();
    }
    moveCursor(n) {
      if (this.placeholder)
        return;
      this.cursor = this.cursor + n;
      this.cursorOffset += n;
    }
    _(c, key12) {
      let s1 = this.value.slice(0, this.cursor);
      let s2 = this.value.slice(this.cursor);
      this.value = `${s1}${c}${s2}`;
      this.red = false;
      this.cursor = this.placeholder ? 0 : s1.length + 1;
      this.render();
    }
    delete() {
      if (this.isCursorAtStart())
        return this.bell();
      let s1 = this.value.slice(0, this.cursor - 1);
      let s2 = this.value.slice(this.cursor);
      this.value = `${s1}${s2}`;
      this.red = false;
      if (this.isCursorAtStart()) {
        this.cursorOffset = 0;
      } else {
        this.cursorOffset++;
        this.moveCursor(-1);
      }
      this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
        return this.bell();
      let s1 = this.value.slice(0, this.cursor);
      let s2 = this.value.slice(this.cursor + 1);
      this.value = `${s1}${s2}`;
      this.red = false;
      if (this.isCursorAtEnd()) {
        this.cursorOffset = 0;
      } else {
        this.cursorOffset++;
      }
      this.render();
    }
    first() {
      this.cursor = 0;
      this.render();
    }
    last() {
      this.cursor = this.value.length;
      this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder)
        return this.bell();
      this.moveCursor(-1);
      this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
        return this.bell();
      this.moveCursor(1);
      this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      if (this.closed)
        return;
      if (!this.firstRender) {
        if (this.outputError)
          this.out.write(cursor.down(lines4(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
        this.out.write(clear(this.outputText, this.out.columns));
      }
      super.render();
      this.outputError = "";
      this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.red ? color.red(this.rendered) : this.rendered].join(` `);
      if (this.error) {
        this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? " " : figures11.pointerSmall} ${color.red().italic(l)}`, ``);
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
    }
  }
  module.exports = TextPrompt;
});

// node_modules/prompts/dist/elements/select.js
var require_select = __commonJS((exports, module) => {
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_util5();
  var style = _require.style;
  var clear = _require.clear;
  var figures11 = _require.figures;
  var wrap = _require.wrap;
  var entriesToDisplay = _require.entriesToDisplay;
  var _require2 = require_src();
  var cursor = _require2.cursor;

  class SelectPrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.hint = opts.hint || "- Use arrow-keys. Return to submit.";
      this.warn = opts.warn || "- This option is disabled";
      this.cursor = opts.initial || 0;
      this.choices = opts.choices.map((ch, idx) => {
        if (typeof ch === "string")
          ch = {
            title: ch,
            value: idx
          };
        return {
          title: ch && (ch.title || ch.value || ch),
          value: ch && (ch.value === undefined ? idx : ch.value),
          description: ch && ch.description,
          selected: ch && ch.selected,
          disabled: ch && ch.disabled
        };
      });
      this.optionsPerPage = opts.optionsPerPage || 10;
      this.value = (this.choices[this.cursor] || {}).value;
      this.clear = clear("", this.out.columns);
      this.render();
    }
    moveCursor(n) {
      this.cursor = n;
      this.value = this.choices[n].value;
      this.fire();
    }
    reset() {
      this.moveCursor(0);
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    submit() {
      if (!this.selection.disabled) {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      } else
        this.bell();
    }
    first() {
      this.moveCursor(0);
      this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1);
      this.render();
    }
    up() {
      if (this.cursor === 0) {
        this.moveCursor(this.choices.length - 1);
      } else {
        this.moveCursor(this.cursor - 1);
      }
      this.render();
    }
    down() {
      if (this.cursor === this.choices.length - 1) {
        this.moveCursor(0);
      } else {
        this.moveCursor(this.cursor + 1);
      }
      this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length);
      this.render();
    }
    _(c, key12) {
      if (c === " ")
        return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      let _entriesToDisplay = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
      this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)].join(" ");
      if (!this.done) {
        this.outputText += `
`;
        for (let i = startIndex;i < endIndex; i++) {
          let title, prefix, desc = "", v = this.choices[i];
          if (i === startIndex && startIndex > 0) {
            prefix = figures11.arrowUp;
          } else if (i === endIndex - 1 && endIndex < this.choices.length) {
            prefix = figures11.arrowDown;
          } else {
            prefix = " ";
          }
          if (v.disabled) {
            title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
            prefix = (this.cursor === i ? color.bold().gray(figures11.pointer) + " " : "  ") + prefix;
          } else {
            title = this.cursor === i ? color.cyan().underline(v.title) : v.title;
            prefix = (this.cursor === i ? color.cyan(figures11.pointer) + " " : "  ") + prefix;
            if (v.description && this.cursor === i) {
              desc = ` - ${v.description}`;
              if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                desc = `
` + wrap(v.description, {
                  margin: 3,
                  width: this.out.columns
                });
              }
            }
          }
          this.outputText += `${prefix} ${title}${color.gray(desc)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  }
  module.exports = SelectPrompt;
});

// node_modules/prompts/dist/elements/toggle.js
var require_toggle = __commonJS((exports, module) => {
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_util5();
  var style = _require.style;
  var clear = _require.clear;
  var _require2 = require_src();
  var cursor = _require2.cursor;
  var erase = _require2.erase;

  class TogglePrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.value = !!opts.initial;
      this.active = opts.active || "on";
      this.inactive = opts.inactive || "off";
      this.initialValue = this.value;
      this.render();
    }
    reset() {
      this.value = this.initialValue;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    submit() {
      this.done = true;
      this.aborted = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    deactivate() {
      if (this.value === false)
        return this.bell();
      this.value = false;
      this.render();
    }
    activate() {
      if (this.value === true)
        return this.bell();
      this.value = true;
      this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value;
      this.fire();
      this.render();
    }
    _(c, key12) {
      if (c === " ") {
        this.value = !this.value;
      } else if (c === "1") {
        this.value = true;
      } else if (c === "0") {
        this.value = false;
      } else
        return this.bell();
      this.render();
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.value ? this.inactive : color.cyan().underline(this.inactive), color.gray("/"), this.value ? color.cyan().underline(this.active) : this.active].join(" ");
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  }
  module.exports = TogglePrompt;
});

// node_modules/prompts/dist/dateparts/datepart.js
var require_datepart = __commonJS((exports, module) => {
  class DatePart {
    constructor({
      token,
      date,
      parts,
      locales
    }) {
      this.token = token;
      this.date = date || new Date;
      this.parts = parts || [this];
      this.locales = locales || {};
    }
    up() {
    }
    down() {
    }
    next() {
      const currentIdx = this.parts.indexOf(this);
      return this.parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
    }
    setTo(val) {
    }
    prev() {
      let parts = [].concat(this.parts).reverse();
      const currentIdx = parts.indexOf(this);
      return parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
    }
    toString() {
      return String(this.date);
    }
  }
  module.exports = DatePart;
});

// node_modules/prompts/dist/dateparts/meridiem.js
var require_meridiem = __commonJS((exports, module) => {
  var DatePart = require_datepart();

  class Meridiem extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let meridiem = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
    }
  }
  module.exports = Meridiem;
});

// node_modules/prompts/dist/dateparts/day.js
var require_day = __commonJS((exports, module) => {
  var DatePart = require_datepart();
  var pos = (n) => {
    n = n % 10;
    return n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
  };

  class Day extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(val) {
      this.date.setDate(parseInt(val.substr(-2)));
    }
    toString() {
      let date = this.date.getDate();
      let day = this.date.getDay();
      return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
    }
  }
  module.exports = Day;
});

// node_modules/prompts/dist/dateparts/hours.js
var require_hours = __commonJS((exports, module) => {
  var DatePart = require_datepart();

  class Hours extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(val) {
      this.date.setHours(parseInt(val.substr(-2)));
    }
    toString() {
      let hours = this.date.getHours();
      if (/h/.test(this.token))
        hours = hours % 12 || 12;
      return this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
    }
  }
  module.exports = Hours;
});

// node_modules/prompts/dist/dateparts/milliseconds.js
var require_milliseconds = __commonJS((exports, module) => {
  var DatePart = require_datepart();

  class Milliseconds extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(val) {
      this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  }
  module.exports = Milliseconds;
});

// node_modules/prompts/dist/dateparts/minutes.js
var require_minutes = __commonJS((exports, module) => {
  var DatePart = require_datepart();

  class Minutes extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(val) {
      this.date.setMinutes(parseInt(val.substr(-2)));
    }
    toString() {
      let m = this.date.getMinutes();
      return this.token.length > 1 ? String(m).padStart(2, "0") : m;
    }
  }
  module.exports = Minutes;
});

// node_modules/prompts/dist/dateparts/month.js
var require_month = __commonJS((exports, module) => {
  var DatePart = require_datepart();

  class Month extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(val) {
      val = parseInt(val.substr(-2)) - 1;
      this.date.setMonth(val < 0 ? 0 : val);
    }
    toString() {
      let month = this.date.getMonth();
      let tl = this.token.length;
      return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
    }
  }
  module.exports = Month;
});

// node_modules/prompts/dist/dateparts/seconds.js
var require_seconds = __commonJS((exports, module) => {
  var DatePart = require_datepart();

  class Seconds extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(val) {
      this.date.setSeconds(parseInt(val.substr(-2)));
    }
    toString() {
      let s = this.date.getSeconds();
      return this.token.length > 1 ? String(s).padStart(2, "0") : s;
    }
  }
  module.exports = Seconds;
});

// node_modules/prompts/dist/dateparts/year.js
var require_year = __commonJS((exports, module) => {
  var DatePart = require_datepart();

  class Year extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(val) {
      this.date.setFullYear(val.substr(-4));
    }
    toString() {
      let year = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? year.substr(-2) : year;
    }
  }
  module.exports = Year;
});

// node_modules/prompts/dist/dateparts/index.js
var require_dateparts = __commonJS((exports, module) => {
  module.exports = {
    DatePart: require_datepart(),
    Meridiem: require_meridiem(),
    Day: require_day(),
    Hours: require_hours(),
    Milliseconds: require_milliseconds(),
    Minutes: require_minutes(),
    Month: require_month(),
    Seconds: require_seconds(),
    Year: require_year()
  };
});

// node_modules/prompts/dist/elements/date.js
var require_date = __commonJS((exports, module) => {
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key12, arg) {
    try {
      var info = gen[key12](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_util5();
  var style = _require.style;
  var clear = _require.clear;
  var figures11 = _require.figures;
  var _require2 = require_src();
  var erase = _require2.erase;
  var cursor = _require2.cursor;
  var _require3 = require_dateparts();
  var DatePart = _require3.DatePart;
  var Meridiem = _require3.Meridiem;
  var Day = _require3.Day;
  var Hours = _require3.Hours;
  var Milliseconds = _require3.Milliseconds;
  var Minutes = _require3.Minutes;
  var Month = _require3.Month;
  var Seconds = _require3.Seconds;
  var Year = _require3.Year;
  var regex2 = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
  var regexGroups = {
    1: ({
      token
    }) => token.replace(/\\(.)/g, "$1"),
    2: (opts) => new Day(opts),
    3: (opts) => new Month(opts),
    4: (opts) => new Year(opts),
    5: (opts) => new Meridiem(opts),
    6: (opts) => new Hours(opts),
    7: (opts) => new Minutes(opts),
    8: (opts) => new Seconds(opts),
    9: (opts) => new Milliseconds(opts)
  };
  var dfltLocales = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  };

  class DatePrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.cursor = 0;
      this.typed = "";
      this.locales = Object.assign(dfltLocales, opts.locales);
      this._date = opts.initial || new Date;
      this.errorMsg = opts.error || "Please Enter A Valid Value";
      this.validator = opts.validate || (() => true);
      this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss";
      this.clear = clear("", this.out.columns);
      this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(date) {
      if (date)
        this._date.setTime(date.getTime());
    }
    set mask(mask) {
      let result;
      this.parts = [];
      while (result = regex2.exec(mask)) {
        let match = result.shift();
        let idx = result.findIndex((gr) => gr != null);
        this.parts.push(idx in regexGroups ? regexGroups[idx]({
          token: result[idx] || match,
          date: this.date,
          parts: this.parts,
          locales: this.locales
        }) : result[idx] || match);
      }
      let parts = this.parts.reduce((arr, i) => {
        if (typeof i === "string" && typeof arr[arr.length - 1] === "string")
          arr[arr.length - 1] += i;
        else
          arr.push(i);
        return arr;
      }, []);
      this.parts.splice(0);
      this.parts.push(...parts);
      this.reset();
    }
    moveCursor(n) {
      this.typed = "";
      this.cursor = n;
      this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart));
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.error = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    validate() {
      var _this = this;
      return _asyncToGenerator(function* () {
        let valid = yield _this.validator(_this.value);
        if (typeof valid === "string") {
          _this.errorMsg = valid;
          valid = false;
        }
        _this.error = !valid;
      })();
    }
    submit() {
      var _this2 = this;
      return _asyncToGenerator(function* () {
        yield _this2.validate();
        if (_this2.error) {
          _this2.color = "red";
          _this2.fire();
          _this2.render();
          return;
        }
        _this2.done = true;
        _this2.aborted = false;
        _this2.fire();
        _this2.render();
        _this2.out.write(`
`);
        _this2.close();
      })();
    }
    up() {
      this.typed = "";
      this.parts[this.cursor].up();
      this.render();
    }
    down() {
      this.typed = "";
      this.parts[this.cursor].down();
      this.render();
    }
    left() {
      let prev = this.parts[this.cursor].prev();
      if (prev == null)
        return this.bell();
      this.moveCursor(this.parts.indexOf(prev));
      this.render();
    }
    right() {
      let next = this.parts[this.cursor].next();
      if (next == null)
        return this.bell();
      this.moveCursor(this.parts.indexOf(next));
      this.render();
    }
    next() {
      let next = this.parts[this.cursor].next();
      this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart));
      this.render();
    }
    _(c) {
      if (/\d/.test(c)) {
        this.typed += c;
        this.parts[this.cursor].setTo(this.typed);
        this.render();
      }
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")].join(" ");
      if (this.error) {
        this.outputText += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? ` ` : figures11.pointerSmall} ${color.red().italic(l)}`, ``);
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  }
  module.exports = DatePrompt;
});

// node_modules/prompts/dist/elements/number.js
var require_number = __commonJS((exports, module) => {
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key12, arg) {
    try {
      var info = gen[key12](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_src();
  var cursor = _require.cursor;
  var erase = _require.erase;
  var _require2 = require_util5();
  var style = _require2.style;
  var figures11 = _require2.figures;
  var clear = _require2.clear;
  var lines4 = _require2.lines;
  var isNumber = /[0-9]/;
  var isDef = (any) => any !== undefined;
  var round = (number2, precision) => {
    let factor = Math.pow(10, precision);
    return Math.round(number2 * factor) / factor;
  };

  class NumberPrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.transform = style.render(opts.style);
      this.msg = opts.message;
      this.initial = isDef(opts.initial) ? opts.initial : "";
      this.float = !!opts.float;
      this.round = opts.round || 2;
      this.inc = opts.increment || 1;
      this.min = isDef(opts.min) ? opts.min : -Infinity;
      this.max = isDef(opts.max) ? opts.max : Infinity;
      this.errorMsg = opts.error || `Please Enter A Valid Value`;
      this.validator = opts.validate || (() => true);
      this.color = `cyan`;
      this.value = ``;
      this.typed = ``;
      this.lastHit = 0;
      this.render();
    }
    set value(v) {
      if (!v && v !== 0) {
        this.placeholder = true;
        this.rendered = color.gray(this.transform.render(`${this.initial}`));
        this._value = ``;
      } else {
        this.placeholder = false;
        this.rendered = this.transform.render(`${round(v, this.round)}`);
        this._value = round(v, this.round);
      }
      this.fire();
    }
    get value() {
      return this._value;
    }
    parse(x) {
      return this.float ? parseFloat(x) : parseInt(x);
    }
    valid(c) {
      return c === `-` || c === `.` && this.float || isNumber.test(c);
    }
    reset() {
      this.typed = ``;
      this.value = ``;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let x = this.value;
      this.value = x !== `` ? x : this.initial;
      this.done = this.aborted = true;
      this.error = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    validate() {
      var _this = this;
      return _asyncToGenerator(function* () {
        let valid = yield _this.validator(_this.value);
        if (typeof valid === `string`) {
          _this.errorMsg = valid;
          valid = false;
        }
        _this.error = !valid;
      })();
    }
    submit() {
      var _this2 = this;
      return _asyncToGenerator(function* () {
        yield _this2.validate();
        if (_this2.error) {
          _this2.color = `red`;
          _this2.fire();
          _this2.render();
          return;
        }
        let x = _this2.value;
        _this2.value = x !== `` ? x : _this2.initial;
        _this2.done = true;
        _this2.aborted = false;
        _this2.error = false;
        _this2.fire();
        _this2.render();
        _this2.out.write(`
`);
        _this2.close();
      })();
    }
    up() {
      this.typed = ``;
      if (this.value === "") {
        this.value = this.min - this.inc;
      }
      if (this.value >= this.max)
        return this.bell();
      this.value += this.inc;
      this.color = `cyan`;
      this.fire();
      this.render();
    }
    down() {
      this.typed = ``;
      if (this.value === "") {
        this.value = this.min + this.inc;
      }
      if (this.value <= this.min)
        return this.bell();
      this.value -= this.inc;
      this.color = `cyan`;
      this.fire();
      this.render();
    }
    delete() {
      let val = this.value.toString();
      if (val.length === 0)
        return this.bell();
      this.value = this.parse(val = val.slice(0, -1)) || ``;
      if (this.value !== "" && this.value < this.min) {
        this.value = this.min;
      }
      this.color = `cyan`;
      this.fire();
      this.render();
    }
    next() {
      this.value = this.initial;
      this.fire();
      this.render();
    }
    _(c, key12) {
      if (!this.valid(c))
        return this.bell();
      const now = Date.now();
      if (now - this.lastHit > 1000)
        this.typed = ``;
      this.typed += c;
      this.lastHit = now;
      this.color = `cyan`;
      if (c === `.`)
        return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max);
      if (this.value > this.max)
        this.value = this.max;
      if (this.value < this.min)
        this.value = this.min;
      this.fire();
      this.render();
    }
    render() {
      if (this.closed)
        return;
      if (!this.firstRender) {
        if (this.outputError)
          this.out.write(cursor.down(lines4(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
        this.out.write(clear(this.outputText, this.out.columns));
      }
      super.render();
      this.outputError = "";
      this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered].join(` `);
      if (this.error) {
        this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? ` ` : figures11.pointerSmall} ${color.red().italic(l)}`, ``);
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
    }
  }
  module.exports = NumberPrompt;
});

// node_modules/prompts/dist/elements/multiselect.js
var require_multiselect = __commonJS((exports, module) => {
  var color = require_kleur();
  var _require = require_src();
  var cursor = _require.cursor;
  var Prompt = require_prompt();
  var _require2 = require_util5();
  var clear = _require2.clear;
  var figures11 = _require2.figures;
  var style = _require2.style;
  var wrap = _require2.wrap;
  var entriesToDisplay = _require2.entriesToDisplay;

  class MultiselectPrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.cursor = opts.cursor || 0;
      this.scrollIndex = opts.cursor || 0;
      this.hint = opts.hint || "";
      this.warn = opts.warn || "- This option is disabled -";
      this.minSelected = opts.min;
      this.showMinError = false;
      this.maxChoices = opts.max;
      this.instructions = opts.instructions;
      this.optionsPerPage = opts.optionsPerPage || 10;
      this.value = opts.choices.map((ch, idx) => {
        if (typeof ch === "string")
          ch = {
            title: ch,
            value: idx
          };
        return {
          title: ch && (ch.title || ch.value || ch),
          description: ch && ch.description,
          value: ch && (ch.value === undefined ? idx : ch.value),
          selected: ch && ch.selected,
          disabled: ch && ch.disabled
        };
      });
      this.clear = clear("", this.out.columns);
      if (!opts.overrideRender) {
        this.render();
      }
    }
    reset() {
      this.value.map((v) => !v.selected);
      this.cursor = 0;
      this.fire();
      this.render();
    }
    selected() {
      return this.value.filter((v) => v.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    submit() {
      const selected = this.value.filter((e) => e.selected);
      if (this.minSelected && selected.length < this.minSelected) {
        this.showMinError = true;
        this.render();
      } else {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      }
    }
    first() {
      this.cursor = 0;
      this.render();
    }
    last() {
      this.cursor = this.value.length - 1;
      this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length;
      this.render();
    }
    up() {
      if (this.cursor === 0) {
        this.cursor = this.value.length - 1;
      } else {
        this.cursor--;
      }
      this.render();
    }
    down() {
      if (this.cursor === this.value.length - 1) {
        this.cursor = 0;
      } else {
        this.cursor++;
      }
      this.render();
    }
    left() {
      this.value[this.cursor].selected = false;
      this.render();
    }
    right() {
      if (this.value.filter((e) => e.selected).length >= this.maxChoices)
        return this.bell();
      this.value[this.cursor].selected = true;
      this.render();
    }
    handleSpaceToggle() {
      const v = this.value[this.cursor];
      if (v.selected) {
        v.selected = false;
        this.render();
      } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
        return this.bell();
      } else {
        v.selected = true;
        this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== undefined || this.value[this.cursor].disabled) {
        return this.bell();
      }
      const newSelected = !this.value[this.cursor].selected;
      this.value.filter((v) => !v.disabled).forEach((v) => v.selected = newSelected);
      this.render();
    }
    _(c, key12) {
      if (c === " ") {
        this.handleSpaceToggle();
      } else if (c === "a") {
        this.toggleAll();
      } else {
        return this.bell();
      }
    }
    renderInstructions() {
      if (this.instructions === undefined || this.instructions) {
        if (typeof this.instructions === "string") {
          return this.instructions;
        }
        return `
Instructions:
` + `    ${figures11.arrowUp}/${figures11.arrowDown}: Highlight option
` + `    ${figures11.arrowLeft}/${figures11.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === undefined ? `    a: Toggle all
` : "") + `    enter/return: Complete answer`;
      }
      return "";
    }
    renderOption(cursor2, v, i, arrowIndicator) {
      const prefix = (v.selected ? color.green(figures11.radioOn) : figures11.radioOff) + " " + arrowIndicator + " ";
      let title, desc;
      if (v.disabled) {
        title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
      } else {
        title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
        if (cursor2 === i && v.description) {
          desc = ` - ${v.description}`;
          if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
            desc = `
` + wrap(v.description, {
              margin: prefix.length,
              width: this.out.columns
            });
          }
        }
      }
      return prefix + title + color.gray(desc || "");
    }
    paginateOptions(options) {
      if (options.length === 0) {
        return color.red("No matches for this query.");
      }
      let _entriesToDisplay = entriesToDisplay(this.cursor, options.length, this.optionsPerPage), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
      let prefix, styledOptions = [];
      for (let i = startIndex;i < endIndex; i++) {
        if (i === startIndex && startIndex > 0) {
          prefix = figures11.arrowUp;
        } else if (i === endIndex - 1 && endIndex < options.length) {
          prefix = figures11.arrowDown;
        } else {
          prefix = " ";
        }
        styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
      }
      return `
` + styledOptions.join(`
`);
    }
    renderOptions(options) {
      if (!this.done) {
        return this.paginateOptions(options);
      }
      return "";
    }
    renderDoneOrInstructions() {
      if (this.done) {
        return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
      }
      const output = [color.gray(this.hint), this.renderInstructions()];
      if (this.value[this.cursor].disabled) {
        output.push(color.yellow(this.warn));
      }
      return output.join(" ");
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      super.render();
      let prompt2 = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(" ");
      if (this.showMinError) {
        prompt2 += color.red(`You must select a minimum of ${this.minSelected} choices.`);
        this.showMinError = false;
      }
      prompt2 += this.renderOptions(this.value);
      this.out.write(this.clear + prompt2);
      this.clear = clear(prompt2, this.out.columns);
    }
  }
  module.exports = MultiselectPrompt;
});

// node_modules/prompts/dist/elements/autocomplete.js
var require_autocomplete = __commonJS((exports, module) => {
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key12, arg) {
    try {
      var info = gen[key12](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_src();
  var erase = _require.erase;
  var cursor = _require.cursor;
  var _require2 = require_util5();
  var style = _require2.style;
  var clear = _require2.clear;
  var figures11 = _require2.figures;
  var wrap = _require2.wrap;
  var entriesToDisplay = _require2.entriesToDisplay;
  var getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);
  var getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);
  var getIndex = (arr, valOrTitle) => {
    const index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
    return index > -1 ? index : undefined;
  };

  class AutocompletePrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.suggest = opts.suggest;
      this.choices = opts.choices;
      this.initial = typeof opts.initial === "number" ? opts.initial : getIndex(opts.choices, opts.initial);
      this.select = this.initial || opts.cursor || 0;
      this.i18n = {
        noMatches: opts.noMatches || "no matches found"
      };
      this.fallback = opts.fallback || this.initial;
      this.clearFirst = opts.clearFirst || false;
      this.suggestions = [];
      this.input = "";
      this.limit = opts.limit || 10;
      this.cursor = 0;
      this.transform = style.render(opts.style);
      this.scale = this.transform.scale;
      this.render = this.render.bind(this);
      this.complete = this.complete.bind(this);
      this.clear = clear("", this.out.columns);
      this.complete(this.render);
      this.render();
    }
    set fallback(fb) {
      this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
    }
    get fallback() {
      let choice;
      if (typeof this._fb === "number")
        choice = this.choices[this._fb];
      else if (typeof this._fb === "string")
        choice = {
          title: this._fb
        };
      return choice || this._fb || {
        title: this.i18n.noMatches
      };
    }
    moveSelect(i) {
      this.select = i;
      if (this.suggestions.length > 0)
        this.value = getVal(this.suggestions, i);
      else
        this.value = this.fallback.value;
      this.fire();
    }
    complete(cb) {
      var _this = this;
      return _asyncToGenerator(function* () {
        const p = _this.completing = _this.suggest(_this.input, _this.choices);
        const suggestions = yield p;
        if (_this.completing !== p)
          return;
        _this.suggestions = suggestions.map((s, i, arr) => ({
          title: getTitle(arr, i),
          value: getVal(arr, i),
          description: s.description
        }));
        _this.completing = false;
        const l = Math.max(suggestions.length - 1, 0);
        _this.moveSelect(Math.min(l, _this.select));
        cb && cb();
      })();
    }
    reset() {
      this.input = "";
      this.complete(() => {
        this.moveSelect(this.initial !== undefined ? this.initial : 0);
        this.render();
      });
      this.render();
    }
    exit() {
      if (this.clearFirst && this.input.length > 0) {
        this.reset();
      } else {
        this.done = this.exited = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      }
    }
    abort() {
      this.done = this.aborted = true;
      this.exited = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    submit() {
      this.done = true;
      this.aborted = this.exited = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    _(c, key12) {
      let s1 = this.input.slice(0, this.cursor);
      let s2 = this.input.slice(this.cursor);
      this.input = `${s1}${c}${s2}`;
      this.cursor = s1.length + 1;
      this.complete(this.render);
      this.render();
    }
    delete() {
      if (this.cursor === 0)
        return this.bell();
      let s1 = this.input.slice(0, this.cursor - 1);
      let s2 = this.input.slice(this.cursor);
      this.input = `${s1}${s2}`;
      this.complete(this.render);
      this.cursor = this.cursor - 1;
      this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length)
        return this.bell();
      let s1 = this.input.slice(0, this.cursor);
      let s2 = this.input.slice(this.cursor + 1);
      this.input = `${s1}${s2}`;
      this.complete(this.render);
      this.render();
    }
    first() {
      this.moveSelect(0);
      this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1);
      this.render();
    }
    up() {
      if (this.select === 0) {
        this.moveSelect(this.suggestions.length - 1);
      } else {
        this.moveSelect(this.select - 1);
      }
      this.render();
    }
    down() {
      if (this.select === this.suggestions.length - 1) {
        this.moveSelect(0);
      } else {
        this.moveSelect(this.select + 1);
      }
      this.render();
    }
    next() {
      if (this.select === this.suggestions.length - 1) {
        this.moveSelect(0);
      } else
        this.moveSelect(this.select + 1);
      this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
      this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0));
      this.render();
    }
    left() {
      if (this.cursor <= 0)
        return this.bell();
      this.cursor = this.cursor - 1;
      this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length)
        return this.bell();
      this.cursor = this.cursor + 1;
      this.render();
    }
    renderOption(v, hovered, isStart, isEnd) {
      let desc;
      let prefix = isStart ? figures11.arrowUp : isEnd ? figures11.arrowDown : " ";
      let title = hovered ? color.cyan().underline(v.title) : v.title;
      prefix = (hovered ? color.cyan(figures11.pointer) + " " : "  ") + prefix;
      if (v.description) {
        desc = ` - ${v.description}`;
        if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
          desc = `
` + wrap(v.description, {
            margin: 3,
            width: this.out.columns
          });
        }
      }
      return prefix + " " + title + color.gray(desc || "");
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      let _entriesToDisplay = entriesToDisplay(this.select, this.choices.length, this.limit), startIndex = _entriesToDisplay.startIndex, endIndex = _entriesToDisplay.endIndex;
      this.outputText = [style.symbol(this.done, this.aborted, this.exited), color.bold(this.msg), style.delimiter(this.completing), this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(" ");
      if (!this.done) {
        const suggestions = this.suggestions.slice(startIndex, endIndex).map((item, i) => this.renderOption(item, this.select === i + startIndex, i === 0 && startIndex > 0, i + startIndex === endIndex - 1 && endIndex < this.choices.length)).join(`
`);
        this.outputText += `
` + (suggestions || color.gray(this.fallback.title));
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  }
  module.exports = AutocompletePrompt;
});

// node_modules/prompts/dist/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect = __commonJS((exports, module) => {
  var color = require_kleur();
  var _require = require_src();
  var cursor = _require.cursor;
  var MultiselectPrompt = require_multiselect();
  var _require2 = require_util5();
  var clear = _require2.clear;
  var style = _require2.style;
  var figures11 = _require2.figures;

  class AutocompleteMultiselectPrompt extends MultiselectPrompt {
    constructor(opts = {}) {
      opts.overrideRender = true;
      super(opts);
      this.inputValue = "";
      this.clear = clear("", this.out.columns);
      this.filteredOptions = this.value;
      this.render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1;
      this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length;
      this.render();
    }
    up() {
      if (this.cursor === 0) {
        this.cursor = this.filteredOptions.length - 1;
      } else {
        this.cursor--;
      }
      this.render();
    }
    down() {
      if (this.cursor === this.filteredOptions.length - 1) {
        this.cursor = 0;
      } else {
        this.cursor++;
      }
      this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = false;
      this.render();
    }
    right() {
      if (this.value.filter((e) => e.selected).length >= this.maxChoices)
        return this.bell();
      this.filteredOptions[this.cursor].selected = true;
      this.render();
    }
    delete() {
      if (this.inputValue.length) {
        this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
        this.updateFilteredOptions();
      }
    }
    updateFilteredOptions() {
      const currentHighlight = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((v) => {
        if (this.inputValue) {
          if (typeof v.title === "string") {
            if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
              return true;
            }
          }
          if (typeof v.value === "string") {
            if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
              return true;
            }
          }
          return false;
        }
        return true;
      });
      const newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
      this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
      this.render();
    }
    handleSpaceToggle() {
      const v = this.filteredOptions[this.cursor];
      if (v.selected) {
        v.selected = false;
        this.render();
      } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
        return this.bell();
      } else {
        v.selected = true;
        this.render();
      }
    }
    handleInputChange(c) {
      this.inputValue = this.inputValue + c;
      this.updateFilteredOptions();
    }
    _(c, key12) {
      if (c === " ") {
        this.handleSpaceToggle();
      } else {
        this.handleInputChange(c);
      }
    }
    renderInstructions() {
      if (this.instructions === undefined || this.instructions) {
        if (typeof this.instructions === "string") {
          return this.instructions;
        }
        return `
Instructions:
    ${figures11.arrowUp}/${figures11.arrowDown}: Highlight option
    ${figures11.arrowLeft}/${figures11.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
      }
      return "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
    }
    renderOption(cursor2, v, i) {
      let title;
      if (v.disabled)
        title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
      else
        title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
      return (v.selected ? color.green(figures11.radioOn) : figures11.radioOff) + "  " + title;
    }
    renderDoneOrInstructions() {
      if (this.done) {
        return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
      }
      const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
        output.push(color.yellow(this.warn));
      }
      return output.join(" ");
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      super.render();
      let prompt2 = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.renderDoneOrInstructions()].join(" ");
      if (this.showMinError) {
        prompt2 += color.red(`You must select a minimum of ${this.minSelected} choices.`);
        this.showMinError = false;
      }
      prompt2 += this.renderOptions(this.filteredOptions);
      this.out.write(this.clear + prompt2);
      this.clear = clear(prompt2, this.out.columns);
    }
  }
  module.exports = AutocompleteMultiselectPrompt;
});

// node_modules/prompts/dist/elements/confirm.js
var require_confirm = __commonJS((exports, module) => {
  var color = require_kleur();
  var Prompt = require_prompt();
  var _require = require_util5();
  var style = _require.style;
  var clear = _require.clear;
  var _require2 = require_src();
  var erase = _require2.erase;
  var cursor = _require2.cursor;

  class ConfirmPrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.value = opts.initial;
      this.initialValue = !!opts.initial;
      this.yesMsg = opts.yes || "yes";
      this.yesOption = opts.yesOption || "(Y/n)";
      this.noMsg = opts.no || "no";
      this.noOption = opts.noOption || "(y/N)";
      this.render();
    }
    reset() {
      this.value = this.initialValue;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    submit() {
      this.value = this.value || false;
      this.done = true;
      this.aborted = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    _(c, key12) {
      if (c.toLowerCase() === "y") {
        this.value = true;
        return this.submit();
      }
      if (c.toLowerCase() === "n") {
        this.value = false;
        return this.submit();
      }
      return this.bell();
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)].join(" ");
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  }
  module.exports = ConfirmPrompt;
});

// node_modules/prompts/dist/elements/index.js
var require_elements = __commonJS((exports, module) => {
  module.exports = {
    TextPrompt: require_text(),
    SelectPrompt: require_select(),
    TogglePrompt: require_toggle(),
    DatePrompt: require_date(),
    NumberPrompt: require_number(),
    MultiselectPrompt: require_multiselect(),
    AutocompletePrompt: require_autocomplete(),
    AutocompleteMultiselectPrompt: require_autocompleteMultiselect(),
    ConfirmPrompt: require_confirm()
  };
});

// node_modules/prompts/dist/prompts.js
var require_prompts = __commonJS((exports) => {
  var $2 = exports;
  var el = require_elements();
  var noop = (v) => v;
  function toPrompt(type, args, opts = {}) {
    return new Promise((res, rej) => {
      const p = new el[type](args);
      const onAbort = opts.onAbort || noop;
      const onSubmit = opts.onSubmit || noop;
      const onExit2 = opts.onExit || noop;
      p.on("state", args.onState || noop);
      p.on("submit", (x) => res(onSubmit(x)));
      p.on("exit", (x) => res(onExit2(x)));
      p.on("abort", (x) => rej(onAbort(x)));
    });
  }
  $2.text = (args) => toPrompt("TextPrompt", args);
  $2.password = (args) => {
    args.style = "password";
    return $2.text(args);
  };
  $2.invisible = (args) => {
    args.style = "invisible";
    return $2.text(args);
  };
  $2.number = (args) => toPrompt("NumberPrompt", args);
  $2.date = (args) => toPrompt("DatePrompt", args);
  $2.confirm = (args) => toPrompt("ConfirmPrompt", args);
  $2.list = (args) => {
    const sep = args.separator || ",";
    return toPrompt("TextPrompt", args, {
      onSubmit: (str) => str.split(sep).map((s) => s.trim())
    });
  };
  $2.toggle = (args) => toPrompt("TogglePrompt", args);
  $2.select = (args) => toPrompt("SelectPrompt", args);
  $2.multiselect = (args) => {
    args.choices = [].concat(args.choices || []);
    const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
    return toPrompt("MultiselectPrompt", args, {
      onAbort: toSelected,
      onSubmit: toSelected
    });
  };
  $2.autocompleteMultiselect = (args) => {
    args.choices = [].concat(args.choices || []);
    const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
    return toPrompt("AutocompleteMultiselectPrompt", args, {
      onAbort: toSelected,
      onSubmit: toSelected
    });
  };
  var byTitle = (input, choices) => Promise.resolve(choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase()));
  $2.autocomplete = (args) => {
    args.suggest = args.suggest || byTitle;
    args.choices = [].concat(args.choices || []);
    return toPrompt("AutocompletePrompt", args);
  };
});

// node_modules/prompts/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols2 = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols2 = symbols2.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys.push.apply(keys, symbols2);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key12) {
          _defineProperty(target, key12, source[key12]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key12) {
          Object.defineProperty(target, key12, Object.getOwnPropertyDescriptor(source, key12));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key12, value) {
    if (key12 in obj) {
      Object.defineProperty(obj, key12, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key12] = value;
    }
    return obj;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len);i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key12, arg) {
    try {
      var info = gen[key12](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  var prompts = require_prompts();
  var passOn = ["suggest", "format", "onState", "validate", "onRender", "type"];
  var noop = () => {
  };
  function prompt2() {
    return _prompt.apply(this, arguments);
  }
  function _prompt() {
    _prompt = _asyncToGenerator(function* (questions = [], {
      onSubmit = noop,
      onCancel = noop
    } = {}) {
      const answers = {};
      const override2 = prompt2._override || {};
      questions = [].concat(questions);
      let answer, question, quit, name, type, lastPrompt;
      const getFormattedAnswer = /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator(function* (question2, answer2, skipValidation = false) {
          if (!skipValidation && question2.validate && question2.validate(answer2) !== true) {
            return;
          }
          return question2.format ? yield question2.format(answer2, answers) : answer2;
        });
        return function getFormattedAnswer(_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }();
      var _iterator = _createForOfIteratorHelper(questions), _step;
      try {
        for (_iterator.s();!(_step = _iterator.n()).done; ) {
          question = _step.value;
          var _question = question;
          name = _question.name;
          type = _question.type;
          if (typeof type === "function") {
            type = yield type(answer, _objectSpread({}, answers), question);
            question["type"] = type;
          }
          if (!type)
            continue;
          for (let key12 in question) {
            if (passOn.includes(key12))
              continue;
            let value = question[key12];
            question[key12] = typeof value === "function" ? yield value(answer, _objectSpread({}, answers), lastPrompt) : value;
          }
          lastPrompt = question;
          if (typeof question.message !== "string") {
            throw new Error("prompt message is required");
          }
          var _question2 = question;
          name = _question2.name;
          type = _question2.type;
          if (prompts[type] === undefined) {
            throw new Error(`prompt type (${type}) is not defined`);
          }
          if (override2[question.name] !== undefined) {
            answer = yield getFormattedAnswer(question, override2[question.name]);
            if (answer !== undefined) {
              answers[name] = answer;
              continue;
            }
          }
          try {
            answer = prompt2._injected ? getInjectedAnswer(prompt2._injected, question.initial) : yield prompts[type](question);
            answers[name] = answer = yield getFormattedAnswer(question, answer, true);
            quit = yield onSubmit(question, answer, answers);
          } catch (err) {
            quit = !(yield onCancel(question, answers));
          }
          if (quit)
            return answers;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return answers;
    });
    return _prompt.apply(this, arguments);
  }
  function getInjectedAnswer(injected, deafultValue) {
    const answer = injected.shift();
    if (answer instanceof Error) {
      throw answer;
    }
    return answer === undefined ? deafultValue : answer;
  }
  function inject(answers) {
    prompt2._injected = (prompt2._injected || []).concat(answers);
  }
  function override(answers) {
    prompt2._override = Object.assign({}, answers);
  }
  module.exports = Object.assign(prompt2, {
    prompt: prompt2,
    prompts,
    inject,
    override
  });
});

// node_modules/prompts/lib/util/action.js
var require_action2 = __commonJS((exports, module) => {
  module.exports = (key12, isSelect) => {
    if (key12.meta && key12.name !== "escape")
      return;
    if (key12.ctrl) {
      if (key12.name === "a")
        return "first";
      if (key12.name === "c")
        return "abort";
      if (key12.name === "d")
        return "abort";
      if (key12.name === "e")
        return "last";
      if (key12.name === "g")
        return "reset";
    }
    if (isSelect) {
      if (key12.name === "j")
        return "down";
      if (key12.name === "k")
        return "up";
    }
    if (key12.name === "return")
      return "submit";
    if (key12.name === "enter")
      return "submit";
    if (key12.name === "backspace")
      return "delete";
    if (key12.name === "delete")
      return "deleteForward";
    if (key12.name === "abort")
      return "abort";
    if (key12.name === "escape")
      return "exit";
    if (key12.name === "tab")
      return "next";
    if (key12.name === "pagedown")
      return "nextPage";
    if (key12.name === "pageup")
      return "prevPage";
    if (key12.name === "home")
      return "home";
    if (key12.name === "end")
      return "end";
    if (key12.name === "up")
      return "up";
    if (key12.name === "down")
      return "down";
    if (key12.name === "right")
      return "right";
    if (key12.name === "left")
      return "left";
    return false;
  };
});

// node_modules/prompts/lib/util/strip.js
var require_strip2 = __commonJS((exports, module) => {
  module.exports = (str) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
    ].join("|");
    const RGX = new RegExp(pattern, "g");
    return typeof str === "string" ? str.replace(RGX, "") : str;
  };
});

// node_modules/prompts/lib/util/clear.js
var require_clear2 = __commonJS((exports, module) => {
  var strip = require_strip2();
  var { erase, cursor } = require_src();
  var width = (str) => [...strip(str)].length;
  module.exports = function(prompt2, perLine) {
    if (!perLine)
      return erase.line + cursor.to(0);
    let rows = 0;
    const lines4 = prompt2.split(/\r?\n/);
    for (let line of lines4) {
      rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
    }
    return erase.lines(rows);
  };
});

// node_modules/prompts/lib/util/figures.js
var require_figures2 = __commonJS((exports, module) => {
  var main2 = {
    arrowUp: "",
    arrowDown: "",
    arrowLeft: "",
    arrowRight: "",
    radioOn: "",
    radioOff: "",
    tick: "",
    cross: "",
    ellipsis: "",
    pointerSmall: "",
    line: "",
    pointer: ""
  };
  var win = {
    arrowUp: main2.arrowUp,
    arrowDown: main2.arrowDown,
    arrowLeft: main2.arrowLeft,
    arrowRight: main2.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "",
    cross: "",
    ellipsis: "...",
    pointerSmall: "",
    line: "",
    pointer: ">"
  };
  var figures11 = process.platform === "win32" ? win : main2;
  module.exports = figures11;
});

// node_modules/prompts/lib/util/style.js
var require_style2 = __commonJS((exports, module) => {
  var c = require_kleur();
  var figures11 = require_figures2();
  var styles3 = Object.freeze({
    password: { scale: 1, render: (input) => "*".repeat(input.length) },
    emoji: { scale: 2, render: (input) => "\uD83D\uDE03".repeat(input.length) },
    invisible: { scale: 0, render: (input) => "" },
    default: { scale: 1, render: (input) => `${input}` }
  });
  var render = (type) => styles3[type] || styles3.default;
  var symbols2 = Object.freeze({
    aborted: c.red(figures11.cross),
    done: c.green(figures11.tick),
    exited: c.yellow(figures11.cross),
    default: c.cyan("?")
  });
  var symbol = (done, aborted, exited) => aborted ? symbols2.aborted : exited ? symbols2.exited : done ? symbols2.done : symbols2.default;
  var delimiter = (completing) => c.gray(completing ? figures11.ellipsis : figures11.pointerSmall);
  var item = (expandable, expanded) => c.gray(expandable ? expanded ? figures11.pointerSmall : "+" : figures11.line);
  module.exports = {
    styles: styles3,
    render,
    symbols: symbols2,
    symbol,
    delimiter,
    item
  };
});

// node_modules/prompts/lib/util/lines.js
var require_lines2 = __commonJS((exports, module) => {
  var strip = require_strip2();
  module.exports = function(msg, perLine) {
    let lines4 = String(strip(msg) || "").split(/\r?\n/);
    if (!perLine)
      return lines4.length;
    return lines4.map((l) => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
  };
});

// node_modules/prompts/lib/util/wrap.js
var require_wrap2 = __commonJS((exports, module) => {
  module.exports = (msg, opts = {}) => {
    const tab = Number.isSafeInteger(parseInt(opts.margin)) ? new Array(parseInt(opts.margin)).fill(" ").join("") : opts.margin || "";
    const width = opts.width;
    return (msg || "").split(/\r?\n/g).map((line) => line.split(/\s+/g).reduce((arr, w) => {
      if (w.length + tab.length >= width || arr[arr.length - 1].length + w.length + 1 < width)
        arr[arr.length - 1] += ` ${w}`;
      else
        arr.push(`${tab}${w}`);
      return arr;
    }, [tab]).join(`
`)).join(`
`);
  };
});

// node_modules/prompts/lib/util/entriesToDisplay.js
var require_entriesToDisplay2 = __commonJS((exports, module) => {
  module.exports = (cursor, total, maxVisible) => {
    maxVisible = maxVisible || total;
    let startIndex = Math.min(total - maxVisible, cursor - Math.floor(maxVisible / 2));
    if (startIndex < 0)
      startIndex = 0;
    let endIndex = Math.min(startIndex + maxVisible, total);
    return { startIndex, endIndex };
  };
});

// node_modules/prompts/lib/util/index.js
var require_util6 = __commonJS((exports, module) => {
  module.exports = {
    action: require_action2(),
    clear: require_clear2(),
    style: require_style2(),
    strip: require_strip2(),
    figures: require_figures2(),
    lines: require_lines2(),
    wrap: require_wrap2(),
    entriesToDisplay: require_entriesToDisplay2()
  };
});

// node_modules/prompts/lib/elements/prompt.js
var require_prompt2 = __commonJS((exports, module) => {
  var readline22 = __require("readline");
  var { action } = require_util6();
  var EventEmitter = __require("events");
  var { beep, cursor } = require_src();
  var color = require_kleur();

  class Prompt extends EventEmitter {
    constructor(opts = {}) {
      super();
      this.firstRender = true;
      this.in = opts.stdin || process.stdin;
      this.out = opts.stdout || process.stdout;
      this.onRender = (opts.onRender || (() => {
        return;
      })).bind(this);
      const rl = readline22.createInterface({ input: this.in, escapeCodeTimeout: 50 });
      readline22.emitKeypressEvents(this.in, rl);
      if (this.in.isTTY)
        this.in.setRawMode(true);
      const isSelect = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1;
      const keypress = (str, key12) => {
        let a = action(key12, isSelect);
        if (a === false) {
          this._ && this._(str, key12);
        } else if (typeof this[a] === "function") {
          this[a](key12);
        } else {
          this.bell();
        }
      };
      this.close = () => {
        this.out.write(cursor.show);
        this.in.removeListener("keypress", keypress);
        if (this.in.isTTY)
          this.in.setRawMode(false);
        rl.close();
        this.emit(this.aborted ? "abort" : this.exited ? "exit" : "submit", this.value);
        this.closed = true;
      };
      this.in.on("keypress", keypress);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(beep);
    }
    render() {
      this.onRender(color);
      if (this.firstRender)
        this.firstRender = false;
    }
  }
  module.exports = Prompt;
});

// node_modules/prompts/lib/elements/text.js
var require_text2 = __commonJS((exports, module) => {
  var color = require_kleur();
  var Prompt = require_prompt2();
  var { erase, cursor } = require_src();
  var { style, clear, lines: lines4, figures: figures11 } = require_util6();

  class TextPrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.transform = style.render(opts.style);
      this.scale = this.transform.scale;
      this.msg = opts.message;
      this.initial = opts.initial || ``;
      this.validator = opts.validate || (() => true);
      this.value = ``;
      this.errorMsg = opts.error || `Please Enter A Valid Value`;
      this.cursor = Number(!!this.initial);
      this.cursorOffset = 0;
      this.clear = clear(``, this.out.columns);
      this.render();
    }
    set value(v) {
      if (!v && this.initial) {
        this.placeholder = true;
        this.rendered = color.gray(this.transform.render(this.initial));
      } else {
        this.placeholder = false;
        this.rendered = this.transform.render(v);
      }
      this._value = v;
      this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = ``;
      this.cursor = Number(!!this.initial);
      this.cursorOffset = 0;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial;
      this.done = this.aborted = true;
      this.error = false;
      this.red = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    async validate() {
      let valid = await this.validator(this.value);
      if (typeof valid === `string`) {
        this.errorMsg = valid;
        valid = false;
      }
      this.error = !valid;
    }
    async submit() {
      this.value = this.value || this.initial;
      this.cursorOffset = 0;
      this.cursor = this.rendered.length;
      await this.validate();
      if (this.error) {
        this.red = true;
        this.fire();
        this.render();
        return;
      }
      this.done = true;
      this.aborted = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    next() {
      if (!this.placeholder)
        return this.bell();
      this.value = this.initial;
      this.cursor = this.rendered.length;
      this.fire();
      this.render();
    }
    moveCursor(n) {
      if (this.placeholder)
        return;
      this.cursor = this.cursor + n;
      this.cursorOffset += n;
    }
    _(c, key12) {
      let s1 = this.value.slice(0, this.cursor);
      let s2 = this.value.slice(this.cursor);
      this.value = `${s1}${c}${s2}`;
      this.red = false;
      this.cursor = this.placeholder ? 0 : s1.length + 1;
      this.render();
    }
    delete() {
      if (this.isCursorAtStart())
        return this.bell();
      let s1 = this.value.slice(0, this.cursor - 1);
      let s2 = this.value.slice(this.cursor);
      this.value = `${s1}${s2}`;
      this.red = false;
      if (this.isCursorAtStart()) {
        this.cursorOffset = 0;
      } else {
        this.cursorOffset++;
        this.moveCursor(-1);
      }
      this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
        return this.bell();
      let s1 = this.value.slice(0, this.cursor);
      let s2 = this.value.slice(this.cursor + 1);
      this.value = `${s1}${s2}`;
      this.red = false;
      if (this.isCursorAtEnd()) {
        this.cursorOffset = 0;
      } else {
        this.cursorOffset++;
      }
      this.render();
    }
    first() {
      this.cursor = 0;
      this.render();
    }
    last() {
      this.cursor = this.value.length;
      this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder)
        return this.bell();
      this.moveCursor(-1);
      this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
        return this.bell();
      this.moveCursor(1);
      this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      if (this.closed)
        return;
      if (!this.firstRender) {
        if (this.outputError)
          this.out.write(cursor.down(lines4(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
        this.out.write(clear(this.outputText, this.out.columns));
      }
      super.render();
      this.outputError = "";
      this.outputText = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(this.done),
        this.red ? color.red(this.rendered) : this.rendered
      ].join(` `);
      if (this.error) {
        this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? " " : figures11.pointerSmall} ${color.red().italic(l)}`, ``);
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore + cursor.move(this.cursorOffset, 0));
    }
  }
  module.exports = TextPrompt;
});

// node_modules/prompts/lib/elements/select.js
var require_select2 = __commonJS((exports, module) => {
  var color = require_kleur();
  var Prompt = require_prompt2();
  var { style, clear, figures: figures11, wrap, entriesToDisplay } = require_util6();
  var { cursor } = require_src();

  class SelectPrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.hint = opts.hint || "- Use arrow-keys. Return to submit.";
      this.warn = opts.warn || "- This option is disabled";
      this.cursor = opts.initial || 0;
      this.choices = opts.choices.map((ch, idx) => {
        if (typeof ch === "string")
          ch = { title: ch, value: idx };
        return {
          title: ch && (ch.title || ch.value || ch),
          value: ch && (ch.value === undefined ? idx : ch.value),
          description: ch && ch.description,
          selected: ch && ch.selected,
          disabled: ch && ch.disabled
        };
      });
      this.optionsPerPage = opts.optionsPerPage || 10;
      this.value = (this.choices[this.cursor] || {}).value;
      this.clear = clear("", this.out.columns);
      this.render();
    }
    moveCursor(n) {
      this.cursor = n;
      this.value = this.choices[n].value;
      this.fire();
    }
    reset() {
      this.moveCursor(0);
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    submit() {
      if (!this.selection.disabled) {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      } else
        this.bell();
    }
    first() {
      this.moveCursor(0);
      this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1);
      this.render();
    }
    up() {
      if (this.cursor === 0) {
        this.moveCursor(this.choices.length - 1);
      } else {
        this.moveCursor(this.cursor - 1);
      }
      this.render();
    }
    down() {
      if (this.cursor === this.choices.length - 1) {
        this.moveCursor(0);
      } else {
        this.moveCursor(this.cursor + 1);
      }
      this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length);
      this.render();
    }
    _(c, key12) {
      if (c === " ")
        return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      let { startIndex, endIndex } = entriesToDisplay(this.cursor, this.choices.length, this.optionsPerPage);
      this.outputText = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(false),
        this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)
      ].join(" ");
      if (!this.done) {
        this.outputText += `
`;
        for (let i = startIndex;i < endIndex; i++) {
          let title, prefix, desc = "", v = this.choices[i];
          if (i === startIndex && startIndex > 0) {
            prefix = figures11.arrowUp;
          } else if (i === endIndex - 1 && endIndex < this.choices.length) {
            prefix = figures11.arrowDown;
          } else {
            prefix = " ";
          }
          if (v.disabled) {
            title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
            prefix = (this.cursor === i ? color.bold().gray(figures11.pointer) + " " : "  ") + prefix;
          } else {
            title = this.cursor === i ? color.cyan().underline(v.title) : v.title;
            prefix = (this.cursor === i ? color.cyan(figures11.pointer) + " " : "  ") + prefix;
            if (v.description && this.cursor === i) {
              desc = ` - ${v.description}`;
              if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
                desc = `
` + wrap(v.description, { margin: 3, width: this.out.columns });
              }
            }
          }
          this.outputText += `${prefix} ${title}${color.gray(desc)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  }
  module.exports = SelectPrompt;
});

// node_modules/prompts/lib/elements/toggle.js
var require_toggle2 = __commonJS((exports, module) => {
  var color = require_kleur();
  var Prompt = require_prompt2();
  var { style, clear } = require_util6();
  var { cursor, erase } = require_src();

  class TogglePrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.value = !!opts.initial;
      this.active = opts.active || "on";
      this.inactive = opts.inactive || "off";
      this.initialValue = this.value;
      this.render();
    }
    reset() {
      this.value = this.initialValue;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    submit() {
      this.done = true;
      this.aborted = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    deactivate() {
      if (this.value === false)
        return this.bell();
      this.value = false;
      this.render();
    }
    activate() {
      if (this.value === true)
        return this.bell();
      this.value = true;
      this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value;
      this.fire();
      this.render();
    }
    _(c, key12) {
      if (c === " ") {
        this.value = !this.value;
      } else if (c === "1") {
        this.value = true;
      } else if (c === "0") {
        this.value = false;
      } else
        return this.bell();
      this.render();
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      this.outputText = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(this.done),
        this.value ? this.inactive : color.cyan().underline(this.inactive),
        color.gray("/"),
        this.value ? color.cyan().underline(this.active) : this.active
      ].join(" ");
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  }
  module.exports = TogglePrompt;
});

// node_modules/prompts/lib/dateparts/datepart.js
var require_datepart2 = __commonJS((exports, module) => {
  class DatePart {
    constructor({ token, date, parts, locales }) {
      this.token = token;
      this.date = date || new Date;
      this.parts = parts || [this];
      this.locales = locales || {};
    }
    up() {
    }
    down() {
    }
    next() {
      const currentIdx = this.parts.indexOf(this);
      return this.parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
    }
    setTo(val) {
    }
    prev() {
      let parts = [].concat(this.parts).reverse();
      const currentIdx = parts.indexOf(this);
      return parts.find((part, idx) => idx > currentIdx && part instanceof DatePart);
    }
    toString() {
      return String(this.date);
    }
  }
  module.exports = DatePart;
});

// node_modules/prompts/lib/dateparts/meridiem.js
var require_meridiem2 = __commonJS((exports, module) => {
  var DatePart = require_datepart2();

  class Meridiem extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let meridiem = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
    }
  }
  module.exports = Meridiem;
});

// node_modules/prompts/lib/dateparts/day.js
var require_day2 = __commonJS((exports, module) => {
  var DatePart = require_datepart2();
  var pos = (n) => {
    n = n % 10;
    return n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th";
  };

  class Day extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(val) {
      this.date.setDate(parseInt(val.substr(-2)));
    }
    toString() {
      let date = this.date.getDate();
      let day = this.date.getDay();
      return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
    }
  }
  module.exports = Day;
});

// node_modules/prompts/lib/dateparts/hours.js
var require_hours2 = __commonJS((exports, module) => {
  var DatePart = require_datepart2();

  class Hours extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(val) {
      this.date.setHours(parseInt(val.substr(-2)));
    }
    toString() {
      let hours = this.date.getHours();
      if (/h/.test(this.token))
        hours = hours % 12 || 12;
      return this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
    }
  }
  module.exports = Hours;
});

// node_modules/prompts/lib/dateparts/milliseconds.js
var require_milliseconds2 = __commonJS((exports, module) => {
  var DatePart = require_datepart2();

  class Milliseconds extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(val) {
      this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  }
  module.exports = Milliseconds;
});

// node_modules/prompts/lib/dateparts/minutes.js
var require_minutes2 = __commonJS((exports, module) => {
  var DatePart = require_datepart2();

  class Minutes extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(val) {
      this.date.setMinutes(parseInt(val.substr(-2)));
    }
    toString() {
      let m = this.date.getMinutes();
      return this.token.length > 1 ? String(m).padStart(2, "0") : m;
    }
  }
  module.exports = Minutes;
});

// node_modules/prompts/lib/dateparts/month.js
var require_month2 = __commonJS((exports, module) => {
  var DatePart = require_datepart2();

  class Month extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(val) {
      val = parseInt(val.substr(-2)) - 1;
      this.date.setMonth(val < 0 ? 0 : val);
    }
    toString() {
      let month = this.date.getMonth();
      let tl = this.token.length;
      return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
    }
  }
  module.exports = Month;
});

// node_modules/prompts/lib/dateparts/seconds.js
var require_seconds2 = __commonJS((exports, module) => {
  var DatePart = require_datepart2();

  class Seconds extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(val) {
      this.date.setSeconds(parseInt(val.substr(-2)));
    }
    toString() {
      let s = this.date.getSeconds();
      return this.token.length > 1 ? String(s).padStart(2, "0") : s;
    }
  }
  module.exports = Seconds;
});

// node_modules/prompts/lib/dateparts/year.js
var require_year2 = __commonJS((exports, module) => {
  var DatePart = require_datepart2();

  class Year extends DatePart {
    constructor(opts = {}) {
      super(opts);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(val) {
      this.date.setFullYear(val.substr(-4));
    }
    toString() {
      let year = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? year.substr(-2) : year;
    }
  }
  module.exports = Year;
});

// node_modules/prompts/lib/dateparts/index.js
var require_dateparts2 = __commonJS((exports, module) => {
  module.exports = {
    DatePart: require_datepart2(),
    Meridiem: require_meridiem2(),
    Day: require_day2(),
    Hours: require_hours2(),
    Milliseconds: require_milliseconds2(),
    Minutes: require_minutes2(),
    Month: require_month2(),
    Seconds: require_seconds2(),
    Year: require_year2()
  };
});

// node_modules/prompts/lib/elements/date.js
var require_date2 = __commonJS((exports, module) => {
  var color = require_kleur();
  var Prompt = require_prompt2();
  var { style, clear, figures: figures11 } = require_util6();
  var { erase, cursor } = require_src();
  var { DatePart, Meridiem, Day, Hours, Milliseconds, Minutes, Month, Seconds, Year } = require_dateparts2();
  var regex2 = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g;
  var regexGroups = {
    1: ({ token }) => token.replace(/\\(.)/g, "$1"),
    2: (opts) => new Day(opts),
    3: (opts) => new Month(opts),
    4: (opts) => new Year(opts),
    5: (opts) => new Meridiem(opts),
    6: (opts) => new Hours(opts),
    7: (opts) => new Minutes(opts),
    8: (opts) => new Seconds(opts),
    9: (opts) => new Milliseconds(opts)
  };
  var dfltLocales = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  };

  class DatePrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.cursor = 0;
      this.typed = "";
      this.locales = Object.assign(dfltLocales, opts.locales);
      this._date = opts.initial || new Date;
      this.errorMsg = opts.error || "Please Enter A Valid Value";
      this.validator = opts.validate || (() => true);
      this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss";
      this.clear = clear("", this.out.columns);
      this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(date) {
      if (date)
        this._date.setTime(date.getTime());
    }
    set mask(mask) {
      let result;
      this.parts = [];
      while (result = regex2.exec(mask)) {
        let match = result.shift();
        let idx = result.findIndex((gr) => gr != null);
        this.parts.push(idx in regexGroups ? regexGroups[idx]({ token: result[idx] || match, date: this.date, parts: this.parts, locales: this.locales }) : result[idx] || match);
      }
      let parts = this.parts.reduce((arr, i) => {
        if (typeof i === "string" && typeof arr[arr.length - 1] === "string")
          arr[arr.length - 1] += i;
        else
          arr.push(i);
        return arr;
      }, []);
      this.parts.splice(0);
      this.parts.push(...parts);
      this.reset();
    }
    moveCursor(n) {
      this.typed = "";
      this.cursor = n;
      this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart));
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.error = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    async validate() {
      let valid = await this.validator(this.value);
      if (typeof valid === "string") {
        this.errorMsg = valid;
        valid = false;
      }
      this.error = !valid;
    }
    async submit() {
      await this.validate();
      if (this.error) {
        this.color = "red";
        this.fire();
        this.render();
        return;
      }
      this.done = true;
      this.aborted = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    up() {
      this.typed = "";
      this.parts[this.cursor].up();
      this.render();
    }
    down() {
      this.typed = "";
      this.parts[this.cursor].down();
      this.render();
    }
    left() {
      let prev = this.parts[this.cursor].prev();
      if (prev == null)
        return this.bell();
      this.moveCursor(this.parts.indexOf(prev));
      this.render();
    }
    right() {
      let next = this.parts[this.cursor].next();
      if (next == null)
        return this.bell();
      this.moveCursor(this.parts.indexOf(next));
      this.render();
    }
    next() {
      let next = this.parts[this.cursor].next();
      this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart));
      this.render();
    }
    _(c) {
      if (/\d/.test(c)) {
        this.typed += c;
        this.parts[this.cursor].setTo(this.typed);
        this.render();
      }
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      this.outputText = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(false),
        this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")
      ].join(" ");
      if (this.error) {
        this.outputText += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? ` ` : figures11.pointerSmall} ${color.red().italic(l)}`, ``);
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  }
  module.exports = DatePrompt;
});

// node_modules/prompts/lib/elements/number.js
var require_number2 = __commonJS((exports, module) => {
  var color = require_kleur();
  var Prompt = require_prompt2();
  var { cursor, erase } = require_src();
  var { style, figures: figures11, clear, lines: lines4 } = require_util6();
  var isNumber = /[0-9]/;
  var isDef = (any) => any !== undefined;
  var round = (number2, precision) => {
    let factor = Math.pow(10, precision);
    return Math.round(number2 * factor) / factor;
  };

  class NumberPrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.transform = style.render(opts.style);
      this.msg = opts.message;
      this.initial = isDef(opts.initial) ? opts.initial : "";
      this.float = !!opts.float;
      this.round = opts.round || 2;
      this.inc = opts.increment || 1;
      this.min = isDef(opts.min) ? opts.min : -Infinity;
      this.max = isDef(opts.max) ? opts.max : Infinity;
      this.errorMsg = opts.error || `Please Enter A Valid Value`;
      this.validator = opts.validate || (() => true);
      this.color = `cyan`;
      this.value = ``;
      this.typed = ``;
      this.lastHit = 0;
      this.render();
    }
    set value(v) {
      if (!v && v !== 0) {
        this.placeholder = true;
        this.rendered = color.gray(this.transform.render(`${this.initial}`));
        this._value = ``;
      } else {
        this.placeholder = false;
        this.rendered = this.transform.render(`${round(v, this.round)}`);
        this._value = round(v, this.round);
      }
      this.fire();
    }
    get value() {
      return this._value;
    }
    parse(x) {
      return this.float ? parseFloat(x) : parseInt(x);
    }
    valid(c) {
      return c === `-` || c === `.` && this.float || isNumber.test(c);
    }
    reset() {
      this.typed = ``;
      this.value = ``;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let x = this.value;
      this.value = x !== `` ? x : this.initial;
      this.done = this.aborted = true;
      this.error = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    async validate() {
      let valid = await this.validator(this.value);
      if (typeof valid === `string`) {
        this.errorMsg = valid;
        valid = false;
      }
      this.error = !valid;
    }
    async submit() {
      await this.validate();
      if (this.error) {
        this.color = `red`;
        this.fire();
        this.render();
        return;
      }
      let x = this.value;
      this.value = x !== `` ? x : this.initial;
      this.done = true;
      this.aborted = false;
      this.error = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    up() {
      this.typed = ``;
      if (this.value === "") {
        this.value = this.min - this.inc;
      }
      if (this.value >= this.max)
        return this.bell();
      this.value += this.inc;
      this.color = `cyan`;
      this.fire();
      this.render();
    }
    down() {
      this.typed = ``;
      if (this.value === "") {
        this.value = this.min + this.inc;
      }
      if (this.value <= this.min)
        return this.bell();
      this.value -= this.inc;
      this.color = `cyan`;
      this.fire();
      this.render();
    }
    delete() {
      let val = this.value.toString();
      if (val.length === 0)
        return this.bell();
      this.value = this.parse(val = val.slice(0, -1)) || ``;
      if (this.value !== "" && this.value < this.min) {
        this.value = this.min;
      }
      this.color = `cyan`;
      this.fire();
      this.render();
    }
    next() {
      this.value = this.initial;
      this.fire();
      this.render();
    }
    _(c, key12) {
      if (!this.valid(c))
        return this.bell();
      const now = Date.now();
      if (now - this.lastHit > 1000)
        this.typed = ``;
      this.typed += c;
      this.lastHit = now;
      this.color = `cyan`;
      if (c === `.`)
        return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max);
      if (this.value > this.max)
        this.value = this.max;
      if (this.value < this.min)
        this.value = this.min;
      this.fire();
      this.render();
    }
    render() {
      if (this.closed)
        return;
      if (!this.firstRender) {
        if (this.outputError)
          this.out.write(cursor.down(lines4(this.outputError, this.out.columns) - 1) + clear(this.outputError, this.out.columns));
        this.out.write(clear(this.outputText, this.out.columns));
      }
      super.render();
      this.outputError = "";
      this.outputText = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(this.done),
        !this.done || !this.done && !this.placeholder ? color[this.color]().underline(this.rendered) : this.rendered
      ].join(` `);
      if (this.error) {
        this.outputError += this.errorMsg.split(`
`).reduce((a, l, i) => a + `
${i ? ` ` : figures11.pointerSmall} ${color.red().italic(l)}`, ``);
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText + cursor.save + this.outputError + cursor.restore);
    }
  }
  module.exports = NumberPrompt;
});

// node_modules/prompts/lib/elements/multiselect.js
var require_multiselect2 = __commonJS((exports, module) => {
  var color = require_kleur();
  var { cursor } = require_src();
  var Prompt = require_prompt2();
  var { clear, figures: figures11, style, wrap, entriesToDisplay } = require_util6();

  class MultiselectPrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.cursor = opts.cursor || 0;
      this.scrollIndex = opts.cursor || 0;
      this.hint = opts.hint || "";
      this.warn = opts.warn || "- This option is disabled -";
      this.minSelected = opts.min;
      this.showMinError = false;
      this.maxChoices = opts.max;
      this.instructions = opts.instructions;
      this.optionsPerPage = opts.optionsPerPage || 10;
      this.value = opts.choices.map((ch, idx) => {
        if (typeof ch === "string")
          ch = { title: ch, value: idx };
        return {
          title: ch && (ch.title || ch.value || ch),
          description: ch && ch.description,
          value: ch && (ch.value === undefined ? idx : ch.value),
          selected: ch && ch.selected,
          disabled: ch && ch.disabled
        };
      });
      this.clear = clear("", this.out.columns);
      if (!opts.overrideRender) {
        this.render();
      }
    }
    reset() {
      this.value.map((v) => !v.selected);
      this.cursor = 0;
      this.fire();
      this.render();
    }
    selected() {
      return this.value.filter((v) => v.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    submit() {
      const selected = this.value.filter((e) => e.selected);
      if (this.minSelected && selected.length < this.minSelected) {
        this.showMinError = true;
        this.render();
      } else {
        this.done = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      }
    }
    first() {
      this.cursor = 0;
      this.render();
    }
    last() {
      this.cursor = this.value.length - 1;
      this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length;
      this.render();
    }
    up() {
      if (this.cursor === 0) {
        this.cursor = this.value.length - 1;
      } else {
        this.cursor--;
      }
      this.render();
    }
    down() {
      if (this.cursor === this.value.length - 1) {
        this.cursor = 0;
      } else {
        this.cursor++;
      }
      this.render();
    }
    left() {
      this.value[this.cursor].selected = false;
      this.render();
    }
    right() {
      if (this.value.filter((e) => e.selected).length >= this.maxChoices)
        return this.bell();
      this.value[this.cursor].selected = true;
      this.render();
    }
    handleSpaceToggle() {
      const v = this.value[this.cursor];
      if (v.selected) {
        v.selected = false;
        this.render();
      } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
        return this.bell();
      } else {
        v.selected = true;
        this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== undefined || this.value[this.cursor].disabled) {
        return this.bell();
      }
      const newSelected = !this.value[this.cursor].selected;
      this.value.filter((v) => !v.disabled).forEach((v) => v.selected = newSelected);
      this.render();
    }
    _(c, key12) {
      if (c === " ") {
        this.handleSpaceToggle();
      } else if (c === "a") {
        this.toggleAll();
      } else {
        return this.bell();
      }
    }
    renderInstructions() {
      if (this.instructions === undefined || this.instructions) {
        if (typeof this.instructions === "string") {
          return this.instructions;
        }
        return `
Instructions:
` + `    ${figures11.arrowUp}/${figures11.arrowDown}: Highlight option
` + `    ${figures11.arrowLeft}/${figures11.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === undefined ? `    a: Toggle all
` : "") + `    enter/return: Complete answer`;
      }
      return "";
    }
    renderOption(cursor2, v, i, arrowIndicator) {
      const prefix = (v.selected ? color.green(figures11.radioOn) : figures11.radioOff) + " " + arrowIndicator + " ";
      let title, desc;
      if (v.disabled) {
        title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
      } else {
        title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
        if (cursor2 === i && v.description) {
          desc = ` - ${v.description}`;
          if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
            desc = `
` + wrap(v.description, { margin: prefix.length, width: this.out.columns });
          }
        }
      }
      return prefix + title + color.gray(desc || "");
    }
    paginateOptions(options) {
      if (options.length === 0) {
        return color.red("No matches for this query.");
      }
      let { startIndex, endIndex } = entriesToDisplay(this.cursor, options.length, this.optionsPerPage);
      let prefix, styledOptions = [];
      for (let i = startIndex;i < endIndex; i++) {
        if (i === startIndex && startIndex > 0) {
          prefix = figures11.arrowUp;
        } else if (i === endIndex - 1 && endIndex < options.length) {
          prefix = figures11.arrowDown;
        } else {
          prefix = " ";
        }
        styledOptions.push(this.renderOption(this.cursor, options[i], i, prefix));
      }
      return `
` + styledOptions.join(`
`);
    }
    renderOptions(options) {
      if (!this.done) {
        return this.paginateOptions(options);
      }
      return "";
    }
    renderDoneOrInstructions() {
      if (this.done) {
        return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
      }
      const output = [color.gray(this.hint), this.renderInstructions()];
      if (this.value[this.cursor].disabled) {
        output.push(color.yellow(this.warn));
      }
      return output.join(" ");
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      super.render();
      let prompt2 = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(false),
        this.renderDoneOrInstructions()
      ].join(" ");
      if (this.showMinError) {
        prompt2 += color.red(`You must select a minimum of ${this.minSelected} choices.`);
        this.showMinError = false;
      }
      prompt2 += this.renderOptions(this.value);
      this.out.write(this.clear + prompt2);
      this.clear = clear(prompt2, this.out.columns);
    }
  }
  module.exports = MultiselectPrompt;
});

// node_modules/prompts/lib/elements/autocomplete.js
var require_autocomplete2 = __commonJS((exports, module) => {
  var color = require_kleur();
  var Prompt = require_prompt2();
  var { erase, cursor } = require_src();
  var { style, clear, figures: figures11, wrap, entriesToDisplay } = require_util6();
  var getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]);
  var getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]);
  var getIndex = (arr, valOrTitle) => {
    const index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
    return index > -1 ? index : undefined;
  };

  class AutocompletePrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.suggest = opts.suggest;
      this.choices = opts.choices;
      this.initial = typeof opts.initial === "number" ? opts.initial : getIndex(opts.choices, opts.initial);
      this.select = this.initial || opts.cursor || 0;
      this.i18n = { noMatches: opts.noMatches || "no matches found" };
      this.fallback = opts.fallback || this.initial;
      this.clearFirst = opts.clearFirst || false;
      this.suggestions = [];
      this.input = "";
      this.limit = opts.limit || 10;
      this.cursor = 0;
      this.transform = style.render(opts.style);
      this.scale = this.transform.scale;
      this.render = this.render.bind(this);
      this.complete = this.complete.bind(this);
      this.clear = clear("", this.out.columns);
      this.complete(this.render);
      this.render();
    }
    set fallback(fb) {
      this._fb = Number.isSafeInteger(parseInt(fb)) ? parseInt(fb) : fb;
    }
    get fallback() {
      let choice;
      if (typeof this._fb === "number")
        choice = this.choices[this._fb];
      else if (typeof this._fb === "string")
        choice = { title: this._fb };
      return choice || this._fb || { title: this.i18n.noMatches };
    }
    moveSelect(i) {
      this.select = i;
      if (this.suggestions.length > 0)
        this.value = getVal(this.suggestions, i);
      else
        this.value = this.fallback.value;
      this.fire();
    }
    async complete(cb) {
      const p = this.completing = this.suggest(this.input, this.choices);
      const suggestions = await p;
      if (this.completing !== p)
        return;
      this.suggestions = suggestions.map((s, i, arr) => ({ title: getTitle(arr, i), value: getVal(arr, i), description: s.description }));
      this.completing = false;
      const l = Math.max(suggestions.length - 1, 0);
      this.moveSelect(Math.min(l, this.select));
      cb && cb();
    }
    reset() {
      this.input = "";
      this.complete(() => {
        this.moveSelect(this.initial !== undefined ? this.initial : 0);
        this.render();
      });
      this.render();
    }
    exit() {
      if (this.clearFirst && this.input.length > 0) {
        this.reset();
      } else {
        this.done = this.exited = true;
        this.aborted = false;
        this.fire();
        this.render();
        this.out.write(`
`);
        this.close();
      }
    }
    abort() {
      this.done = this.aborted = true;
      this.exited = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    submit() {
      this.done = true;
      this.aborted = this.exited = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    _(c, key12) {
      let s1 = this.input.slice(0, this.cursor);
      let s2 = this.input.slice(this.cursor);
      this.input = `${s1}${c}${s2}`;
      this.cursor = s1.length + 1;
      this.complete(this.render);
      this.render();
    }
    delete() {
      if (this.cursor === 0)
        return this.bell();
      let s1 = this.input.slice(0, this.cursor - 1);
      let s2 = this.input.slice(this.cursor);
      this.input = `${s1}${s2}`;
      this.complete(this.render);
      this.cursor = this.cursor - 1;
      this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length)
        return this.bell();
      let s1 = this.input.slice(0, this.cursor);
      let s2 = this.input.slice(this.cursor + 1);
      this.input = `${s1}${s2}`;
      this.complete(this.render);
      this.render();
    }
    first() {
      this.moveSelect(0);
      this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1);
      this.render();
    }
    up() {
      if (this.select === 0) {
        this.moveSelect(this.suggestions.length - 1);
      } else {
        this.moveSelect(this.select - 1);
      }
      this.render();
    }
    down() {
      if (this.select === this.suggestions.length - 1) {
        this.moveSelect(0);
      } else {
        this.moveSelect(this.select + 1);
      }
      this.render();
    }
    next() {
      if (this.select === this.suggestions.length - 1) {
        this.moveSelect(0);
      } else
        this.moveSelect(this.select + 1);
      this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1));
      this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0));
      this.render();
    }
    left() {
      if (this.cursor <= 0)
        return this.bell();
      this.cursor = this.cursor - 1;
      this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length)
        return this.bell();
      this.cursor = this.cursor + 1;
      this.render();
    }
    renderOption(v, hovered, isStart, isEnd) {
      let desc;
      let prefix = isStart ? figures11.arrowUp : isEnd ? figures11.arrowDown : " ";
      let title = hovered ? color.cyan().underline(v.title) : v.title;
      prefix = (hovered ? color.cyan(figures11.pointer) + " " : "  ") + prefix;
      if (v.description) {
        desc = ` - ${v.description}`;
        if (prefix.length + title.length + desc.length >= this.out.columns || v.description.split(/\r?\n/).length > 1) {
          desc = `
` + wrap(v.description, { margin: 3, width: this.out.columns });
        }
      }
      return prefix + " " + title + color.gray(desc || "");
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      let { startIndex, endIndex } = entriesToDisplay(this.select, this.choices.length, this.limit);
      this.outputText = [
        style.symbol(this.done, this.aborted, this.exited),
        color.bold(this.msg),
        style.delimiter(this.completing),
        this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)
      ].join(" ");
      if (!this.done) {
        const suggestions = this.suggestions.slice(startIndex, endIndex).map((item, i) => this.renderOption(item, this.select === i + startIndex, i === 0 && startIndex > 0, i + startIndex === endIndex - 1 && endIndex < this.choices.length)).join(`
`);
        this.outputText += `
` + (suggestions || color.gray(this.fallback.title));
      }
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  }
  module.exports = AutocompletePrompt;
});

// node_modules/prompts/lib/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect2 = __commonJS((exports, module) => {
  var color = require_kleur();
  var { cursor } = require_src();
  var MultiselectPrompt = require_multiselect2();
  var { clear, style, figures: figures11 } = require_util6();

  class AutocompleteMultiselectPrompt extends MultiselectPrompt {
    constructor(opts = {}) {
      opts.overrideRender = true;
      super(opts);
      this.inputValue = "";
      this.clear = clear("", this.out.columns);
      this.filteredOptions = this.value;
      this.render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1;
      this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length;
      this.render();
    }
    up() {
      if (this.cursor === 0) {
        this.cursor = this.filteredOptions.length - 1;
      } else {
        this.cursor--;
      }
      this.render();
    }
    down() {
      if (this.cursor === this.filteredOptions.length - 1) {
        this.cursor = 0;
      } else {
        this.cursor++;
      }
      this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = false;
      this.render();
    }
    right() {
      if (this.value.filter((e) => e.selected).length >= this.maxChoices)
        return this.bell();
      this.filteredOptions[this.cursor].selected = true;
      this.render();
    }
    delete() {
      if (this.inputValue.length) {
        this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1);
        this.updateFilteredOptions();
      }
    }
    updateFilteredOptions() {
      const currentHighlight = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((v) => {
        if (this.inputValue) {
          if (typeof v.title === "string") {
            if (v.title.toLowerCase().includes(this.inputValue.toLowerCase())) {
              return true;
            }
          }
          if (typeof v.value === "string") {
            if (v.value.toLowerCase().includes(this.inputValue.toLowerCase())) {
              return true;
            }
          }
          return false;
        }
        return true;
      });
      const newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
      this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex;
      this.render();
    }
    handleSpaceToggle() {
      const v = this.filteredOptions[this.cursor];
      if (v.selected) {
        v.selected = false;
        this.render();
      } else if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices) {
        return this.bell();
      } else {
        v.selected = true;
        this.render();
      }
    }
    handleInputChange(c) {
      this.inputValue = this.inputValue + c;
      this.updateFilteredOptions();
    }
    _(c, key12) {
      if (c === " ") {
        this.handleSpaceToggle();
      } else {
        this.handleInputChange(c);
      }
    }
    renderInstructions() {
      if (this.instructions === undefined || this.instructions) {
        if (typeof this.instructions === "string") {
          return this.instructions;
        }
        return `
Instructions:
    ${figures11.arrowUp}/${figures11.arrowDown}: Highlight option
    ${figures11.arrowLeft}/${figures11.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
`;
      }
      return "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
    }
    renderOption(cursor2, v, i) {
      let title;
      if (v.disabled)
        title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title);
      else
        title = cursor2 === i ? color.cyan().underline(v.title) : v.title;
      return (v.selected ? color.green(figures11.radioOn) : figures11.radioOff) + "  " + title;
    }
    renderDoneOrInstructions() {
      if (this.done) {
        return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
      }
      const output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      if (this.filteredOptions.length && this.filteredOptions[this.cursor].disabled) {
        output.push(color.yellow(this.warn));
      }
      return output.join(" ");
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      super.render();
      let prompt2 = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(false),
        this.renderDoneOrInstructions()
      ].join(" ");
      if (this.showMinError) {
        prompt2 += color.red(`You must select a minimum of ${this.minSelected} choices.`);
        this.showMinError = false;
      }
      prompt2 += this.renderOptions(this.filteredOptions);
      this.out.write(this.clear + prompt2);
      this.clear = clear(prompt2, this.out.columns);
    }
  }
  module.exports = AutocompleteMultiselectPrompt;
});

// node_modules/prompts/lib/elements/confirm.js
var require_confirm2 = __commonJS((exports, module) => {
  var color = require_kleur();
  var Prompt = require_prompt2();
  var { style, clear } = require_util6();
  var { erase, cursor } = require_src();

  class ConfirmPrompt extends Prompt {
    constructor(opts = {}) {
      super(opts);
      this.msg = opts.message;
      this.value = opts.initial;
      this.initialValue = !!opts.initial;
      this.yesMsg = opts.yes || "yes";
      this.yesOption = opts.yesOption || "(Y/n)";
      this.noMsg = opts.no || "no";
      this.noOption = opts.noOption || "(y/N)";
      this.render();
    }
    reset() {
      this.value = this.initialValue;
      this.fire();
      this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = true;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    submit() {
      this.value = this.value || false;
      this.done = true;
      this.aborted = false;
      this.fire();
      this.render();
      this.out.write(`
`);
      this.close();
    }
    _(c, key12) {
      if (c.toLowerCase() === "y") {
        this.value = true;
        return this.submit();
      }
      if (c.toLowerCase() === "n") {
        this.value = false;
        return this.submit();
      }
      return this.bell();
    }
    render() {
      if (this.closed)
        return;
      if (this.firstRender)
        this.out.write(cursor.hide);
      else
        this.out.write(clear(this.outputText, this.out.columns));
      super.render();
      this.outputText = [
        style.symbol(this.done, this.aborted),
        color.bold(this.msg),
        style.delimiter(this.done),
        this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)
      ].join(" ");
      this.out.write(erase.line + cursor.to(0) + this.outputText);
    }
  }
  module.exports = ConfirmPrompt;
});

// node_modules/prompts/lib/elements/index.js
var require_elements2 = __commonJS((exports, module) => {
  module.exports = {
    TextPrompt: require_text2(),
    SelectPrompt: require_select2(),
    TogglePrompt: require_toggle2(),
    DatePrompt: require_date2(),
    NumberPrompt: require_number2(),
    MultiselectPrompt: require_multiselect2(),
    AutocompletePrompt: require_autocomplete2(),
    AutocompleteMultiselectPrompt: require_autocompleteMultiselect2(),
    ConfirmPrompt: require_confirm2()
  };
});

// node_modules/prompts/lib/prompts.js
var require_prompts2 = __commonJS((exports) => {
  var $2 = exports;
  var el = require_elements2();
  var noop = (v) => v;
  function toPrompt(type, args, opts = {}) {
    return new Promise((res, rej) => {
      const p = new el[type](args);
      const onAbort = opts.onAbort || noop;
      const onSubmit = opts.onSubmit || noop;
      const onExit2 = opts.onExit || noop;
      p.on("state", args.onState || noop);
      p.on("submit", (x) => res(onSubmit(x)));
      p.on("exit", (x) => res(onExit2(x)));
      p.on("abort", (x) => rej(onAbort(x)));
    });
  }
  $2.text = (args) => toPrompt("TextPrompt", args);
  $2.password = (args) => {
    args.style = "password";
    return $2.text(args);
  };
  $2.invisible = (args) => {
    args.style = "invisible";
    return $2.text(args);
  };
  $2.number = (args) => toPrompt("NumberPrompt", args);
  $2.date = (args) => toPrompt("DatePrompt", args);
  $2.confirm = (args) => toPrompt("ConfirmPrompt", args);
  $2.list = (args) => {
    const sep = args.separator || ",";
    return toPrompt("TextPrompt", args, {
      onSubmit: (str) => str.split(sep).map((s) => s.trim())
    });
  };
  $2.toggle = (args) => toPrompt("TogglePrompt", args);
  $2.select = (args) => toPrompt("SelectPrompt", args);
  $2.multiselect = (args) => {
    args.choices = [].concat(args.choices || []);
    const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
    return toPrompt("MultiselectPrompt", args, {
      onAbort: toSelected,
      onSubmit: toSelected
    });
  };
  $2.autocompleteMultiselect = (args) => {
    args.choices = [].concat(args.choices || []);
    const toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
    return toPrompt("AutocompleteMultiselectPrompt", args, {
      onAbort: toSelected,
      onSubmit: toSelected
    });
  };
  var byTitle = (input, choices) => Promise.resolve(choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase()));
  $2.autocomplete = (args) => {
    args.suggest = args.suggest || byTitle;
    args.choices = [].concat(args.choices || []);
    return toPrompt("AutocompletePrompt", args);
  };
});

// node_modules/prompts/lib/index.js
var require_lib5 = __commonJS((exports, module) => {
  var prompts = require_prompts2();
  var passOn = ["suggest", "format", "onState", "validate", "onRender", "type"];
  var noop = () => {
  };
  async function prompt2(questions = [], { onSubmit = noop, onCancel = noop } = {}) {
    const answers = {};
    const override2 = prompt2._override || {};
    questions = [].concat(questions);
    let answer, question, quit, name, type, lastPrompt;
    const getFormattedAnswer = async (question2, answer2, skipValidation = false) => {
      if (!skipValidation && question2.validate && question2.validate(answer2) !== true) {
        return;
      }
      return question2.format ? await question2.format(answer2, answers) : answer2;
    };
    for (question of questions) {
      ({ name, type } = question);
      if (typeof type === "function") {
        type = await type(answer, { ...answers }, question);
        question["type"] = type;
      }
      if (!type)
        continue;
      for (let key12 in question) {
        if (passOn.includes(key12))
          continue;
        let value = question[key12];
        question[key12] = typeof value === "function" ? await value(answer, { ...answers }, lastPrompt) : value;
      }
      lastPrompt = question;
      if (typeof question.message !== "string") {
        throw new Error("prompt message is required");
      }
      ({ name, type } = question);
      if (prompts[type] === undefined) {
        throw new Error(`prompt type (${type}) is not defined`);
      }
      if (override2[question.name] !== undefined) {
        answer = await getFormattedAnswer(question, override2[question.name]);
        if (answer !== undefined) {
          answers[name] = answer;
          continue;
        }
      }
      try {
        answer = prompt2._injected ? getInjectedAnswer(prompt2._injected, question.initial) : await prompts[type](question);
        answers[name] = answer = await getFormattedAnswer(question, answer, true);
        quit = await onSubmit(question, answer, answers);
      } catch (err) {
        quit = !await onCancel(question, answers);
      }
      if (quit)
        return answers;
    }
    return answers;
  }
  function getInjectedAnswer(injected, deafultValue) {
    const answer = injected.shift();
    if (answer instanceof Error) {
      throw answer;
    }
    return answer === undefined ? deafultValue : answer;
  }
  function inject(answers) {
    prompt2._injected = (prompt2._injected || []).concat(answers);
  }
  function override(answers) {
    prompt2._override = Object.assign({}, answers);
  }
  module.exports = Object.assign(prompt2, { prompt: prompt2, prompts, inject, override });
});

// node_modules/prompts/index.js
var require_prompts3 = __commonJS((exports, module) => {
  function isNodeLT(tar) {
    tar = (Array.isArray(tar) ? tar : tar.split(".")).map(Number);
    let i = 0, src = process.versions.node.split(".").map(Number);
    for (;i < tar.length; i++) {
      if (src[i] > tar[i])
        return false;
      if (tar[i] > src[i])
        return true;
    }
    return false;
  }
  module.exports = isNodeLT("8.6.0") ? require_dist2() : require_lib5();
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs2 = __commonJS((exports, module) => {
  var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key12, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key12);
    return typeof customMerge === "function" ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_3) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key12) {
    return propertyIsOnObject(target, key12) && !(Object.hasOwnProperty.call(target, key12) && Object.propertyIsEnumerable.call(target, key12));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key12) {
        destination[key12] = cloneUnlessOtherwiseSpecified(target[key12], options);
      });
    }
    getKeys(source).forEach(function(key12) {
      if (propertyIsUnsafe(target, key12)) {
        return;
      }
      if (propertyIsOnObject(target, key12) && options.isMergeableObject(source[key12])) {
        destination[key12] = getMergeFunction(key12, options)(target[key12], source[key12], options);
      } else {
        destination[key12] = cloneUnlessOtherwiseSpecified(source[key12], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error("first argument should be an array");
    }
    return array.reduce(function(prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  module.exports = deepmerge_1;
});

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports, module) => {
  module.exports = isexe;
  isexe.sync = sync;
  var fs6 = __require("fs");
  function checkPathExt(path5, options) {
    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0;i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path5.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path5, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path5, options);
  }
  function isexe(path5, options, cb) {
    fs6.stat(path5, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path5, options));
    });
  }
  function sync(path5, options) {
    return checkStat(fs6.statSync(path5), path5, options);
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports, module) => {
  module.exports = isexe;
  isexe.sync = sync;
  var fs6 = __require("fs");
  function isexe(path5, options, cb) {
    fs6.stat(path5, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }
  function sync(path5, options) {
    return checkStat(fs6.statSync(path5), options);
  }
  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }
  function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports, module) => {
  var fs6 = __require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows();
  } else {
    core = require_mode();
  }
  module.exports = isexe;
  isexe.sync = sync;
  function isexe(path5, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path5, options || {}, function(er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }
    core(path5, options || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync(path5, options) {
    try {
      return core.sync(path5, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS((exports, module) => {
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path5 = __require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path5.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0;i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path5.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0;j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is = isexe.sync(cur, { pathExt: pathExtExe });
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module.exports = which;
  which.sync = whichSync;
});

// node_modules/path-key/index.js
var require_path_key = __commonJS((exports, module) => {
  var pathKey = (options = {}) => {
    const environment = options.env || process.env;
    const platform2 = options.platform || process.platform;
    if (platform2 !== "win32") {
      return "PATH";
    }
    return Object.keys(environment).reverse().find((key12) => key12.toUpperCase() === "PATH") || "Path";
  };
  module.exports = pathKey;
  module.exports.default = pathKey;
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS((exports, module) => {
  var path5 = __require("path");
  var which = require_which();
  var getPathKey = require_path_key();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const env2 = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
    if (shouldSwitchCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {
      }
    }
    let resolved;
    try {
      resolved = which.sync(parsed.command, {
        path: env2[getPathKey({ env: env2 })],
        pathExt: withoutPathExt ? path5.delimiter : undefined
      });
    } catch (e) {
    } finally {
      if (shouldSwitchCwd) {
        process.chdir(cwd);
      }
    }
    if (resolved) {
      resolved = path5.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  module.exports = resolveCommand;
});

// node_modules/cross-spawn/lib/util/escape.js
var require_escape2 = __commonJS((exports, module) => {
  var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg) {
    arg = arg.replace(metaCharsRegExp, "^$1");
    return arg;
  }
  function escapeArgument(arg, doubleEscapeMetaChars) {
    arg = `${arg}`;
    arg = arg.replace(/(?=(\\+?)?)\1"/g, "$1$1\\\"");
    arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
    arg = `"${arg}"`;
    arg = arg.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg = arg.replace(metaCharsRegExp, "^$1");
    }
    return arg;
  }
  exports.command = escapeCommand;
  exports.argument = escapeArgument;
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS((exports, module) => {
  module.exports = /^#!(.*)/;
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS((exports, module) => {
  var shebangRegex = require_shebang_regex();
  module.exports = (string2 = "") => {
    const match = string2.match(shebangRegex);
    if (!match) {
      return null;
    }
    const [path5, argument] = match[0].replace(/#! ?/, "").split(" ");
    const binary = path5.split("/").pop();
    if (binary === "env") {
      return argument;
    }
    return argument ? `${binary} ${argument}` : binary;
  };
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS((exports, module) => {
  var fs6 = __require("fs");
  var shebangCommand = require_shebang_command();
  function readShebang(command2) {
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
      fd = fs6.openSync(command2, "r");
      fs6.readSync(fd, buffer, 0, size, 0);
      fs6.closeSync(fd);
    } catch (e) {
    }
    return shebangCommand(buffer.toString());
  }
  module.exports = readShebang;
});

// node_modules/cross-spawn/lib/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var path5 = __require("path");
  var resolveCommand = require_resolveCommand();
  var escape = require_escape2();
  var readShebang = require_readShebang();
  var isWin = process.platform === "win32";
  var isExecutableRegExp = /\.(?:com|exe)$/i;
  var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path5.normalize(parsed.command);
      parsed.command = escape.command(parsed.command);
      parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parse(command2, args, options) {
    if (args && !Array.isArray(args)) {
      options = args;
      args = null;
    }
    args = args ? args.slice(0) : [];
    options = Object.assign({}, options);
    const parsed = {
      command: command2,
      args,
      options,
      file: undefined,
      original: {
        command: command2,
        args
      }
    };
    return options.shell ? parsed : parseNonShell(parsed);
  }
  module.exports = parse;
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS((exports, module) => {
  var isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed);
        if (err) {
          return originalEmit.call(cp, "error", err);
        }
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS((exports, module) => {
  var cp = __require("child_process");
  var parse = require_parse2();
  var enoent = require_enoent();
  function spawn(command2, args, options) {
    const parsed = parse(command2, args, options);
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync(command2, args, options) {
    const parsed = parse(command2, args, options);
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  module.exports = spawn;
  module.exports.spawn = spawn;
  module.exports.sync = spawnSync;
  module.exports._parse = parse;
  module.exports._enoent = enoent;
});

// node_modules/@drizzle-team/brocli/index.js
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
var require_clone = __commonJS2({
  "node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js"(exports, module) {
    var clone2 = function() {
      function _instanceof(obj, type) {
        return type != null && obj instanceof type;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_2) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_2) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_2) {
        nativePromise = function() {
        };
      }
      function clone3(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap;
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet;
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve, reject) {
              parent2.then(function(value) {
                resolve(_clone(value, depth2 - 1));
              }, function(err) {
                reject(_clone(err, depth2 - 1));
              });
            });
          } else if (clone3.__isArray(parent2)) {
            child = [];
          } else if (clone3.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex)
              child.lastIndex = parent2.lastIndex;
          } else if (clone3.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent2);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value) {
              var entryChild = _clone(value, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i = 0;i < symbols.length; i++) {
              var symbol = symbols[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i = 0;i < allPropertyNames.length; i++) {
              var propertyName = allPropertyNames[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone3.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c = function() {
        };
        c.prototype = parent;
        return new c;
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone3.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      clone3.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      clone3.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      clone3.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global)
          flags += "g";
        if (re.ignoreCase)
          flags += "i";
        if (re.multiline)
          flags += "m";
        return flags;
      }
      clone3.__getRegExpFlags = __getRegExpFlags;
      return clone3;
    }();
    if (typeof module === "object" && module.exports) {
      module.exports = clone2;
    }
  }
});
var require_quote = __commonJS2({
  "node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/quote.js"(exports, module) {
    module.exports = function quote(xs) {
      return xs.map(function(s) {
        if (s && typeof s === "object") {
          return s.op.replace(/(.)/g, "\\$1");
        }
        if (/["\s]/.test(s) && !/'/.test(s)) {
          return "'" + s.replace(/(['\\])/g, "\\$1") + "'";
        }
        if (/["'\s]/.test(s)) {
          return '"' + s.replace(/(["\\$`!])/g, "\\$1") + '"';
        }
        return String(s).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@[\\\]^`{|}])/g, "$1\\$2");
      }).join(" ");
    };
  }
});
var require_parse = __commonJS2({
  "node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/parse.js"(exports, module) {
    var CONTROL = "(?:" + [
      "\\|\\|",
      "\\&\\&",
      ";;",
      "\\|\\&",
      "\\<\\(",
      "\\<\\<\\<",
      ">>",
      ">\\&",
      "<\\&",
      "[&;()|<>]"
    ].join("|") + ")";
    var controlRE = new RegExp("^" + CONTROL + "$");
    var META = "|&;()<> \\t";
    var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
    var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
    var hash = /^#$/;
    var SQ = "'";
    var DQ = '"';
    var DS = "$";
    var TOKEN = "";
    var mult = 4294967296;
    for (i = 0;i < 4; i++) {
      TOKEN += (mult * Math.random()).toString(16);
    }
    var i;
    var startsWithToken = new RegExp("^" + TOKEN);
    function matchAll(s, r) {
      var origIndex = r.lastIndex;
      var matches = [];
      var matchObj;
      while (matchObj = r.exec(s)) {
        matches.push(matchObj);
        if (r.lastIndex === matchObj.index) {
          r.lastIndex += 1;
        }
      }
      r.lastIndex = origIndex;
      return matches;
    }
    function getVar(env, pre, key) {
      var r = typeof env === "function" ? env(key) : env[key];
      if (typeof r === "undefined" && key != "") {
        r = "";
      } else if (typeof r === "undefined") {
        r = "$";
      }
      if (typeof r === "object") {
        return pre + TOKEN + JSON.stringify(r) + TOKEN;
      }
      return pre + r;
    }
    function parseInternal(string2, env, opts) {
      if (!opts) {
        opts = {};
      }
      var BS = opts.escape || "\\";
      var BAREWORD = "(\\" + BS + `['"` + META + `]|[^\\s'"` + META + "])+";
      var chunker = new RegExp([
        "(" + CONTROL + ")",
        "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")+"
      ].join("|"), "g");
      var matches = matchAll(string2, chunker);
      if (matches.length === 0) {
        return [];
      }
      if (!env) {
        env = {};
      }
      var commented = false;
      return matches.map(function(match) {
        var s = match[0];
        if (!s || commented) {
          return;
        }
        if (controlRE.test(s)) {
          return { op: s };
        }
        var quote = false;
        var esc = false;
        var out = "";
        var isGlob = false;
        var i2;
        function parseEnvVar() {
          i2 += 1;
          var varend;
          var varname;
          var char = s.charAt(i2);
          if (char === "{") {
            i2 += 1;
            if (s.charAt(i2) === "}") {
              throw new Error("Bad substitution: " + s.slice(i2 - 2, i2 + 1));
            }
            varend = s.indexOf("}", i2);
            if (varend < 0) {
              throw new Error("Bad substitution: " + s.slice(i2));
            }
            varname = s.slice(i2, varend);
            i2 = varend;
          } else if (/[*@#?$!_-]/.test(char)) {
            varname = char;
            i2 += 1;
          } else {
            var slicedFromI = s.slice(i2);
            varend = slicedFromI.match(/[^\w\d_]/);
            if (!varend) {
              varname = slicedFromI;
              i2 = s.length;
            } else {
              varname = slicedFromI.slice(0, varend.index);
              i2 += varend.index - 1;
            }
          }
          return getVar(env, "", varname);
        }
        for (i2 = 0;i2 < s.length; i2++) {
          var c = s.charAt(i2);
          isGlob = isGlob || !quote && (c === "*" || c === "?");
          if (esc) {
            out += c;
            esc = false;
          } else if (quote) {
            if (c === quote) {
              quote = false;
            } else if (quote == SQ) {
              out += c;
            } else {
              if (c === BS) {
                i2 += 1;
                c = s.charAt(i2);
                if (c === DQ || c === BS || c === DS) {
                  out += c;
                } else {
                  out += BS + c;
                }
              } else if (c === DS) {
                out += parseEnvVar();
              } else {
                out += c;
              }
            }
          } else if (c === DQ || c === SQ) {
            quote = c;
          } else if (controlRE.test(c)) {
            return { op: s };
          } else if (hash.test(c)) {
            commented = true;
            var commentObj = { comment: string2.slice(match.index + i2 + 1) };
            if (out.length) {
              return [out, commentObj];
            }
            return [commentObj];
          } else if (c === BS) {
            esc = true;
          } else if (c === DS) {
            out += parseEnvVar();
          } else {
            out += c;
          }
        }
        if (isGlob) {
          return { op: "glob", pattern: out };
        }
        return out;
      }).reduce(function(prev, arg) {
        return typeof arg === "undefined" ? prev : prev.concat(arg);
      }, []);
    }
    module.exports = function parse(s, env, opts) {
      var mapped = parseInternal(s, env, opts);
      if (typeof env !== "function") {
        return mapped;
      }
      return mapped.reduce(function(acc, s2) {
        if (typeof s2 === "object") {
          return acc.concat(s2);
        }
        var xs = s2.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
        if (xs.length === 1) {
          return acc.concat(xs[0]);
        }
        return acc.concat(xs.filter(Boolean).map(function(x) {
          if (startsWithToken.test(x)) {
            return JSON.parse(x.split(TOKEN)[1]);
          }
          return x;
        }));
      }, []);
    };
  }
});
var require_shell_quote = __commonJS2({
  "node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/index.js"(exports) {
    exports.quote = require_quote();
    exports.parse = require_parse();
  }
});
var BroCliError = class extends Error {
  constructor(message, event) {
    const errPrefix = "BroCli error: ";
    super(message === undefined ? message : `${errPrefix}${message}`);
    this.event = event;
  }
};
var import_clone = __toESM2(require_clone(), 1);
var getOptionTypeText = (option) => {
  let result = "";
  switch (option.type) {
    case "boolean":
      result = "";
      break;
    case "number": {
      if ((option.minVal ?? option.maxVal) !== undefined) {
        let text = "";
        if (option.isInt)
          text = text + `integer `;
        if (option.minVal !== undefined)
          text = text + `[${option.minVal};`;
        else
          text = text + `(;`;
        if (option.maxVal !== undefined)
          text = text + `${option.maxVal}]`;
        else
          text = text + `)`;
        result = text;
        break;
      }
      if (option.isInt) {
        result = "integer";
        break;
      }
      result = "number";
      break;
    }
    case "string": {
      if (option.enumVals) {
        result = "[ " + option.enumVals.join(" | ") + " ]";
        break;
      }
      result = "string";
      break;
    }
    case "positional": {
      result = `${option.isRequired ? "<" : "["}${option.enumVals ? option.enumVals.join("|") : option.name}${option.isRequired ? ">" : "]"}`;
      break;
    }
  }
  if (option.isRequired && option.type !== "positional")
    result = "!" + result.length ? " " : "" + result;
  return result;
};
var defaultEventHandler = async (event) => {
  switch (event.type) {
    case "command_help": {
      const command2 = event.command;
      const commandName = getCommandNameWithParents(command2);
      const cliName = event.name;
      const desc = command2.desc ?? command2.shortDesc;
      const subs = command2.subcommands?.filter((s) => !s.hidden);
      const subcommands = subs && subs.length ? subs : undefined;
      const defaultGlobals = [
        {
          config: {
            name: "--help",
            aliases: ["-h"],
            type: "boolean",
            description: `help for ${commandName}`,
            default: undefined
          },
          $output: undefined
        },
        {
          config: {
            name: "--version",
            aliases: ["-v"],
            type: "boolean",
            description: `version${cliName ? ` for ${cliName}` : ""}`,
            default: undefined
          },
          $output: undefined
        }
      ];
      const globals = event.globals ? [...Object.values(event.globals), ...defaultGlobals] : defaultGlobals;
      if (desc !== undefined) {
        console.log(`
${desc}`);
      }
      const opts = Object.values(command2.options ?? {}).filter((opt) => !opt.config.isHidden);
      const positionals = opts.filter((opt) => opt.config.type === "positional");
      const options = [...opts.filter((opt) => opt.config.type !== "positional"), ...globals];
      console.log(`
Usage:`);
      if (command2.handler) {
        console.log(`  ${cliName ? cliName + " " : ""}${commandName}${positionals.length ? " " + positionals.map(({ config: p }) => getOptionTypeText(p)).join(" ") : ""} [flags]`);
      } else
        console.log(`  ${cliName ? cliName + " " : ""}${commandName} [command]`);
      if (command2.aliases) {
        console.log(`
Aliases:`);
        console.log(`  ${[command2.name, ...command2.aliases].join(", ")}`);
      }
      if (subcommands) {
        console.log(`
Available Commands:`);
        const padding = 3;
        const maxLength = subcommands.reduce((p, e) => e.name.length > p ? e.name.length : p, 0);
        const paddedLength = maxLength + padding;
        const preDescPad = 2 + paddedLength;
        const data = subcommands.map((s) => `  ${s.name.padEnd(paddedLength)}${(() => {
          const description = s.shortDesc ?? s.desc;
          if (!description?.length)
            return "";
          const split = description.split(`
`);
          const first = split.shift();
          const final = [first, ...split.map((s2) => "".padEnd(preDescPad) + s2)].join(`
`);
          return final;
        })()}`).join(`
`);
        console.log(data);
      }
      if (options.length) {
        const aliasLength = options.reduce((p, e) => {
          const currentLength = e.config.aliases.reduce((pa, a) => pa + a.length, 0) + (e.config.aliases.length - 1) * 2 + 1;
          return currentLength > p ? currentLength : p;
        }, 0);
        const paddedAliasLength = aliasLength > 0 ? aliasLength + 1 : 0;
        const nameLength = options.reduce((p, e) => {
          const typeLen = getOptionTypeText(e.config).length;
          const length = typeLen > 0 ? e.config.name.length + 1 + typeLen : e.config.name.length;
          return length > p ? length : p;
        }, 0) + 3;
        const preDescPad = paddedAliasLength + nameLength + 2;
        const data = options.map(({ config: opt }) => `  ${`${opt.aliases.length ? opt.aliases.join(", ") + "," : ""}`.padEnd(paddedAliasLength)}${`${opt.name}${(() => {
          const typeText = getOptionTypeText(opt);
          return typeText.length ? " " + typeText : "";
        })()}`.padEnd(nameLength)}${(() => {
          if (!opt.description?.length) {
            return opt.default !== undefined ? `default: ${JSON.stringify(opt.default)}` : "";
          }
          const split = opt.description.split(`
`);
          const first = split.shift();
          const def = opt.default !== undefined ? ` (default: ${JSON.stringify(opt.default)})` : "";
          const final = [first, ...split.map((s) => "".padEnd(preDescPad) + s)].join(`
`) + def;
          return final;
        })()}`).join(`
`);
        console.log(`
Flags:`);
        console.log(data);
      }
      if (subcommands) {
        console.log(`
Use "${cliName ? cliName + " " : ""}${commandName} [command] --help" for more information about a command.
`);
      }
      return true;
    }
    case "global_help": {
      const cliName = event.name;
      const desc = event.description;
      const commands = event.commands.filter((c) => !c.hidden);
      const defaultGlobals = [
        {
          config: {
            name: "--help",
            aliases: ["-h"],
            type: "boolean",
            description: `help${cliName ? ` for ${cliName}` : ""}`,
            default: undefined
          },
          $output: undefined
        },
        {
          config: {
            name: "--version",
            aliases: ["-v"],
            type: "boolean",
            description: `version${cliName ? ` for ${cliName}` : ""}`,
            default: undefined
          },
          $output: undefined
        }
      ];
      const globals = event.globals ? [...defaultGlobals, ...Object.values(event.globals)] : defaultGlobals;
      if (desc !== undefined) {
        console.log(`${desc}
`);
      }
      console.log("Usage:");
      console.log(`  ${cliName ? cliName + " " : ""}[command]`);
      if (commands.length) {
        console.log(`
Available Commands:`);
        const padding = 3;
        const maxLength = commands.reduce((p, e) => e.name.length > p ? e.name.length : p, 0);
        const paddedLength = maxLength + padding;
        const data = commands.map((c) => `  ${c.name.padEnd(paddedLength)}${(() => {
          const desc2 = c.shortDesc ?? c.desc;
          if (!desc2?.length)
            return "";
          const split = desc2.split(`
`);
          const first = split.shift();
          const final = [first, ...split.map((s) => "".padEnd(paddedLength + 2) + s)].join(`
`);
          return final;
        })()}`).join(`
`);
        console.log(data);
      } else {
        console.log(`
No available commands.`);
      }
      const aliasLength = globals.reduce((p, e) => {
        const currentLength = e.config.aliases.reduce((pa, a) => pa + a.length, 0) + (e.config.aliases.length - 1) * 2 + 1;
        return currentLength > p ? currentLength : p;
      }, 0);
      const paddedAliasLength = aliasLength > 0 ? aliasLength + 1 : 0;
      const nameLength = globals.reduce((p, e) => {
        const typeLen = getOptionTypeText(e.config).length;
        const length = typeLen > 0 ? e.config.name.length + 1 + typeLen : e.config.name.length;
        return length > p ? length : p;
      }, 0) + 3;
      const preDescPad = paddedAliasLength + nameLength + 2;
      const gData = globals.map(({ config: opt }) => `  ${`${opt.aliases.length ? opt.aliases.join(", ") + "," : ""}`.padEnd(paddedAliasLength)}${`${opt.name}${(() => {
        const typeText = getOptionTypeText(opt);
        return typeText.length ? " " + typeText : "";
      })()}`.padEnd(nameLength)}${(() => {
        if (!opt.description?.length) {
          return opt.default !== undefined ? `default: ${JSON.stringify(opt.default)}` : "";
        }
        const split = opt.description.split(`
`);
        const first = split.shift();
        const def = opt.default !== undefined ? ` (default: ${JSON.stringify(opt.default)})` : "";
        const final = [first, ...split.map((s) => "".padEnd(preDescPad) + s)].join(`
`) + def;
        return final;
      })()}`).join(`
`);
      console.log(`
Flags:`);
      console.log(gData);
      return true;
    }
    case "version": {
      return true;
    }
    case "error": {
      let msg;
      switch (event.violation) {
        case "above_max": {
          const matchedName = event.offender.namePart;
          const data = event.offender.dataPart;
          const option = event.option;
          const max = option.maxVal;
          msg = `Invalid value: number type argument '${matchedName}' expects maximal value of ${max} as an input, got: ${data}`;
          break;
        }
        case "below_min": {
          const matchedName = event.offender.namePart;
          const data = event.offender.dataPart;
          const option = event.option;
          const min = option.minVal;
          msg = `Invalid value: number type argument '${matchedName}' expects minimal value of ${min} as an input, got: ${data}`;
          break;
        }
        case "expected_int": {
          const matchedName = event.offender.namePart;
          const data = event.offender.dataPart;
          msg = `Invalid value: number type argument '${matchedName}' expects an integer as an input, got: ${data}`;
          break;
        }
        case "invalid_boolean_syntax": {
          const matchedName = event.offender.namePart;
          const data = event.offender.dataPart;
          msg = `Invalid syntax: boolean type argument '${matchedName}' must have it's value passed in the following formats: ${matchedName}=<value> | ${matchedName} <value> | ${matchedName}.
Allowed values: true, false, 0, 1`;
          break;
        }
        case "invalid_string_syntax": {
          const matchedName = event.offender.namePart;
          msg = `Invalid syntax: string type argument '${matchedName}' must have it's value passed in the following formats: ${matchedName}=<value> | ${matchedName} <value>`;
          break;
        }
        case "invalid_number_syntax": {
          const matchedName = event.offender.namePart;
          msg = `Invalid syntax: number type argument '${matchedName}' must have it's value passed in the following formats: ${matchedName}=<value> | ${matchedName} <value>`;
          break;
        }
        case "invalid_number_value": {
          const matchedName = event.offender.namePart;
          const data = event.offender.dataPart;
          msg = `Invalid value: number type argument '${matchedName}' expects a number as an input, got: ${data}`;
          break;
        }
        case "enum_violation": {
          const matchedName = event.offender.namePart;
          const data = event.offender.dataPart;
          const option = event.option;
          const values = option.enumVals;
          msg = option.type === "positional" ? `Invalid value: value for the positional argument '${option.name}' must be either one of the following: ${values.join(", ")}; Received: ${data}` : `Invalid value: value for the argument '${matchedName}' must be either one of the following: ${values.join(", ")}; Received: ${data}`;
          break;
        }
        case "unknown_command_error": {
          const msg2 = `Unknown command: '${event.offender}'.
Type '--help' to get help on the cli.`;
          console.error(msg2);
          return true;
        }
        case "unknown_subcommand_error": {
          const cName = getCommandNameWithParents(event.command);
          const msg2 = `Unknown command: ${cName} ${event.offender}.
Type '${cName} --help' to get the help on command.`;
          console.error(msg2);
          return true;
        }
        case "missing_args_error": {
          const { missing: missingOpts, command: command2 } = event;
          msg = `Command '${command2.name}' is missing following required options: ${missingOpts.map((opt) => {
            const name = opt.shift();
            const aliases = opt;
            if (aliases.length)
              return `${name} [${aliases.join(", ")}]`;
            return name;
          }).join(", ")}`;
          break;
        }
        case "unrecognized_args_error": {
          const { command: command2, unrecognized } = event;
          msg = `Unrecognized options for command '${command2.name}': ${unrecognized.join(", ")}`;
          break;
        }
        case "unknown_error": {
          const e = event.error;
          console.error(typeof e === "object" && e !== null && "message" in e ? e.message : e);
          return true;
        }
      }
      console.error(msg);
      return true;
    }
  }
  return false;
};
var eventHandlerWrapper = (customEventHandler) => async (event) => await customEventHandler(event) ? true : await defaultEventHandler(event);
var import_shell_quote = __toESM2(require_shell_quote(), 1);
function isInt(value) {
  return value === Math.floor(value);
}
var executeOrLog = async (target) => typeof target === "string" ? console.log(target) : target ? await target() : undefined;
var generatePrefix = (name) => name.startsWith("-") ? name : name.length > 1 ? `--${name}` : `-${name}`;
var validateOptions = (config) => {
  const cloned = (0, import_clone.default)(config);
  const entries = [];
  const storedNames = [];
  const cfgEntries = Object.entries(cloned);
  for (const [key, value] of cfgEntries) {
    const cfg = value._.config;
    if (cfg.name === undefined)
      cfg.name = key;
    if (cfg.type === "positional")
      continue;
    if (cfg.name.includes("=")) {
      throw new BroCliError(`Can't define option '${generatePrefix(cfg.name)}' - option names and aliases cannot contain '='!`);
    }
    for (const alias of cfg.aliases) {
      if (alias.includes("=")) {
        throw new BroCliError(`Can't define option '${generatePrefix(cfg.name)}' - option names and aliases cannot contain '='!`);
      }
    }
    cfg.name = generatePrefix(cfg.name);
    cfg.aliases = cfg.aliases.map((a) => generatePrefix(a));
  }
  for (const [key, value] of cfgEntries) {
    const cfg = value._.config;
    if (cfg.type === "positional") {
      entries.push([key, { config: cfg, $output: undefined }]);
      continue;
    }
    const reservedNames = ["--help", "-h", "--version", "-v"];
    const allNames = [cfg.name, ...cfg.aliases];
    for (const name of allNames) {
      const match = reservedNames.find((n) => n === name);
      if (match)
        throw new BroCliError(`Can't define option '${cfg.name}' - name '${match}' is reserved!`);
    }
    for (const storage of storedNames) {
      const nameOccupier = storage.find((e) => e === cfg.name);
      if (!nameOccupier)
        continue;
      throw new BroCliError(`Can't define option '${cfg.name}' - name is already in use by option '${storage[0]}'!`);
    }
    for (const alias of cfg.aliases) {
      for (const storage of storedNames) {
        const nameOccupier = storage.find((e) => e === alias);
        if (!nameOccupier)
          continue;
        throw new BroCliError(`Can't define option '${cfg.name}' - alias '${alias}' is already in use by option '${storage[0]}'!`);
      }
    }
    const currentNames = [cfg.name, ...cfg.aliases];
    storedNames.push(currentNames);
    currentNames.forEach((name, idx) => {
      if (currentNames.findIndex((e) => e === name) === idx)
        return;
      throw new BroCliError(`Can't define option '${cfg.name}' - duplicate alias '${name}'!`);
    });
    entries.push([key, { config: cfg, $output: undefined }]);
  }
  return Object.fromEntries(entries);
};
var assignParent = (parent, subcommands) => subcommands.forEach((e) => {
  e.parent = parent;
  if (e.subcommands)
    assignParent(e, e.subcommands);
});
var command = (command2) => {
  const allNames = command2.aliases ? [command2.name, ...command2.aliases] : [command2.name];
  const cmd = (0, import_clone.default)(command2);
  if (command2.subcommands && command2.options && Object.values(command2.options).find((opt) => opt._.config.type === "positional")) {
    throw new BroCliError(`Can't define command '${cmd.name}' - command can't have subcommands and positional args at the same time!`);
  }
  if (!command2.handler && !command2.subcommands) {
    throw new BroCliError(`Can't define command '${cmd.name}' - command without subcommands must have a handler present!`);
  }
  const processedOptions = command2.options ? validateOptions(command2.options) : undefined;
  cmd.options = processedOptions;
  cmd.name = cmd.name ?? cmd.aliases?.shift();
  if (!cmd.name)
    throw new BroCliError(`Can't define command without name!`);
  cmd.aliases = cmd.aliases?.length ? cmd.aliases : undefined;
  if (cmd.name.startsWith("-")) {
    throw new BroCliError(`Can't define command '${cmd.name}' - command name can't start with '-'!`);
  }
  cmd.aliases?.forEach((a) => {
    if (a.startsWith("-")) {
      throw new BroCliError(`Can't define command '${cmd.name}' - command aliases can't start with '-'!`);
    }
  });
  allNames.forEach((n, i) => {
    if (n === "help") {
      throw new BroCliError(`Can't define command '${cmd.name}' - 'help' is a reserved name. If you want to redefine help message - do so in runCli's config.`);
    }
    const lCaseName = n?.toLowerCase();
    if (lCaseName === "0" || lCaseName === "1" || lCaseName === "true" || lCaseName === "false") {
      throw new BroCliError(`Can't define command '${cmd.name}' - '${n}' is a reserved for boolean values name!`);
    }
    const idx = allNames.findIndex((an) => an === n);
    if (idx !== i)
      throw new BroCliError(`Can't define command '${cmd.name}' - duplicate alias '${n}'!`);
  });
  if (cmd.subcommands) {
    assignParent(cmd, cmd.subcommands);
  }
  return cmd;
};
var getCommandInner = (commands, candidates, args, cliName, cliDescription) => {
  const { data: arg, originalIndex: index } = candidates.shift();
  const command2 = commands.find((c) => {
    const names = c.aliases ? [c.name, ...c.aliases] : [c.name];
    const res = names.find((name) => name === arg);
    return res;
  });
  if (!command2) {
    return {
      command: command2,
      args
    };
  }
  const newArgs = removeByIndex(args, index);
  if (!candidates.length || !command2.subcommands) {
    return {
      command: command2,
      args: newArgs
    };
  }
  const newCandidates = candidates.map((c) => ({ data: c.data, originalIndex: c.originalIndex - 1 }));
  const subcommand = getCommandInner(command2.subcommands, newCandidates, newArgs, cliName, cliDescription);
  if (!subcommand.command) {
    throw new BroCliError(undefined, {
      type: "error",
      violation: "unknown_subcommand_error",
      name: cliName,
      description: cliDescription,
      command: command2,
      offender: candidates[0].data
    });
  }
  return subcommand;
};
var getCommand = (commands, args, cliName, cliDescription) => {
  const candidates = [];
  for (let i = 0;i < args.length; ++i) {
    const arg = args[i];
    if (arg === "--help" || arg === "-h" || arg === "--version" || arg === "-v") {
      const lCaseNext = args[i + 1]?.toLowerCase();
      if (lCaseNext === "0" || lCaseNext === "1" || lCaseNext === "true" || lCaseNext === "false")
        ++i;
      continue;
    }
    if (arg?.startsWith("-")) {
      if (!arg.includes("="))
        ++i;
      continue;
    }
    candidates.push({
      data: arg,
      originalIndex: i
    });
  }
  if (!candidates.length) {
    return {
      command: undefined,
      args
    };
  }
  const firstCandidate = candidates[0];
  if (firstCandidate.data === "help") {
    return {
      command: "help",
      args: removeByIndex(args, firstCandidate.originalIndex)
    };
  }
  const { command: command2, args: argsRes } = getCommandInner(commands, candidates, args, cliName, cliDescription);
  if (!command2) {
    throw new BroCliError(undefined, {
      type: "error",
      violation: "unknown_command_error",
      commands,
      name: cliName,
      description: cliDescription,
      offender: firstCandidate.data
    });
  }
  return {
    command: command2,
    args: argsRes
  };
};
var parseArg = (command2, options, positionals, arg, nextArg, cliName, cliDescription) => {
  let data = undefined;
  const argSplit = arg.split("=");
  const hasEq = arg.includes("=");
  const namePart = argSplit.shift();
  const dataPart = hasEq ? argSplit.join("=") : nextArg;
  let skipNext = !hasEq;
  if (namePart === "--help" || namePart === "-h") {
    return {
      isHelp: true
    };
  }
  if (namePart === "--version" || namePart === "-v") {
    return {
      isVersion: true
    };
  }
  if (!arg.startsWith("-")) {
    if (!positionals.length)
      return {};
    const pos = positionals.shift();
    if (pos[1].enumVals && !pos[1].enumVals.find((val) => val === arg)) {
      throw new BroCliError(undefined, {
        type: "error",
        name: cliName,
        description: cliDescription,
        violation: "enum_violation",
        command: command2,
        option: pos[1],
        offender: {
          dataPart: arg
        }
      });
    }
    data = arg;
    return {
      data,
      skipNext: false,
      name: pos[0],
      option: pos[1]
    };
  }
  const option = options.find(([optKey, opt]) => {
    const names = [opt.name, ...opt.aliases];
    if (opt.type === "boolean") {
      const match = names.find((name) => name === namePart);
      if (!match)
        return false;
      let lcaseData = dataPart?.toLowerCase();
      if (!hasEq && nextArg?.startsWith("-")) {
        data = true;
        skipNext = false;
        return true;
      }
      if (lcaseData === undefined || lcaseData === "" || lcaseData === "true" || lcaseData === "1") {
        data = true;
        return true;
      }
      if (lcaseData === "false" || lcaseData === "0") {
        data = false;
        return true;
      }
      if (!hasEq) {
        data = true;
        skipNext = false;
        return true;
      }
      throw new BroCliError(undefined, {
        type: "error",
        name: cliName,
        description: cliDescription,
        violation: "invalid_boolean_syntax",
        option: opt,
        command: command2,
        offender: {
          namePart,
          dataPart
        }
      });
    } else {
      const match = names.find((name) => name === namePart);
      if (!match)
        return false;
      if (opt.type === "string") {
        if (!hasEq && nextArg === undefined) {
          throw new BroCliError(undefined, {
            type: "error",
            name: cliName,
            description: cliDescription,
            violation: "invalid_string_syntax",
            option: opt,
            command: command2,
            offender: {
              namePart,
              dataPart
            }
          });
        }
        if (opt.enumVals && !opt.enumVals.find((val) => val === dataPart)) {
          throw new BroCliError(undefined, {
            type: "error",
            name: cliName,
            description: cliDescription,
            violation: "enum_violation",
            option: opt,
            command: command2,
            offender: {
              namePart,
              dataPart
            }
          });
        }
        data = dataPart;
        return true;
      }
      if (!hasEq && nextArg === undefined) {
        throw new BroCliError(undefined, {
          type: "error",
          name: cliName,
          description: cliDescription,
          violation: "invalid_number_syntax",
          option: opt,
          command: command2,
          offender: {
            namePart,
            dataPart
          }
        });
      }
      const numData = Number(dataPart);
      if (isNaN(numData)) {
        throw new BroCliError(undefined, {
          type: "error",
          name: cliName,
          description: cliDescription,
          violation: "invalid_number_value",
          option: opt,
          command: command2,
          offender: {
            namePart,
            dataPart
          }
        });
      }
      if (opt.isInt && !isInt(numData)) {
        throw new BroCliError(undefined, {
          type: "error",
          name: cliName,
          description: cliDescription,
          violation: "expected_int",
          option: opt,
          command: command2,
          offender: {
            namePart,
            dataPart
          }
        });
      }
      if (opt.minVal !== undefined && numData < opt.minVal) {
        throw new BroCliError(undefined, {
          type: "error",
          name: cliName,
          description: cliDescription,
          violation: "below_min",
          option: opt,
          command: command2,
          offender: {
            namePart,
            dataPart
          }
        });
      }
      if (opt.maxVal !== undefined && numData > opt.maxVal) {
        throw new BroCliError(undefined, {
          type: "error",
          name: cliName,
          description: cliDescription,
          violation: "above_max",
          option: opt,
          command: command2,
          offender: {
            namePart,
            dataPart
          }
        });
      }
      data = numData;
      return true;
    }
  });
  return {
    data,
    skipNext,
    name: option?.[0],
    option: option?.[1]
  };
};
var parseOptions = (command2, args, cliName, cliDescription, omitKeysOfUndefinedOptions) => {
  const options = command2.options;
  let noOpts = !options;
  const optEntries = Object.entries(options ?? {}).map((opt) => [opt[0], opt[1].config]);
  const nonPositionalEntries = optEntries.filter(([key, opt]) => opt.type !== "positional");
  const positionalEntries = optEntries.filter(([key, opt]) => opt.type === "positional");
  const result = {};
  const missingRequiredArr = [];
  const unrecognizedArgsArr = [];
  for (let i = 0;i < args.length; ++i) {
    const arg = args[i];
    const nextArg = args[i + 1];
    const {
      data,
      name,
      option,
      skipNext,
      isHelp,
      isVersion
    } = parseArg(command2, nonPositionalEntries, positionalEntries, arg, nextArg, cliName, cliDescription);
    if (!option)
      unrecognizedArgsArr.push(arg.split("=")[0]);
    if (skipNext)
      ++i;
    if (isHelp)
      return "help";
    if (isVersion)
      return "version";
    result[name] = data;
  }
  for (const [optKey, option] of optEntries) {
    const data = result[optKey] ?? option.default;
    if (!omitKeysOfUndefinedOptions) {
      result[optKey] = data;
    } else {
      if (data !== undefined)
        result[optKey] = data;
    }
    if (option.isRequired && result[optKey] === undefined)
      missingRequiredArr.push([option.name, ...option.aliases]);
  }
  if (missingRequiredArr.length) {
    throw new BroCliError(undefined, {
      type: "error",
      violation: "missing_args_error",
      name: cliName,
      description: cliDescription,
      command: command2,
      missing: missingRequiredArr
    });
  }
  if (unrecognizedArgsArr.length) {
    throw new BroCliError(undefined, {
      type: "error",
      violation: "unrecognized_args_error",
      name: cliName,
      description: cliDescription,
      command: command2,
      unrecognized: unrecognizedArgsArr
    });
  }
  return noOpts ? undefined : result;
};
var parseGlobals = (command2, globals, args, cliName, cliDescription, omitKeysOfUndefinedOptions) => {
  if (!globals)
    return;
  const optEntries = Object.entries(globals).map((opt) => [opt[0], opt[1].config]);
  const result = {};
  const missingRequiredArr = [];
  for (let i = 0;i < args.length; ++i) {
    const arg = args[i];
    const nextArg = args[i + 1];
    const {
      data,
      name,
      option,
      skipNext,
      isHelp,
      isVersion
    } = parseArg(command2, optEntries, [], arg, nextArg, cliName, cliDescription);
    if (skipNext)
      ++i;
    if (isHelp)
      return "help";
    if (isVersion)
      return "version";
    if (!option)
      continue;
    delete args[i];
    if (skipNext)
      delete args[i - 1];
    result[name] = data;
  }
  for (const [optKey, option] of optEntries) {
    const data = result[optKey] ?? option.default;
    if (!omitKeysOfUndefinedOptions) {
      result[optKey] = data;
    } else {
      if (data !== undefined)
        result[optKey] = data;
    }
    if (option.isRequired && result[optKey] === undefined)
      missingRequiredArr.push([option.name, ...option.aliases]);
  }
  if (missingRequiredArr.length) {
    throw new BroCliError(undefined, {
      type: "error",
      violation: "missing_args_error",
      name: cliName,
      description: cliDescription,
      command: command2,
      missing: missingRequiredArr
    });
  }
  return Object.keys(result).length ? result : undefined;
};
var getCommandNameWithParents = (command2) => command2.parent ? `${getCommandNameWithParents(command2.parent)} ${command2.name}` : command2.name;
var validateCommands = (commands, parent) => {
  const storedNames = {};
  for (const cmd of commands) {
    const storageVals = Object.values(storedNames);
    for (const storage of storageVals) {
      const nameOccupier = storage.find((e) => e === cmd.name);
      if (!nameOccupier)
        continue;
      throw new BroCliError(`Can't define command '${getCommandNameWithParents(cmd)}': name is already in use by command '${parent ? `${getCommandNameWithParents(parent)} ` : ""}${storage[0]}'!`);
    }
    if (cmd.aliases) {
      for (const alias of cmd.aliases) {
        for (const storage of storageVals) {
          const nameOccupier = storage.find((e) => e === alias);
          if (!nameOccupier)
            continue;
          throw new BroCliError(`Can't define command '${getCommandNameWithParents(cmd)}': alias '${alias}' is already in use by command '${parent ? `${getCommandNameWithParents(parent)} ` : ""}${storage[0]}'!`);
        }
      }
    }
    storedNames[cmd.name] = cmd.aliases ? [cmd.name, ...cmd.aliases] : [cmd.name];
    if (cmd.subcommands)
      cmd.subcommands = validateCommands(cmd.subcommands, cmd);
  }
  return commands;
};
var validateGlobalsInner = (commands, globals) => {
  for (const c of commands) {
    const { options } = c;
    if (!options)
      continue;
    for (const { config: opt } of Object.values(options)) {
      const foundNameOverlap = globals.find(({ config: g }) => g.name === opt.name);
      if (foundNameOverlap) {
        throw new BroCliError(`Global options overlap with option '${opt.name}' of command '${getCommandNameWithParents(c)}' on name`);
      }
      let foundAliasOverlap = opt.aliases.find((a) => globals.find(({ config: g }) => g.name === a)) ?? globals.find(({ config: g }) => opt.aliases.find((a) => a === g.name));
      if (!foundAliasOverlap) {
        for (const { config: g } of globals) {
          foundAliasOverlap = g.aliases.find((gAlias) => opt.name === gAlias);
          if (foundAliasOverlap)
            break;
        }
      }
      if (!foundAliasOverlap) {
        for (const { config: g } of globals) {
          foundAliasOverlap = g.aliases.find((gAlias) => opt.aliases.find((a) => a === gAlias));
          if (foundAliasOverlap)
            break;
        }
      }
      if (foundAliasOverlap) {
        throw new BroCliError(`Global options overlap with option '${opt.name}' of command '${getCommandNameWithParents(c)}' on alias '${foundAliasOverlap}'`);
      }
    }
    if (c.subcommands)
      validateGlobalsInner(c.subcommands, globals);
  }
};
var validateGlobals = (commands, globals) => {
  if (!globals)
    return;
  const globalEntries = Object.values(globals);
  validateGlobalsInner(commands, globalEntries);
};
var removeByIndex = (arr, idx) => [...arr.slice(0, idx), ...arr.slice(idx + 1, arr.length)];
var run = async (commands, config) => {
  const eventHandler = config?.theme ? eventHandlerWrapper(config.theme) : defaultEventHandler;
  const argSource = config?.argSource ?? process.argv;
  const version = config?.version;
  const help = config?.help;
  const omitKeysOfUndefinedOptions = config?.omitKeysOfUndefinedOptions ?? false;
  const cliName = config?.name;
  const cliDescription = config?.description;
  const globals = config?.globals;
  try {
    const processedCmds = validateCommands(commands);
    const processedGlobals = globals ? validateOptions(globals) : undefined;
    if (processedGlobals)
      validateGlobals(processedCmds, processedGlobals);
    let args = argSource.slice(2, argSource.length);
    if (!args.length) {
      return help !== undefined ? await executeOrLog(help) : await eventHandler({
        type: "global_help",
        description: cliDescription,
        name: cliName,
        commands: processedCmds,
        globals: processedGlobals
      });
    }
    const helpIndex = args.findIndex((arg) => arg === "--help" || arg === "-h");
    if (helpIndex !== -1 && (helpIndex > 0 ? args[helpIndex - 1]?.startsWith("-") && !args[helpIndex - 1].includes("=") ? false : true : true)) {
      const command3 = getCommand(processedCmds, args, cliName, cliDescription).command;
      if (typeof command3 === "object") {
        return command3.help !== undefined ? await executeOrLog(command3.help) : await eventHandler({
          type: "command_help",
          description: cliDescription,
          name: cliName,
          command: command3,
          globals: processedGlobals
        });
      } else {
        return help !== undefined ? await executeOrLog(help) : await eventHandler({
          type: "global_help",
          description: cliDescription,
          name: cliName,
          commands: processedCmds,
          globals: processedGlobals
        });
      }
    }
    const versionIndex = args.findIndex((arg) => arg === "--version" || arg === "-v");
    if (versionIndex !== -1 && (versionIndex > 0 ? args[versionIndex - 1]?.startsWith("-") ? false : true : true)) {
      return version !== undefined ? await executeOrLog(version) : await eventHandler({
        type: "version",
        name: cliName,
        description: cliDescription
      });
    }
    const { command: command2, args: newArgs } = getCommand(processedCmds, args, cliName, cliDescription);
    if (!command2) {
      return help !== undefined ? await executeOrLog(help) : await eventHandler({
        type: "global_help",
        description: cliDescription,
        name: cliName,
        commands: processedCmds,
        globals: processedGlobals
      });
    }
    if (command2 === "help") {
      let helpCommand;
      let newestArgs = newArgs;
      do {
        const res = getCommand(processedCmds, newestArgs, cliName, cliDescription);
        helpCommand = res.command;
        newestArgs = res.args;
      } while (helpCommand === "help");
      return helpCommand ? helpCommand.help !== undefined ? await executeOrLog(helpCommand.help) : await eventHandler({
        type: "command_help",
        description: cliDescription,
        name: cliName,
        command: helpCommand,
        globals: processedGlobals
      }) : help !== undefined ? await executeOrLog(help) : await eventHandler({
        type: "global_help",
        description: cliDescription,
        name: cliName,
        commands: processedCmds,
        globals: processedGlobals
      });
    }
    const gOptionResult = parseGlobals(command2, processedGlobals, newArgs, cliName, cliDescription, omitKeysOfUndefinedOptions);
    const optionResult = gOptionResult && (gOptionResult === "help" || gOptionResult === "version") ? gOptionResult : parseOptions(command2, globals ? newArgs.filter((a) => a !== undefined) : newArgs, cliName, cliDescription, omitKeysOfUndefinedOptions);
    if (optionResult === "help" || gOptionResult === "help") {
      return command2.help !== undefined ? await executeOrLog(command2.help) : await eventHandler({
        type: "command_help",
        description: cliDescription,
        name: cliName,
        command: command2,
        globals: processedGlobals
      });
    }
    if (optionResult === "version" || gOptionResult === "version") {
      return version !== undefined ? await executeOrLog(version) : await eventHandler({
        type: "version",
        name: cliName,
        description: cliDescription
      });
    }
    if (command2.handler) {
      if (config?.hook)
        await config.hook("before", command2, gOptionResult);
      await command2.handler(command2.transform ? await command2.transform(optionResult) : optionResult);
      if (config?.hook)
        await config.hook("after", command2, gOptionResult);
      return;
    } else {
      return command2.help !== undefined ? await executeOrLog(command2.help) : await eventHandler({
        type: "command_help",
        description: cliDescription,
        name: cliName,
        command: command2,
        globals: processedGlobals
      });
    }
  } catch (e) {
    if (e instanceof BroCliError) {
      if (e.event)
        await eventHandler(e.event);
      else {
        if (!config?.noExit)
          console.error(e.message);
        else
          return e.message;
      }
    } else {
      await eventHandler({
        type: "error",
        violation: "unknown_error",
        name: cliName,
        description: cliDescription,
        error: e
      });
    }
    if (!config?.noExit)
      process.exit(1);
    return;
  }
};
var OptionBuilderBase = class _OptionBuilderBase {
  _;
  config = () => this._.config;
  constructor(config) {
    this._ = {
      config: config ?? {
        aliases: [],
        type: "string"
      },
      $output: undefined
    };
  }
  string(name) {
    const config = this.config();
    return new _OptionBuilderBase({ ...config, type: "string", name });
  }
  number(name) {
    const config = this.config();
    return new _OptionBuilderBase({ ...config, type: "number", name });
  }
  boolean(name) {
    const config = this.config();
    return new _OptionBuilderBase({ ...config, type: "boolean", name });
  }
  positional(displayName) {
    const config = this.config();
    return new _OptionBuilderBase({ ...config, type: "positional", name: displayName });
  }
  alias(...aliases) {
    const config = this.config();
    return new _OptionBuilderBase({ ...config, aliases });
  }
  desc(description) {
    const config = this.config();
    return new _OptionBuilderBase({ ...config, description });
  }
  hidden() {
    const config = this.config();
    return new _OptionBuilderBase({ ...config, isHidden: true });
  }
  required() {
    const config = this.config();
    return new _OptionBuilderBase({ ...config, isRequired: true });
  }
  default(value) {
    const config = this.config();
    const enums = config.enumVals;
    if (enums && !enums.find((v) => value === v)) {
      throw new Error(`Option enums [ ${enums.join(", ")} ] are incompatible with default value ${value}`);
    }
    return new _OptionBuilderBase({ ...config, default: value });
  }
  enum(...values) {
    const config = this.config();
    const defaultVal = config.default;
    if (defaultVal !== undefined && !values.find((v) => defaultVal === v)) {
      throw new Error(`Option enums [ ${values.join(", ")} ] are incompatible with default value ${defaultVal}`);
    }
    return new _OptionBuilderBase({ ...config, enumVals: values });
  }
  min(value) {
    const config = this.config();
    const maxVal = config.maxVal;
    if (maxVal !== undefined && maxVal < value) {
      throw new BroCliError("Unable to define option's min value to be higher than max value!");
    }
    return new _OptionBuilderBase({ ...config, minVal: value });
  }
  max(value) {
    const config = this.config();
    const minVal = config.minVal;
    if (minVal !== undefined && minVal > value) {
      throw new BroCliError("Unable to define option's max value to be lower than min value!");
    }
    return new _OptionBuilderBase({ ...config, maxVal: value });
  }
  int() {
    const config = this.config();
    return new _OptionBuilderBase({ ...config, isInt: true });
  }
};
function string(name) {
  return typeof name === "string" ? new OptionBuilderBase().string(name) : new OptionBuilderBase().string();
}
function number(name) {
  return typeof name === "string" ? new OptionBuilderBase().number(name) : new OptionBuilderBase().number();
}
function boolean(name) {
  return typeof name === "string" ? new OptionBuilderBase().boolean(name) : new OptionBuilderBase().boolean();
}

// src/commands/create.ts
var import_fs_extra = __toESM(require_lib(), 1);
init_esm31();
import path from "path";

// node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    blackBright: [90, 39],
    gray: [90, 39],
    grey: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = new Map;
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// node_modules/chalk/source/vendor/supports-color/index.js
import process13 from "node:process";
import os from "node:os";
import tty from "node:tty";
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process13.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = process13;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== undefined) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (process13.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key11) => (key11 in env))) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// node_modules/chalk/source/utilities.js
function stringReplaceAll(string2, substring, replacer) {
  let index = string2.indexOf(substring);
  if (index === -1) {
    return string2;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string2.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string2.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string2.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string2, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string2[index - 1] === "\r";
    returnValue += string2.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? `\r
` : `
`) + postfix;
    endIndex = index + 1;
    index = string2.indexOf(`
`, endIndex);
  } while (index !== -1);
  returnValue += string2.slice(endIndex);
  return returnValue;
}

// node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === undefined ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk = (...strings) => strings.join(" ");
  applyOptions(chalk, options);
  Object.setPrototypeOf(chalk, createChalk.prototype);
  return chalk;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string2) => {
  if (self2.level <= 0 || !string2) {
    return self2[IS_EMPTY] ? "" : string2;
  }
  let styler = self2[STYLER];
  if (styler === undefined) {
    return string2;
  }
  const { openAll, closeAll } = styler;
  if (string2.includes("\x1B")) {
    while (styler !== undefined) {
      string2 = stringReplaceAll(string2, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string2.indexOf(`
`);
  if (lfIndex !== -1) {
    string2 = stringEncaseCRLFWithFirstIndex(string2, closeAll, openAll, lfIndex);
  }
  return openAll + string2 + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// node_modules/ora/index.js
import process19 from "node:process";

// node_modules/cli-cursor/index.js
import process15 from "node:process";

// node_modules/restore-cursor/index.js
import process14 from "node:process";

// node_modules/mimic-function/index.js
var copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
var canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
var changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
var changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  const { writable, enumerable, configurable } = toStringDescriptor;
  Object.defineProperty(to, "toString", { value: newToString, writable, enumerable, configurable });
};
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
}

// node_modules/onetime/index.js
var calledFunctions = new WeakMap;
var onetime = (function_, options = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = undefined;
    } else if (options.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFunction(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
var onetime_default = onetime;

// node_modules/restore-cursor/index.js
init_mjs();
var terminal = process14.stderr.isTTY ? process14.stderr : process14.stdout.isTTY ? process14.stdout : undefined;
var restoreCursor = terminal ? onetime_default(() => {
  onExit(() => {
    terminal.write("\x1B[?25h");
  }, { alwaysLast: true });
}) : () => {
};
var restore_cursor_default = restoreCursor;

// node_modules/cli-cursor/index.js
var isHidden = false;
var cliCursor = {};
cliCursor.show = (writableStream = process15.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  isHidden = false;
  writableStream.write("\x1B[?25h");
};
cliCursor.hide = (writableStream = process15.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  restore_cursor_default();
  isHidden = true;
  writableStream.write("\x1B[?25l");
};
cliCursor.toggle = (force, writableStream) => {
  if (force !== undefined) {
    isHidden = force;
  }
  if (isHidden) {
    cliCursor.show(writableStream);
  } else {
    cliCursor.hide(writableStream);
  }
};
var cli_cursor_default = cliCursor;

// node_modules/ora/index.js
var import_cli_spinners = __toESM(require_cli_spinners(), 1);

// node_modules/log-symbols/node_modules/is-unicode-supported/index.js
import process16 from "node:process";
function isUnicodeSupported11() {
  if (process16.platform !== "win32") {
    return process16.env.TERM !== "linux";
  }
  return Boolean(process16.env.CI) || Boolean(process16.env.WT_SESSION) || Boolean(process16.env.TERMINUS_SUBLIME) || process16.env.ConEmuTask === "{cmd::Cmder}" || process16.env.TERM_PROGRAM === "Terminus-Sublime" || process16.env.TERM_PROGRAM === "vscode" || process16.env.TERM === "xterm-256color" || process16.env.TERM === "alacritty" || process16.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// node_modules/log-symbols/index.js
var main = {
  info: source_default.blue(""),
  success: source_default.green(""),
  warning: source_default.yellow(""),
  error: source_default.red("")
};
var fallback = {
  info: source_default.blue("i"),
  success: source_default.green(""),
  warning: source_default.yellow(""),
  error: source_default.red("")
};
var logSymbols = isUnicodeSupported11() ? main : fallback;
var log_symbols_default = logSymbols;

// node_modules/ansi-regex/index.js
function ansiRegex({ onlyFirst = false } = {}) {
  const ST = "(?:\\u0007|\\u001B\\u005C|\\u009C)";
  const pattern = [
    `[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`,
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? undefined : "g");
}

// node_modules/strip-ansi/index.js
var regex = ansiRegex();
function stripAnsi11(string2) {
  if (typeof string2 !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string2}\``);
  }
  return string2.replace(regex, "");
}

// node_modules/get-east-asian-width/lookup.js
function isAmbiguous(x) {
  return x === 161 || x === 164 || x === 167 || x === 168 || x === 170 || x === 173 || x === 174 || x >= 176 && x <= 180 || x >= 182 && x <= 186 || x >= 188 && x <= 191 || x === 198 || x === 208 || x === 215 || x === 216 || x >= 222 && x <= 225 || x === 230 || x >= 232 && x <= 234 || x === 236 || x === 237 || x === 240 || x === 242 || x === 243 || x >= 247 && x <= 250 || x === 252 || x === 254 || x === 257 || x === 273 || x === 275 || x === 283 || x === 294 || x === 295 || x === 299 || x >= 305 && x <= 307 || x === 312 || x >= 319 && x <= 322 || x === 324 || x >= 328 && x <= 331 || x === 333 || x === 338 || x === 339 || x === 358 || x === 359 || x === 363 || x === 462 || x === 464 || x === 466 || x === 468 || x === 470 || x === 472 || x === 474 || x === 476 || x === 593 || x === 609 || x === 708 || x === 711 || x >= 713 && x <= 715 || x === 717 || x === 720 || x >= 728 && x <= 731 || x === 733 || x === 735 || x >= 768 && x <= 879 || x >= 913 && x <= 929 || x >= 931 && x <= 937 || x >= 945 && x <= 961 || x >= 963 && x <= 969 || x === 1025 || x >= 1040 && x <= 1103 || x === 1105 || x === 8208 || x >= 8211 && x <= 8214 || x === 8216 || x === 8217 || x === 8220 || x === 8221 || x >= 8224 && x <= 8226 || x >= 8228 && x <= 8231 || x === 8240 || x === 8242 || x === 8243 || x === 8245 || x === 8251 || x === 8254 || x === 8308 || x === 8319 || x >= 8321 && x <= 8324 || x === 8364 || x === 8451 || x === 8453 || x === 8457 || x === 8467 || x === 8470 || x === 8481 || x === 8482 || x === 8486 || x === 8491 || x === 8531 || x === 8532 || x >= 8539 && x <= 8542 || x >= 8544 && x <= 8555 || x >= 8560 && x <= 8569 || x === 8585 || x >= 8592 && x <= 8601 || x === 8632 || x === 8633 || x === 8658 || x === 8660 || x === 8679 || x === 8704 || x === 8706 || x === 8707 || x === 8711 || x === 8712 || x === 8715 || x === 8719 || x === 8721 || x === 8725 || x === 8730 || x >= 8733 && x <= 8736 || x === 8739 || x === 8741 || x >= 8743 && x <= 8748 || x === 8750 || x >= 8756 && x <= 8759 || x === 8764 || x === 8765 || x === 8776 || x === 8780 || x === 8786 || x === 8800 || x === 8801 || x >= 8804 && x <= 8807 || x === 8810 || x === 8811 || x === 8814 || x === 8815 || x === 8834 || x === 8835 || x === 8838 || x === 8839 || x === 8853 || x === 8857 || x === 8869 || x === 8895 || x === 8978 || x >= 9312 && x <= 9449 || x >= 9451 && x <= 9547 || x >= 9552 && x <= 9587 || x >= 9600 && x <= 9615 || x >= 9618 && x <= 9621 || x === 9632 || x === 9633 || x >= 9635 && x <= 9641 || x === 9650 || x === 9651 || x === 9654 || x === 9655 || x === 9660 || x === 9661 || x === 9664 || x === 9665 || x >= 9670 && x <= 9672 || x === 9675 || x >= 9678 && x <= 9681 || x >= 9698 && x <= 9701 || x === 9711 || x === 9733 || x === 9734 || x === 9737 || x === 9742 || x === 9743 || x === 9756 || x === 9758 || x === 9792 || x === 9794 || x === 9824 || x === 9825 || x >= 9827 && x <= 9829 || x >= 9831 && x <= 9834 || x === 9836 || x === 9837 || x === 9839 || x === 9886 || x === 9887 || x === 9919 || x >= 9926 && x <= 9933 || x >= 9935 && x <= 9939 || x >= 9941 && x <= 9953 || x === 9955 || x === 9960 || x === 9961 || x >= 9963 && x <= 9969 || x === 9972 || x >= 9974 && x <= 9977 || x === 9979 || x === 9980 || x === 9982 || x === 9983 || x === 10045 || x >= 10102 && x <= 10111 || x >= 11094 && x <= 11097 || x >= 12872 && x <= 12879 || x >= 57344 && x <= 63743 || x >= 65024 && x <= 65039 || x === 65533 || x >= 127232 && x <= 127242 || x >= 127248 && x <= 127277 || x >= 127280 && x <= 127337 || x >= 127344 && x <= 127373 || x === 127375 || x === 127376 || x >= 127387 && x <= 127404 || x >= 917760 && x <= 917999 || x >= 983040 && x <= 1048573 || x >= 1048576 && x <= 1114109;
}
function isFullWidth(x) {
  return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
}
function isWide(x) {
  return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9776 && x <= 9783 || x >= 9800 && x <= 9811 || x === 9855 || x >= 9866 && x <= 9871 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12773 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x === 94192 || x === 94193 || x >= 94208 && x <= 100343 || x >= 100352 && x <= 101589 || x >= 101631 && x <= 101640 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x >= 119552 && x <= 119638 || x >= 119648 && x <= 119670 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128727 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129673 || x >= 129679 && x <= 129734 || x >= 129742 && x <= 129756 || x >= 129759 && x <= 129769 || x >= 129776 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
}

// node_modules/get-east-asian-width/index.js
function validate(codePoint) {
  if (!Number.isSafeInteger(codePoint)) {
    throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
  }
}
function eastAsianWidth(codePoint, { ambiguousAsWide = false } = {}) {
  validate(codePoint);
  if (isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint)) {
    return 2;
  }
  return 1;
}

// node_modules/string-width/index.js
var import_emoji_regex = __toESM(require_emoji_regex2(), 1);
var segmenter = new Intl.Segmenter;
var defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;
function stringWidth(string2, options = {}) {
  if (typeof string2 !== "string" || string2.length === 0) {
    return 0;
  }
  const {
    ambiguousIsNarrow = true,
    countAnsiEscapeCodes = false
  } = options;
  if (!countAnsiEscapeCodes) {
    string2 = stripAnsi11(string2);
  }
  if (string2.length === 0) {
    return 0;
  }
  let width = 0;
  const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
  for (const { segment: character } of segmenter.segment(string2)) {
    const codePoint = character.codePointAt(0);
    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
      continue;
    }
    if (codePoint >= 8203 && codePoint <= 8207 || codePoint === 65279) {
      continue;
    }
    if (codePoint >= 768 && codePoint <= 879 || codePoint >= 6832 && codePoint <= 6911 || codePoint >= 7616 && codePoint <= 7679 || codePoint >= 8400 && codePoint <= 8447 || codePoint >= 65056 && codePoint <= 65071) {
      continue;
    }
    if (codePoint >= 55296 && codePoint <= 57343) {
      continue;
    }
    if (codePoint >= 65024 && codePoint <= 65039) {
      continue;
    }
    if (defaultIgnorableCodePointRegex.test(character)) {
      continue;
    }
    if (import_emoji_regex.default().test(character)) {
      width += 2;
      continue;
    }
    width += eastAsianWidth(codePoint, eastAsianWidthOptions);
  }
  return width;
}

// node_modules/is-interactive/index.js
function isInteractive({ stream = process.stdout } = {}) {
  return Boolean(stream && stream.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env));
}

// node_modules/is-unicode-supported/index.js
import process17 from "node:process";
function isUnicodeSupported12() {
  const { env: env2 } = process17;
  const { TERM, TERM_PROGRAM } = env2;
  if (process17.platform !== "win32") {
    return TERM !== "linux";
  }
  return Boolean(env2.WT_SESSION) || Boolean(env2.TERMINUS_SUBLIME) || env2.ConEmuTask === "{cmd::Cmder}" || TERM_PROGRAM === "Terminus-Sublime" || TERM_PROGRAM === "vscode" || TERM === "xterm-256color" || TERM === "alacritty" || TERM === "rxvt-unicode" || TERM === "rxvt-unicode-256color" || env2.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// node_modules/stdin-discarder/index.js
import process18 from "node:process";
var ASCII_ETX_CODE = 3;

class StdinDiscarder {
  #activeCount = 0;
  start() {
    this.#activeCount++;
    if (this.#activeCount === 1) {
      this.#realStart();
    }
  }
  stop() {
    if (this.#activeCount <= 0) {
      throw new Error("`stop` called more times than `start`");
    }
    this.#activeCount--;
    if (this.#activeCount === 0) {
      this.#realStop();
    }
  }
  #realStart() {
    if (process18.platform === "win32" || !process18.stdin.isTTY) {
      return;
    }
    process18.stdin.setRawMode(true);
    process18.stdin.on("data", this.#handleInput);
    process18.stdin.resume();
  }
  #realStop() {
    if (!process18.stdin.isTTY) {
      return;
    }
    process18.stdin.off("data", this.#handleInput);
    process18.stdin.pause();
    process18.stdin.setRawMode(false);
  }
  #handleInput(chunk) {
    if (chunk[0] === ASCII_ETX_CODE) {
      process18.emit("SIGINT");
    }
  }
}
var stdinDiscarder = new StdinDiscarder;
var stdin_discarder_default = stdinDiscarder;

// node_modules/ora/index.js
var import_cli_spinners2 = __toESM(require_cli_spinners(), 1);

class Ora {
  #linesToClear = 0;
  #isDiscardingStdin = false;
  #lineCount = 0;
  #frameIndex = -1;
  #lastSpinnerFrameTime = 0;
  #options;
  #spinner;
  #stream;
  #id;
  #initialInterval;
  #isEnabled;
  #isSilent;
  #indent;
  #text;
  #prefixText;
  #suffixText;
  color;
  constructor(options) {
    if (typeof options === "string") {
      options = {
        text: options
      };
    }
    this.#options = {
      color: "cyan",
      stream: process19.stderr,
      discardStdin: true,
      hideCursor: true,
      ...options
    };
    this.color = this.#options.color;
    this.spinner = this.#options.spinner;
    this.#initialInterval = this.#options.interval;
    this.#stream = this.#options.stream;
    this.#isEnabled = typeof this.#options.isEnabled === "boolean" ? this.#options.isEnabled : isInteractive({ stream: this.#stream });
    this.#isSilent = typeof this.#options.isSilent === "boolean" ? this.#options.isSilent : false;
    this.text = this.#options.text;
    this.prefixText = this.#options.prefixText;
    this.suffixText = this.#options.suffixText;
    this.indent = this.#options.indent;
    if (process19.env.NODE_ENV === "test") {
      this._stream = this.#stream;
      this._isEnabled = this.#isEnabled;
      Object.defineProperty(this, "_linesToClear", {
        get() {
          return this.#linesToClear;
        },
        set(newValue) {
          this.#linesToClear = newValue;
        }
      });
      Object.defineProperty(this, "_frameIndex", {
        get() {
          return this.#frameIndex;
        }
      });
      Object.defineProperty(this, "_lineCount", {
        get() {
          return this.#lineCount;
        }
      });
    }
  }
  get indent() {
    return this.#indent;
  }
  set indent(indent = 0) {
    if (!(indent >= 0 && Number.isInteger(indent))) {
      throw new Error("The `indent` option must be an integer from 0 and up");
    }
    this.#indent = indent;
    this.#updateLineCount();
  }
  get interval() {
    return this.#initialInterval ?? this.#spinner.interval ?? 100;
  }
  get spinner() {
    return this.#spinner;
  }
  set spinner(spinner) {
    this.#frameIndex = -1;
    this.#initialInterval = undefined;
    if (typeof spinner === "object") {
      if (spinner.frames === undefined) {
        throw new Error("The given spinner must have a `frames` property");
      }
      this.#spinner = spinner;
    } else if (!isUnicodeSupported12()) {
      this.#spinner = import_cli_spinners.default.line;
    } else if (spinner === undefined) {
      this.#spinner = import_cli_spinners.default.dots;
    } else if (spinner !== "default" && import_cli_spinners.default[spinner]) {
      this.#spinner = import_cli_spinners.default[spinner];
    } else {
      throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
    }
  }
  get text() {
    return this.#text;
  }
  set text(value = "") {
    this.#text = value;
    this.#updateLineCount();
  }
  get prefixText() {
    return this.#prefixText;
  }
  set prefixText(value = "") {
    this.#prefixText = value;
    this.#updateLineCount();
  }
  get suffixText() {
    return this.#suffixText;
  }
  set suffixText(value = "") {
    this.#suffixText = value;
    this.#updateLineCount();
  }
  get isSpinning() {
    return this.#id !== undefined;
  }
  #getFullPrefixText(prefixText = this.#prefixText, postfix = " ") {
    if (typeof prefixText === "string" && prefixText !== "") {
      return prefixText + postfix;
    }
    if (typeof prefixText === "function") {
      return prefixText() + postfix;
    }
    return "";
  }
  #getFullSuffixText(suffixText = this.#suffixText, prefix = " ") {
    if (typeof suffixText === "string" && suffixText !== "") {
      return prefix + suffixText;
    }
    if (typeof suffixText === "function") {
      return prefix + suffixText();
    }
    return "";
  }
  #updateLineCount() {
    const columns = this.#stream.columns ?? 80;
    const fullPrefixText = this.#getFullPrefixText(this.#prefixText, "-");
    const fullSuffixText = this.#getFullSuffixText(this.#suffixText, "-");
    const fullText = " ".repeat(this.#indent) + fullPrefixText + "--" + this.#text + "--" + fullSuffixText;
    this.#lineCount = 0;
    for (const line of stripAnsi11(fullText).split(`
`)) {
      this.#lineCount += Math.max(1, Math.ceil(stringWidth(line, { countAnsiEscapeCodes: true }) / columns));
    }
  }
  get isEnabled() {
    return this.#isEnabled && !this.#isSilent;
  }
  set isEnabled(value) {
    if (typeof value !== "boolean") {
      throw new TypeError("The `isEnabled` option must be a boolean");
    }
    this.#isEnabled = value;
  }
  get isSilent() {
    return this.#isSilent;
  }
  set isSilent(value) {
    if (typeof value !== "boolean") {
      throw new TypeError("The `isSilent` option must be a boolean");
    }
    this.#isSilent = value;
  }
  frame() {
    const now = Date.now();
    if (this.#frameIndex === -1 || now - this.#lastSpinnerFrameTime >= this.interval) {
      this.#frameIndex = ++this.#frameIndex % this.#spinner.frames.length;
      this.#lastSpinnerFrameTime = now;
    }
    const { frames } = this.#spinner;
    let frame = frames[this.#frameIndex];
    if (this.color) {
      frame = source_default[this.color](frame);
    }
    const fullPrefixText = typeof this.#prefixText === "string" && this.#prefixText !== "" ? this.#prefixText + " " : "";
    const fullText = typeof this.text === "string" ? " " + this.text : "";
    const fullSuffixText = typeof this.#suffixText === "string" && this.#suffixText !== "" ? " " + this.#suffixText : "";
    return fullPrefixText + frame + fullText + fullSuffixText;
  }
  clear() {
    if (!this.#isEnabled || !this.#stream.isTTY) {
      return this;
    }
    this.#stream.cursorTo(0);
    for (let index = 0;index < this.#linesToClear; index++) {
      if (index > 0) {
        this.#stream.moveCursor(0, -1);
      }
      this.#stream.clearLine(1);
    }
    if (this.#indent || this.lastIndent !== this.#indent) {
      this.#stream.cursorTo(this.#indent);
    }
    this.lastIndent = this.#indent;
    this.#linesToClear = 0;
    return this;
  }
  render() {
    if (this.#isSilent) {
      return this;
    }
    this.clear();
    this.#stream.write(this.frame());
    this.#linesToClear = this.#lineCount;
    return this;
  }
  start(text) {
    if (text) {
      this.text = text;
    }
    if (this.#isSilent) {
      return this;
    }
    if (!this.#isEnabled) {
      if (this.text) {
        this.#stream.write(`- ${this.text}
`);
      }
      return this;
    }
    if (this.isSpinning) {
      return this;
    }
    if (this.#options.hideCursor) {
      cli_cursor_default.hide(this.#stream);
    }
    if (this.#options.discardStdin && process19.stdin.isTTY) {
      this.#isDiscardingStdin = true;
      stdin_discarder_default.start();
    }
    this.render();
    this.#id = setInterval(this.render.bind(this), this.interval);
    return this;
  }
  stop() {
    if (!this.#isEnabled) {
      return this;
    }
    clearInterval(this.#id);
    this.#id = undefined;
    this.#frameIndex = 0;
    this.clear();
    if (this.#options.hideCursor) {
      cli_cursor_default.show(this.#stream);
    }
    if (this.#options.discardStdin && process19.stdin.isTTY && this.#isDiscardingStdin) {
      stdin_discarder_default.stop();
      this.#isDiscardingStdin = false;
    }
    return this;
  }
  succeed(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.success, text });
  }
  fail(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.error, text });
  }
  warn(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.warning, text });
  }
  info(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.info, text });
  }
  stopAndPersist(options = {}) {
    if (this.#isSilent) {
      return this;
    }
    const prefixText = options.prefixText ?? this.#prefixText;
    const fullPrefixText = this.#getFullPrefixText(prefixText, " ");
    const symbolText = options.symbol ?? " ";
    const text = options.text ?? this.text;
    const separatorText = symbolText ? " " : "";
    const fullText = typeof text === "string" ? separatorText + text : "";
    const suffixText = options.suffixText ?? this.#suffixText;
    const fullSuffixText = this.#getFullSuffixText(suffixText, " ");
    const textToWrite = fullPrefixText + symbolText + fullText + fullSuffixText + `
`;
    this.stop();
    this.#stream.write(textToWrite);
    return this;
  }
}
function ora(options) {
  return new Ora(options);
}

// src/commands/create.ts
import https from "https";

// node_modules/unzip-stream/unzip.js
var $Parse = require_parser_stream();
var $Extract = require_extract();

// src/commands/create.ts
process.removeAllListeners("warning");
var PIPE_ADDITIONS = {
  dependencies: {
    "@screenpipe/js": "latest"
  },
  devDependencies: {
    "bun-types": "latest"
  }
};
async function downloadAndExtractRepo(owner, repo, branch, subdir, destPath) {
  const url = `https://github.com/${owner}/${repo}/archive/refs/heads/${branch}.zip`;
  const tempDir = path.join(destPath, "_temp");
  await import_fs_extra.default.ensureDir(tempDir);
  return new Promise((resolve, reject) => {
    const request = https.get(url, (response) => {
      if (response.statusCode === 302 || response.statusCode === 301) {
        const redirectUrl = response.headers.location;
        if (!redirectUrl) {
          reject(new Error("Redirect location not found"));
          return;
        }
        https.get(redirectUrl, async (redirectResponse) => {
          if (redirectResponse.statusCode !== 200) {
            reject(new Error(`Failed to download: ${redirectResponse.statusCode}`));
            return;
          }
          const extractStream = $Extract({ path: tempDir });
          extractStream.on("finish", async () => {
            try {
              const sourcePath = path.join(tempDir, `screenpipe-${branch}`, subdir);
              await import_fs_extra.default.copy(sourcePath, destPath);
              await import_fs_extra.default.remove(tempDir);
              console.log("extraction completed");
              resolve();
            } catch (err) {
              reject(err);
            }
          });
          extractStream.on("error", async (err) => {
            await import_fs_extra.default.remove(tempDir).catch(console.error);
            reject(err);
          });
          redirectResponse.pipe(extractStream);
        }).on("error", async (err) => {
          await import_fs_extra.default.remove(tempDir).catch(console.error);
          reject(err);
        });
      } else {
        reject(new Error(`Failed to download: ${response.statusCode}`));
      }
    }).on("error", async (err) => {
      await import_fs_extra.default.remove(tempDir).catch(console.error);
      reject(err);
    });
    request.end();
  });
}
var createCommand = command({
  name: "create",
  desc: "create a new pipe template",
  handler: async () => {
    console.log(source_default.bold(`
welcome to create-pipe! \uD83D\uDE80
`));
    console.log(`let's create a new screenpipe pipe.
`);
    console.log("pipes are plugins that interact with captured screen and audio data.");
    console.log(`build powerful agents, monetize it, etc.
`);
    const pipeName = await esm_default8({
      message: "what is your pipe name?",
      default: "my-screenpipe",
      validate: (input) => {
        if (input.trim().length === 0)
          return "pipe name is required";
        return true;
      }
    });
    const directory = await esm_default8({
      message: "where would you like to create your pipe?",
      default: pipeName
    });
    const spinner = ora("creating your pipe...").start();
    try {
      await downloadAndExtractRepo("mediar-ai", "screenpipe", "main", "pipes/obsidian", directory);
      const pkgPath = path.join(process.cwd(), directory, "package.json");
      const pkg = await import_fs_extra.default.readJson(pkgPath);
      pkg.name = pipeName;
      pkg.dependencies = {
        ...pkg.dependencies,
        ...PIPE_ADDITIONS.dependencies
      };
      pkg.devDependencies = {
        ...pkg.devDependencies,
        ...PIPE_ADDITIONS.devDependencies
      };
      await import_fs_extra.default.writeJson(pkgPath, pkg, { spaces: 2 });
      spinner.succeed(source_default.green("pipe created successfully! \uD83C\uDF89"));
      console.log(`
to get started:`);
      console.log(source_default.cyan(`cd ${directory}`));
      console.log(source_default.cyan("bun install    # or use: npm install, pnpm install, yarn"));
      console.log(source_default.cyan("bun dev      # or use: npm run dev, pnpm dev, yarn dev"));
      console.log(`
when you're ready, you can ship your pipe to the app by adding it to the pipe store using the UI and then send a PR to the main repo.
`);
    } catch (error) {
      spinner.fail("failed to create pipe");
      console.error(error);
      process.exit(1);
    }
  }
});
// src/constants.ts
var API_BASE_URL = process.env.SC_API_BASE_URL || "https://screenpi.pe";

// src/utils/credentials.ts
import os2 from "os";
import fs2 from "fs";
import path2 from "path";

class Credentials {
  static configDir = path2.join(os2.homedir(), ".screenpipe");
  static configFile = path2.join(this.configDir, "config-developer.json");
  static getApiKey() {
    try {
      if (!fs2.existsSync(this.configFile)) {
        return null;
      }
      const config = JSON.parse(fs2.readFileSync(this.configFile, "utf-8"));
      return config.apiKey || null;
    } catch (error) {
      return null;
    }
  }
  static setApiKey(apiKey, developerId) {
    if (!fs2.existsSync(this.configDir)) {
      fs2.mkdirSync(this.configDir);
    }
    fs2.writeFileSync(this.configFile, JSON.stringify({
      apiKey,
      developerId
    }, null, 2));
  }
  static clearCredentials() {
    if (fs2.existsSync(this.configFile)) {
      fs2.unlinkSync(this.configFile);
    }
  }
}

// src/utils/colors.ts
var colors21 = {
  primary: source_default.cyan,
  success: source_default.green,
  error: source_default.red,
  warning: source_default.yellow,
  info: source_default.blue,
  dim: source_default.gray,
  highlight: source_default.magenta,
  bold: source_default.bold,
  header: (text) => source_default.bold.cyan(`
${text}`),
  subHeader: (text) => source_default.dim(`${text}`),
  listItem: (text) => source_default.cyan(`  * ${text}`),
  label: (text) => source_default.bold.blue(`${text}:`),
  value: (text) => source_default.white(`${text}`)
};
var symbols = {
  success: "+",
  error: "x",
  warning: "!",
  info: "i",
  arrow: ">"
};

// src/commands/login.ts
var loginCommand = command({
  name: "login",
  options: {
    apiKey: string().required().desc("API key to login with")
  },
  handler: async (opts) => {
    try {
      console.log(colors21.info(`
${symbols.info} Validating API key...`));
      const response = await fetch(`${API_BASE_URL}/api/plugins/dev-status`, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${opts.apiKey}`,
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`Failed to validate API key ${error.error}`);
      }
      const data = await response.json();
      if (data.data.needs_name) {
        const inquirer2 = (await Promise.resolve().then(() => (init_esm33(), exports_esm))).default;
        const { developerName } = await inquirer2.prompt([
          {
            type: "input",
            name: "developerName",
            message: "Enter your developer name:",
            validate: (input) => {
              if (input.length < 2) {
                return "Developer name must be at least 2 characters";
              }
              if (input.length > 50) {
                return "Developer name must be less than 50 characters";
              }
              return true;
            }
          }
        ]);
        const updateResponse = await fetch(`${API_BASE_URL}/api/plugins/dev-status`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${opts.apiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ developer_name: developerName })
        });
        if (!updateResponse.ok) {
          const error = await updateResponse.json();
          throw new Error(`Failed to set developer name: ${error.error}`);
        }
        const updateData = await updateResponse.json();
        data.data.developer_name = updateData.data.developer_name;
      }
      console.log(colors21.success(`
${symbols.success} Successfully logged in!`));
      console.log(colors21.listItem(`${colors21.label("Developer ID")} ${data.data.developer_id}`));
      console.log(colors21.listItem(`${colors21.label("Developer Name")} ${data.data.developer_name}`));
      Credentials.setApiKey(opts.apiKey, data.data.developer_id);
    } catch (error) {
      if (error instanceof Error) {
        console.error(colors21.error(`
${symbols.error} Login failed: ${error.message}`));
      } else {
        console.error(colors21.error(`
${symbols.error} Login failed with unexpected error`));
      }
      process.exit(1);
    }
  }
});
// src/commands/logout.ts
var logoutCommand = command({
  name: "logout",
  desc: "End current session",
  handler: async () => {
    Credentials.clearCredentials();
    console.log(colors21.success(`
${symbols.success} Successfully logged out`));
    console.log(colors21.info(`${symbols.info} Thanks for using ScreenPipe! Come back soon.`));
  }
});
// src/commands/publish.ts
import fs3 from "fs";
import path3 from "path";
var import_archiver = __toESM(require_archiver(), 1);
var import_ignore = __toESM(require_ignore2(), 1);
import crypto from "crypto";
var NEXTJS_FILES = {
  required: ["package.json", ".next"],
  optional: [
    "package-lock.json",
    "bun.lockb",
    "next.config.js",
    "next.config.mjs"
  ]
};
var MAX_FILE_SIZE = 500 * 1024 * 1024;
async function archiveNextJsProject(archive) {
  const { required, optional } = NEXTJS_FILES;
  const missingFiles = required.filter((file) => !fs3.existsSync(file));
  if (missingFiles.length > 0) {
    throw new Error(`Required files not found: ${missingFiles.join(", ")}. ` + "Make sure you're in the correct directory and the project is built.");
  }
  for (const file of required) {
    if (file === ".next") {
      archive.directory(".next", ".next", (entry) => {
        return entry.name.startsWith(".next/cache/") ? false : entry;
      });
    } else {
      archive.file(file, { name: file });
    }
  }
  optional.filter((file) => fs3.existsSync(file)).forEach((file) => {
    archive.file(file, { name: file });
  });
}
function archiveStandardProject(archive, ig) {
  archive.glob("**/*", {
    ignore: [".git/**", "node_modules/**", ".next/cache/**"],
    dot: true,
    nodir: false,
    mark: true
  });
}
var publishCommand = command({
  name: "publish",
  desc: "Deploy new pipe (includes pricing for paid)",
  options: {
    name: string().required().desc("name of the pipe"),
    verbose: boolean().desc("enable verbose logging").default(false)
  },
  handler: async (opts) => {
    try {
      if (opts.verbose) {
        console.log(colors21.dim(`${symbols.arrow} starting publish command...`));
      }
      const apiKey = Credentials.getApiKey();
      if (!apiKey) {
        console.error(colors21.error(`${symbols.error} Not logged in. Please login first using ${colors21.highlight("screenpipe login")}`));
        process.exit(1);
      }
      if (opts.verbose) {
        console.log(colors21.dim(`${symbols.arrow} reading package.json...`));
      }
      let packageJson;
      try {
        packageJson = JSON.parse(fs3.readFileSync("package.json", "utf-8"));
      } catch (error) {
        console.error(colors21.error(`${symbols.error} Failed to read package.json. Make sure you're in the correct directory.`));
        process.exit(1);
      }
      if (!packageJson.name || !packageJson.version) {
        console.error(colors21.error(`${symbols.error} Package name and version are required in package.json`));
        process.exit(1);
      }
      console.log(colors21.info(`
${symbols.info} Publishing ${colors21.highlight(packageJson.name)} v${packageJson.version}...`));
      console.log(colors21.dim(`${symbols.arrow} Creating package archive...`));
      const zipPath = path3.join(process.cwd(), `${packageJson.name}-${packageJson.version}.zip`);
      const output = fs3.createWriteStream(zipPath);
      const archive = import_archiver.default("zip", { zlib: { level: 9 } });
      const ig = import_ignore.default();
      if (fs3.existsSync(".gitignore")) {
        ig.add(fs3.readFileSync(".gitignore").toString());
      }
      const isNextProject = fs3.existsSync("next.config.js") || fs3.existsSync("next.config.mjs") || fs3.existsSync("next.config.ts");
      archive.pipe(output);
      if (isNextProject) {
        await archiveNextJsProject(archive);
      } else {
        archiveStandardProject(archive, ig);
      }
      await new Promise((resolve, reject) => {
        output.on("close", resolve);
        archive.on("error", reject);
        archive.finalize();
      });
      if (opts.verbose) {
        console.log(colors21.dim(`${symbols.arrow} detected project type: ${isNextProject ? "nextjs" : "standard"}`));
        console.log(colors21.dim(`${symbols.arrow} starting archive creation...`));
      }
      const fileBuffer = fs3.readFileSync(zipPath);
      const hashSum = crypto.createHash("sha256");
      hashSum.update(fileBuffer);
      const fileHash = hashSum.digest("hex");
      const fileSize = fs3.statSync(zipPath).size;
      if (fileSize > MAX_FILE_SIZE) {
        console.error(colors21.error(`${symbols.error} Package size (${(fileSize / 1024 / 1024).toFixed(2)}MB) exceeds maximum allowed size (${MAX_FILE_SIZE / 1024 / 1024}MB)`));
        fs3.unlinkSync(zipPath);
        process.exit(1);
      }
      let description = null;
      try {
        const readmeContent = fs3.readFileSync("README.md", "utf-8");
        if (readmeContent) {
          description = readmeContent;
        }
      } catch (error) {
        console.log(colors21.dim(`${symbols.arrow} No README.md found, required for description`));
      }
      if (!description) {
        console.error(colors21.error(`${symbols.error} Description is required`));
        process.exit(1);
      }
      if (opts.verbose) {
        console.log(colors21.dim(`${symbols.arrow} calculating file hash...`));
      }
      try {
        console.log(colors21.dim(`${symbols.arrow} Getting upload URL...`));
        const urlResponse = await fetch(`${API_BASE_URL}/api/plugins/publish`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${apiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            name: opts.name,
            version: packageJson.version,
            fileSize,
            fileHash,
            description
          })
        });
        if (!urlResponse.ok) {
          throw new Error(`Failed to get upload URL: ${await urlResponse.text()}`);
        }
        const { uploadUrl, path: path4 } = await urlResponse.json();
        console.log(colors21.dim(`${symbols.arrow} Uploading to storage...`));
        const uploadResponse = await fetch(uploadUrl, {
          method: "PUT",
          headers: {
            "Content-Type": "application/zip"
          },
          body: fileBuffer
        });
        if (!uploadResponse.ok) {
          throw new Error("Failed to upload file to storage");
        }
        console.log(colors21.dim(`${symbols.arrow} Finalizing upload...`));
        const finalizeResponse = await fetch(`${API_BASE_URL}/api/plugins/publish/finalize`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${apiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            name: opts.name,
            version: packageJson.version,
            fileHash,
            storagePath: path4,
            description,
            fileSize
          })
        });
        if (!finalizeResponse.ok) {
          throw new Error(`Failed to finalize upload: ${await finalizeResponse.text()}`);
        }
        const data = await finalizeResponse.json();
        console.log(colors21.success(`
${symbols.success} Successfully published plugin!`));
        console.log(colors21.listItem(`${colors21.label("Name")} ${packageJson.name}`));
        console.log(colors21.listItem(`${colors21.label("Version")} ${packageJson.version}`));
        console.log(colors21.listItem(`${colors21.label("Size")} ${(fileSize / 1024).toFixed(2)} KB`));
        if (data.message) {
          console.log(colors21.info(`
${symbols.info} ${data.message}`));
        }
        fs3.unlinkSync(zipPath);
        if (opts.verbose) {
          console.log(colors21.dim(`${symbols.arrow} cleaned up temporary zip file`));
        }
      } catch (error) {
        if (fs3.existsSync(zipPath)) {
          fs3.unlinkSync(zipPath);
          if (opts.verbose) {
            console.log(colors21.dim(`${symbols.arrow} cleaned up temporary zip file`));
          }
        }
        if (error instanceof Error) {
          console.error(colors21.error(`
${symbols.error} Publishing failed: ${error.message}`));
        }
        process.exit(1);
      }
    } catch (error) {
      if (error instanceof Error) {
        console.error(colors21.error(`
${symbols.error} Publishing failed: ${error.message}`));
      } else {
        console.error(colors21.error(`
${symbols.error} Publishing failed with unexpected error`));
      }
      process.exit(1);
    }
  }
});
// src/commands/register.ts
import fs4 from "fs";
var registerCommand = command({
  name: "register",
  desc: "register a new pipe",
  options: {
    name: string().required().desc("name of the pipe"),
    paid: boolean().desc("set this flag to create a paid pipe"),
    price: number().desc("price in USD (required for paid pipes)"),
    source: string().desc("source code URL (e.g. GitHub repository)")
  },
  transform: (opts) => {
    if (opts.paid && !opts.price) {
      throw new Error("Price is required for paid pipes, i.e. --price <amount>");
    }
    if (opts.paid && opts.price && opts.price <= 0) {
      throw new Error("Price must be positive for paid pipes");
    }
    return opts;
  },
  handler: async (opts) => {
    try {
      const apiKey = Credentials.getApiKey();
      if (!apiKey) {
        console.error(colors21.error(`${symbols.error} Not logged in. Please login first using ${colors21.highlight("screenpipe login")}`));
        process.exit(1);
      }
      let packageJson;
      try {
        packageJson = JSON.parse(fs4.readFileSync("package.json", "utf-8"));
      } catch (error) {
        console.error(colors21.error(`${symbols.error} Failed to read package.json. Make sure you're in the correct directory.`));
        process.exit(1);
      }
      const isPaid = opts.paid || false;
      const price = opts.price;
      let description = null;
      try {
        const readmeContent = fs4.readFileSync("README.md", "utf-8");
        if (readmeContent) {
          description = readmeContent;
        }
      } catch (error) {
        console.log(colors21.dim(`${symbols.arrow} No README.md found, required for description`));
      }
      const response = await fetch(`${API_BASE_URL}/api/plugins/create`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name: opts.name,
          description,
          is_paid: isPaid,
          price: isPaid ? price : null,
          source_url: opts.source || null
        })
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to create plugin");
      }
      const data = await response.json();
      console.log(colors21.success(`
${symbols.success} Successfully created pipe: ${colors21.highlight(opts.name)}`));
      console.log(colors21.info(`
${symbols.info} Plugin Details:`));
      console.log(colors21.listItem(`${colors21.label("Name")} ${opts.name}`));
      console.log(colors21.listItem(`${colors21.label("Type")} ${isPaid ? `Paid ($${price})` : "Free"}`));
      if (opts.source) {
        console.log(colors21.listItem(`${colors21.label("Source")} ${opts.source}`));
      }
    } catch (error) {
      if (error instanceof Error) {
        console.error(colors21.error(`
${symbols.error} Creating failed: ${error.message}`));
      } else {
        console.error(colors21.error(`
${symbols.error} Creating failed with unexpected error`));
      }
      process.exit(1);
    }
  }
});
// src/commands/list-versions.ts
var listVersionsCommand = command({
  name: "list-versions",
  desc: "List all versions of a pipe",
  options: {
    name: string().required().desc("name of the pipe")
  },
  handler: async (opts) => {
    try {
      const response = await fetch(`${API_BASE_URL}/api/plugins/list-versions`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${Credentials.getApiKey()}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name: opts.name
        })
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`Failed to list versions ${error.error}`);
      }
      const data = await response.json();
      console.log(colors21.header(`Plugin Information`));
      console.log(colors21.listItem(`${colors21.label("Name")} ${opts.name}`));
      console.log(colors21.listItem(`${colors21.label("ID")} ${data.plugin_id}`));
      console.log(colors21.header("Version History"));
      data.versions.forEach((version) => {
        const status = version.status === "published" ? colors21.success(version.status) : colors21.warning(version.status);
        console.log(colors21.primary(`
  ${symbols.arrow} Version ${colors21.bold(version.version)} ${colors21.dim(`(${status})`)}`));
        console.log(colors21.listItem(`${colors21.label("Created")} ${new Date(version.created_at).toLocaleString()}`));
        console.log(colors21.listItem(`${colors21.label("Size")} ${(version.file_size / 1024).toFixed(2)} KB`));
        console.log(colors21.listItem(`${colors21.label("Hash")} ${colors21.dim(version.file_hash)}`));
        if (version.changelog) {
          console.log(colors21.listItem(`${colors21.label("Changelog")} ${version.changelog}`));
        }
      });
    } catch (error) {
      if (error instanceof Error) {
        console.error(colors21.error(`
${symbols.error} List versions failed: ${error.message}`));
      } else {
        console.error(colors21.error(`
${symbols.error} List versions failed with unexpected error`));
      }
      process.exit(1);
    }
  }
});
// node_modules/kleur/colors.mjs
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
var $ = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY)
};
function init(x, y) {
  let rgx = new RegExp(`\\x1b\\[${y}m`, "g");
  let open = `\x1B[${x}m`, close = `\x1B[${y}m`;
  return function(txt) {
    if (!$.enabled || txt == null)
      return txt;
    return open + (~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
  };
}
var reset = init(0, 0);
var bold = init(1, 22);
var dim = init(2, 22);
var italic = init(3, 23);
var underline = init(4, 24);
var inverse = init(7, 27);
var hidden = init(8, 28);
var strikethrough = init(9, 29);
var black = init(30, 39);
var red = init(31, 39);
var green = init(32, 39);
var yellow = init(33, 39);
var blue = init(34, 39);
var magenta = init(35, 39);
var cyan = init(36, 39);
var white = init(37, 39);
var gray = init(90, 39);
var grey = init(90, 39);
var bgBlack = init(40, 49);
var bgRed = init(41, 49);
var bgGreen = init(42, 49);
var bgYellow = init(43, 49);
var bgBlue = init(44, 49);
var bgMagenta = init(45, 49);
var bgCyan = init(46, 49);
var bgWhite = init(47, 49);

// src/commands/components/commands/add/utils/logger.ts
var highlighter = {
  error: red,
  warn: yellow,
  info: cyan,
  success: green
};
var logger = {
  error(...args) {
    console.log(highlighter.error(args.join(" ")));
  },
  warn(...args) {
    console.log(highlighter.warn(args.join(" ")));
  },
  info(...args) {
    console.log(highlighter.info(args.join(" ")));
  },
  success(...args) {
    console.log(highlighter.success(args.join(" ")));
  },
  log(...args) {
    console.log(args.join(" "));
  },
  break() {
    console.log("");
  }
};
function spinner(text, options) {
  return ora({
    text,
    isSilent: options?.silent
  });
}

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key12 in object) {
      if (Object.prototype.hasOwnProperty.call(object, key12)) {
        keys.push(key12);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_3, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal2 = i === issue.path.length - 1;
            if (!terminal2) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path: path4, errorMaps, issueData } = params;
  const fullPath = [...path4, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? undefined : errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key12 = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key: key12,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key: key12, value } = pair;
      if (key12.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key12.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key12.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key12.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;

class ParseInputLazyPath {
  constructor(parent, value, path4, key12) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path4;
    this._key = key12;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== undefined ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== undefined ? message : required_error) !== null && _a !== undefined ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== undefined ? message : invalid_type_error) !== null && _b !== undefined ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === undefined ? undefined : err.message) === null || _a === undefined ? undefined : _a.toLowerCase()) === null || _b === undefined ? undefined : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex2;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex2 = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex2 = `${regex2}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex2 = `${regex2}(\\.\\d+)?`;
  }
  return regex2;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex2 = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex2 = `${regex2}(${opts.join("|")})`;
  return new RegExp(`^${regex2}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex2) {
          emojiRegex2 = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex2 = datetimeRegex(check2);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "date") {
        const regex2 = dateRegex;
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "time") {
        const regex2 = timeRegex(check2);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "jwt") {
        if (!isValidJWT(input.data, check2.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cidr") {
        if (!isValidCidr(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data) => regex2.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      local: (_b = options === null || options === undefined ? undefined : options.local) !== null && _b !== undefined ? _b : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key12 in schema.shape) {
      const fieldSchema = schema.shape[key12];
      newShape[key12] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key12 in ctx.data) {
        if (!shapeKeys.includes(key12)) {
          extraKeys.push(key12);
        }
      }
    }
    const pairs = [];
    for (const key12 of shapeKeys) {
      const keyValidator = shape[key12];
      const value = ctx.data[key12];
      pairs.push({
        key: { status: "valid", value: key12 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key12)),
        alwaysSet: key12 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key12 of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key12 },
            value: { status: "valid", value: ctx.data[key12] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key12 of extraKeys) {
        const value = ctx.data[key12];
        pairs.push({
          key: { status: "valid", value: key12 },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key12)),
          alwaysSet: key12 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key12 = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key: key12,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key12, schema) {
    return this.augment({ [key12]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key12) => {
      if (mask[key12] && this.shape[key12]) {
        shape[key12] = this.shape[key12];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key12) => {
      if (!mask[key12]) {
        shape[key12] = this.shape[key12];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key12) => {
      const fieldSchema = this.shape[key12];
      if (mask && !mask[key12]) {
        newShape[key12] = fieldSchema;
      } else {
        newShape[key12] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key12) => {
      if (mask && !mask[key12]) {
        newShape[key12] = this.shape[key12];
      } else {
        const fieldSchema = this.shape[key12];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key12] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key12) => bKeys.indexOf(key12) !== -1);
    const newObj = { ...a, ...b };
    for (const key12 of sharedKeys) {
      const sharedValue = mergeValues(a[key12], b[key12]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key12] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key12 in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key12, ctx.path, key12)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key12], ctx.path, key12)),
        alwaysSet: key12 in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key12, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key12, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key12 = await pair.key;
          const value = await pair.value;
          if (key12.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key12.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key12.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key12 = pair.key;
        const value = pair.value;
        if (key12.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key12.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key12.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, undefined);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = new WeakMap;
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, undefined);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = new WeakMap;
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function custom(check2, params = {}, fatal) {
  if (check2)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check2(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/commands/components/commands/add/utils/handle-error.ts
function handleError(error) {
  logger.error(`Something went wrong. Please check the error below for more details.`);
  logger.error(`If the problem persists, please open an issue on GitHub.`);
  logger.error("");
  if (typeof error === "string") {
    logger.error(error);
    logger.break();
    process.exit(1);
  }
  if (error instanceof z.ZodError) {
    logger.error("Validation failed:");
    for (const [key12, value] of Object.entries(error.flatten().fieldErrors)) {
      logger.error(`- ${highlighter.info(key12)}: ${value}`);
    }
    logger.break();
    process.exit(1);
  }
  if (error instanceof Error) {
    logger.error(error.message);
    logger.break();
    process.exit(1);
  }
  logger.break();
  process.exit(1);
}
var ERRORS = {
  MISSING_DIR_OR_EMPTY_PIPE: "1",
  COMPONENT_NOT_FOUND: "2",
  BUILD_MISSING_REGISTRY_FILE: "3"
};

// src/commands/components/commands/add/utils/prompt-for-component.ts
var import_prompts3 = __toESM(require_prompts3(), 1);

// src/commands/components/commands/add/registry/schema.ts
var registryComponentSchema = z.object({
  name: z.string(),
  src: z.string(),
  internal: z.boolean().optional(),
  docs: z.string().optional(),
  target: z.string(),
  dependencies: z.array(z.string()).optional(),
  registryDependencies: z.array(z.string()).optional(),
  devDependencies: z.array(z.string()).optional()
});
var registrySchema = z.record(z.string(), registryComponentSchema);
var registryResolvedComponentsTreeSchema = registryComponentSchema.pick({
  dependencies: true,
  devDependencies: true,
  docs: true
}).merge(z.object({
  files: z.array(z.object({
    src: z.string(),
    target: z.string()
  }))
}));

// src/commands/components/commands/add/registry/registry.json
var registry_default = {
  "use-health": {
    name: "use-health",
    src: "https://api.github.com/repos/mediar-ai/screenpipe/contents/pipes/obsidian/src/lib/hooks/use-health-check.tsx",
    target: "./src/hooks/use-health.tsx",
    dependencies: [
      "lodash"
    ],
    devDependencies: [
      "@types/lodash"
    ]
  },
  "use-settings": {
    name: "use-settings",
    src: "https://api.github.com/repos/mediar-ai/screenpipe/contents/pipes/obsidian/src/lib/hooks/use-settings.tsx",
    target: "./src/hooks/use-settings.ts",
    dependencies: [
      "@screenpipe/browser"
    ],
    registryDependencies: [
      "route-settings"
    ]
  },
  "route-settings": {
    name: "route-settings",
    src: "https://api.github.com/repos/mediar-ai/screenpipe/contents/pipes/obsidian/src/app/api/settings/route.ts",
    target: "./src/app/api/settings/route.ts",
    dependencies: [
      "@screenpipe/js"
    ]
  },
  "use-sql-autocomplete": {
    name: "use-sql-autocomplete",
    src: "https://api.github.com/repos/mediar-ai/screenpipe/contents/screenpipe-app-tauri/components/sql-autocomplete-input.tsx",
    target: "./src/hooks/use-sql-autocomplete.ts"
  },
  "sql-autocomplete-input": {
    name: "sql-autocomplete-input",
    src: "https://api.github.com/repos/mediar-ai/screenpipe/contents/screenpipe-app-tauri/components/sql-autocomplete-input.tsx",
    target: "./src/components/sql-autocomplete-input.ts",
    dependencies: [
      "cmdk",
      "lucide-react"
    ],
    registryDependencies: [
      "use-sql-autocomplete"
    ]
  }
};

// src/commands/components/commands/add/registry/api.ts
var import_deepmerge = __toESM(require_cjs2(), 1);
async function getRegistry() {
  try {
    const parsedRegistry = registrySchema.parse(registry_default);
    return parsedRegistry;
  } catch (error) {
    logger.error(`
`);
    handleError(error);
  }
}
async function resolveRegistryItems(names) {
  let registryDependencies = {};
  const registry = await getRegistry();
  if (!registry)
    return;
  for (const name of names) {
    const itemRegistryDependencies = await resolveRegistryDependencies(name, registry);
    registryDependencies = {
      ...registryDependencies,
      ...itemRegistryDependencies
    };
  }
  return registryDependencies;
}
async function resolveRegistryDependencies(name, registry) {
  const components = {};
  async function resolveDependencies(componentName) {
    try {
      if (registry[componentName]) {
        components[componentName] = registry[componentName];
      } else {
        throw Error(componentName);
      }
      if (registry[componentName].registryDependencies) {
        for (const dependency of registry[componentName].registryDependencies) {
          await resolveDependencies(dependency);
        }
      }
    } catch (error) {
      console.error(`Component ${error.message} not found.`, error);
    }
  }
  await resolveDependencies(name);
  return components;
}
async function registryResolveItemsTree(names) {
  try {
    let relevantItemsRegistry = await resolveRegistryItems(names);
    const payload = registrySchema.parse(relevantItemsRegistry);
    if (!payload) {
      return null;
    }
    const componentArray = Object.values(payload);
    let docs = "";
    componentArray.forEach((item) => {
      if (item.docs) {
        docs += `${item.docs}
`;
      }
    });
    return registryResolvedComponentsTreeSchema.parse({
      dependencies: import_deepmerge.default.all(componentArray.map((item) => item.dependencies ?? [])),
      devDependencies: import_deepmerge.default.all(componentArray.map((item) => item.devDependencies ?? [])),
      files: componentArray.map((item) => {
        return {
          src: item.src,
          target: item.target
        };
      }),
      docs
    });
  } catch (error) {
    handleError(error);
    return null;
  }
}

// src/commands/components/commands/add/utils/prompt-for-component.ts
async function promptForRegistryComponents(all) {
  const registryIndex = await getRegistry();
  if (!registryIndex) {
    logger.break();
    handleError(new Error("Failed to fetch registry index."));
    return [];
  }
  if (all) {
    return Object.values(registryIndex).map((entry) => entry.name);
  }
  const { components } = await import_prompts3.default({
    type: "multiselect",
    name: "components",
    message: "Which components would you like to add?",
    hint: "Space to select. A to toggle all. Enter to submit.",
    instructions: false,
    choices: Object.values(registryIndex).map((entry) => ({
      title: entry.name,
      value: entry.name
    }))
  });
  if (!components?.length) {
    logger.warn("No components selected. Exiting.");
    logger.info("");
    process.exit(1);
  }
  const result = z.array(z.string()).safeParse(components);
  if (!result.success) {
    logger.error("");
    handleError(new Error("Something went wrong. Please try again."));
    return [];
  }
  return result.data;
}

// src/commands/components/commands/add/preflights/preflight-add.ts
import fs5 from "fs";
import path4 from "path";
async function preFlightAdd(cwd) {
  const errors12 = {};
  if (!fs5.existsSync(cwd) || !fs5.existsSync(path4.resolve(cwd, "package.json"))) {
    errors12[ERRORS.MISSING_DIR_OR_EMPTY_PIPE] = true;
    return {
      errors: errors12
    };
  }
}

// node_modules/is-plain-obj/index.js
function isPlainObject11(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/execa/lib/arguments/file-url.js
import { fileURLToPath } from "node:url";
var safeNormalizeFileUrl = (file, name) => {
  const fileString = normalizeFileUrl(normalizeDenoExecPath(file));
  if (typeof fileString !== "string") {
    throw new TypeError(`${name} must be a string or a file URL: ${fileString}.`);
  }
  return fileString;
};
var normalizeDenoExecPath = (file) => isDenoExecPath(file) ? file.toString() : file;
var isDenoExecPath = (file) => typeof file !== "string" && file && Object.getPrototypeOf(file) === String.prototype;
var normalizeFileUrl = (file) => file instanceof URL ? fileURLToPath(file) : file;

// node_modules/execa/lib/methods/parameters.js
var normalizeParameters = (rawFile, rawArguments = [], rawOptions = {}) => {
  const filePath = safeNormalizeFileUrl(rawFile, "First argument");
  const [commandArguments, options] = isPlainObject11(rawArguments) ? [[], rawArguments] : [rawArguments, rawOptions];
  if (!Array.isArray(commandArguments)) {
    throw new TypeError(`Second argument must be either an array of arguments or an options object: ${commandArguments}`);
  }
  if (commandArguments.some((commandArgument) => typeof commandArgument === "object" && commandArgument !== null)) {
    throw new TypeError(`Second argument must be an array of strings: ${commandArguments}`);
  }
  const normalizedArguments = commandArguments.map(String);
  const nullByteArgument = normalizedArguments.find((normalizedArgument) => normalizedArgument.includes("\x00"));
  if (nullByteArgument !== undefined) {
    throw new TypeError(`Arguments cannot contain null bytes ("\\0"): ${nullByteArgument}`);
  }
  if (!isPlainObject11(options)) {
    throw new TypeError(`Last argument must be an options object: ${options}`);
  }
  return [filePath, normalizedArguments, options];
};

// node_modules/execa/lib/methods/template.js
import { ChildProcess } from "node:child_process";

// node_modules/execa/lib/utils/uint-array.js
import { StringDecoder } from "node:string_decoder";
var { toString: objectToString } = Object.prototype;
var isArrayBuffer = (value) => objectToString.call(value) === "[object ArrayBuffer]";
var isUint8Array = (value) => objectToString.call(value) === "[object Uint8Array]";
var bufferToUint8Array = (buffer) => new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
var textEncoder = new TextEncoder;
var stringToUint8Array = (string2) => textEncoder.encode(string2);
var textDecoder = new TextDecoder;
var uint8ArrayToString = (uint8Array) => textDecoder.decode(uint8Array);
var joinToString = (uint8ArraysOrStrings, encoding) => {
  const strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);
  return strings.join("");
};
var uint8ArraysToStrings = (uint8ArraysOrStrings, encoding) => {
  if (encoding === "utf8" && uint8ArraysOrStrings.every((uint8ArrayOrString) => typeof uint8ArrayOrString === "string")) {
    return uint8ArraysOrStrings;
  }
  const decoder = new StringDecoder(encoding);
  const strings = uint8ArraysOrStrings.map((uint8ArrayOrString) => typeof uint8ArrayOrString === "string" ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString).map((uint8Array) => decoder.write(uint8Array));
  const finalString = decoder.end();
  return finalString === "" ? strings : [...strings, finalString];
};
var joinToUint8Array = (uint8ArraysOrStrings) => {
  if (uint8ArraysOrStrings.length === 1 && isUint8Array(uint8ArraysOrStrings[0])) {
    return uint8ArraysOrStrings[0];
  }
  return concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));
};
var stringsToUint8Arrays = (uint8ArraysOrStrings) => uint8ArraysOrStrings.map((uint8ArrayOrString) => typeof uint8ArrayOrString === "string" ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString);
var concatUint8Arrays = (uint8Arrays) => {
  const result = new Uint8Array(getJoinLength(uint8Arrays));
  let index = 0;
  for (const uint8Array of uint8Arrays) {
    result.set(uint8Array, index);
    index += uint8Array.length;
  }
  return result;
};
var getJoinLength = (uint8Arrays) => {
  let joinLength = 0;
  for (const uint8Array of uint8Arrays) {
    joinLength += uint8Array.length;
  }
  return joinLength;
};

// node_modules/execa/lib/methods/template.js
var isTemplateString = (templates) => Array.isArray(templates) && Array.isArray(templates.raw);
var parseTemplates = (templates, expressions) => {
  let tokens = [];
  for (const [index, template] of templates.entries()) {
    tokens = parseTemplate({
      templates,
      expressions,
      tokens,
      index,
      template
    });
  }
  if (tokens.length === 0) {
    throw new TypeError("Template script must not be empty");
  }
  const [file, ...commandArguments] = tokens;
  return [file, commandArguments, {}];
};
var parseTemplate = ({ templates, expressions, tokens, index, template }) => {
  if (template === undefined) {
    throw new TypeError(`Invalid backslash sequence: ${templates.raw[index]}`);
  }
  const { nextTokens, leadingWhitespaces, trailingWhitespaces } = splitByWhitespaces(template, templates.raw[index]);
  const newTokens = concatTokens(tokens, nextTokens, leadingWhitespaces);
  if (index === expressions.length) {
    return newTokens;
  }
  const expression = expressions[index];
  const expressionTokens = Array.isArray(expression) ? expression.map((expression2) => parseExpression(expression2)) : [parseExpression(expression)];
  return concatTokens(newTokens, expressionTokens, trailingWhitespaces);
};
var splitByWhitespaces = (template, rawTemplate) => {
  if (rawTemplate.length === 0) {
    return { nextTokens: [], leadingWhitespaces: false, trailingWhitespaces: false };
  }
  const nextTokens = [];
  let templateStart = 0;
  const leadingWhitespaces = DELIMITERS.has(rawTemplate[0]);
  for (let templateIndex = 0, rawIndex = 0;templateIndex < template.length; templateIndex += 1, rawIndex += 1) {
    const rawCharacter = rawTemplate[rawIndex];
    if (DELIMITERS.has(rawCharacter)) {
      if (templateStart !== templateIndex) {
        nextTokens.push(template.slice(templateStart, templateIndex));
      }
      templateStart = templateIndex + 1;
    } else if (rawCharacter === "\\") {
      const nextRawCharacter = rawTemplate[rawIndex + 1];
      if (nextRawCharacter === `
`) {
        templateIndex -= 1;
        rawIndex += 1;
      } else if (nextRawCharacter === "u" && rawTemplate[rawIndex + 2] === "{") {
        rawIndex = rawTemplate.indexOf("}", rawIndex + 3);
      } else {
        rawIndex += ESCAPE_LENGTH[nextRawCharacter] ?? 1;
      }
    }
  }
  const trailingWhitespaces = templateStart === template.length;
  if (!trailingWhitespaces) {
    nextTokens.push(template.slice(templateStart));
  }
  return { nextTokens, leadingWhitespaces, trailingWhitespaces };
};
var DELIMITERS = new Set([" ", "\t", "\r", `
`]);
var ESCAPE_LENGTH = { x: 3, u: 5 };
var concatTokens = (tokens, nextTokens, isSeparated) => isSeparated || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [
  ...tokens.slice(0, -1),
  `${tokens.at(-1)}${nextTokens[0]}`,
  ...nextTokens.slice(1)
];
var parseExpression = (expression) => {
  const typeOfExpression = typeof expression;
  if (typeOfExpression === "string") {
    return expression;
  }
  if (typeOfExpression === "number") {
    return String(expression);
  }
  if (isPlainObject11(expression) && (("stdout" in expression) || ("isMaxBuffer" in expression))) {
    return getSubprocessResult(expression);
  }
  if (expression instanceof ChildProcess || Object.prototype.toString.call(expression) === "[object Promise]") {
    throw new TypeError("Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.");
  }
  throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
};
var getSubprocessResult = ({ stdout }) => {
  if (typeof stdout === "string") {
    return stdout;
  }
  if (isUint8Array(stdout)) {
    return uint8ArrayToString(stdout);
  }
  if (stdout === undefined) {
    throw new TypeError(`Missing result.stdout in template expression. This is probably due to the previous subprocess' "stdout" option.`);
  }
  throw new TypeError(`Unexpected "${typeof stdout}" stdout in template expression`);
};

// node_modules/execa/lib/methods/main-sync.js
import { spawnSync } from "node:child_process";

// node_modules/execa/lib/arguments/specific.js
import { debuglog } from "node:util";

// node_modules/execa/lib/utils/standard-stream.js
import process20 from "node:process";
var isStandardStream = (stream) => STANDARD_STREAMS.includes(stream);
var STANDARD_STREAMS = [process20.stdin, process20.stdout, process20.stderr];
var STANDARD_STREAMS_ALIASES = ["stdin", "stdout", "stderr"];
var getStreamName = (fdNumber) => STANDARD_STREAMS_ALIASES[fdNumber] ?? `stdio[${fdNumber}]`;

// node_modules/execa/lib/arguments/specific.js
var normalizeFdSpecificOptions = (options) => {
  const optionsCopy = { ...options };
  for (const optionName of FD_SPECIFIC_OPTIONS) {
    optionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);
  }
  return optionsCopy;
};
var normalizeFdSpecificOption = (options, optionName) => {
  const optionBaseArray = Array.from({ length: getStdioLength(options) + 1 });
  const optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);
  return addDefaultValue(optionArray, optionName);
};
var getStdioLength = ({ stdio }) => Array.isArray(stdio) ? Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length) : STANDARD_STREAMS_ALIASES.length;
var normalizeFdSpecificValue = (optionValue, optionArray, optionName) => isPlainObject11(optionValue) ? normalizeOptionObject(optionValue, optionArray, optionName) : optionArray.fill(optionValue);
var normalizeOptionObject = (optionValue, optionArray, optionName) => {
  for (const fdName of Object.keys(optionValue).sort(compareFdName)) {
    for (const fdNumber of parseFdName(fdName, optionName, optionArray)) {
      optionArray[fdNumber] = optionValue[fdName];
    }
  }
  return optionArray;
};
var compareFdName = (fdNameA, fdNameB) => getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1;
var getFdNameOrder = (fdName) => {
  if (fdName === "stdout" || fdName === "stderr") {
    return 0;
  }
  return fdName === "all" ? 2 : 1;
};
var parseFdName = (fdName, optionName, optionArray) => {
  if (fdName === "ipc") {
    return [optionArray.length - 1];
  }
  const fdNumber = parseFd(fdName);
  if (fdNumber === undefined || fdNumber === 0) {
    throw new TypeError(`"${optionName}.${fdName}" is invalid.
It must be "${optionName}.stdout", "${optionName}.stderr", "${optionName}.all", "${optionName}.ipc", or "${optionName}.fd3", "${optionName}.fd4" (and so on).`);
  }
  if (fdNumber >= optionArray.length) {
    throw new TypeError(`"${optionName}.${fdName}" is invalid: that file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
  }
  return fdNumber === "all" ? [1, 2] : [fdNumber];
};
var parseFd = (fdName) => {
  if (fdName === "all") {
    return fdName;
  }
  if (STANDARD_STREAMS_ALIASES.includes(fdName)) {
    return STANDARD_STREAMS_ALIASES.indexOf(fdName);
  }
  const regexpResult = FD_REGEXP.exec(fdName);
  if (regexpResult !== null) {
    return Number(regexpResult[1]);
  }
};
var FD_REGEXP = /^fd(\d+)$/;
var addDefaultValue = (optionArray, optionName) => optionArray.map((optionValue) => optionValue === undefined ? DEFAULT_OPTIONS[optionName] : optionValue);
var verboseDefault = debuglog("execa").enabled ? "full" : "none";
var DEFAULT_OPTIONS = {
  lines: false,
  buffer: true,
  maxBuffer: 1000 * 1000 * 100,
  verbose: verboseDefault,
  stripFinalNewline: true
};
var FD_SPECIFIC_OPTIONS = ["lines", "buffer", "maxBuffer", "verbose", "stripFinalNewline"];
var getFdSpecificValue = (optionArray, fdNumber) => fdNumber === "ipc" ? optionArray.at(-1) : optionArray[fdNumber];

// node_modules/execa/lib/verbose/values.js
var isVerbose = ({ verbose }, fdNumber) => getFdVerbose(verbose, fdNumber) !== "none";
var isFullVerbose = ({ verbose }, fdNumber) => !["none", "short"].includes(getFdVerbose(verbose, fdNumber));
var getVerboseFunction = ({ verbose }, fdNumber) => {
  const fdVerbose = getFdVerbose(verbose, fdNumber);
  return isVerboseFunction(fdVerbose) ? fdVerbose : undefined;
};
var getFdVerbose = (verbose, fdNumber) => fdNumber === undefined ? getFdGenericVerbose(verbose) : getFdSpecificValue(verbose, fdNumber);
var getFdGenericVerbose = (verbose) => verbose.find((fdVerbose) => isVerboseFunction(fdVerbose)) ?? VERBOSE_VALUES.findLast((fdVerbose) => verbose.includes(fdVerbose));
var isVerboseFunction = (fdVerbose) => typeof fdVerbose === "function";
var VERBOSE_VALUES = ["none", "short", "full"];

// node_modules/execa/lib/verbose/log.js
import { inspect } from "node:util";

// node_modules/execa/lib/arguments/escape.js
import { platform } from "node:process";
import { stripVTControlCharacters } from "node:util";
var joinCommand = (filePath, rawArguments) => {
  const fileAndArguments = [filePath, ...rawArguments];
  const command2 = fileAndArguments.join(" ");
  const escapedCommand = fileAndArguments.map((fileAndArgument) => quoteString(escapeControlCharacters(fileAndArgument))).join(" ");
  return { command: command2, escapedCommand };
};
var escapeLines = (lines4) => stripVTControlCharacters(lines4).split(`
`).map((line) => escapeControlCharacters(line)).join(`
`);
var escapeControlCharacters = (line) => line.replaceAll(SPECIAL_CHAR_REGEXP, (character) => escapeControlCharacter(character));
var escapeControlCharacter = (character) => {
  const commonEscape = COMMON_ESCAPES[character];
  if (commonEscape !== undefined) {
    return commonEscape;
  }
  const codepoint = character.codePointAt(0);
  const codepointHex = codepoint.toString(16);
  return codepoint <= ASTRAL_START ? `\\u${codepointHex.padStart(4, "0")}` : `\\U${codepointHex}`;
};
var getSpecialCharRegExp = () => {
  try {
    return new RegExp("\\p{Separator}|\\p{Other}", "gu");
  } catch {
    return /[\s\u0000-\u001F\u007F-\u009F\u00AD]/g;
  }
};
var SPECIAL_CHAR_REGEXP = getSpecialCharRegExp();
var COMMON_ESCAPES = {
  " ": " ",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "\t": "\\t"
};
var ASTRAL_START = 65535;
var quoteString = (escapedArgument) => {
  if (NO_ESCAPE_REGEXP.test(escapedArgument)) {
    return escapedArgument;
  }
  return platform === "win32" ? `"${escapedArgument.replaceAll('"', '""')}"` : `'${escapedArgument.replaceAll("'", "'\\''")}'`;
};
var NO_ESCAPE_REGEXP = /^[\w./-]+$/;

// node_modules/figures/index.js
var common11 = {
  circleQuestionMark: "(?)",
  questionMarkPrefix: "(?)",
  square: "",
  squareDarkShade: "",
  squareMediumShade: "",
  squareLightShade: "",
  squareTop: "",
  squareBottom: "",
  squareLeft: "",
  squareRight: "",
  squareCenter: "",
  bullet: "",
  dot: "",
  ellipsis: "",
  pointerSmall: "",
  triangleUp: "",
  triangleUpSmall: "",
  triangleDown: "",
  triangleDownSmall: "",
  triangleLeftSmall: "",
  triangleRightSmall: "",
  home: "",
  heart: "",
  musicNote: "",
  musicNoteBeamed: "",
  arrowUp: "",
  arrowDown: "",
  arrowLeft: "",
  arrowRight: "",
  arrowLeftRight: "",
  arrowUpDown: "",
  almostEqual: "",
  notEqual: "",
  lessOrEqual: "",
  greaterOrEqual: "",
  identical: "",
  infinity: "",
  subscriptZero: "",
  subscriptOne: "",
  subscriptTwo: "",
  subscriptThree: "",
  subscriptFour: "",
  subscriptFive: "",
  subscriptSix: "",
  subscriptSeven: "",
  subscriptEight: "",
  subscriptNine: "",
  oneHalf: "",
  oneThird: "",
  oneQuarter: "",
  oneFifth: "",
  oneSixth: "",
  oneEighth: "",
  twoThirds: "",
  twoFifths: "",
  threeQuarters: "",
  threeFifths: "",
  threeEighths: "",
  fourFifths: "",
  fiveSixths: "",
  fiveEighths: "",
  sevenEighths: "",
  line: "",
  lineBold: "",
  lineDouble: "",
  lineDashed0: "",
  lineDashed1: "",
  lineDashed2: "",
  lineDashed3: "",
  lineDashed4: "",
  lineDashed5: "",
  lineDashed6: "",
  lineDashed7: "",
  lineDashed8: "",
  lineDashed9: "",
  lineDashed10: "",
  lineDashed11: "",
  lineDashed12: "",
  lineDashed13: "",
  lineDashed14: "",
  lineDashed15: "",
  lineVertical: "",
  lineVerticalBold: "",
  lineVerticalDouble: "",
  lineVerticalDashed0: "",
  lineVerticalDashed1: "",
  lineVerticalDashed2: "",
  lineVerticalDashed3: "",
  lineVerticalDashed4: "",
  lineVerticalDashed5: "",
  lineVerticalDashed6: "",
  lineVerticalDashed7: "",
  lineVerticalDashed8: "",
  lineVerticalDashed9: "",
  lineVerticalDashed10: "",
  lineVerticalDashed11: "",
  lineDownLeft: "",
  lineDownLeftArc: "",
  lineDownBoldLeftBold: "",
  lineDownBoldLeft: "",
  lineDownLeftBold: "",
  lineDownDoubleLeftDouble: "",
  lineDownDoubleLeft: "",
  lineDownLeftDouble: "",
  lineDownRight: "",
  lineDownRightArc: "",
  lineDownBoldRightBold: "",
  lineDownBoldRight: "",
  lineDownRightBold: "",
  lineDownDoubleRightDouble: "",
  lineDownDoubleRight: "",
  lineDownRightDouble: "",
  lineUpLeft: "",
  lineUpLeftArc: "",
  lineUpBoldLeftBold: "",
  lineUpBoldLeft: "",
  lineUpLeftBold: "",
  lineUpDoubleLeftDouble: "",
  lineUpDoubleLeft: "",
  lineUpLeftDouble: "",
  lineUpRight: "",
  lineUpRightArc: "",
  lineUpBoldRightBold: "",
  lineUpBoldRight: "",
  lineUpRightBold: "",
  lineUpDoubleRightDouble: "",
  lineUpDoubleRight: "",
  lineUpRightDouble: "",
  lineUpDownLeft: "",
  lineUpBoldDownBoldLeftBold: "",
  lineUpBoldDownBoldLeft: "",
  lineUpDownLeftBold: "",
  lineUpBoldDownLeftBold: "",
  lineUpDownBoldLeftBold: "",
  lineUpDownBoldLeft: "",
  lineUpBoldDownLeft: "",
  lineUpDoubleDownDoubleLeftDouble: "",
  lineUpDoubleDownDoubleLeft: "",
  lineUpDownLeftDouble: "",
  lineUpDownRight: "",
  lineUpBoldDownBoldRightBold: "",
  lineUpBoldDownBoldRight: "",
  lineUpDownRightBold: "",
  lineUpBoldDownRightBold: "",
  lineUpDownBoldRightBold: "",
  lineUpDownBoldRight: "",
  lineUpBoldDownRight: "",
  lineUpDoubleDownDoubleRightDouble: "",
  lineUpDoubleDownDoubleRight: "",
  lineUpDownRightDouble: "",
  lineDownLeftRight: "",
  lineDownBoldLeftBoldRightBold: "",
  lineDownLeftBoldRightBold: "",
  lineDownBoldLeftRight: "",
  lineDownBoldLeftBoldRight: "",
  lineDownBoldLeftRightBold: "",
  lineDownLeftRightBold: "",
  lineDownLeftBoldRight: "",
  lineDownDoubleLeftDoubleRightDouble: "",
  lineDownDoubleLeftRight: "",
  lineDownLeftDoubleRightDouble: "",
  lineUpLeftRight: "",
  lineUpBoldLeftBoldRightBold: "",
  lineUpLeftBoldRightBold: "",
  lineUpBoldLeftRight: "",
  lineUpBoldLeftBoldRight: "",
  lineUpBoldLeftRightBold: "",
  lineUpLeftRightBold: "",
  lineUpLeftBoldRight: "",
  lineUpDoubleLeftDoubleRightDouble: "",
  lineUpDoubleLeftRight: "",
  lineUpLeftDoubleRightDouble: "",
  lineUpDownLeftRight: "",
  lineUpBoldDownBoldLeftBoldRightBold: "",
  lineUpDownBoldLeftBoldRightBold: "",
  lineUpBoldDownLeftBoldRightBold: "",
  lineUpBoldDownBoldLeftRightBold: "",
  lineUpBoldDownBoldLeftBoldRight: "",
  lineUpBoldDownLeftRight: "",
  lineUpDownBoldLeftRight: "",
  lineUpDownLeftBoldRight: "",
  lineUpDownLeftRightBold: "",
  lineUpBoldDownBoldLeftRight: "",
  lineUpDownLeftBoldRightBold: "",
  lineUpBoldDownLeftBoldRight: "",
  lineUpBoldDownLeftRightBold: "",
  lineUpDownBoldLeftBoldRight: "",
  lineUpDownBoldLeftRightBold: "",
  lineUpDoubleDownDoubleLeftDoubleRightDouble: "",
  lineUpDoubleDownDoubleLeftRight: "",
  lineUpDownLeftDoubleRightDouble: "",
  lineCross: "",
  lineBackslash: "",
  lineSlash: ""
};
var specialMainSymbols11 = {
  tick: "",
  info: "",
  warning: "",
  cross: "",
  squareSmall: "",
  squareSmallFilled: "",
  circle: "",
  circleFilled: "",
  circleDotted: "",
  circleDouble: "",
  circleCircle: "",
  circleCross: "",
  circlePipe: "",
  radioOn: "",
  radioOff: "",
  checkboxOn: "",
  checkboxOff: "",
  checkboxCircleOn: "",
  checkboxCircleOff: "",
  pointer: "",
  triangleUpOutline: "",
  triangleLeft: "",
  triangleRight: "",
  lozenge: "",
  lozengeOutline: "",
  hamburger: "",
  smiley: "",
  mustache: "",
  star: "",
  play: "",
  nodejs: "",
  oneSeventh: "",
  oneNinth: "",
  oneTenth: ""
};
var specialFallbackSymbols11 = {
  tick: "",
  info: "i",
  warning: "",
  cross: "",
  squareSmall: "",
  squareSmallFilled: "",
  circle: "( )",
  circleFilled: "(*)",
  circleDotted: "( )",
  circleDouble: "( )",
  circleCircle: "()",
  circleCross: "()",
  circlePipe: "()",
  radioOn: "(*)",
  radioOff: "( )",
  checkboxOn: "[]",
  checkboxOff: "[ ]",
  checkboxCircleOn: "()",
  checkboxCircleOff: "( )",
  pointer: ">",
  triangleUpOutline: "",
  triangleLeft: "",
  triangleRight: "",
  lozenge: "",
  lozengeOutline: "",
  hamburger: "",
  smiley: "",
  mustache: "",
  star: "",
  play: "",
  nodejs: "",
  oneSeventh: "1/7",
  oneNinth: "1/9",
  oneTenth: "1/10"
};
var mainSymbols11 = { ...common11, ...specialMainSymbols11 };
var fallbackSymbols11 = { ...common11, ...specialFallbackSymbols11 };
var shouldUseMain11 = isUnicodeSupported12();
var figures11 = shouldUseMain11 ? mainSymbols11 : fallbackSymbols11;
var figures_default = figures11;
var replacements11 = Object.entries(specialMainSymbols11);

// node_modules/yoctocolors/base.js
import tty2 from "node:tty";
var hasColors = tty2?.WriteStream?.prototype?.hasColors?.() ?? false;
var format = (open, close) => {
  if (!hasColors) {
    return (input) => input;
  }
  const openCode = `\x1B[${open}m`;
  const closeCode = `\x1B[${close}m`;
  return (input) => {
    const string2 = input + "";
    let index = string2.indexOf(closeCode);
    if (index === -1) {
      return openCode + string2 + closeCode;
    }
    let result = openCode;
    let lastIndex = 0;
    while (index !== -1) {
      result += string2.slice(lastIndex, index) + openCode;
      lastIndex = index + closeCode.length;
      index = string2.indexOf(closeCode, lastIndex);
    }
    result += string2.slice(lastIndex) + closeCode;
    return result;
  };
};
var reset2 = format(0, 0);
var bold2 = format(1, 22);
var dim2 = format(2, 22);
var italic2 = format(3, 23);
var underline2 = format(4, 24);
var overline = format(53, 55);
var inverse2 = format(7, 27);
var hidden2 = format(8, 28);
var strikethrough2 = format(9, 29);
var black2 = format(30, 39);
var red2 = format(31, 39);
var green2 = format(32, 39);
var yellow2 = format(33, 39);
var blue2 = format(34, 39);
var magenta2 = format(35, 39);
var cyan2 = format(36, 39);
var white2 = format(37, 39);
var gray2 = format(90, 39);
var bgBlack2 = format(40, 49);
var bgRed2 = format(41, 49);
var bgGreen2 = format(42, 49);
var bgYellow2 = format(43, 49);
var bgBlue2 = format(44, 49);
var bgMagenta2 = format(45, 49);
var bgCyan2 = format(46, 49);
var bgWhite2 = format(47, 49);
var bgGray = format(100, 49);
var redBright = format(91, 39);
var greenBright = format(92, 39);
var yellowBright = format(93, 39);
var blueBright = format(94, 39);
var magentaBright = format(95, 39);
var cyanBright = format(96, 39);
var whiteBright = format(97, 39);
var bgRedBright = format(101, 49);
var bgGreenBright = format(102, 49);
var bgYellowBright = format(103, 49);
var bgBlueBright = format(104, 49);
var bgMagentaBright = format(105, 49);
var bgCyanBright = format(106, 49);
var bgWhiteBright = format(107, 49);

// node_modules/execa/lib/verbose/default.js
var defaultVerboseFunction = ({
  type,
  message,
  timestamp,
  piped,
  commandId,
  result: { failed = false } = {},
  options: { reject = true }
}) => {
  const timestampString = serializeTimestamp(timestamp);
  const icon = ICONS[type]({ failed, reject, piped });
  const color = COLORS[type]({ reject });
  return `${gray2(`[${timestampString}]`)} ${gray2(`[${commandId}]`)} ${color(icon)} ${color(message)}`;
};
var serializeTimestamp = (timestamp) => `${padField(timestamp.getHours(), 2)}:${padField(timestamp.getMinutes(), 2)}:${padField(timestamp.getSeconds(), 2)}.${padField(timestamp.getMilliseconds(), 3)}`;
var padField = (field, padding) => String(field).padStart(padding, "0");
var getFinalIcon = ({ failed, reject }) => {
  if (!failed) {
    return figures_default.tick;
  }
  return reject ? figures_default.cross : figures_default.warning;
};
var ICONS = {
  command: ({ piped }) => piped ? "|" : "$",
  output: () => " ",
  ipc: () => "*",
  error: getFinalIcon,
  duration: getFinalIcon
};
var identity = (string2) => string2;
var COLORS = {
  command: () => bold2,
  output: () => identity,
  ipc: () => identity,
  error: ({ reject }) => reject ? redBright : yellowBright,
  duration: () => gray2
};

// node_modules/execa/lib/verbose/custom.js
var applyVerboseOnLines = (printedLines, verboseInfo, fdNumber) => {
  const verboseFunction = getVerboseFunction(verboseInfo, fdNumber);
  return printedLines.map(({ verboseLine, verboseObject }) => applyVerboseFunction(verboseLine, verboseObject, verboseFunction)).filter((printedLine) => printedLine !== undefined).map((printedLine) => appendNewline(printedLine)).join("");
};
var applyVerboseFunction = (verboseLine, verboseObject, verboseFunction) => {
  if (verboseFunction === undefined) {
    return verboseLine;
  }
  const printedLine = verboseFunction(verboseLine, verboseObject);
  if (typeof printedLine === "string") {
    return printedLine;
  }
};
var appendNewline = (printedLine) => printedLine.endsWith(`
`) ? printedLine : `${printedLine}
`;

// node_modules/execa/lib/verbose/log.js
var verboseLog = ({ type, verboseMessage, fdNumber, verboseInfo, result }) => {
  const verboseObject = getVerboseObject({ type, result, verboseInfo });
  const printedLines = getPrintedLines(verboseMessage, verboseObject);
  const finalLines = applyVerboseOnLines(printedLines, verboseInfo, fdNumber);
  if (finalLines !== "") {
    console.warn(finalLines.slice(0, -1));
  }
};
var getVerboseObject = ({
  type,
  result,
  verboseInfo: { escapedCommand, commandId, rawOptions: { piped = false, ...options } }
}) => ({
  type,
  escapedCommand,
  commandId: `${commandId}`,
  timestamp: new Date,
  piped,
  result,
  options
});
var getPrintedLines = (verboseMessage, verboseObject) => verboseMessage.split(`
`).map((message) => getPrintedLine({ ...verboseObject, message }));
var getPrintedLine = (verboseObject) => {
  const verboseLine = defaultVerboseFunction(verboseObject);
  return { verboseLine, verboseObject };
};
var serializeVerboseMessage = (message) => {
  const messageString = typeof message === "string" ? message : inspect(message);
  const escapedMessage = escapeLines(messageString);
  return escapedMessage.replaceAll("\t", " ".repeat(TAB_SIZE));
};
var TAB_SIZE = 2;

// node_modules/execa/lib/verbose/start.js
var logCommand = (escapedCommand, verboseInfo) => {
  if (!isVerbose(verboseInfo)) {
    return;
  }
  verboseLog({
    type: "command",
    verboseMessage: escapedCommand,
    verboseInfo
  });
};

// node_modules/execa/lib/verbose/info.js
var getVerboseInfo = (verbose, escapedCommand, rawOptions) => {
  validateVerbose(verbose);
  const commandId = getCommandId(verbose);
  return {
    verbose,
    escapedCommand,
    commandId,
    rawOptions
  };
};
var getCommandId = (verbose) => isVerbose({ verbose }) ? COMMAND_ID++ : undefined;
var COMMAND_ID = 0n;
var validateVerbose = (verbose) => {
  for (const fdVerbose of verbose) {
    if (fdVerbose === false) {
      throw new TypeError(`The "verbose: false" option was renamed to "verbose: 'none'".`);
    }
    if (fdVerbose === true) {
      throw new TypeError(`The "verbose: true" option was renamed to "verbose: 'short'".`);
    }
    if (!VERBOSE_VALUES.includes(fdVerbose) && !isVerboseFunction(fdVerbose)) {
      const allowedValues = VERBOSE_VALUES.map((allowedValue) => `'${allowedValue}'`).join(", ");
      throw new TypeError(`The "verbose" option must not be ${fdVerbose}. Allowed values are: ${allowedValues} or a function.`);
    }
  }
};

// node_modules/execa/lib/return/duration.js
import { hrtime } from "node:process";
var getStartTime = () => hrtime.bigint();
var getDurationMs = (startTime) => Number(hrtime.bigint() - startTime) / 1e6;

// node_modules/execa/lib/arguments/command.js
var handleCommand = (filePath, rawArguments, rawOptions) => {
  const startTime = getStartTime();
  const { command: command2, escapedCommand } = joinCommand(filePath, rawArguments);
  const verbose = normalizeFdSpecificOption(rawOptions, "verbose");
  const verboseInfo = getVerboseInfo(verbose, escapedCommand, { ...rawOptions });
  logCommand(escapedCommand, verboseInfo);
  return {
    command: command2,
    escapedCommand,
    startTime,
    verboseInfo
  };
};

// node_modules/execa/lib/arguments/options.js
var import_cross_spawn = __toESM(require_cross_spawn(), 1);
import path9 from "node:path";
import process23 from "node:process";

// node_modules/npm-run-path/index.js
import process21 from "node:process";
import path6 from "node:path";

// node_modules/npm-run-path/node_modules/path-key/index.js
function pathKey(options = {}) {
  const {
    env: env2 = process.env,
    platform: platform2 = process.platform
  } = options;
  if (platform2 !== "win32") {
    return "PATH";
  }
  return Object.keys(env2).reverse().find((key12) => key12.toUpperCase() === "PATH") || "Path";
}

// node_modules/unicorn-magic/node.js
import { promisify } from "node:util";
import { execFile as execFileCallback, execFileSync as execFileSyncOriginal } from "node:child_process";
import path5 from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";
var execFileOriginal = promisify(execFileCallback);
function toPath(urlOrPath) {
  return urlOrPath instanceof URL ? fileURLToPath2(urlOrPath) : urlOrPath;
}
function traversePathUp(startPath) {
  return {
    *[Symbol.iterator]() {
      let currentPath = path5.resolve(toPath(startPath));
      let previousPath;
      while (previousPath !== currentPath) {
        yield currentPath;
        previousPath = currentPath;
        currentPath = path5.resolve(currentPath, "..");
      }
    }
  };
}
var TEN_MEGABYTES_IN_BYTES = 10 * 1024 * 1024;

// node_modules/npm-run-path/index.js
var npmRunPath = ({
  cwd = process21.cwd(),
  path: pathOption = process21.env[pathKey()],
  preferLocal = true,
  execPath = process21.execPath,
  addExecPath = true
} = {}) => {
  const cwdPath = path6.resolve(toPath(cwd));
  const result = [];
  const pathParts = pathOption.split(path6.delimiter);
  if (preferLocal) {
    applyPreferLocal(result, pathParts, cwdPath);
  }
  if (addExecPath) {
    applyExecPath(result, pathParts, execPath, cwdPath);
  }
  return pathOption === "" || pathOption === path6.delimiter ? `${result.join(path6.delimiter)}${pathOption}` : [...result, pathOption].join(path6.delimiter);
};
var applyPreferLocal = (result, pathParts, cwdPath) => {
  for (const directory of traversePathUp(cwdPath)) {
    const pathPart = path6.join(directory, "node_modules/.bin");
    if (!pathParts.includes(pathPart)) {
      result.push(pathPart);
    }
  }
};
var applyExecPath = (result, pathParts, execPath, cwdPath) => {
  const pathPart = path6.resolve(cwdPath, toPath(execPath), "..");
  if (!pathParts.includes(pathPart)) {
    result.push(pathPart);
  }
};
var npmRunPathEnv = ({ env: env2 = process21.env, ...options } = {}) => {
  env2 = { ...env2 };
  const pathName = pathKey({ env: env2 });
  options.path = env2[pathName];
  env2[pathName] = npmRunPath(options);
  return env2;
};

// node_modules/execa/lib/terminate/kill.js
import { setTimeout as setTimeout2 } from "node:timers/promises";

// node_modules/execa/lib/return/final-error.js
var getFinalError = (originalError, message, isSync) => {
  const ErrorClass = isSync ? ExecaSyncError : ExecaError;
  const options = originalError instanceof DiscardedError ? {} : { cause: originalError };
  return new ErrorClass(message, options);
};

class DiscardedError extends Error {
}
var setErrorName = (ErrorClass, value) => {
  Object.defineProperty(ErrorClass.prototype, "name", {
    value,
    writable: true,
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ErrorClass.prototype, execaErrorSymbol, {
    value: true,
    writable: false,
    enumerable: false,
    configurable: false
  });
};
var isExecaError = (error) => isErrorInstance(error) && (execaErrorSymbol in error);
var execaErrorSymbol = Symbol("isExecaError");
var isErrorInstance = (value) => Object.prototype.toString.call(value) === "[object Error]";

class ExecaError extends Error {
}
setErrorName(ExecaError, ExecaError.name);

class ExecaSyncError extends Error {
}
setErrorName(ExecaSyncError, ExecaSyncError.name);

// node_modules/execa/lib/terminate/signal.js
import { constants as constants3 } from "node:os";

// node_modules/human-signals/build/src/main.js
import { constants as constants2 } from "node:os";

// node_modules/human-signals/build/src/realtime.js
var getRealtimeSignals = () => {
  const length = SIGRTMAX - SIGRTMIN + 1;
  return Array.from({ length }, getRealtimeSignal);
};
var getRealtimeSignal = (value, index) => ({
  name: `SIGRT${index + 1}`,
  number: SIGRTMIN + index,
  action: "terminate",
  description: "Application-specific signal (realtime)",
  standard: "posix"
});
var SIGRTMIN = 34;
var SIGRTMAX = 64;

// node_modules/human-signals/build/src/signals.js
import { constants } from "node:os";

// node_modules/human-signals/build/src/core.js
var SIGNALS = [
  {
    name: "SIGHUP",
    number: 1,
    action: "terminate",
    description: "Terminal closed",
    standard: "posix"
  },
  {
    name: "SIGINT",
    number: 2,
    action: "terminate",
    description: "User interruption with CTRL-C",
    standard: "ansi"
  },
  {
    name: "SIGQUIT",
    number: 3,
    action: "core",
    description: "User interruption with CTRL-\\",
    standard: "posix"
  },
  {
    name: "SIGILL",
    number: 4,
    action: "core",
    description: "Invalid machine instruction",
    standard: "ansi"
  },
  {
    name: "SIGTRAP",
    number: 5,
    action: "core",
    description: "Debugger breakpoint",
    standard: "posix"
  },
  {
    name: "SIGABRT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "ansi"
  },
  {
    name: "SIGIOT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "bsd"
  },
  {
    name: "SIGBUS",
    number: 7,
    action: "core",
    description: "Bus error due to misaligned, non-existing address or paging error",
    standard: "bsd"
  },
  {
    name: "SIGEMT",
    number: 7,
    action: "terminate",
    description: "Command should be emulated but is not implemented",
    standard: "other"
  },
  {
    name: "SIGFPE",
    number: 8,
    action: "core",
    description: "Floating point arithmetic error",
    standard: "ansi"
  },
  {
    name: "SIGKILL",
    number: 9,
    action: "terminate",
    description: "Forced termination",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGUSR1",
    number: 10,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGSEGV",
    number: 11,
    action: "core",
    description: "Segmentation fault",
    standard: "ansi"
  },
  {
    name: "SIGUSR2",
    number: 12,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGPIPE",
    number: 13,
    action: "terminate",
    description: "Broken pipe or socket",
    standard: "posix"
  },
  {
    name: "SIGALRM",
    number: 14,
    action: "terminate",
    description: "Timeout or timer",
    standard: "posix"
  },
  {
    name: "SIGTERM",
    number: 15,
    action: "terminate",
    description: "Termination",
    standard: "ansi"
  },
  {
    name: "SIGSTKFLT",
    number: 16,
    action: "terminate",
    description: "Stack is empty or overflowed",
    standard: "other"
  },
  {
    name: "SIGCHLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "posix"
  },
  {
    name: "SIGCLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "other"
  },
  {
    name: "SIGCONT",
    number: 18,
    action: "unpause",
    description: "Unpaused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGSTOP",
    number: 19,
    action: "pause",
    description: "Paused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGTSTP",
    number: 20,
    action: "pause",
    description: 'Paused using CTRL-Z or "suspend"',
    standard: "posix"
  },
  {
    name: "SIGTTIN",
    number: 21,
    action: "pause",
    description: "Background process cannot read terminal input",
    standard: "posix"
  },
  {
    name: "SIGBREAK",
    number: 21,
    action: "terminate",
    description: "User interruption with CTRL-BREAK",
    standard: "other"
  },
  {
    name: "SIGTTOU",
    number: 22,
    action: "pause",
    description: "Background process cannot write to terminal output",
    standard: "posix"
  },
  {
    name: "SIGURG",
    number: 23,
    action: "ignore",
    description: "Socket received out-of-band data",
    standard: "bsd"
  },
  {
    name: "SIGXCPU",
    number: 24,
    action: "core",
    description: "Process timed out",
    standard: "bsd"
  },
  {
    name: "SIGXFSZ",
    number: 25,
    action: "core",
    description: "File too big",
    standard: "bsd"
  },
  {
    name: "SIGVTALRM",
    number: 26,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGPROF",
    number: 27,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGWINCH",
    number: 28,
    action: "ignore",
    description: "Terminal window size changed",
    standard: "bsd"
  },
  {
    name: "SIGIO",
    number: 29,
    action: "terminate",
    description: "I/O is available",
    standard: "other"
  },
  {
    name: "SIGPOLL",
    number: 29,
    action: "terminate",
    description: "Watched event",
    standard: "other"
  },
  {
    name: "SIGINFO",
    number: 29,
    action: "ignore",
    description: "Request for process information",
    standard: "other"
  },
  {
    name: "SIGPWR",
    number: 30,
    action: "terminate",
    description: "Device running out of power",
    standard: "systemv"
  },
  {
    name: "SIGSYS",
    number: 31,
    action: "core",
    description: "Invalid system call",
    standard: "other"
  },
  {
    name: "SIGUNUSED",
    number: 31,
    action: "terminate",
    description: "Invalid system call",
    standard: "other"
  }
];

// node_modules/human-signals/build/src/signals.js
var getSignals = () => {
  const realtimeSignals = getRealtimeSignals();
  const signals2 = [...SIGNALS, ...realtimeSignals].map(normalizeSignal);
  return signals2;
};
var normalizeSignal = ({
  name,
  number: defaultNumber,
  description,
  action,
  forced = false,
  standard
}) => {
  const {
    signals: { [name]: constantSignal }
  } = constants;
  const supported = constantSignal !== undefined;
  const number2 = supported ? constantSignal : defaultNumber;
  return { name, number: number2, description, supported, action, forced, standard };
};

// node_modules/human-signals/build/src/main.js
var getSignalsByName = () => {
  const signals2 = getSignals();
  return Object.fromEntries(signals2.map(getSignalByName));
};
var getSignalByName = ({
  name,
  number: number2,
  description,
  supported,
  action,
  forced,
  standard
}) => [name, { name, number: number2, description, supported, action, forced, standard }];
var signalsByName = getSignalsByName();
var getSignalsByNumber = () => {
  const signals2 = getSignals();
  const length = SIGRTMAX + 1;
  const signalsA = Array.from({ length }, (value, number2) => getSignalByNumber(number2, signals2));
  return Object.assign({}, ...signalsA);
};
var getSignalByNumber = (number2, signals2) => {
  const signal = findSignalByNumber(number2, signals2);
  if (signal === undefined) {
    return {};
  }
  const { name, description, supported, action, forced, standard } = signal;
  return {
    [number2]: {
      name,
      number: number2,
      description,
      supported,
      action,
      forced,
      standard
    }
  };
};
var findSignalByNumber = (number2, signals2) => {
  const signal = signals2.find(({ name }) => constants2.signals[name] === number2);
  if (signal !== undefined) {
    return signal;
  }
  return signals2.find((signalA) => signalA.number === number2);
};
var signalsByNumber = getSignalsByNumber();

// node_modules/execa/lib/terminate/signal.js
var normalizeKillSignal = (killSignal) => {
  const optionName = "option `killSignal`";
  if (killSignal === 0) {
    throw new TypeError(`Invalid ${optionName}: 0 cannot be used.`);
  }
  return normalizeSignal2(killSignal, optionName);
};
var normalizeSignalArgument = (signal) => signal === 0 ? signal : normalizeSignal2(signal, "`subprocess.kill()`'s argument");
var normalizeSignal2 = (signalNameOrInteger, optionName) => {
  if (Number.isInteger(signalNameOrInteger)) {
    return normalizeSignalInteger(signalNameOrInteger, optionName);
  }
  if (typeof signalNameOrInteger === "string") {
    return normalizeSignalName(signalNameOrInteger, optionName);
  }
  throw new TypeError(`Invalid ${optionName} ${String(signalNameOrInteger)}: it must be a string or an integer.
${getAvailableSignals()}`);
};
var normalizeSignalInteger = (signalInteger, optionName) => {
  if (signalsIntegerToName.has(signalInteger)) {
    return signalsIntegerToName.get(signalInteger);
  }
  throw new TypeError(`Invalid ${optionName} ${signalInteger}: this signal integer does not exist.
${getAvailableSignals()}`);
};
var getSignalsIntegerToName = () => new Map(Object.entries(constants3.signals).reverse().map(([signalName, signalInteger]) => [signalInteger, signalName]));
var signalsIntegerToName = getSignalsIntegerToName();
var normalizeSignalName = (signalName, optionName) => {
  if (signalName in constants3.signals) {
    return signalName;
  }
  if (signalName.toUpperCase() in constants3.signals) {
    throw new TypeError(`Invalid ${optionName} '${signalName}': please rename it to '${signalName.toUpperCase()}'.`);
  }
  throw new TypeError(`Invalid ${optionName} '${signalName}': this signal name does not exist.
${getAvailableSignals()}`);
};
var getAvailableSignals = () => `Available signal names: ${getAvailableSignalNames()}.
Available signal numbers: ${getAvailableSignalIntegers()}.`;
var getAvailableSignalNames = () => Object.keys(constants3.signals).sort().map((signalName) => `'${signalName}'`).join(", ");
var getAvailableSignalIntegers = () => [...new Set(Object.values(constants3.signals).sort((signalInteger, signalIntegerTwo) => signalInteger - signalIntegerTwo))].join(", ");
var getSignalDescription = (signal) => signalsByName[signal].description;

// node_modules/execa/lib/terminate/kill.js
var normalizeForceKillAfterDelay = (forceKillAfterDelay) => {
  if (forceKillAfterDelay === false) {
    return forceKillAfterDelay;
  }
  if (forceKillAfterDelay === true) {
    return DEFAULT_FORCE_KILL_TIMEOUT;
  }
  if (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) {
    throw new TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${forceKillAfterDelay}\` (${typeof forceKillAfterDelay})`);
  }
  return forceKillAfterDelay;
};
var DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;
var subprocessKill = ({ kill, options: { forceKillAfterDelay, killSignal }, onInternalError, context, controller }, signalOrError, errorArgument) => {
  const { signal, error } = parseKillArguments(signalOrError, errorArgument, killSignal);
  emitKillError(error, onInternalError);
  const killResult = kill(signal);
  setKillTimeout({
    kill,
    signal,
    forceKillAfterDelay,
    killSignal,
    killResult,
    context,
    controller
  });
  return killResult;
};
var parseKillArguments = (signalOrError, errorArgument, killSignal) => {
  const [signal = killSignal, error] = isErrorInstance(signalOrError) ? [undefined, signalOrError] : [signalOrError, errorArgument];
  if (typeof signal !== "string" && !Number.isInteger(signal)) {
    throw new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(signal)}`);
  }
  if (error !== undefined && !isErrorInstance(error)) {
    throw new TypeError(`The second argument is optional. If specified, it must be an error instance: ${error}`);
  }
  return { signal: normalizeSignalArgument(signal), error };
};
var emitKillError = (error, onInternalError) => {
  if (error !== undefined) {
    onInternalError.reject(error);
  }
};
var setKillTimeout = async ({ kill, signal, forceKillAfterDelay, killSignal, killResult, context, controller }) => {
  if (signal === killSignal && killResult) {
    killOnTimeout({
      kill,
      forceKillAfterDelay,
      context,
      controllerSignal: controller.signal
    });
  }
};
var killOnTimeout = async ({ kill, forceKillAfterDelay, context, controllerSignal }) => {
  if (forceKillAfterDelay === false) {
    return;
  }
  try {
    await setTimeout2(forceKillAfterDelay, undefined, { signal: controllerSignal });
    if (kill("SIGKILL")) {
      context.isForcefullyTerminated ??= true;
    }
  } catch {
  }
};

// node_modules/execa/lib/utils/abort-signal.js
import { once } from "node:events";
var onAbortedSignal = async (mainSignal, stopSignal) => {
  if (!mainSignal.aborted) {
    await once(mainSignal, "abort", { signal: stopSignal });
  }
};

// node_modules/execa/lib/terminate/cancel.js
var validateCancelSignal = ({ cancelSignal }) => {
  if (cancelSignal !== undefined && Object.prototype.toString.call(cancelSignal) !== "[object AbortSignal]") {
    throw new Error(`The \`cancelSignal\` option must be an AbortSignal: ${String(cancelSignal)}`);
  }
};
var throwOnCancel = ({ subprocess, cancelSignal, gracefulCancel, context, controller }) => cancelSignal === undefined || gracefulCancel ? [] : [terminateOnCancel(subprocess, cancelSignal, context, controller)];
var terminateOnCancel = async (subprocess, cancelSignal, context, { signal }) => {
  await onAbortedSignal(cancelSignal, signal);
  context.terminationReason ??= "cancel";
  subprocess.kill();
  throw cancelSignal.reason;
};

// node_modules/execa/lib/ipc/graceful.js
import { scheduler as scheduler2 } from "node:timers/promises";

// node_modules/execa/lib/ipc/send.js
import { promisify as promisify2 } from "node:util";

// node_modules/execa/lib/ipc/validation.js
var validateIpcMethod = ({ methodName, isSubprocess, ipc, isConnected }) => {
  validateIpcOption(methodName, isSubprocess, ipc);
  validateConnection(methodName, isSubprocess, isConnected);
};
var validateIpcOption = (methodName, isSubprocess, ipc) => {
  if (!ipc) {
    throw new Error(`${getMethodName(methodName, isSubprocess)} can only be used if the \`ipc\` option is \`true\`.`);
  }
};
var validateConnection = (methodName, isSubprocess, isConnected) => {
  if (!isConnected) {
    throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} has already exited or disconnected.`);
  }
};
var throwOnEarlyDisconnect = (isSubprocess) => {
  throw new Error(`${getMethodName("getOneMessage", isSubprocess)} could not complete: the ${getOtherProcessName(isSubprocess)} exited or disconnected.`);
};
var throwOnStrictDeadlockError = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is sending a message too, instead of listening to incoming messages.
This can be fixed by both sending a message and listening to incoming messages at the same time:

const [receivedMessage] = await Promise.all([
\t${getMethodName("getOneMessage", isSubprocess)},
\t${getMethodName("sendMessage", isSubprocess, "message, {strict: true}")},
]);`);
};
var getStrictResponseError = (error, isSubprocess) => new Error(`${getMethodName("sendMessage", isSubprocess)} failed when sending an acknowledgment response to the ${getOtherProcessName(isSubprocess)}.`, { cause: error });
var throwOnMissingStrict = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is not listening to incoming messages.`);
};
var throwOnStrictDisconnect = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} exited without listening to incoming messages.`);
};
var getAbortDisconnectError = () => new Error(`\`cancelSignal\` aborted: the ${getOtherProcessName(true)} disconnected.`);
var throwOnMissingParent = () => {
  throw new Error("`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.");
};
var handleEpipeError = ({ error, methodName, isSubprocess }) => {
  if (error.code === "EPIPE") {
    throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} is disconnecting.`, { cause: error });
  }
};
var handleSerializationError = ({ error, methodName, isSubprocess, message }) => {
  if (isSerializationError(error)) {
    throw new Error(`${getMethodName(methodName, isSubprocess)}'s argument type is invalid: the message cannot be serialized: ${String(message)}.`, { cause: error });
  }
};
var isSerializationError = ({ code, message }) => SERIALIZATION_ERROR_CODES.has(code) || SERIALIZATION_ERROR_MESSAGES.some((serializationErrorMessage) => message.includes(serializationErrorMessage));
var SERIALIZATION_ERROR_CODES = new Set([
  "ERR_MISSING_ARGS",
  "ERR_INVALID_ARG_TYPE"
]);
var SERIALIZATION_ERROR_MESSAGES = [
  "could not be cloned",
  "circular structure",
  "call stack size exceeded"
];
var getMethodName = (methodName, isSubprocess, parameters = "") => methodName === "cancelSignal" ? "`cancelSignal`'s `controller.abort()`" : `${getNamespaceName(isSubprocess)}${methodName}(${parameters})`;
var getNamespaceName = (isSubprocess) => isSubprocess ? "" : "subprocess.";
var getOtherProcessName = (isSubprocess) => isSubprocess ? "parent process" : "subprocess";
var disconnect = (anyProcess) => {
  if (anyProcess.connected) {
    anyProcess.disconnect();
  }
};

// node_modules/execa/lib/utils/deferred.js
var createDeferred = () => {
  const methods = {};
  const promise = new Promise((resolve, reject) => {
    Object.assign(methods, { resolve, reject });
  });
  return Object.assign(promise, methods);
};

// node_modules/execa/lib/arguments/fd-options.js
var getToStream = (destination, to = "stdin") => {
  const isWritable = true;
  const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(destination);
  const fdNumber = getFdNumber(fileDescriptors, to, isWritable);
  const destinationStream = destination.stdio[fdNumber];
  if (destinationStream === null) {
    throw new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable));
  }
  return destinationStream;
};
var getFromStream = (source, from2 = "stdout") => {
  const isWritable = false;
  const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
  const fdNumber = getFdNumber(fileDescriptors, from2, isWritable);
  const sourceStream = fdNumber === "all" ? source.all : source.stdio[fdNumber];
  if (sourceStream === null || sourceStream === undefined) {
    throw new TypeError(getInvalidStdioOptionMessage(fdNumber, from2, options, isWritable));
  }
  return sourceStream;
};
var SUBPROCESS_OPTIONS = new WeakMap;
var getFdNumber = (fileDescriptors, fdName, isWritable) => {
  const fdNumber = parseFdNumber(fdName, isWritable);
  validateFdNumber(fdNumber, fdName, isWritable, fileDescriptors);
  return fdNumber;
};
var parseFdNumber = (fdName, isWritable) => {
  const fdNumber = parseFd(fdName);
  if (fdNumber !== undefined) {
    return fdNumber;
  }
  const { validOptions, defaultValue } = isWritable ? { validOptions: '"stdin"', defaultValue: "stdin" } : { validOptions: '"stdout", "stderr", "all"', defaultValue: "stdout" };
  throw new TypeError(`"${getOptionName(isWritable)}" must not be "${fdName}".
It must be ${validOptions} or "fd3", "fd4" (and so on).
It is optional and defaults to "${defaultValue}".`);
};
var validateFdNumber = (fdNumber, fdName, isWritable, fileDescriptors) => {
  const fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];
  if (fileDescriptor === undefined) {
    throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. That file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
  }
  if (fileDescriptor.direction === "input" && !isWritable) {
    throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a readable stream, not writable.`);
  }
  if (fileDescriptor.direction !== "input" && isWritable) {
    throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a writable stream, not readable.`);
  }
};
var getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable) => {
  if (fdNumber === "all" && !options.all) {
    return `The "all" option must be true to use "from: 'all'".`;
  }
  const { optionName, optionValue } = getInvalidStdioOption(fdNumber, options);
  return `The "${optionName}: ${serializeOptionValue(optionValue)}" option is incompatible with using "${getOptionName(isWritable)}: ${serializeOptionValue(fdName)}".
Please set this option with "pipe" instead.`;
};
var getInvalidStdioOption = (fdNumber, { stdin, stdout, stderr, stdio }) => {
  const usedDescriptor = getUsedDescriptor(fdNumber);
  if (usedDescriptor === 0 && stdin !== undefined) {
    return { optionName: "stdin", optionValue: stdin };
  }
  if (usedDescriptor === 1 && stdout !== undefined) {
    return { optionName: "stdout", optionValue: stdout };
  }
  if (usedDescriptor === 2 && stderr !== undefined) {
    return { optionName: "stderr", optionValue: stderr };
  }
  return { optionName: `stdio[${usedDescriptor}]`, optionValue: stdio[usedDescriptor] };
};
var getUsedDescriptor = (fdNumber) => fdNumber === "all" ? 1 : fdNumber;
var getOptionName = (isWritable) => isWritable ? "to" : "from";
var serializeOptionValue = (value) => {
  if (typeof value === "string") {
    return `'${value}'`;
  }
  return typeof value === "number" ? `${value}` : "Stream";
};

// node_modules/execa/lib/ipc/strict.js
import { once as once3 } from "node:events";

// node_modules/execa/lib/utils/max-listeners.js
import { addAbortListener } from "node:events";
var incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal) => {
  const maxListeners = eventEmitter.getMaxListeners();
  if (maxListeners === 0 || maxListeners === Number.POSITIVE_INFINITY) {
    return;
  }
  eventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);
  addAbortListener(signal, () => {
    eventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);
  });
};

// node_modules/execa/lib/ipc/forward.js
import { EventEmitter } from "node:events";

// node_modules/execa/lib/ipc/incoming.js
import { once as once2 } from "node:events";
import { scheduler } from "node:timers/promises";

// node_modules/execa/lib/ipc/reference.js
var addReference = (channel, reference) => {
  if (reference) {
    addReferenceCount(channel);
  }
};
var addReferenceCount = (channel) => {
  channel.refCounted();
};
var removeReference = (channel, reference) => {
  if (reference) {
    removeReferenceCount(channel);
  }
};
var removeReferenceCount = (channel) => {
  channel.unrefCounted();
};
var undoAddedReferences = (channel, isSubprocess) => {
  if (isSubprocess) {
    removeReferenceCount(channel);
    removeReferenceCount(channel);
  }
};
var redoAddedReferences = (channel, isSubprocess) => {
  if (isSubprocess) {
    addReferenceCount(channel);
    addReferenceCount(channel);
  }
};

// node_modules/execa/lib/ipc/incoming.js
var onMessage = async ({ anyProcess, channel, isSubprocess, ipcEmitter }, wrappedMessage) => {
  if (handleStrictResponse(wrappedMessage) || handleAbort(wrappedMessage)) {
    return;
  }
  if (!INCOMING_MESSAGES.has(anyProcess)) {
    INCOMING_MESSAGES.set(anyProcess, []);
  }
  const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
  incomingMessages.push(wrappedMessage);
  if (incomingMessages.length > 1) {
    return;
  }
  while (incomingMessages.length > 0) {
    await waitForOutgoingMessages(anyProcess, ipcEmitter, wrappedMessage);
    await scheduler.yield();
    const message = await handleStrictRequest({
      wrappedMessage: incomingMessages[0],
      anyProcess,
      channel,
      isSubprocess,
      ipcEmitter
    });
    incomingMessages.shift();
    ipcEmitter.emit("message", message);
    ipcEmitter.emit("message:done");
  }
};
var onDisconnect = async ({ anyProcess, channel, isSubprocess, ipcEmitter, boundOnMessage }) => {
  abortOnDisconnect();
  const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
  while (incomingMessages?.length > 0) {
    await once2(ipcEmitter, "message:done");
  }
  anyProcess.removeListener("message", boundOnMessage);
  redoAddedReferences(channel, isSubprocess);
  ipcEmitter.connected = false;
  ipcEmitter.emit("disconnect");
};
var INCOMING_MESSAGES = new WeakMap;

// node_modules/execa/lib/ipc/forward.js
var getIpcEmitter = (anyProcess, channel, isSubprocess) => {
  if (IPC_EMITTERS.has(anyProcess)) {
    return IPC_EMITTERS.get(anyProcess);
  }
  const ipcEmitter = new EventEmitter;
  ipcEmitter.connected = true;
  IPC_EMITTERS.set(anyProcess, ipcEmitter);
  forwardEvents({
    ipcEmitter,
    anyProcess,
    channel,
    isSubprocess
  });
  return ipcEmitter;
};
var IPC_EMITTERS = new WeakMap;
var forwardEvents = ({ ipcEmitter, anyProcess, channel, isSubprocess }) => {
  const boundOnMessage = onMessage.bind(undefined, {
    anyProcess,
    channel,
    isSubprocess,
    ipcEmitter
  });
  anyProcess.on("message", boundOnMessage);
  anyProcess.once("disconnect", onDisconnect.bind(undefined, {
    anyProcess,
    channel,
    isSubprocess,
    ipcEmitter,
    boundOnMessage
  }));
  undoAddedReferences(channel, isSubprocess);
};
var isConnected = (anyProcess) => {
  const ipcEmitter = IPC_EMITTERS.get(anyProcess);
  return ipcEmitter === undefined ? anyProcess.channel !== null : ipcEmitter.connected;
};

// node_modules/execa/lib/ipc/strict.js
var handleSendStrict = ({ anyProcess, channel, isSubprocess, message, strict }) => {
  if (!strict) {
    return message;
  }
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const hasListeners = hasMessageListeners(anyProcess, ipcEmitter);
  return {
    id: count++,
    type: REQUEST_TYPE,
    message,
    hasListeners
  };
};
var count = 0n;
var validateStrictDeadlock = (outgoingMessages, wrappedMessage) => {
  if (wrappedMessage?.type !== REQUEST_TYPE || wrappedMessage.hasListeners) {
    return;
  }
  for (const { id } of outgoingMessages) {
    if (id !== undefined) {
      STRICT_RESPONSES[id].resolve({ isDeadlock: true, hasListeners: false });
    }
  }
};
var handleStrictRequest = async ({ wrappedMessage, anyProcess, channel, isSubprocess, ipcEmitter }) => {
  if (wrappedMessage?.type !== REQUEST_TYPE || !anyProcess.connected) {
    return wrappedMessage;
  }
  const { id, message } = wrappedMessage;
  const response = { id, type: RESPONSE_TYPE, message: hasMessageListeners(anyProcess, ipcEmitter) };
  try {
    await sendMessage({
      anyProcess,
      channel,
      isSubprocess,
      ipc: true
    }, response);
  } catch (error) {
    ipcEmitter.emit("strict:error", error);
  }
  return message;
};
var handleStrictResponse = (wrappedMessage) => {
  if (wrappedMessage?.type !== RESPONSE_TYPE) {
    return false;
  }
  const { id, message: hasListeners } = wrappedMessage;
  STRICT_RESPONSES[id]?.resolve({ isDeadlock: false, hasListeners });
  return true;
};
var waitForStrictResponse = async (wrappedMessage, anyProcess, isSubprocess) => {
  if (wrappedMessage?.type !== REQUEST_TYPE) {
    return;
  }
  const deferred = createDeferred();
  STRICT_RESPONSES[wrappedMessage.id] = deferred;
  const controller = new AbortController;
  try {
    const { isDeadlock, hasListeners } = await Promise.race([
      deferred,
      throwOnDisconnect(anyProcess, isSubprocess, controller)
    ]);
    if (isDeadlock) {
      throwOnStrictDeadlockError(isSubprocess);
    }
    if (!hasListeners) {
      throwOnMissingStrict(isSubprocess);
    }
  } finally {
    controller.abort();
    delete STRICT_RESPONSES[wrappedMessage.id];
  }
};
var STRICT_RESPONSES = {};
var throwOnDisconnect = async (anyProcess, isSubprocess, { signal }) => {
  incrementMaxListeners(anyProcess, 1, signal);
  await once3(anyProcess, "disconnect", { signal });
  throwOnStrictDisconnect(isSubprocess);
};
var REQUEST_TYPE = "execa:ipc:request";
var RESPONSE_TYPE = "execa:ipc:response";

// node_modules/execa/lib/ipc/outgoing.js
var startSendMessage = (anyProcess, wrappedMessage, strict) => {
  if (!OUTGOING_MESSAGES.has(anyProcess)) {
    OUTGOING_MESSAGES.set(anyProcess, new Set);
  }
  const outgoingMessages = OUTGOING_MESSAGES.get(anyProcess);
  const onMessageSent = createDeferred();
  const id = strict ? wrappedMessage.id : undefined;
  const outgoingMessage = { onMessageSent, id };
  outgoingMessages.add(outgoingMessage);
  return { outgoingMessages, outgoingMessage };
};
var endSendMessage = ({ outgoingMessages, outgoingMessage }) => {
  outgoingMessages.delete(outgoingMessage);
  outgoingMessage.onMessageSent.resolve();
};
var waitForOutgoingMessages = async (anyProcess, ipcEmitter, wrappedMessage) => {
  while (!hasMessageListeners(anyProcess, ipcEmitter) && OUTGOING_MESSAGES.get(anyProcess)?.size > 0) {
    const outgoingMessages = [...OUTGOING_MESSAGES.get(anyProcess)];
    validateStrictDeadlock(outgoingMessages, wrappedMessage);
    await Promise.all(outgoingMessages.map(({ onMessageSent }) => onMessageSent));
  }
};
var OUTGOING_MESSAGES = new WeakMap;
var hasMessageListeners = (anyProcess, ipcEmitter) => ipcEmitter.listenerCount("message") > getMinListenerCount(anyProcess);
var getMinListenerCount = (anyProcess) => SUBPROCESS_OPTIONS.has(anyProcess) && !getFdSpecificValue(SUBPROCESS_OPTIONS.get(anyProcess).options.buffer, "ipc") ? 1 : 0;

// node_modules/execa/lib/ipc/send.js
var sendMessage = ({ anyProcess, channel, isSubprocess, ipc }, message, { strict = false } = {}) => {
  const methodName = "sendMessage";
  validateIpcMethod({
    methodName,
    isSubprocess,
    ipc,
    isConnected: anyProcess.connected
  });
  return sendMessageAsync({
    anyProcess,
    channel,
    methodName,
    isSubprocess,
    message,
    strict
  });
};
var sendMessageAsync = async ({ anyProcess, channel, methodName, isSubprocess, message, strict }) => {
  const wrappedMessage = handleSendStrict({
    anyProcess,
    channel,
    isSubprocess,
    message,
    strict
  });
  const outgoingMessagesState = startSendMessage(anyProcess, wrappedMessage, strict);
  try {
    await sendOneMessage({
      anyProcess,
      methodName,
      isSubprocess,
      wrappedMessage,
      message
    });
  } catch (error) {
    disconnect(anyProcess);
    throw error;
  } finally {
    endSendMessage(outgoingMessagesState);
  }
};
var sendOneMessage = async ({ anyProcess, methodName, isSubprocess, wrappedMessage, message }) => {
  const sendMethod = getSendMethod(anyProcess);
  try {
    await Promise.all([
      waitForStrictResponse(wrappedMessage, anyProcess, isSubprocess),
      sendMethod(wrappedMessage)
    ]);
  } catch (error) {
    handleEpipeError({ error, methodName, isSubprocess });
    handleSerializationError({
      error,
      methodName,
      isSubprocess,
      message
    });
    throw error;
  }
};
var getSendMethod = (anyProcess) => {
  if (PROCESS_SEND_METHODS.has(anyProcess)) {
    return PROCESS_SEND_METHODS.get(anyProcess);
  }
  const sendMethod = promisify2(anyProcess.send.bind(anyProcess));
  PROCESS_SEND_METHODS.set(anyProcess, sendMethod);
  return sendMethod;
};
var PROCESS_SEND_METHODS = new WeakMap;

// node_modules/execa/lib/ipc/graceful.js
var sendAbort = (subprocess, message) => {
  const methodName = "cancelSignal";
  validateConnection(methodName, false, subprocess.connected);
  return sendOneMessage({
    anyProcess: subprocess,
    methodName,
    isSubprocess: false,
    wrappedMessage: { type: GRACEFUL_CANCEL_TYPE, message },
    message
  });
};
var getCancelSignal = async ({ anyProcess, channel, isSubprocess, ipc }) => {
  await startIpc({
    anyProcess,
    channel,
    isSubprocess,
    ipc
  });
  return cancelController.signal;
};
var startIpc = async ({ anyProcess, channel, isSubprocess, ipc }) => {
  if (cancelListening) {
    return;
  }
  cancelListening = true;
  if (!ipc) {
    throwOnMissingParent();
    return;
  }
  if (channel === null) {
    abortOnDisconnect();
    return;
  }
  getIpcEmitter(anyProcess, channel, isSubprocess);
  await scheduler2.yield();
};
var cancelListening = false;
var handleAbort = (wrappedMessage) => {
  if (wrappedMessage?.type !== GRACEFUL_CANCEL_TYPE) {
    return false;
  }
  cancelController.abort(wrappedMessage.message);
  return true;
};
var GRACEFUL_CANCEL_TYPE = "execa:ipc:cancel";
var abortOnDisconnect = () => {
  cancelController.abort(getAbortDisconnectError());
};
var cancelController = new AbortController;

// node_modules/execa/lib/terminate/graceful.js
var validateGracefulCancel = ({ gracefulCancel, cancelSignal, ipc, serialization }) => {
  if (!gracefulCancel) {
    return;
  }
  if (cancelSignal === undefined) {
    throw new Error("The `cancelSignal` option must be defined when setting the `gracefulCancel` option.");
  }
  if (!ipc) {
    throw new Error("The `ipc` option cannot be false when setting the `gracefulCancel` option.");
  }
  if (serialization === "json") {
    throw new Error("The `serialization` option cannot be 'json' when setting the `gracefulCancel` option.");
  }
};
var throwOnGracefulCancel = ({
  subprocess,
  cancelSignal,
  gracefulCancel,
  forceKillAfterDelay,
  context,
  controller
}) => gracefulCancel ? [sendOnAbort({
  subprocess,
  cancelSignal,
  forceKillAfterDelay,
  context,
  controller
})] : [];
var sendOnAbort = async ({ subprocess, cancelSignal, forceKillAfterDelay, context, controller: { signal } }) => {
  await onAbortedSignal(cancelSignal, signal);
  const reason = getReason(cancelSignal);
  await sendAbort(subprocess, reason);
  killOnTimeout({
    kill: subprocess.kill,
    forceKillAfterDelay,
    context,
    controllerSignal: signal
  });
  context.terminationReason ??= "gracefulCancel";
  throw cancelSignal.reason;
};
var getReason = ({ reason }) => {
  if (!(reason instanceof DOMException)) {
    return reason;
  }
  const error = new Error(reason.message);
  Object.defineProperty(error, "stack", {
    value: reason.stack,
    enumerable: false,
    configurable: true,
    writable: true
  });
  return error;
};

// node_modules/execa/lib/terminate/timeout.js
import { setTimeout as setTimeout3 } from "node:timers/promises";
var validateTimeout = ({ timeout }) => {
  if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
    throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
  }
};
var throwOnTimeout = (subprocess, timeout, context, controller) => timeout === 0 || timeout === undefined ? [] : [killAfterTimeout(subprocess, timeout, context, controller)];
var killAfterTimeout = async (subprocess, timeout, context, { signal }) => {
  await setTimeout3(timeout, undefined, { signal });
  context.terminationReason ??= "timeout";
  subprocess.kill();
  throw new DiscardedError;
};

// node_modules/execa/lib/methods/node.js
import { execPath, execArgv } from "node:process";
import path7 from "node:path";
var mapNode = ({ options }) => {
  if (options.node === false) {
    throw new TypeError('The "node" option cannot be false with `execaNode()`.');
  }
  return { options: { ...options, node: true } };
};
var handleNodeOption = (file, commandArguments, {
  node: shouldHandleNode = false,
  nodePath = execPath,
  nodeOptions = execArgv.filter((nodeOption) => !nodeOption.startsWith("--inspect")),
  cwd,
  execPath: formerNodePath,
  ...options
}) => {
  if (formerNodePath !== undefined) {
    throw new TypeError('The "execPath" option has been removed. Please use the "nodePath" option instead.');
  }
  const normalizedNodePath = safeNormalizeFileUrl(nodePath, 'The "nodePath" option');
  const resolvedNodePath = path7.resolve(cwd, normalizedNodePath);
  const newOptions = {
    ...options,
    nodePath: resolvedNodePath,
    node: shouldHandleNode,
    cwd
  };
  if (!shouldHandleNode) {
    return [file, commandArguments, newOptions];
  }
  if (path7.basename(file, ".exe") === "node") {
    throw new TypeError('When the "node" option is true, the first argument does not need to be "node".');
  }
  return [
    resolvedNodePath,
    [...nodeOptions, file, ...commandArguments],
    { ipc: true, ...newOptions, shell: false }
  ];
};

// node_modules/execa/lib/ipc/ipc-input.js
import { serialize } from "node:v8";
var validateIpcInputOption = ({ ipcInput, ipc, serialization }) => {
  if (ipcInput === undefined) {
    return;
  }
  if (!ipc) {
    throw new Error("The `ipcInput` option cannot be set unless the `ipc` option is `true`.");
  }
  validateIpcInput[serialization](ipcInput);
};
var validateAdvancedInput = (ipcInput) => {
  try {
    serialize(ipcInput);
  } catch (error) {
    throw new Error("The `ipcInput` option is not serializable with a structured clone.", { cause: error });
  }
};
var validateJsonInput = (ipcInput) => {
  try {
    JSON.stringify(ipcInput);
  } catch (error) {
    throw new Error("The `ipcInput` option is not serializable with JSON.", { cause: error });
  }
};
var validateIpcInput = {
  advanced: validateAdvancedInput,
  json: validateJsonInput
};
var sendIpcInput = async (subprocess, ipcInput) => {
  if (ipcInput === undefined) {
    return;
  }
  await subprocess.sendMessage(ipcInput);
};

// node_modules/execa/lib/arguments/encoding-option.js
var validateEncoding = ({ encoding }) => {
  if (ENCODINGS.has(encoding)) {
    return;
  }
  const correctEncoding = getCorrectEncoding(encoding);
  if (correctEncoding !== undefined) {
    throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to ${serializeEncoding(correctEncoding)}.`);
  }
  const correctEncodings = [...ENCODINGS].map((correctEncoding2) => serializeEncoding(correctEncoding2)).join(", ");
  throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to one of: ${correctEncodings}.`);
};
var TEXT_ENCODINGS = new Set(["utf8", "utf16le"]);
var BINARY_ENCODINGS = new Set(["buffer", "hex", "base64", "base64url", "latin1", "ascii"]);
var ENCODINGS = new Set([...TEXT_ENCODINGS, ...BINARY_ENCODINGS]);
var getCorrectEncoding = (encoding) => {
  if (encoding === null) {
    return "buffer";
  }
  if (typeof encoding !== "string") {
    return;
  }
  const lowerEncoding = encoding.toLowerCase();
  if (lowerEncoding in ENCODING_ALIASES) {
    return ENCODING_ALIASES[lowerEncoding];
  }
  if (ENCODINGS.has(lowerEncoding)) {
    return lowerEncoding;
  }
};
var ENCODING_ALIASES = {
  "utf-8": "utf8",
  "utf-16le": "utf16le",
  "ucs-2": "utf16le",
  ucs2: "utf16le",
  binary: "latin1"
};
var serializeEncoding = (encoding) => typeof encoding === "string" ? `"${encoding}"` : String(encoding);

// node_modules/execa/lib/arguments/cwd.js
import { statSync } from "node:fs";
import path8 from "node:path";
import process22 from "node:process";
var normalizeCwd = (cwd = getDefaultCwd()) => {
  const cwdString = safeNormalizeFileUrl(cwd, 'The "cwd" option');
  return path8.resolve(cwdString);
};
var getDefaultCwd = () => {
  try {
    return process22.cwd();
  } catch (error) {
    error.message = `The current directory does not exist.
${error.message}`;
    throw error;
  }
};
var fixCwdError = (originalMessage, cwd) => {
  if (cwd === getDefaultCwd()) {
    return originalMessage;
  }
  let cwdStat;
  try {
    cwdStat = statSync(cwd);
  } catch (error) {
    return `The "cwd" option is invalid: ${cwd}.
${error.message}
${originalMessage}`;
  }
  if (!cwdStat.isDirectory()) {
    return `The "cwd" option is not a directory: ${cwd}.
${originalMessage}`;
  }
  return originalMessage;
};

// node_modules/execa/lib/arguments/options.js
var normalizeOptions = (filePath, rawArguments, rawOptions) => {
  rawOptions.cwd = normalizeCwd(rawOptions.cwd);
  const [processedFile, processedArguments, processedOptions] = handleNodeOption(filePath, rawArguments, rawOptions);
  const { command: file, args: commandArguments, options: initialOptions } = import_cross_spawn.default._parse(processedFile, processedArguments, processedOptions);
  const fdOptions = normalizeFdSpecificOptions(initialOptions);
  const options = addDefaultOptions(fdOptions);
  validateTimeout(options);
  validateEncoding(options);
  validateIpcInputOption(options);
  validateCancelSignal(options);
  validateGracefulCancel(options);
  options.shell = normalizeFileUrl(options.shell);
  options.env = getEnv(options);
  options.killSignal = normalizeKillSignal(options.killSignal);
  options.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);
  options.lines = options.lines.map((lines4, fdNumber) => lines4 && !BINARY_ENCODINGS.has(options.encoding) && options.buffer[fdNumber]);
  if (process23.platform === "win32" && path9.basename(file, ".exe") === "cmd") {
    commandArguments.unshift("/q");
  }
  return { file, commandArguments, options };
};
var addDefaultOptions = ({
  extendEnv = true,
  preferLocal = false,
  cwd,
  localDir: localDirectory = cwd,
  encoding = "utf8",
  reject = true,
  cleanup = true,
  all = false,
  windowsHide = true,
  killSignal = "SIGTERM",
  forceKillAfterDelay = true,
  gracefulCancel = false,
  ipcInput,
  ipc = ipcInput !== undefined || gracefulCancel,
  serialization = "advanced",
  ...options
}) => ({
  ...options,
  extendEnv,
  preferLocal,
  cwd,
  localDirectory,
  encoding,
  reject,
  cleanup,
  all,
  windowsHide,
  killSignal,
  forceKillAfterDelay,
  gracefulCancel,
  ipcInput,
  ipc,
  serialization
});
var getEnv = ({ env: envOption, extendEnv, preferLocal, node, localDirectory, nodePath }) => {
  const env2 = extendEnv ? { ...process23.env, ...envOption } : envOption;
  if (preferLocal || node) {
    return npmRunPathEnv({
      env: env2,
      cwd: localDirectory,
      execPath: nodePath,
      preferLocal,
      addExecPath: node
    });
  }
  return env2;
};

// node_modules/execa/lib/return/message.js
import { inspect as inspect2 } from "node:util";

// node_modules/strip-final-newline/index.js
function stripFinalNewline(input) {
  if (typeof input === "string") {
    return stripFinalNewlineString(input);
  }
  if (!(ArrayBuffer.isView(input) && input.BYTES_PER_ELEMENT === 1)) {
    throw new Error("Input must be a string or a Uint8Array");
  }
  return stripFinalNewlineBinary(input);
}
var stripFinalNewlineString = (input) => input.at(-1) === LF ? input.slice(0, input.at(-2) === CR ? -2 : -1) : input;
var stripFinalNewlineBinary = (input) => input.at(-1) === LF_BINARY ? input.subarray(0, input.at(-2) === CR_BINARY ? -2 : -1) : input;
var LF = `
`;
var LF_BINARY = LF.codePointAt(0);
var CR = "\r";
var CR_BINARY = CR.codePointAt(0);

// node_modules/get-stream/source/index.js
import { on } from "node:events";
import { finished } from "node:stream/promises";

// node_modules/is-stream/index.js
function isStream(stream, { checkOpen = true } = {}) {
  return stream !== null && typeof stream === "object" && (stream.writable || stream.readable || !checkOpen || stream.writable === undefined && stream.readable === undefined) && typeof stream.pipe === "function";
}
function isWritableStream(stream, { checkOpen = true } = {}) {
  return isStream(stream, { checkOpen }) && (stream.writable || !checkOpen) && typeof stream.write === "function" && typeof stream.end === "function" && typeof stream.writable === "boolean" && typeof stream.writableObjectMode === "boolean" && typeof stream.destroy === "function" && typeof stream.destroyed === "boolean";
}
function isReadableStream(stream, { checkOpen = true } = {}) {
  return isStream(stream, { checkOpen }) && (stream.readable || !checkOpen) && typeof stream.read === "function" && typeof stream.readable === "boolean" && typeof stream.readableObjectMode === "boolean" && typeof stream.destroy === "function" && typeof stream.destroyed === "boolean";
}
function isDuplexStream(stream, options) {
  return isWritableStream(stream, options) && isReadableStream(stream, options);
}

// node_modules/@sec-ant/readable-stream/dist/ponyfill/asyncIterator.js
var a = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
}).prototype);

class c {
  #t;
  #n;
  #r = false;
  #e = undefined;
  constructor(e, t) {
    this.#t = e, this.#n = t;
  }
  next() {
    const e = () => this.#s();
    return this.#e = this.#e ? this.#e.then(e, e) : e(), this.#e;
  }
  return(e) {
    const t = () => this.#i(e);
    return this.#e ? this.#e.then(t, t) : t();
  }
  async#s() {
    if (this.#r)
      return {
        done: true,
        value: undefined
      };
    let e;
    try {
      e = await this.#t.read();
    } catch (t) {
      throw this.#e = undefined, this.#r = true, this.#t.releaseLock(), t;
    }
    return e.done && (this.#e = undefined, this.#r = true, this.#t.releaseLock()), e;
  }
  async#i(e) {
    if (this.#r)
      return {
        done: true,
        value: e
      };
    if (this.#r = true, !this.#n) {
      const t = this.#t.cancel(e);
      return this.#t.releaseLock(), await t, {
        done: true,
        value: e
      };
    }
    return this.#t.releaseLock(), {
      done: true,
      value: e
    };
  }
}
var n = Symbol();
function i() {
  return this[n].next();
}
Object.defineProperty(i, "name", { value: "next" });
function o(r) {
  return this[n].return(r);
}
Object.defineProperty(o, "name", { value: "return" });
var u = Object.create(a, {
  next: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: i
  },
  return: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: o
  }
});
function h({ preventCancel: r = false } = {}) {
  const e = this.getReader(), t = new c(e, r), s = Object.create(u);
  return s[n] = t, s;
}

// node_modules/get-stream/source/stream.js
var getAsyncIterable = (stream) => {
  if (isReadableStream(stream, { checkOpen: false }) && nodeImports.on !== undefined) {
    return getStreamIterable(stream);
  }
  if (typeof stream?.[Symbol.asyncIterator] === "function") {
    return stream;
  }
  if (toString.call(stream) === "[object ReadableStream]") {
    return h.call(stream);
  }
  throw new TypeError("The first argument must be a Readable, a ReadableStream, or an async iterable.");
};
var { toString } = Object.prototype;
var getStreamIterable = async function* (stream) {
  const controller = new AbortController;
  const state = {};
  handleStreamEnd(stream, controller, state);
  try {
    for await (const [chunk] of nodeImports.on(stream, "data", { signal: controller.signal })) {
      yield chunk;
    }
  } catch (error) {
    if (state.error !== undefined) {
      throw state.error;
    } else if (!controller.signal.aborted) {
      throw error;
    }
  } finally {
    stream.destroy();
  }
};
var handleStreamEnd = async (stream, controller, state) => {
  try {
    await nodeImports.finished(stream, {
      cleanup: true,
      readable: true,
      writable: false,
      error: false
    });
  } catch (error) {
    state.error = error;
  } finally {
    controller.abort();
  }
};
var nodeImports = {};

// node_modules/get-stream/source/contents.js
var getStreamContents = async (stream, { init: init2, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize }, { maxBuffer = Number.POSITIVE_INFINITY } = {}) => {
  const asyncIterable = getAsyncIterable(stream);
  const state = init2();
  state.length = 0;
  try {
    for await (const chunk of asyncIterable) {
      const chunkType = getChunkType(chunk);
      const convertedChunk = convertChunk[chunkType](chunk, state);
      appendChunk({
        convertedChunk,
        state,
        getSize,
        truncateChunk,
        addChunk,
        maxBuffer
      });
    }
    appendFinalChunk({
      state,
      convertChunk,
      getSize,
      truncateChunk,
      addChunk,
      getFinalChunk,
      maxBuffer
    });
    return finalize(state);
  } catch (error) {
    const normalizedError = typeof error === "object" && error !== null ? error : new Error(error);
    normalizedError.bufferedData = finalize(state);
    throw normalizedError;
  }
};
var appendFinalChunk = ({ state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer }) => {
  const convertedChunk = getFinalChunk(state);
  if (convertedChunk !== undefined) {
    appendChunk({
      convertedChunk,
      state,
      getSize,
      truncateChunk,
      addChunk,
      maxBuffer
    });
  }
};
var appendChunk = ({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer }) => {
  const chunkSize = getSize(convertedChunk);
  const newLength = state.length + chunkSize;
  if (newLength <= maxBuffer) {
    addNewChunk(convertedChunk, state, addChunk, newLength);
    return;
  }
  const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);
  if (truncatedChunk !== undefined) {
    addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
  }
  throw new MaxBufferError;
};
var addNewChunk = (convertedChunk, state, addChunk, newLength) => {
  state.contents = addChunk(convertedChunk, state, newLength);
  state.length = newLength;
};
var getChunkType = (chunk) => {
  const typeOfChunk = typeof chunk;
  if (typeOfChunk === "string") {
    return "string";
  }
  if (typeOfChunk !== "object" || chunk === null) {
    return "others";
  }
  if (globalThis.Buffer?.isBuffer(chunk)) {
    return "buffer";
  }
  const prototypeName = objectToString2.call(chunk);
  if (prototypeName === "[object ArrayBuffer]") {
    return "arrayBuffer";
  }
  if (prototypeName === "[object DataView]") {
    return "dataView";
  }
  if (Number.isInteger(chunk.byteLength) && Number.isInteger(chunk.byteOffset) && objectToString2.call(chunk.buffer) === "[object ArrayBuffer]") {
    return "typedArray";
  }
  return "others";
};
var { toString: objectToString2 } = Object.prototype;

class MaxBufferError extends Error {
  name = "MaxBufferError";
  constructor() {
    super("maxBuffer exceeded");
  }
}

// node_modules/get-stream/source/utils.js
var identity2 = (value) => value;
var noop = () => {
  return;
};
var getContentsProperty = ({ contents }) => contents;
var throwObjectStream = (chunk) => {
  throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
};
var getLengthProperty = (convertedChunk) => convertedChunk.length;

// node_modules/get-stream/source/array.js
async function getStreamAsArray(stream, options) {
  return getStreamContents(stream, arrayMethods, options);
}
var initArray = () => ({ contents: [] });
var increment = () => 1;
var addArrayChunk = (convertedChunk, { contents }) => {
  contents.push(convertedChunk);
  return contents;
};
var arrayMethods = {
  init: initArray,
  convertChunk: {
    string: identity2,
    buffer: identity2,
    arrayBuffer: identity2,
    dataView: identity2,
    typedArray: identity2,
    others: identity2
  },
  getSize: increment,
  truncateChunk: noop,
  addChunk: addArrayChunk,
  getFinalChunk: noop,
  finalize: getContentsProperty
};
// node_modules/get-stream/source/array-buffer.js
async function getStreamAsArrayBuffer(stream, options) {
  return getStreamContents(stream, arrayBufferMethods, options);
}
var initArrayBuffer = () => ({ contents: new ArrayBuffer(0) });
var useTextEncoder = (chunk) => textEncoder2.encode(chunk);
var textEncoder2 = new TextEncoder;
var useUint8Array = (chunk) => new Uint8Array(chunk);
var useUint8ArrayWithOffset = (chunk) => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
var truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
var addArrayBufferChunk = (convertedChunk, { contents, length: previousLength }, length) => {
  const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
  new Uint8Array(newContents).set(convertedChunk, previousLength);
  return newContents;
};
var resizeArrayBufferSlow = (contents, length) => {
  if (length <= contents.byteLength) {
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
};
var resizeArrayBuffer = (contents, length) => {
  if (length <= contents.maxByteLength) {
    contents.resize(length);
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(length, { maxByteLength: getNewContentsLength(length) });
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
};
var getNewContentsLength = (length) => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));
var SCALE_FACTOR = 2;
var finalizeArrayBuffer = ({ contents, length }) => hasArrayBufferResize() ? contents : contents.slice(0, length);
var hasArrayBufferResize = () => ("resize" in ArrayBuffer.prototype);
var arrayBufferMethods = {
  init: initArrayBuffer,
  convertChunk: {
    string: useTextEncoder,
    buffer: useUint8Array,
    arrayBuffer: useUint8Array,
    dataView: useUint8ArrayWithOffset,
    typedArray: useUint8ArrayWithOffset,
    others: throwObjectStream
  },
  getSize: getLengthProperty,
  truncateChunk: truncateArrayBufferChunk,
  addChunk: addArrayBufferChunk,
  getFinalChunk: noop,
  finalize: finalizeArrayBuffer
};
// node_modules/get-stream/source/string.js
async function getStreamAsString(stream, options) {
  return getStreamContents(stream, stringMethods, options);
}
var initString = () => ({ contents: "", textDecoder: new TextDecoder });
var useTextDecoder = (chunk, { textDecoder: textDecoder2 }) => textDecoder2.decode(chunk, { stream: true });
var addStringChunk = (convertedChunk, { contents }) => contents + convertedChunk;
var truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
var getFinalStringChunk = ({ textDecoder: textDecoder2 }) => {
  const finalChunk = textDecoder2.decode();
  return finalChunk === "" ? undefined : finalChunk;
};
var stringMethods = {
  init: initString,
  convertChunk: {
    string: identity2,
    buffer: useTextDecoder,
    arrayBuffer: useTextDecoder,
    dataView: useTextDecoder,
    typedArray: useTextDecoder,
    others: throwObjectStream
  },
  getSize: getLengthProperty,
  truncateChunk: truncateStringChunk,
  addChunk: addStringChunk,
  getFinalChunk: getFinalStringChunk,
  finalize: getContentsProperty
};
// node_modules/get-stream/source/index.js
Object.assign(nodeImports, { on, finished });

// node_modules/execa/lib/io/max-buffer.js
var handleMaxBuffer = ({ error, stream, readableObjectMode, lines: lines4, encoding, fdNumber }) => {
  if (!(error instanceof MaxBufferError)) {
    throw error;
  }
  if (fdNumber === "all") {
    return error;
  }
  const unit = getMaxBufferUnit(readableObjectMode, lines4, encoding);
  error.maxBufferInfo = { fdNumber, unit };
  stream.destroy();
  throw error;
};
var getMaxBufferUnit = (readableObjectMode, lines4, encoding) => {
  if (readableObjectMode) {
    return "objects";
  }
  if (lines4) {
    return "lines";
  }
  if (encoding === "buffer") {
    return "bytes";
  }
  return "characters";
};
var checkIpcMaxBuffer = (subprocess, ipcOutput, maxBuffer) => {
  if (ipcOutput.length !== maxBuffer) {
    return;
  }
  const error = new MaxBufferError;
  error.maxBufferInfo = { fdNumber: "ipc" };
  throw error;
};
var getMaxBufferMessage = (error, maxBuffer) => {
  const { streamName, threshold, unit } = getMaxBufferInfo(error, maxBuffer);
  return `Command's ${streamName} was larger than ${threshold} ${unit}`;
};
var getMaxBufferInfo = (error, maxBuffer) => {
  if (error?.maxBufferInfo === undefined) {
    return { streamName: "output", threshold: maxBuffer[1], unit: "bytes" };
  }
  const { maxBufferInfo: { fdNumber, unit } } = error;
  delete error.maxBufferInfo;
  const threshold = getFdSpecificValue(maxBuffer, fdNumber);
  if (fdNumber === "ipc") {
    return { streamName: "IPC output", threshold, unit: "messages" };
  }
  return { streamName: getStreamName(fdNumber), threshold, unit };
};
var isMaxBufferSync = (resultError, output, maxBuffer) => resultError?.code === "ENOBUFS" && output !== null && output.some((result) => result !== null && result.length > getMaxBufferSync(maxBuffer));
var truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer) => {
  if (!isMaxBuffer) {
    return result;
  }
  const maxBufferValue = getMaxBufferSync(maxBuffer);
  return result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;
};
var getMaxBufferSync = ([, stdoutMaxBuffer]) => stdoutMaxBuffer;

// node_modules/execa/lib/return/message.js
var createMessages = ({
  stdio,
  all,
  ipcOutput,
  originalError,
  signal,
  signalDescription,
  exitCode,
  escapedCommand,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  forceKillAfterDelay,
  killSignal,
  maxBuffer,
  timeout,
  cwd
}) => {
  const errorCode = originalError?.code;
  const prefix = getErrorPrefix({
    originalError,
    timedOut,
    timeout,
    isMaxBuffer,
    maxBuffer,
    errorCode,
    signal,
    signalDescription,
    exitCode,
    isCanceled,
    isGracefullyCanceled,
    isForcefullyTerminated,
    forceKillAfterDelay,
    killSignal
  });
  const originalMessage = getOriginalMessage(originalError, cwd);
  const suffix = originalMessage === undefined ? "" : `
${originalMessage}`;
  const shortMessage = `${prefix}: ${escapedCommand}${suffix}`;
  const messageStdio = all === undefined ? [stdio[2], stdio[1]] : [all];
  const message = [
    shortMessage,
    ...messageStdio,
    ...stdio.slice(3),
    ipcOutput.map((ipcMessage) => serializeIpcMessage(ipcMessage)).join(`
`)
  ].map((messagePart) => escapeLines(stripFinalNewline(serializeMessagePart(messagePart)))).filter(Boolean).join(`

`);
  return { originalMessage, shortMessage, message };
};
var getErrorPrefix = ({
  originalError,
  timedOut,
  timeout,
  isMaxBuffer,
  maxBuffer,
  errorCode,
  signal,
  signalDescription,
  exitCode,
  isCanceled,
  isGracefullyCanceled,
  isForcefullyTerminated,
  forceKillAfterDelay,
  killSignal
}) => {
  const forcefulSuffix = getForcefulSuffix(isForcefullyTerminated, forceKillAfterDelay);
  if (timedOut) {
    return `Command timed out after ${timeout} milliseconds${forcefulSuffix}`;
  }
  if (isGracefullyCanceled) {
    if (signal === undefined) {
      return `Command was gracefully canceled with exit code ${exitCode}`;
    }
    return isForcefullyTerminated ? `Command was gracefully canceled${forcefulSuffix}` : `Command was gracefully canceled with ${signal} (${signalDescription})`;
  }
  if (isCanceled) {
    return `Command was canceled${forcefulSuffix}`;
  }
  if (isMaxBuffer) {
    return `${getMaxBufferMessage(originalError, maxBuffer)}${forcefulSuffix}`;
  }
  if (errorCode !== undefined) {
    return `Command failed with ${errorCode}${forcefulSuffix}`;
  }
  if (isForcefullyTerminated) {
    return `Command was killed with ${killSignal} (${getSignalDescription(killSignal)})${forcefulSuffix}`;
  }
  if (signal !== undefined) {
    return `Command was killed with ${signal} (${signalDescription})`;
  }
  if (exitCode !== undefined) {
    return `Command failed with exit code ${exitCode}`;
  }
  return "Command failed";
};
var getForcefulSuffix = (isForcefullyTerminated, forceKillAfterDelay) => isForcefullyTerminated ? ` and was forcefully terminated after ${forceKillAfterDelay} milliseconds` : "";
var getOriginalMessage = (originalError, cwd) => {
  if (originalError instanceof DiscardedError) {
    return;
  }
  const originalMessage = isExecaError(originalError) ? originalError.originalMessage : String(originalError?.message ?? originalError);
  const escapedOriginalMessage = escapeLines(fixCwdError(originalMessage, cwd));
  return escapedOriginalMessage === "" ? undefined : escapedOriginalMessage;
};
var serializeIpcMessage = (ipcMessage) => typeof ipcMessage === "string" ? ipcMessage : inspect2(ipcMessage);
var serializeMessagePart = (messagePart) => Array.isArray(messagePart) ? messagePart.map((messageItem) => stripFinalNewline(serializeMessageItem(messageItem))).filter(Boolean).join(`
`) : serializeMessageItem(messagePart);
var serializeMessageItem = (messageItem) => {
  if (typeof messageItem === "string") {
    return messageItem;
  }
  if (isUint8Array(messageItem)) {
    return uint8ArrayToString(messageItem);
  }
  return "";
};

// node_modules/execa/lib/return/result.js
var makeSuccessResult = ({
  command: command2,
  escapedCommand,
  stdio,
  all,
  ipcOutput,
  options: { cwd },
  startTime
}) => omitUndefinedProperties({
  command: command2,
  escapedCommand,
  cwd,
  durationMs: getDurationMs(startTime),
  failed: false,
  timedOut: false,
  isCanceled: false,
  isGracefullyCanceled: false,
  isTerminated: false,
  isMaxBuffer: false,
  isForcefullyTerminated: false,
  exitCode: 0,
  stdout: stdio[1],
  stderr: stdio[2],
  all,
  stdio,
  ipcOutput,
  pipedFrom: []
});
var makeEarlyError = ({
  error,
  command: command2,
  escapedCommand,
  fileDescriptors,
  options,
  startTime,
  isSync
}) => makeError({
  error,
  command: command2,
  escapedCommand,
  startTime,
  timedOut: false,
  isCanceled: false,
  isGracefullyCanceled: false,
  isMaxBuffer: false,
  isForcefullyTerminated: false,
  stdio: Array.from({ length: fileDescriptors.length }),
  ipcOutput: [],
  options,
  isSync
});
var makeError = ({
  error: originalError,
  command: command2,
  escapedCommand,
  startTime,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode: rawExitCode,
  signal: rawSignal,
  stdio,
  all,
  ipcOutput,
  options: {
    timeoutDuration,
    timeout = timeoutDuration,
    forceKillAfterDelay,
    killSignal,
    cwd,
    maxBuffer
  },
  isSync
}) => {
  const { exitCode, signal, signalDescription } = normalizeExitPayload(rawExitCode, rawSignal);
  const { originalMessage, shortMessage, message } = createMessages({
    stdio,
    all,
    ipcOutput,
    originalError,
    signal,
    signalDescription,
    exitCode,
    escapedCommand,
    timedOut,
    isCanceled,
    isGracefullyCanceled,
    isMaxBuffer,
    isForcefullyTerminated,
    forceKillAfterDelay,
    killSignal,
    maxBuffer,
    timeout,
    cwd
  });
  const error = getFinalError(originalError, message, isSync);
  Object.assign(error, getErrorProperties({
    error,
    command: command2,
    escapedCommand,
    startTime,
    timedOut,
    isCanceled,
    isGracefullyCanceled,
    isMaxBuffer,
    isForcefullyTerminated,
    exitCode,
    signal,
    signalDescription,
    stdio,
    all,
    ipcOutput,
    cwd,
    originalMessage,
    shortMessage
  }));
  return error;
};
var getErrorProperties = ({
  error,
  command: command2,
  escapedCommand,
  startTime,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode,
  signal,
  signalDescription,
  stdio,
  all,
  ipcOutput,
  cwd,
  originalMessage,
  shortMessage
}) => omitUndefinedProperties({
  shortMessage,
  originalMessage,
  command: command2,
  escapedCommand,
  cwd,
  durationMs: getDurationMs(startTime),
  failed: true,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isTerminated: signal !== undefined,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode,
  signal,
  signalDescription,
  code: error.cause?.code,
  stdout: stdio[1],
  stderr: stdio[2],
  all,
  stdio,
  ipcOutput,
  pipedFrom: []
});
var omitUndefinedProperties = (result) => Object.fromEntries(Object.entries(result).filter(([, value]) => value !== undefined));
var normalizeExitPayload = (rawExitCode, rawSignal) => {
  const exitCode = rawExitCode === null ? undefined : rawExitCode;
  const signal = rawSignal === null ? undefined : rawSignal;
  const signalDescription = signal === undefined ? undefined : getSignalDescription(rawSignal);
  return { exitCode, signal, signalDescription };
};

// node_modules/parse-ms/index.js
var toZeroIfInfinity = (value) => Number.isFinite(value) ? value : 0;
function parseNumber(milliseconds) {
  return {
    days: Math.trunc(milliseconds / 86400000),
    hours: Math.trunc(milliseconds / 3600000 % 24),
    minutes: Math.trunc(milliseconds / 60000 % 60),
    seconds: Math.trunc(milliseconds / 1000 % 60),
    milliseconds: Math.trunc(milliseconds % 1000),
    microseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1000) % 1000),
    nanoseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e6) % 1000)
  };
}
function parseBigint(milliseconds) {
  return {
    days: milliseconds / 86400000n,
    hours: milliseconds / 3600000n % 24n,
    minutes: milliseconds / 60000n % 60n,
    seconds: milliseconds / 1000n % 60n,
    milliseconds: milliseconds % 1000n,
    microseconds: 0n,
    nanoseconds: 0n
  };
}
function parseMilliseconds(milliseconds) {
  switch (typeof milliseconds) {
    case "number": {
      if (Number.isFinite(milliseconds)) {
        return parseNumber(milliseconds);
      }
      break;
    }
    case "bigint": {
      return parseBigint(milliseconds);
    }
  }
  throw new TypeError("Expected a finite number or bigint");
}

// node_modules/pretty-ms/index.js
var isZero = (value) => value === 0 || value === 0n;
var pluralize = (word, count2) => count2 === 1 || count2 === 1n ? word : `${word}s`;
var SECOND_ROUNDING_EPSILON = 0.0000001;
var ONE_DAY_IN_MILLISECONDS = 24n * 60n * 60n * 1000n;
function prettyMilliseconds(milliseconds, options) {
  const isBigInt = typeof milliseconds === "bigint";
  if (!isBigInt && !Number.isFinite(milliseconds)) {
    throw new TypeError("Expected a finite number or bigint");
  }
  options = { ...options };
  const sign = milliseconds < 0 ? "-" : "";
  milliseconds = milliseconds < 0 ? -milliseconds : milliseconds;
  if (options.colonNotation) {
    options.compact = false;
    options.formatSubMilliseconds = false;
    options.separateMilliseconds = false;
    options.verbose = false;
  }
  if (options.compact) {
    options.unitCount = 1;
    options.secondsDecimalDigits = 0;
    options.millisecondsDecimalDigits = 0;
  }
  let result = [];
  const floorDecimals = (value, decimalDigits) => {
    const flooredInterimValue = Math.floor(value * 10 ** decimalDigits + SECOND_ROUNDING_EPSILON);
    const flooredValue = Math.round(flooredInterimValue) / 10 ** decimalDigits;
    return flooredValue.toFixed(decimalDigits);
  };
  const add = (value, long, short, valueString) => {
    if ((result.length === 0 || !options.colonNotation) && isZero(value) && !(options.colonNotation && short === "m")) {
      return;
    }
    valueString ??= String(value);
    if (options.colonNotation) {
      const wholeDigits = valueString.includes(".") ? valueString.split(".")[0].length : valueString.length;
      const minLength = result.length > 0 ? 2 : 1;
      valueString = "0".repeat(Math.max(0, minLength - wholeDigits)) + valueString;
    } else {
      valueString += options.verbose ? " " + pluralize(long, value) : short;
    }
    result.push(valueString);
  };
  const parsed = parseMilliseconds(milliseconds);
  const days = BigInt(parsed.days);
  if (options.hideYearAndDays) {
    add(BigInt(days) * 24n + BigInt(parsed.hours), "hour", "h");
  } else {
    if (options.hideYear) {
      add(days, "day", "d");
    } else {
      add(days / 365n, "year", "y");
      add(days % 365n, "day", "d");
    }
    add(Number(parsed.hours), "hour", "h");
  }
  add(Number(parsed.minutes), "minute", "m");
  if (!options.hideSeconds) {
    if (options.separateMilliseconds || options.formatSubMilliseconds || !options.colonNotation && milliseconds < 1000) {
      const seconds = Number(parsed.seconds);
      const milliseconds2 = Number(parsed.milliseconds);
      const microseconds = Number(parsed.microseconds);
      const nanoseconds = Number(parsed.nanoseconds);
      add(seconds, "second", "s");
      if (options.formatSubMilliseconds) {
        add(milliseconds2, "millisecond", "ms");
        add(microseconds, "microsecond", "s");
        add(nanoseconds, "nanosecond", "ns");
      } else {
        const millisecondsAndBelow = milliseconds2 + microseconds / 1000 + nanoseconds / 1e6;
        const millisecondsDecimalDigits = typeof options.millisecondsDecimalDigits === "number" ? options.millisecondsDecimalDigits : 0;
        const roundedMilliseconds = millisecondsAndBelow >= 1 ? Math.round(millisecondsAndBelow) : Math.ceil(millisecondsAndBelow);
        const millisecondsString = millisecondsDecimalDigits ? millisecondsAndBelow.toFixed(millisecondsDecimalDigits) : roundedMilliseconds;
        add(Number.parseFloat(millisecondsString), "millisecond", "ms", millisecondsString);
      }
    } else {
      const seconds = (isBigInt ? Number(milliseconds % ONE_DAY_IN_MILLISECONDS) : milliseconds) / 1000 % 60;
      const secondsDecimalDigits = typeof options.secondsDecimalDigits === "number" ? options.secondsDecimalDigits : 1;
      const secondsFixed = floorDecimals(seconds, secondsDecimalDigits);
      const secondsString = options.keepDecimalsOnWholeSeconds ? secondsFixed : secondsFixed.replace(/\.0+$/, "");
      add(Number.parseFloat(secondsString), "second", "s", secondsString);
    }
  }
  if (result.length === 0) {
    return sign + "0" + (options.verbose ? " milliseconds" : "ms");
  }
  const separator = options.colonNotation ? ":" : " ";
  if (typeof options.unitCount === "number") {
    result = result.slice(0, Math.max(options.unitCount, 1));
  }
  return sign + result.join(separator);
}

// node_modules/execa/lib/verbose/error.js
var logError = (result, verboseInfo) => {
  if (result.failed) {
    verboseLog({
      type: "error",
      verboseMessage: result.shortMessage,
      verboseInfo,
      result
    });
  }
};

// node_modules/execa/lib/verbose/complete.js
var logResult = (result, verboseInfo) => {
  if (!isVerbose(verboseInfo)) {
    return;
  }
  logError(result, verboseInfo);
  logDuration(result, verboseInfo);
};
var logDuration = (result, verboseInfo) => {
  const verboseMessage = `(done in ${prettyMilliseconds(result.durationMs)})`;
  verboseLog({
    type: "duration",
    verboseMessage,
    verboseInfo,
    result
  });
};

// node_modules/execa/lib/return/reject.js
var handleResult2 = (result, verboseInfo, { reject }) => {
  logResult(result, verboseInfo);
  if (result.failed && reject) {
    throw result;
  }
  return result;
};

// node_modules/execa/lib/stdio/handle-sync.js
import { readFileSync as readFileSync2 } from "node:fs";

// node_modules/execa/lib/stdio/type.js
var getStdioItemType = (value, optionName) => {
  if (isAsyncGenerator(value)) {
    return "asyncGenerator";
  }
  if (isSyncGenerator(value)) {
    return "generator";
  }
  if (isUrl(value)) {
    return "fileUrl";
  }
  if (isFilePathObject(value)) {
    return "filePath";
  }
  if (isWebStream(value)) {
    return "webStream";
  }
  if (isStream(value, { checkOpen: false })) {
    return "native";
  }
  if (isUint8Array(value)) {
    return "uint8Array";
  }
  if (isAsyncIterableObject(value)) {
    return "asyncIterable";
  }
  if (isIterableObject(value)) {
    return "iterable";
  }
  if (isTransformStream(value)) {
    return getTransformStreamType({ transform: value }, optionName);
  }
  if (isTransformOptions(value)) {
    return getTransformObjectType(value, optionName);
  }
  return "native";
};
var getTransformObjectType = (value, optionName) => {
  if (isDuplexStream(value.transform, { checkOpen: false })) {
    return getDuplexType(value, optionName);
  }
  if (isTransformStream(value.transform)) {
    return getTransformStreamType(value, optionName);
  }
  return getGeneratorObjectType(value, optionName);
};
var getDuplexType = (value, optionName) => {
  validateNonGeneratorType(value, optionName, "Duplex stream");
  return "duplex";
};
var getTransformStreamType = (value, optionName) => {
  validateNonGeneratorType(value, optionName, "web TransformStream");
  return "webTransform";
};
var validateNonGeneratorType = ({ final, binary, objectMode }, optionName, typeName) => {
  checkUndefinedOption(final, `${optionName}.final`, typeName);
  checkUndefinedOption(binary, `${optionName}.binary`, typeName);
  checkBooleanOption(objectMode, `${optionName}.objectMode`);
};
var checkUndefinedOption = (value, optionName, typeName) => {
  if (value !== undefined) {
    throw new TypeError(`The \`${optionName}\` option can only be defined when using a generator, not a ${typeName}.`);
  }
};
var getGeneratorObjectType = ({ transform, final, binary, objectMode }, optionName) => {
  if (transform !== undefined && !isGenerator(transform)) {
    throw new TypeError(`The \`${optionName}.transform\` option must be a generator, a Duplex stream or a web TransformStream.`);
  }
  if (isDuplexStream(final, { checkOpen: false })) {
    throw new TypeError(`The \`${optionName}.final\` option must not be a Duplex stream.`);
  }
  if (isTransformStream(final)) {
    throw new TypeError(`The \`${optionName}.final\` option must not be a web TransformStream.`);
  }
  if (final !== undefined && !isGenerator(final)) {
    throw new TypeError(`The \`${optionName}.final\` option must be a generator.`);
  }
  checkBooleanOption(binary, `${optionName}.binary`);
  checkBooleanOption(objectMode, `${optionName}.objectMode`);
  return isAsyncGenerator(transform) || isAsyncGenerator(final) ? "asyncGenerator" : "generator";
};
var checkBooleanOption = (value, optionName) => {
  if (value !== undefined && typeof value !== "boolean") {
    throw new TypeError(`The \`${optionName}\` option must use a boolean.`);
  }
};
var isGenerator = (value) => isAsyncGenerator(value) || isSyncGenerator(value);
var isAsyncGenerator = (value) => Object.prototype.toString.call(value) === "[object AsyncGeneratorFunction]";
var isSyncGenerator = (value) => Object.prototype.toString.call(value) === "[object GeneratorFunction]";
var isTransformOptions = (value) => isPlainObject11(value) && (value.transform !== undefined || value.final !== undefined);
var isUrl = (value) => Object.prototype.toString.call(value) === "[object URL]";
var isRegularUrl = (value) => isUrl(value) && value.protocol !== "file:";
var isFilePathObject = (value) => isPlainObject11(value) && Object.keys(value).length > 0 && Object.keys(value).every((key12) => FILE_PATH_KEYS.has(key12)) && isFilePathString(value.file);
var FILE_PATH_KEYS = new Set(["file", "append"]);
var isFilePathString = (file) => typeof file === "string";
var isUnknownStdioString = (type, value) => type === "native" && typeof value === "string" && !KNOWN_STDIO_STRINGS.has(value);
var KNOWN_STDIO_STRINGS = new Set(["ipc", "ignore", "inherit", "overlapped", "pipe"]);
var isReadableStream2 = (value) => Object.prototype.toString.call(value) === "[object ReadableStream]";
var isWritableStream2 = (value) => Object.prototype.toString.call(value) === "[object WritableStream]";
var isWebStream = (value) => isReadableStream2(value) || isWritableStream2(value);
var isTransformStream = (value) => isReadableStream2(value?.readable) && isWritableStream2(value?.writable);
var isAsyncIterableObject = (value) => isObject(value) && typeof value[Symbol.asyncIterator] === "function";
var isIterableObject = (value) => isObject(value) && typeof value[Symbol.iterator] === "function";
var isObject = (value) => typeof value === "object" && value !== null;
var TRANSFORM_TYPES = new Set(["generator", "asyncGenerator", "duplex", "webTransform"]);
var FILE_TYPES = new Set(["fileUrl", "filePath", "fileNumber"]);
var SPECIAL_DUPLICATE_TYPES_SYNC = new Set(["fileUrl", "filePath"]);
var SPECIAL_DUPLICATE_TYPES = new Set([...SPECIAL_DUPLICATE_TYPES_SYNC, "webStream", "nodeStream"]);
var FORBID_DUPLICATE_TYPES = new Set(["webTransform", "duplex"]);
var TYPE_TO_MESSAGE = {
  generator: "a generator",
  asyncGenerator: "an async generator",
  fileUrl: "a file URL",
  filePath: "a file path string",
  fileNumber: "a file descriptor number",
  webStream: "a web stream",
  nodeStream: "a Node.js stream",
  webTransform: "a web TransformStream",
  duplex: "a Duplex stream",
  native: "any value",
  iterable: "an iterable",
  asyncIterable: "an async iterable",
  string: "a string",
  uint8Array: "a Uint8Array"
};

// node_modules/execa/lib/transform/object-mode.js
var getTransformObjectModes = (objectMode, index, newTransforms, direction) => direction === "output" ? getOutputObjectModes(objectMode, index, newTransforms) : getInputObjectModes(objectMode, index, newTransforms);
var getOutputObjectModes = (objectMode, index, newTransforms) => {
  const writableObjectMode = index !== 0 && newTransforms[index - 1].value.readableObjectMode;
  const readableObjectMode = objectMode ?? writableObjectMode;
  return { writableObjectMode, readableObjectMode };
};
var getInputObjectModes = (objectMode, index, newTransforms) => {
  const writableObjectMode = index === 0 ? objectMode === true : newTransforms[index - 1].value.readableObjectMode;
  const readableObjectMode = index !== newTransforms.length - 1 && (objectMode ?? writableObjectMode);
  return { writableObjectMode, readableObjectMode };
};
var getFdObjectMode = (stdioItems, direction) => {
  const lastTransform = stdioItems.findLast(({ type }) => TRANSFORM_TYPES.has(type));
  if (lastTransform === undefined) {
    return false;
  }
  return direction === "input" ? lastTransform.value.writableObjectMode : lastTransform.value.readableObjectMode;
};

// node_modules/execa/lib/transform/normalize.js
var normalizeTransforms = (stdioItems, optionName, direction, options) => [
  ...stdioItems.filter(({ type }) => !TRANSFORM_TYPES.has(type)),
  ...getTransforms(stdioItems, optionName, direction, options)
];
var getTransforms = (stdioItems, optionName, direction, { encoding }) => {
  const transforms = stdioItems.filter(({ type }) => TRANSFORM_TYPES.has(type));
  const newTransforms = Array.from({ length: transforms.length });
  for (const [index, stdioItem] of Object.entries(transforms)) {
    newTransforms[index] = normalizeTransform({
      stdioItem,
      index: Number(index),
      newTransforms,
      optionName,
      direction,
      encoding
    });
  }
  return sortTransforms(newTransforms, direction);
};
var normalizeTransform = ({ stdioItem, stdioItem: { type }, index, newTransforms, optionName, direction, encoding }) => {
  if (type === "duplex") {
    return normalizeDuplex({ stdioItem, optionName });
  }
  if (type === "webTransform") {
    return normalizeTransformStream({
      stdioItem,
      index,
      newTransforms,
      direction
    });
  }
  return normalizeGenerator({
    stdioItem,
    index,
    newTransforms,
    direction,
    encoding
  });
};
var normalizeDuplex = ({
  stdioItem,
  stdioItem: {
    value: {
      transform,
      transform: { writableObjectMode, readableObjectMode },
      objectMode = readableObjectMode
    }
  },
  optionName
}) => {
  if (objectMode && !readableObjectMode) {
    throw new TypeError(`The \`${optionName}.objectMode\` option can only be \`true\` if \`new Duplex({objectMode: true})\` is used.`);
  }
  if (!objectMode && readableObjectMode) {
    throw new TypeError(`The \`${optionName}.objectMode\` option cannot be \`false\` if \`new Duplex({objectMode: true})\` is used.`);
  }
  return {
    ...stdioItem,
    value: { transform, writableObjectMode, readableObjectMode }
  };
};
var normalizeTransformStream = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction }) => {
  const { transform, objectMode } = isPlainObject11(value) ? value : { transform: value };
  const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
  return {
    ...stdioItem,
    value: { transform, writableObjectMode, readableObjectMode }
  };
};
var normalizeGenerator = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction, encoding }) => {
  const {
    transform,
    final,
    binary: binaryOption = false,
    preserveNewlines = false,
    objectMode
  } = isPlainObject11(value) ? value : { transform: value };
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
  return {
    ...stdioItem,
    value: {
      transform,
      final,
      binary,
      preserveNewlines,
      writableObjectMode,
      readableObjectMode
    }
  };
};
var sortTransforms = (newTransforms, direction) => direction === "input" ? newTransforms.reverse() : newTransforms;

// node_modules/execa/lib/stdio/direction.js
import process24 from "node:process";
var getStreamDirection = (stdioItems, fdNumber, optionName) => {
  const directions = stdioItems.map((stdioItem) => getStdioItemDirection(stdioItem, fdNumber));
  if (directions.includes("input") && directions.includes("output")) {
    throw new TypeError(`The \`${optionName}\` option must not be an array of both readable and writable values.`);
  }
  return directions.find(Boolean) ?? DEFAULT_DIRECTION;
};
var getStdioItemDirection = ({ type, value }, fdNumber) => KNOWN_DIRECTIONS[fdNumber] ?? guessStreamDirection[type](value);
var KNOWN_DIRECTIONS = ["input", "output", "output"];
var anyDirection = () => {
  return;
};
var alwaysInput = () => "input";
var guessStreamDirection = {
  generator: anyDirection,
  asyncGenerator: anyDirection,
  fileUrl: anyDirection,
  filePath: anyDirection,
  iterable: alwaysInput,
  asyncIterable: alwaysInput,
  uint8Array: alwaysInput,
  webStream: (value) => isWritableStream2(value) ? "output" : "input",
  nodeStream(value) {
    if (!isReadableStream(value, { checkOpen: false })) {
      return "output";
    }
    return isWritableStream(value, { checkOpen: false }) ? undefined : "input";
  },
  webTransform: anyDirection,
  duplex: anyDirection,
  native(value) {
    const standardStreamDirection = getStandardStreamDirection(value);
    if (standardStreamDirection !== undefined) {
      return standardStreamDirection;
    }
    if (isStream(value, { checkOpen: false })) {
      return guessStreamDirection.nodeStream(value);
    }
  }
};
var getStandardStreamDirection = (value) => {
  if ([0, process24.stdin].includes(value)) {
    return "input";
  }
  if ([1, 2, process24.stdout, process24.stderr].includes(value)) {
    return "output";
  }
};
var DEFAULT_DIRECTION = "output";

// node_modules/execa/lib/ipc/array.js
var normalizeIpcStdioArray = (stdioArray, ipc) => ipc && !stdioArray.includes("ipc") ? [...stdioArray, "ipc"] : stdioArray;

// node_modules/execa/lib/stdio/stdio-option.js
var normalizeStdioOption = ({ stdio, ipc, buffer, ...options }, verboseInfo, isSync) => {
  const stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber) => addDefaultValue2(stdioOption, fdNumber));
  return isSync ? normalizeStdioSync(stdioArray, buffer, verboseInfo) : normalizeIpcStdioArray(stdioArray, ipc);
};
var getStdioArray = (stdio, options) => {
  if (stdio === undefined) {
    return STANDARD_STREAMS_ALIASES.map((alias) => options[alias]);
  }
  if (hasAlias(options)) {
    throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${STANDARD_STREAMS_ALIASES.map((alias) => `\`${alias}\``).join(", ")}`);
  }
  if (typeof stdio === "string") {
    return [stdio, stdio, stdio];
  }
  if (!Array.isArray(stdio)) {
    throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
  }
  const length = Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length);
  return Array.from({ length }, (_3, fdNumber) => stdio[fdNumber]);
};
var hasAlias = (options) => STANDARD_STREAMS_ALIASES.some((alias) => options[alias] !== undefined);
var addDefaultValue2 = (stdioOption, fdNumber) => {
  if (Array.isArray(stdioOption)) {
    return stdioOption.map((item) => addDefaultValue2(item, fdNumber));
  }
  if (stdioOption === null || stdioOption === undefined) {
    return fdNumber >= STANDARD_STREAMS_ALIASES.length ? "ignore" : "pipe";
  }
  return stdioOption;
};
var normalizeStdioSync = (stdioArray, buffer, verboseInfo) => stdioArray.map((stdioOption, fdNumber) => !buffer[fdNumber] && fdNumber !== 0 && !isFullVerbose(verboseInfo, fdNumber) && isOutputPipeOnly(stdioOption) ? "ignore" : stdioOption);
var isOutputPipeOnly = (stdioOption) => stdioOption === "pipe" || Array.isArray(stdioOption) && stdioOption.every((item) => item === "pipe");

// node_modules/execa/lib/stdio/native.js
import { readFileSync } from "node:fs";
import tty3 from "node:tty";
var handleNativeStream = ({ stdioItem, stdioItem: { type }, isStdioArray, fdNumber, direction, isSync }) => {
  if (!isStdioArray || type !== "native") {
    return stdioItem;
  }
  return isSync ? handleNativeStreamSync({ stdioItem, fdNumber, direction }) : handleNativeStreamAsync({ stdioItem, fdNumber });
};
var handleNativeStreamSync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber, direction }) => {
  const targetFd = getTargetFd({
    value,
    optionName,
    fdNumber,
    direction
  });
  if (targetFd !== undefined) {
    return targetFd;
  }
  if (isStream(value, { checkOpen: false })) {
    throw new TypeError(`The \`${optionName}: Stream\` option cannot both be an array and include a stream with synchronous methods.`);
  }
  return stdioItem;
};
var getTargetFd = ({ value, optionName, fdNumber, direction }) => {
  const targetFdNumber = getTargetFdNumber(value, fdNumber);
  if (targetFdNumber === undefined) {
    return;
  }
  if (direction === "output") {
    return { type: "fileNumber", value: targetFdNumber, optionName };
  }
  if (tty3.isatty(targetFdNumber)) {
    throw new TypeError(`The \`${optionName}: ${serializeOptionValue(value)}\` option is invalid: it cannot be a TTY with synchronous methods.`);
  }
  return { type: "uint8Array", value: bufferToUint8Array(readFileSync(targetFdNumber)), optionName };
};
var getTargetFdNumber = (value, fdNumber) => {
  if (value === "inherit") {
    return fdNumber;
  }
  if (typeof value === "number") {
    return value;
  }
  const standardStreamIndex = STANDARD_STREAMS.indexOf(value);
  if (standardStreamIndex !== -1) {
    return standardStreamIndex;
  }
};
var handleNativeStreamAsync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber }) => {
  if (value === "inherit") {
    return { type: "nodeStream", value: getStandardStream(fdNumber, value, optionName), optionName };
  }
  if (typeof value === "number") {
    return { type: "nodeStream", value: getStandardStream(value, value, optionName), optionName };
  }
  if (isStream(value, { checkOpen: false })) {
    return { type: "nodeStream", value, optionName };
  }
  return stdioItem;
};
var getStandardStream = (fdNumber, value, optionName) => {
  const standardStream = STANDARD_STREAMS[fdNumber];
  if (standardStream === undefined) {
    throw new TypeError(`The \`${optionName}: ${value}\` option is invalid: no such standard stream.`);
  }
  return standardStream;
};

// node_modules/execa/lib/stdio/input-option.js
var handleInputOptions = ({ input, inputFile }, fdNumber) => fdNumber === 0 ? [
  ...handleInputOption(input),
  ...handleInputFileOption(inputFile)
] : [];
var handleInputOption = (input) => input === undefined ? [] : [{
  type: getInputType(input),
  value: input,
  optionName: "input"
}];
var getInputType = (input) => {
  if (isReadableStream(input, { checkOpen: false })) {
    return "nodeStream";
  }
  if (typeof input === "string") {
    return "string";
  }
  if (isUint8Array(input)) {
    return "uint8Array";
  }
  throw new Error("The `input` option must be a string, a Uint8Array or a Node.js Readable stream.");
};
var handleInputFileOption = (inputFile) => inputFile === undefined ? [] : [{
  ...getInputFileType(inputFile),
  optionName: "inputFile"
}];
var getInputFileType = (inputFile) => {
  if (isUrl(inputFile)) {
    return { type: "fileUrl", value: inputFile };
  }
  if (isFilePathString(inputFile)) {
    return { type: "filePath", value: { file: inputFile } };
  }
  throw new Error("The `inputFile` option must be a file path string or a file URL.");
};

// node_modules/execa/lib/stdio/duplicate.js
var filterDuplicates = (stdioItems) => stdioItems.filter((stdioItemOne, indexOne) => stdioItems.every((stdioItemTwo, indexTwo) => stdioItemOne.value !== stdioItemTwo.value || indexOne >= indexTwo || stdioItemOne.type === "generator" || stdioItemOne.type === "asyncGenerator"));
var getDuplicateStream = ({ stdioItem: { type, value, optionName }, direction, fileDescriptors, isSync }) => {
  const otherStdioItems = getOtherStdioItems(fileDescriptors, type);
  if (otherStdioItems.length === 0) {
    return;
  }
  if (isSync) {
    validateDuplicateStreamSync({
      otherStdioItems,
      type,
      value,
      optionName,
      direction
    });
    return;
  }
  if (SPECIAL_DUPLICATE_TYPES.has(type)) {
    return getDuplicateStreamInstance({
      otherStdioItems,
      type,
      value,
      optionName,
      direction
    });
  }
  if (FORBID_DUPLICATE_TYPES.has(type)) {
    validateDuplicateTransform({
      otherStdioItems,
      type,
      value,
      optionName
    });
  }
};
var getOtherStdioItems = (fileDescriptors, type) => fileDescriptors.flatMap(({ direction, stdioItems }) => stdioItems.filter((stdioItem) => stdioItem.type === type).map((stdioItem) => ({ ...stdioItem, direction })));
var validateDuplicateStreamSync = ({ otherStdioItems, type, value, optionName, direction }) => {
  if (SPECIAL_DUPLICATE_TYPES_SYNC.has(type)) {
    getDuplicateStreamInstance({
      otherStdioItems,
      type,
      value,
      optionName,
      direction
    });
  }
};
var getDuplicateStreamInstance = ({ otherStdioItems, type, value, optionName, direction }) => {
  const duplicateStdioItems = otherStdioItems.filter((stdioItem) => hasSameValue(stdioItem, value));
  if (duplicateStdioItems.length === 0) {
    return;
  }
  const differentStdioItem = duplicateStdioItems.find((stdioItem) => stdioItem.direction !== direction);
  throwOnDuplicateStream(differentStdioItem, optionName, type);
  return direction === "output" ? duplicateStdioItems[0].stream : undefined;
};
var hasSameValue = ({ type, value }, secondValue) => {
  if (type === "filePath") {
    return value.file === secondValue.file;
  }
  if (type === "fileUrl") {
    return value.href === secondValue.href;
  }
  return value === secondValue;
};
var validateDuplicateTransform = ({ otherStdioItems, type, value, optionName }) => {
  const duplicateStdioItem = otherStdioItems.find(({ value: { transform } }) => transform === value.transform);
  throwOnDuplicateStream(duplicateStdioItem, optionName, type);
};
var throwOnDuplicateStream = (stdioItem, optionName, type) => {
  if (stdioItem !== undefined) {
    throw new TypeError(`The \`${stdioItem.optionName}\` and \`${optionName}\` options must not target ${TYPE_TO_MESSAGE[type]} that is the same.`);
  }
};

// node_modules/execa/lib/stdio/handle.js
var handleStdio = (addProperties, options, verboseInfo, isSync) => {
  const stdio = normalizeStdioOption(options, verboseInfo, isSync);
  const initialFileDescriptors = stdio.map((stdioOption, fdNumber) => getFileDescriptor({
    stdioOption,
    fdNumber,
    options,
    isSync
  }));
  const fileDescriptors = getFinalFileDescriptors({
    initialFileDescriptors,
    addProperties,
    options,
    isSync
  });
  options.stdio = fileDescriptors.map(({ stdioItems }) => forwardStdio(stdioItems));
  return fileDescriptors;
};
var getFileDescriptor = ({ stdioOption, fdNumber, options, isSync }) => {
  const optionName = getStreamName(fdNumber);
  const { stdioItems: initialStdioItems, isStdioArray } = initializeStdioItems({
    stdioOption,
    fdNumber,
    options,
    optionName
  });
  const direction = getStreamDirection(initialStdioItems, fdNumber, optionName);
  const stdioItems = initialStdioItems.map((stdioItem) => handleNativeStream({
    stdioItem,
    isStdioArray,
    fdNumber,
    direction,
    isSync
  }));
  const normalizedStdioItems = normalizeTransforms(stdioItems, optionName, direction, options);
  const objectMode = getFdObjectMode(normalizedStdioItems, direction);
  validateFileObjectMode(normalizedStdioItems, objectMode);
  return { direction, objectMode, stdioItems: normalizedStdioItems };
};
var initializeStdioItems = ({ stdioOption, fdNumber, options, optionName }) => {
  const values = Array.isArray(stdioOption) ? stdioOption : [stdioOption];
  const initialStdioItems = [
    ...values.map((value) => initializeStdioItem(value, optionName)),
    ...handleInputOptions(options, fdNumber)
  ];
  const stdioItems = filterDuplicates(initialStdioItems);
  const isStdioArray = stdioItems.length > 1;
  validateStdioArray(stdioItems, isStdioArray, optionName);
  validateStreams(stdioItems);
  return { stdioItems, isStdioArray };
};
var initializeStdioItem = (value, optionName) => ({
  type: getStdioItemType(value, optionName),
  value,
  optionName
});
var validateStdioArray = (stdioItems, isStdioArray, optionName) => {
  if (stdioItems.length === 0) {
    throw new TypeError(`The \`${optionName}\` option must not be an empty array.`);
  }
  if (!isStdioArray) {
    return;
  }
  for (const { value, optionName: optionName2 } of stdioItems) {
    if (INVALID_STDIO_ARRAY_OPTIONS.has(value)) {
      throw new Error(`The \`${optionName2}\` option must not include \`${value}\`.`);
    }
  }
};
var INVALID_STDIO_ARRAY_OPTIONS = new Set(["ignore", "ipc"]);
var validateStreams = (stdioItems) => {
  for (const stdioItem of stdioItems) {
    validateFileStdio(stdioItem);
  }
};
var validateFileStdio = ({ type, value, optionName }) => {
  if (isRegularUrl(value)) {
    throw new TypeError(`The \`${optionName}: URL\` option must use the \`file:\` scheme.
For example, you can use the \`pathToFileURL()\` method of the \`url\` core module.`);
  }
  if (isUnknownStdioString(type, value)) {
    throw new TypeError(`The \`${optionName}: { file: '...' }\` option must be used instead of \`${optionName}: '...'\`.`);
  }
};
var validateFileObjectMode = (stdioItems, objectMode) => {
  if (!objectMode) {
    return;
  }
  const fileStdioItem = stdioItems.find(({ type }) => FILE_TYPES.has(type));
  if (fileStdioItem !== undefined) {
    throw new TypeError(`The \`${fileStdioItem.optionName}\` option cannot use both files and transforms in objectMode.`);
  }
};
var getFinalFileDescriptors = ({ initialFileDescriptors, addProperties, options, isSync }) => {
  const fileDescriptors = [];
  try {
    for (const fileDescriptor of initialFileDescriptors) {
      fileDescriptors.push(getFinalFileDescriptor({
        fileDescriptor,
        fileDescriptors,
        addProperties,
        options,
        isSync
      }));
    }
    return fileDescriptors;
  } catch (error) {
    cleanupCustomStreams(fileDescriptors);
    throw error;
  }
};
var getFinalFileDescriptor = ({
  fileDescriptor: { direction, objectMode, stdioItems },
  fileDescriptors,
  addProperties,
  options,
  isSync
}) => {
  const finalStdioItems = stdioItems.map((stdioItem) => addStreamProperties({
    stdioItem,
    addProperties,
    direction,
    options,
    fileDescriptors,
    isSync
  }));
  return { direction, objectMode, stdioItems: finalStdioItems };
};
var addStreamProperties = ({ stdioItem, addProperties, direction, options, fileDescriptors, isSync }) => {
  const duplicateStream = getDuplicateStream({
    stdioItem,
    direction,
    fileDescriptors,
    isSync
  });
  if (duplicateStream !== undefined) {
    return { ...stdioItem, stream: duplicateStream };
  }
  return {
    ...stdioItem,
    ...addProperties[direction][stdioItem.type](stdioItem, options)
  };
};
var cleanupCustomStreams = (fileDescriptors) => {
  for (const { stdioItems } of fileDescriptors) {
    for (const { stream } of stdioItems) {
      if (stream !== undefined && !isStandardStream(stream)) {
        stream.destroy();
      }
    }
  }
};
var forwardStdio = (stdioItems) => {
  if (stdioItems.length > 1) {
    return stdioItems.some(({ value: value2 }) => value2 === "overlapped") ? "overlapped" : "pipe";
  }
  const [{ type, value }] = stdioItems;
  return type === "native" ? value : "pipe";
};

// node_modules/execa/lib/stdio/handle-sync.js
var handleStdioSync = (options, verboseInfo) => handleStdio(addPropertiesSync, options, verboseInfo, true);
var forbiddenIfSync = ({ type, optionName }) => {
  throwInvalidSyncValue(optionName, TYPE_TO_MESSAGE[type]);
};
var forbiddenNativeIfSync = ({ optionName, value }) => {
  if (value === "ipc" || value === "overlapped") {
    throwInvalidSyncValue(optionName, `"${value}"`);
  }
  return {};
};
var throwInvalidSyncValue = (optionName, value) => {
  throw new TypeError(`The \`${optionName}\` option cannot be ${value} with synchronous methods.`);
};
var addProperties = {
  generator() {
  },
  asyncGenerator: forbiddenIfSync,
  webStream: forbiddenIfSync,
  nodeStream: forbiddenIfSync,
  webTransform: forbiddenIfSync,
  duplex: forbiddenIfSync,
  asyncIterable: forbiddenIfSync,
  native: forbiddenNativeIfSync
};
var addPropertiesSync = {
  input: {
    ...addProperties,
    fileUrl: ({ value }) => ({ contents: [bufferToUint8Array(readFileSync2(value))] }),
    filePath: ({ value: { file } }) => ({ contents: [bufferToUint8Array(readFileSync2(file))] }),
    fileNumber: forbiddenIfSync,
    iterable: ({ value }) => ({ contents: [...value] }),
    string: ({ value }) => ({ contents: [value] }),
    uint8Array: ({ value }) => ({ contents: [value] })
  },
  output: {
    ...addProperties,
    fileUrl: ({ value }) => ({ path: value }),
    filePath: ({ value: { file, append } }) => ({ path: file, append }),
    fileNumber: ({ value }) => ({ path: value }),
    iterable: forbiddenIfSync,
    string: forbiddenIfSync,
    uint8Array: forbiddenIfSync
  }
};

// node_modules/execa/lib/io/strip-newline.js
var stripNewline = (value, { stripFinalNewline: stripFinalNewline2 }, fdNumber) => getStripFinalNewline(stripFinalNewline2, fdNumber) && value !== undefined && !Array.isArray(value) ? stripFinalNewline(value) : value;
var getStripFinalNewline = (stripFinalNewline2, fdNumber) => fdNumber === "all" ? stripFinalNewline2[1] || stripFinalNewline2[2] : stripFinalNewline2[fdNumber];

// node_modules/execa/lib/transform/generator.js
import { Transform, getDefaultHighWaterMark } from "node:stream";

// node_modules/execa/lib/transform/split.js
var getSplitLinesGenerator = (binary, preserveNewlines, skipped, state) => binary || skipped ? undefined : initializeSplitLines(preserveNewlines, state);
var splitLinesSync = (chunk, preserveNewlines, objectMode) => objectMode ? chunk.flatMap((item) => splitLinesItemSync(item, preserveNewlines)) : splitLinesItemSync(chunk, preserveNewlines);
var splitLinesItemSync = (chunk, preserveNewlines) => {
  const { transform, final } = initializeSplitLines(preserveNewlines, {});
  return [...transform(chunk), ...final()];
};
var initializeSplitLines = (preserveNewlines, state) => {
  state.previousChunks = "";
  return {
    transform: splitGenerator.bind(undefined, state, preserveNewlines),
    final: linesFinal.bind(undefined, state)
  };
};
var splitGenerator = function* (state, preserveNewlines, chunk) {
  if (typeof chunk !== "string") {
    yield chunk;
    return;
  }
  let { previousChunks } = state;
  let start = -1;
  for (let end = 0;end < chunk.length; end += 1) {
    if (chunk[end] === `
`) {
      const newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);
      let line = chunk.slice(start + 1, end + 1 - newlineLength);
      if (previousChunks.length > 0) {
        line = concatString(previousChunks, line);
        previousChunks = "";
      }
      yield line;
      start = end;
    }
  }
  if (start !== chunk.length - 1) {
    previousChunks = concatString(previousChunks, chunk.slice(start + 1));
  }
  state.previousChunks = previousChunks;
};
var getNewlineLength = (chunk, end, preserveNewlines, state) => {
  if (preserveNewlines) {
    return 0;
  }
  state.isWindowsNewline = end !== 0 && chunk[end - 1] === "\r";
  return state.isWindowsNewline ? 2 : 1;
};
var linesFinal = function* ({ previousChunks }) {
  if (previousChunks.length > 0) {
    yield previousChunks;
  }
};
var getAppendNewlineGenerator = ({ binary, preserveNewlines, readableObjectMode, state }) => binary || preserveNewlines || readableObjectMode ? undefined : { transform: appendNewlineGenerator.bind(undefined, state) };
var appendNewlineGenerator = function* ({ isWindowsNewline = false }, chunk) {
  const { unixNewline, windowsNewline, LF: LF2, concatBytes } = typeof chunk === "string" ? linesStringInfo : linesUint8ArrayInfo;
  if (chunk.at(-1) === LF2) {
    yield chunk;
    return;
  }
  const newline = isWindowsNewline ? windowsNewline : unixNewline;
  yield concatBytes(chunk, newline);
};
var concatString = (firstChunk, secondChunk) => `${firstChunk}${secondChunk}`;
var linesStringInfo = {
  windowsNewline: `\r
`,
  unixNewline: `
`,
  LF: `
`,
  concatBytes: concatString
};
var concatUint8Array = (firstChunk, secondChunk) => {
  const chunk = new Uint8Array(firstChunk.length + secondChunk.length);
  chunk.set(firstChunk, 0);
  chunk.set(secondChunk, firstChunk.length);
  return chunk;
};
var linesUint8ArrayInfo = {
  windowsNewline: new Uint8Array([13, 10]),
  unixNewline: new Uint8Array([10]),
  LF: 10,
  concatBytes: concatUint8Array
};

// node_modules/execa/lib/transform/validate.js
import { Buffer as Buffer2 } from "node:buffer";
var getValidateTransformInput = (writableObjectMode, optionName) => writableObjectMode ? undefined : validateStringTransformInput.bind(undefined, optionName);
var validateStringTransformInput = function* (optionName, chunk) {
  if (typeof chunk !== "string" && !isUint8Array(chunk) && !Buffer2.isBuffer(chunk)) {
    throw new TypeError(`The \`${optionName}\` option's transform must use "objectMode: true" to receive as input: ${typeof chunk}.`);
  }
  yield chunk;
};
var getValidateTransformReturn = (readableObjectMode, optionName) => readableObjectMode ? validateObjectTransformReturn.bind(undefined, optionName) : validateStringTransformReturn.bind(undefined, optionName);
var validateObjectTransformReturn = function* (optionName, chunk) {
  validateEmptyReturn(optionName, chunk);
  yield chunk;
};
var validateStringTransformReturn = function* (optionName, chunk) {
  validateEmptyReturn(optionName, chunk);
  if (typeof chunk !== "string" && !isUint8Array(chunk)) {
    throw new TypeError(`The \`${optionName}\` option's function must yield a string or an Uint8Array, not ${typeof chunk}.`);
  }
  yield chunk;
};
var validateEmptyReturn = (optionName, chunk) => {
  if (chunk === null || chunk === undefined) {
    throw new TypeError(`The \`${optionName}\` option's function must not call \`yield ${chunk}\`.
Instead, \`yield\` should either be called with a value, or not be called at all. For example:
  if (condition) { yield value; }`);
  }
};

// node_modules/execa/lib/transform/encoding-transform.js
import { Buffer as Buffer3 } from "node:buffer";
import { StringDecoder as StringDecoder2 } from "node:string_decoder";
var getEncodingTransformGenerator = (binary, encoding, skipped) => {
  if (skipped) {
    return;
  }
  if (binary) {
    return { transform: encodingUint8ArrayGenerator.bind(undefined, new TextEncoder) };
  }
  const stringDecoder = new StringDecoder2(encoding);
  return {
    transform: encodingStringGenerator.bind(undefined, stringDecoder),
    final: encodingStringFinal.bind(undefined, stringDecoder)
  };
};
var encodingUint8ArrayGenerator = function* (textEncoder3, chunk) {
  if (Buffer3.isBuffer(chunk)) {
    yield bufferToUint8Array(chunk);
  } else if (typeof chunk === "string") {
    yield textEncoder3.encode(chunk);
  } else {
    yield chunk;
  }
};
var encodingStringGenerator = function* (stringDecoder, chunk) {
  yield isUint8Array(chunk) ? stringDecoder.write(chunk) : chunk;
};
var encodingStringFinal = function* (stringDecoder) {
  const lastChunk = stringDecoder.end();
  if (lastChunk !== "") {
    yield lastChunk;
  }
};

// node_modules/execa/lib/transform/run-async.js
import { callbackify } from "node:util";
var pushChunks = callbackify(async (getChunks, state, getChunksArguments, transformStream) => {
  state.currentIterable = getChunks(...getChunksArguments);
  try {
    for await (const chunk of state.currentIterable) {
      transformStream.push(chunk);
    }
  } finally {
    delete state.currentIterable;
  }
});
var transformChunk = async function* (chunk, generators, index) {
  if (index === generators.length) {
    yield chunk;
    return;
  }
  const { transform = identityGenerator } = generators[index];
  for await (const transformedChunk of transform(chunk)) {
    yield* transformChunk(transformedChunk, generators, index + 1);
  }
};
var finalChunks = async function* (generators) {
  for (const [index, { final }] of Object.entries(generators)) {
    yield* generatorFinalChunks(final, Number(index), generators);
  }
};
var generatorFinalChunks = async function* (final, index, generators) {
  if (final === undefined) {
    return;
  }
  for await (const finalChunk of final()) {
    yield* transformChunk(finalChunk, generators, index + 1);
  }
};
var destroyTransform = callbackify(async ({ currentIterable }, error) => {
  if (currentIterable !== undefined) {
    await (error ? currentIterable.throw(error) : currentIterable.return());
    return;
  }
  if (error) {
    throw error;
  }
});
var identityGenerator = function* (chunk) {
  yield chunk;
};

// node_modules/execa/lib/transform/run-sync.js
var pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done) => {
  try {
    for (const chunk of getChunksSync(...getChunksArguments)) {
      transformStream.push(chunk);
    }
    done();
  } catch (error) {
    done(error);
  }
};
var runTransformSync = (generators, chunks) => [
  ...chunks.flatMap((chunk) => [...transformChunkSync(chunk, generators, 0)]),
  ...finalChunksSync(generators)
];
var transformChunkSync = function* (chunk, generators, index) {
  if (index === generators.length) {
    yield chunk;
    return;
  }
  const { transform = identityGenerator2 } = generators[index];
  for (const transformedChunk of transform(chunk)) {
    yield* transformChunkSync(transformedChunk, generators, index + 1);
  }
};
var finalChunksSync = function* (generators) {
  for (const [index, { final }] of Object.entries(generators)) {
    yield* generatorFinalChunksSync(final, Number(index), generators);
  }
};
var generatorFinalChunksSync = function* (final, index, generators) {
  if (final === undefined) {
    return;
  }
  for (const finalChunk of final()) {
    yield* transformChunkSync(finalChunk, generators, index + 1);
  }
};
var identityGenerator2 = function* (chunk) {
  yield chunk;
};

// node_modules/execa/lib/transform/generator.js
var generatorToStream = ({
  value,
  value: { transform, final, writableObjectMode, readableObjectMode },
  optionName
}, { encoding }) => {
  const state = {};
  const generators = addInternalGenerators(value, encoding, optionName);
  const transformAsync = isAsyncGenerator(transform);
  const finalAsync = isAsyncGenerator(final);
  const transformMethod = transformAsync ? pushChunks.bind(undefined, transformChunk, state) : pushChunksSync.bind(undefined, transformChunkSync);
  const finalMethod = transformAsync || finalAsync ? pushChunks.bind(undefined, finalChunks, state) : pushChunksSync.bind(undefined, finalChunksSync);
  const destroyMethod = transformAsync || finalAsync ? destroyTransform.bind(undefined, state) : undefined;
  const stream = new Transform({
    writableObjectMode,
    writableHighWaterMark: getDefaultHighWaterMark(writableObjectMode),
    readableObjectMode,
    readableHighWaterMark: getDefaultHighWaterMark(readableObjectMode),
    transform(chunk, encoding2, done) {
      transformMethod([chunk, generators, 0], this, done);
    },
    flush(done) {
      finalMethod([generators], this, done);
    },
    destroy: destroyMethod
  });
  return { stream };
};
var runGeneratorsSync = (chunks, stdioItems, encoding, isInput) => {
  const generators = stdioItems.filter(({ type }) => type === "generator");
  const reversedGenerators = isInput ? generators.reverse() : generators;
  for (const { value, optionName } of reversedGenerators) {
    const generators2 = addInternalGenerators(value, encoding, optionName);
    chunks = runTransformSync(generators2, chunks);
  }
  return chunks;
};
var addInternalGenerators = ({ transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines }, encoding, optionName) => {
  const state = {};
  return [
    { transform: getValidateTransformInput(writableObjectMode, optionName) },
    getEncodingTransformGenerator(binary, encoding, writableObjectMode),
    getSplitLinesGenerator(binary, preserveNewlines, writableObjectMode, state),
    { transform, final },
    { transform: getValidateTransformReturn(readableObjectMode, optionName) },
    getAppendNewlineGenerator({
      binary,
      preserveNewlines,
      readableObjectMode,
      state
    })
  ].filter(Boolean);
};

// node_modules/execa/lib/io/input-sync.js
var addInputOptionsSync = (fileDescriptors, options) => {
  for (const fdNumber of getInputFdNumbers(fileDescriptors)) {
    addInputOptionSync(fileDescriptors, fdNumber, options);
  }
};
var getInputFdNumbers = (fileDescriptors) => new Set(Object.entries(fileDescriptors).filter(([, { direction }]) => direction === "input").map(([fdNumber]) => Number(fdNumber)));
var addInputOptionSync = (fileDescriptors, fdNumber, options) => {
  const { stdioItems } = fileDescriptors[fdNumber];
  const allStdioItems = stdioItems.filter(({ contents }) => contents !== undefined);
  if (allStdioItems.length === 0) {
    return;
  }
  if (fdNumber !== 0) {
    const [{ type, optionName }] = allStdioItems;
    throw new TypeError(`Only the \`stdin\` option, not \`${optionName}\`, can be ${TYPE_TO_MESSAGE[type]} with synchronous methods.`);
  }
  const allContents = allStdioItems.map(({ contents }) => contents);
  const transformedContents = allContents.map((contents) => applySingleInputGeneratorsSync(contents, stdioItems));
  options.input = joinToUint8Array(transformedContents);
};
var applySingleInputGeneratorsSync = (contents, stdioItems) => {
  const newContents = runGeneratorsSync(contents, stdioItems, "utf8", true);
  validateSerializable(newContents);
  return joinToUint8Array(newContents);
};
var validateSerializable = (newContents) => {
  const invalidItem = newContents.find((item) => typeof item !== "string" && !isUint8Array(item));
  if (invalidItem !== undefined) {
    throw new TypeError(`The \`stdin\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${invalidItem}.`);
  }
};

// node_modules/execa/lib/io/output-sync.js
import { writeFileSync, appendFileSync } from "node:fs";

// node_modules/execa/lib/verbose/output.js
var shouldLogOutput = ({ stdioItems, encoding, verboseInfo, fdNumber }) => fdNumber !== "all" && isFullVerbose(verboseInfo, fdNumber) && !BINARY_ENCODINGS.has(encoding) && fdUsesVerbose(fdNumber) && (stdioItems.some(({ type, value }) => type === "native" && PIPED_STDIO_VALUES.has(value)) || stdioItems.every(({ type }) => TRANSFORM_TYPES.has(type)));
var fdUsesVerbose = (fdNumber) => fdNumber === 1 || fdNumber === 2;
var PIPED_STDIO_VALUES = new Set(["pipe", "overlapped"]);
var logLines = async (linesIterable, stream, fdNumber, verboseInfo) => {
  for await (const line of linesIterable) {
    if (!isPipingStream(stream)) {
      logLine(line, fdNumber, verboseInfo);
    }
  }
};
var logLinesSync = (linesArray, fdNumber, verboseInfo) => {
  for (const line of linesArray) {
    logLine(line, fdNumber, verboseInfo);
  }
};
var isPipingStream = (stream) => stream._readableState.pipes.length > 0;
var logLine = (line, fdNumber, verboseInfo) => {
  const verboseMessage = serializeVerboseMessage(line);
  verboseLog({
    type: "output",
    verboseMessage,
    fdNumber,
    verboseInfo
  });
};

// node_modules/execa/lib/io/output-sync.js
var transformOutputSync = ({ fileDescriptors, syncResult: { output }, options, isMaxBuffer, verboseInfo }) => {
  if (output === null) {
    return { output: Array.from({ length: 3 }) };
  }
  const state = {};
  const outputFiles = new Set([]);
  const transformedOutput = output.map((result, fdNumber) => transformOutputResultSync({
    result,
    fileDescriptors,
    fdNumber,
    state,
    outputFiles,
    isMaxBuffer,
    verboseInfo
  }, options));
  return { output: transformedOutput, ...state };
};
var transformOutputResultSync = ({ result, fileDescriptors, fdNumber, state, outputFiles, isMaxBuffer, verboseInfo }, { buffer, encoding, lines: lines4, stripFinalNewline: stripFinalNewline2, maxBuffer }) => {
  if (result === null) {
    return;
  }
  const truncatedResult = truncateMaxBufferSync(result, isMaxBuffer, maxBuffer);
  const uint8ArrayResult = bufferToUint8Array(truncatedResult);
  const { stdioItems, objectMode } = fileDescriptors[fdNumber];
  const chunks = runOutputGeneratorsSync([uint8ArrayResult], stdioItems, encoding, state);
  const { serializedResult, finalResult = serializedResult } = serializeChunks({
    chunks,
    objectMode,
    encoding,
    lines: lines4,
    stripFinalNewline: stripFinalNewline2,
    fdNumber
  });
  logOutputSync({
    serializedResult,
    fdNumber,
    state,
    verboseInfo,
    encoding,
    stdioItems,
    objectMode
  });
  const returnedResult = buffer[fdNumber] ? finalResult : undefined;
  try {
    if (state.error === undefined) {
      writeToFiles(serializedResult, stdioItems, outputFiles);
    }
    return returnedResult;
  } catch (error) {
    state.error = error;
    return returnedResult;
  }
};
var runOutputGeneratorsSync = (chunks, stdioItems, encoding, state) => {
  try {
    return runGeneratorsSync(chunks, stdioItems, encoding, false);
  } catch (error) {
    state.error = error;
    return chunks;
  }
};
var serializeChunks = ({ chunks, objectMode, encoding, lines: lines4, stripFinalNewline: stripFinalNewline2, fdNumber }) => {
  if (objectMode) {
    return { serializedResult: chunks };
  }
  if (encoding === "buffer") {
    return { serializedResult: joinToUint8Array(chunks) };
  }
  const serializedResult = joinToString(chunks, encoding);
  if (lines4[fdNumber]) {
    return { serializedResult, finalResult: splitLinesSync(serializedResult, !stripFinalNewline2[fdNumber], objectMode) };
  }
  return { serializedResult };
};
var logOutputSync = ({ serializedResult, fdNumber, state, verboseInfo, encoding, stdioItems, objectMode }) => {
  if (!shouldLogOutput({
    stdioItems,
    encoding,
    verboseInfo,
    fdNumber
  })) {
    return;
  }
  const linesArray = splitLinesSync(serializedResult, false, objectMode);
  try {
    logLinesSync(linesArray, fdNumber, verboseInfo);
  } catch (error) {
    state.error ??= error;
  }
};
var writeToFiles = (serializedResult, stdioItems, outputFiles) => {
  for (const { path: path10, append } of stdioItems.filter(({ type }) => FILE_TYPES.has(type))) {
    const pathString = typeof path10 === "string" ? path10 : path10.toString();
    if (append || outputFiles.has(pathString)) {
      appendFileSync(path10, serializedResult);
    } else {
      outputFiles.add(pathString);
      writeFileSync(path10, serializedResult);
    }
  }
};

// node_modules/execa/lib/resolve/all-sync.js
var getAllSync = ([, stdout, stderr], options) => {
  if (!options.all) {
    return;
  }
  if (stdout === undefined) {
    return stderr;
  }
  if (stderr === undefined) {
    return stdout;
  }
  if (Array.isArray(stdout)) {
    return Array.isArray(stderr) ? [...stdout, ...stderr] : [...stdout, stripNewline(stderr, options, "all")];
  }
  if (Array.isArray(stderr)) {
    return [stripNewline(stdout, options, "all"), ...stderr];
  }
  if (isUint8Array(stdout) && isUint8Array(stderr)) {
    return concatUint8Arrays([stdout, stderr]);
  }
  return `${stdout}${stderr}`;
};

// node_modules/execa/lib/resolve/exit-async.js
import { once as once4 } from "node:events";
var waitForExit = async (subprocess, context) => {
  const [exitCode, signal] = await waitForExitOrError(subprocess);
  context.isForcefullyTerminated ??= false;
  return [exitCode, signal];
};
var waitForExitOrError = async (subprocess) => {
  const [spawnPayload, exitPayload] = await Promise.allSettled([
    once4(subprocess, "spawn"),
    once4(subprocess, "exit")
  ]);
  if (spawnPayload.status === "rejected") {
    return [];
  }
  return exitPayload.status === "rejected" ? waitForSubprocessExit(subprocess) : exitPayload.value;
};
var waitForSubprocessExit = async (subprocess) => {
  try {
    return await once4(subprocess, "exit");
  } catch {
    return waitForSubprocessExit(subprocess);
  }
};
var waitForSuccessfulExit = async (exitPromise) => {
  const [exitCode, signal] = await exitPromise;
  if (!isSubprocessErrorExit(exitCode, signal) && isFailedExit(exitCode, signal)) {
    throw new DiscardedError;
  }
  return [exitCode, signal];
};
var isSubprocessErrorExit = (exitCode, signal) => exitCode === undefined && signal === undefined;
var isFailedExit = (exitCode, signal) => exitCode !== 0 || signal !== null;

// node_modules/execa/lib/resolve/exit-sync.js
var getExitResultSync = ({ error, status: exitCode, signal, output }, { maxBuffer }) => {
  const resultError = getResultError(error, exitCode, signal);
  const timedOut = resultError?.code === "ETIMEDOUT";
  const isMaxBuffer = isMaxBufferSync(resultError, output, maxBuffer);
  return {
    resultError,
    exitCode,
    signal,
    timedOut,
    isMaxBuffer
  };
};
var getResultError = (error, exitCode, signal) => {
  if (error !== undefined) {
    return error;
  }
  return isFailedExit(exitCode, signal) ? new DiscardedError : undefined;
};

// node_modules/execa/lib/methods/main-sync.js
var execaCoreSync = (rawFile, rawArguments, rawOptions) => {
  const { file, commandArguments, command: command2, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleSyncArguments(rawFile, rawArguments, rawOptions);
  const result = spawnSubprocessSync({
    file,
    commandArguments,
    options,
    command: command2,
    escapedCommand,
    verboseInfo,
    fileDescriptors,
    startTime
  });
  return handleResult2(result, verboseInfo, options);
};
var handleSyncArguments = (rawFile, rawArguments, rawOptions) => {
  const { command: command2, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
  const syncOptions = normalizeSyncOptions(rawOptions);
  const { file, commandArguments, options } = normalizeOptions(rawFile, rawArguments, syncOptions);
  validateSyncOptions(options);
  const fileDescriptors = handleStdioSync(options, verboseInfo);
  return {
    file,
    commandArguments,
    command: command2,
    escapedCommand,
    startTime,
    verboseInfo,
    options,
    fileDescriptors
  };
};
var normalizeSyncOptions = (options) => options.node && !options.ipc ? { ...options, ipc: false } : options;
var validateSyncOptions = ({ ipc, ipcInput, detached, cancelSignal }) => {
  if (ipcInput) {
    throwInvalidSyncOption("ipcInput");
  }
  if (ipc) {
    throwInvalidSyncOption("ipc: true");
  }
  if (detached) {
    throwInvalidSyncOption("detached: true");
  }
  if (cancelSignal) {
    throwInvalidSyncOption("cancelSignal");
  }
};
var throwInvalidSyncOption = (value) => {
  throw new TypeError(`The "${value}" option cannot be used with synchronous methods.`);
};
var spawnSubprocessSync = ({ file, commandArguments, options, command: command2, escapedCommand, verboseInfo, fileDescriptors, startTime }) => {
  const syncResult = runSubprocessSync({
    file,
    commandArguments,
    options,
    command: command2,
    escapedCommand,
    fileDescriptors,
    startTime
  });
  if (syncResult.failed) {
    return syncResult;
  }
  const { resultError, exitCode, signal, timedOut, isMaxBuffer } = getExitResultSync(syncResult, options);
  const { output, error = resultError } = transformOutputSync({
    fileDescriptors,
    syncResult,
    options,
    isMaxBuffer,
    verboseInfo
  });
  const stdio = output.map((stdioOutput, fdNumber) => stripNewline(stdioOutput, options, fdNumber));
  const all = stripNewline(getAllSync(output, options), options, "all");
  return getSyncResult({
    error,
    exitCode,
    signal,
    timedOut,
    isMaxBuffer,
    stdio,
    all,
    options,
    command: command2,
    escapedCommand,
    startTime
  });
};
var runSubprocessSync = ({ file, commandArguments, options, command: command2, escapedCommand, fileDescriptors, startTime }) => {
  try {
    addInputOptionsSync(fileDescriptors, options);
    const normalizedOptions = normalizeSpawnSyncOptions(options);
    return spawnSync(file, commandArguments, normalizedOptions);
  } catch (error) {
    return makeEarlyError({
      error,
      command: command2,
      escapedCommand,
      fileDescriptors,
      options,
      startTime,
      isSync: true
    });
  }
};
var normalizeSpawnSyncOptions = ({ encoding, maxBuffer, ...options }) => ({ ...options, encoding: "buffer", maxBuffer: getMaxBufferSync(maxBuffer) });
var getSyncResult = ({ error, exitCode, signal, timedOut, isMaxBuffer, stdio, all, options, command: command2, escapedCommand, startTime }) => error === undefined ? makeSuccessResult({
  command: command2,
  escapedCommand,
  stdio,
  all,
  ipcOutput: [],
  options,
  startTime
}) : makeError({
  error,
  command: command2,
  escapedCommand,
  timedOut,
  isCanceled: false,
  isGracefullyCanceled: false,
  isMaxBuffer,
  isForcefullyTerminated: false,
  exitCode,
  signal,
  stdio,
  all,
  ipcOutput: [],
  options,
  startTime,
  isSync: true
});

// node_modules/execa/lib/methods/main-async.js
import { setMaxListeners } from "node:events";
import { spawn } from "node:child_process";

// node_modules/execa/lib/ipc/methods.js
import process25 from "node:process";

// node_modules/execa/lib/ipc/get-one.js
import { once as once5, on as on2 } from "node:events";
var getOneMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference = true, filter: filter2 } = {}) => {
  validateIpcMethod({
    methodName: "getOneMessage",
    isSubprocess,
    ipc,
    isConnected: isConnected(anyProcess)
  });
  return getOneMessageAsync({
    anyProcess,
    channel,
    isSubprocess,
    filter: filter2,
    reference
  });
};
var getOneMessageAsync = async ({ anyProcess, channel, isSubprocess, filter: filter2, reference }) => {
  addReference(channel, reference);
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const controller = new AbortController;
  try {
    return await Promise.race([
      getMessage(ipcEmitter, filter2, controller),
      throwOnDisconnect2(ipcEmitter, isSubprocess, controller),
      throwOnStrictError(ipcEmitter, isSubprocess, controller)
    ]);
  } catch (error) {
    disconnect(anyProcess);
    throw error;
  } finally {
    controller.abort();
    removeReference(channel, reference);
  }
};
var getMessage = async (ipcEmitter, filter2, { signal }) => {
  if (filter2 === undefined) {
    const [message] = await once5(ipcEmitter, "message", { signal });
    return message;
  }
  for await (const [message] of on2(ipcEmitter, "message", { signal })) {
    if (filter2(message)) {
      return message;
    }
  }
};
var throwOnDisconnect2 = async (ipcEmitter, isSubprocess, { signal }) => {
  await once5(ipcEmitter, "disconnect", { signal });
  throwOnEarlyDisconnect(isSubprocess);
};
var throwOnStrictError = async (ipcEmitter, isSubprocess, { signal }) => {
  const [error] = await once5(ipcEmitter, "strict:error", { signal });
  throw getStrictResponseError(error, isSubprocess);
};

// node_modules/execa/lib/ipc/get-each.js
import { once as once6, on as on3 } from "node:events";
var getEachMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference = true } = {}) => loopOnMessages({
  anyProcess,
  channel,
  isSubprocess,
  ipc,
  shouldAwait: !isSubprocess,
  reference
});
var loopOnMessages = ({ anyProcess, channel, isSubprocess, ipc, shouldAwait, reference }) => {
  validateIpcMethod({
    methodName: "getEachMessage",
    isSubprocess,
    ipc,
    isConnected: isConnected(anyProcess)
  });
  addReference(channel, reference);
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const controller = new AbortController;
  const state = {};
  stopOnDisconnect(anyProcess, ipcEmitter, controller);
  abortOnStrictError({
    ipcEmitter,
    isSubprocess,
    controller,
    state
  });
  return iterateOnMessages({
    anyProcess,
    channel,
    ipcEmitter,
    isSubprocess,
    shouldAwait,
    controller,
    state,
    reference
  });
};
var stopOnDisconnect = async (anyProcess, ipcEmitter, controller) => {
  try {
    await once6(ipcEmitter, "disconnect", { signal: controller.signal });
    controller.abort();
  } catch {
  }
};
var abortOnStrictError = async ({ ipcEmitter, isSubprocess, controller, state }) => {
  try {
    const [error] = await once6(ipcEmitter, "strict:error", { signal: controller.signal });
    state.error = getStrictResponseError(error, isSubprocess);
    controller.abort();
  } catch {
  }
};
var iterateOnMessages = async function* ({ anyProcess, channel, ipcEmitter, isSubprocess, shouldAwait, controller, state, reference }) {
  try {
    for await (const [message] of on3(ipcEmitter, "message", { signal: controller.signal })) {
      throwIfStrictError(state);
      yield message;
    }
  } catch {
    throwIfStrictError(state);
  } finally {
    controller.abort();
    removeReference(channel, reference);
    if (!isSubprocess) {
      disconnect(anyProcess);
    }
    if (shouldAwait) {
      await anyProcess;
    }
  }
};
var throwIfStrictError = ({ error }) => {
  if (error) {
    throw error;
  }
};

// node_modules/execa/lib/ipc/methods.js
var addIpcMethods = (subprocess, { ipc }) => {
  Object.assign(subprocess, getIpcMethods(subprocess, false, ipc));
};
var getIpcExport = () => {
  const anyProcess = process25;
  const isSubprocess = true;
  const ipc = process25.channel !== undefined;
  return {
    ...getIpcMethods(anyProcess, isSubprocess, ipc),
    getCancelSignal: getCancelSignal.bind(undefined, {
      anyProcess,
      channel: anyProcess.channel,
      isSubprocess,
      ipc
    })
  };
};
var getIpcMethods = (anyProcess, isSubprocess, ipc) => ({
  sendMessage: sendMessage.bind(undefined, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  }),
  getOneMessage: getOneMessage.bind(undefined, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  }),
  getEachMessage: getEachMessage.bind(undefined, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  })
});

// node_modules/execa/lib/return/early-error.js
import { ChildProcess as ChildProcess2 } from "node:child_process";
import {
  PassThrough,
  Readable,
  Writable,
  Duplex
} from "node:stream";
var handleEarlyError = ({ error, command: command2, escapedCommand, fileDescriptors, options, startTime, verboseInfo }) => {
  cleanupCustomStreams(fileDescriptors);
  const subprocess = new ChildProcess2;
  createDummyStreams(subprocess, fileDescriptors);
  Object.assign(subprocess, { readable, writable, duplex });
  const earlyError = makeEarlyError({
    error,
    command: command2,
    escapedCommand,
    fileDescriptors,
    options,
    startTime,
    isSync: false
  });
  const promise = handleDummyPromise(earlyError, verboseInfo, options);
  return { subprocess, promise };
};
var createDummyStreams = (subprocess, fileDescriptors) => {
  const stdin = createDummyStream();
  const stdout = createDummyStream();
  const stderr = createDummyStream();
  const extraStdio = Array.from({ length: fileDescriptors.length - 3 }, createDummyStream);
  const all = createDummyStream();
  const stdio = [stdin, stdout, stderr, ...extraStdio];
  Object.assign(subprocess, {
    stdin,
    stdout,
    stderr,
    all,
    stdio
  });
};
var createDummyStream = () => {
  const stream = new PassThrough;
  stream.end();
  return stream;
};
var readable = () => new Readable({ read() {
} });
var writable = () => new Writable({ write() {
} });
var duplex = () => new Duplex({ read() {
}, write() {
} });
var handleDummyPromise = async (error, verboseInfo, options) => handleResult2(error, verboseInfo, options);

// node_modules/execa/lib/stdio/handle-async.js
import { createReadStream, createWriteStream } from "node:fs";
import { Buffer as Buffer4 } from "node:buffer";
import { Readable as Readable2, Writable as Writable2, Duplex as Duplex2 } from "node:stream";
var handleStdioAsync = (options, verboseInfo) => handleStdio(addPropertiesAsync, options, verboseInfo, false);
var forbiddenIfAsync = ({ type, optionName }) => {
  throw new TypeError(`The \`${optionName}\` option cannot be ${TYPE_TO_MESSAGE[type]}.`);
};
var addProperties2 = {
  fileNumber: forbiddenIfAsync,
  generator: generatorToStream,
  asyncGenerator: generatorToStream,
  nodeStream: ({ value }) => ({ stream: value }),
  webTransform({ value: { transform, writableObjectMode, readableObjectMode } }) {
    const objectMode = writableObjectMode || readableObjectMode;
    const stream = Duplex2.fromWeb(transform, { objectMode });
    return { stream };
  },
  duplex: ({ value: { transform } }) => ({ stream: transform }),
  native() {
  }
};
var addPropertiesAsync = {
  input: {
    ...addProperties2,
    fileUrl: ({ value }) => ({ stream: createReadStream(value) }),
    filePath: ({ value: { file } }) => ({ stream: createReadStream(file) }),
    webStream: ({ value }) => ({ stream: Readable2.fromWeb(value) }),
    iterable: ({ value }) => ({ stream: Readable2.from(value) }),
    asyncIterable: ({ value }) => ({ stream: Readable2.from(value) }),
    string: ({ value }) => ({ stream: Readable2.from(value) }),
    uint8Array: ({ value }) => ({ stream: Readable2.from(Buffer4.from(value)) })
  },
  output: {
    ...addProperties2,
    fileUrl: ({ value }) => ({ stream: createWriteStream(value) }),
    filePath: ({ value: { file, append } }) => ({ stream: createWriteStream(file, append ? { flags: "a" } : {}) }),
    webStream: ({ value }) => ({ stream: Writable2.fromWeb(value) }),
    iterable: forbiddenIfAsync,
    asyncIterable: forbiddenIfAsync,
    string: forbiddenIfAsync,
    uint8Array: forbiddenIfAsync
  }
};

// node_modules/@sindresorhus/merge-streams/index.js
import { on as on4, once as once7 } from "node:events";
import { PassThrough as PassThroughStream, getDefaultHighWaterMark as getDefaultHighWaterMark2 } from "node:stream";
import { finished as finished2 } from "node:stream/promises";
function mergeStreams(streams) {
  if (!Array.isArray(streams)) {
    throw new TypeError(`Expected an array, got \`${typeof streams}\`.`);
  }
  for (const stream of streams) {
    validateStream(stream);
  }
  const objectMode = streams.some(({ readableObjectMode }) => readableObjectMode);
  const highWaterMark = getHighWaterMark(streams, objectMode);
  const passThroughStream = new MergedStream({
    objectMode,
    writableHighWaterMark: highWaterMark,
    readableHighWaterMark: highWaterMark
  });
  for (const stream of streams) {
    passThroughStream.add(stream);
  }
  return passThroughStream;
}
var getHighWaterMark = (streams, objectMode) => {
  if (streams.length === 0) {
    return getDefaultHighWaterMark2(objectMode);
  }
  const highWaterMarks = streams.filter(({ readableObjectMode }) => readableObjectMode === objectMode).map(({ readableHighWaterMark }) => readableHighWaterMark);
  return Math.max(...highWaterMarks);
};

class MergedStream extends PassThroughStream {
  #streams = new Set([]);
  #ended = new Set([]);
  #aborted = new Set([]);
  #onFinished;
  #unpipeEvent = Symbol("unpipe");
  #streamPromises = new WeakMap;
  add(stream) {
    validateStream(stream);
    if (this.#streams.has(stream)) {
      return;
    }
    this.#streams.add(stream);
    this.#onFinished ??= onMergedStreamFinished(this, this.#streams, this.#unpipeEvent);
    const streamPromise = endWhenStreamsDone({
      passThroughStream: this,
      stream,
      streams: this.#streams,
      ended: this.#ended,
      aborted: this.#aborted,
      onFinished: this.#onFinished,
      unpipeEvent: this.#unpipeEvent
    });
    this.#streamPromises.set(stream, streamPromise);
    stream.pipe(this, { end: false });
  }
  async remove(stream) {
    validateStream(stream);
    if (!this.#streams.has(stream)) {
      return false;
    }
    const streamPromise = this.#streamPromises.get(stream);
    if (streamPromise === undefined) {
      return false;
    }
    this.#streamPromises.delete(stream);
    stream.unpipe(this);
    await streamPromise;
    return true;
  }
}
var onMergedStreamFinished = async (passThroughStream, streams, unpipeEvent) => {
  updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_COUNT);
  const controller = new AbortController;
  try {
    await Promise.race([
      onMergedStreamEnd(passThroughStream, controller),
      onInputStreamsUnpipe(passThroughStream, streams, unpipeEvent, controller)
    ]);
  } finally {
    controller.abort();
    updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_COUNT);
  }
};
var onMergedStreamEnd = async (passThroughStream, { signal }) => {
  try {
    await finished2(passThroughStream, { signal, cleanup: true });
  } catch (error) {
    errorOrAbortStream(passThroughStream, error);
    throw error;
  }
};
var onInputStreamsUnpipe = async (passThroughStream, streams, unpipeEvent, { signal }) => {
  for await (const [unpipedStream] of on4(passThroughStream, "unpipe", { signal })) {
    if (streams.has(unpipedStream)) {
      unpipedStream.emit(unpipeEvent);
    }
  }
};
var validateStream = (stream) => {
  if (typeof stream?.pipe !== "function") {
    throw new TypeError(`Expected a readable stream, got: \`${typeof stream}\`.`);
  }
};
var endWhenStreamsDone = async ({ passThroughStream, stream, streams, ended, aborted, onFinished, unpipeEvent }) => {
  updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_PER_STREAM);
  const controller = new AbortController;
  try {
    await Promise.race([
      afterMergedStreamFinished(onFinished, stream, controller),
      onInputStreamEnd({
        passThroughStream,
        stream,
        streams,
        ended,
        aborted,
        controller
      }),
      onInputStreamUnpipe({
        stream,
        streams,
        ended,
        aborted,
        unpipeEvent,
        controller
      })
    ]);
  } finally {
    controller.abort();
    updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_PER_STREAM);
  }
  if (streams.size > 0 && streams.size === ended.size + aborted.size) {
    if (ended.size === 0 && aborted.size > 0) {
      abortStream(passThroughStream);
    } else {
      endStream(passThroughStream);
    }
  }
};
var afterMergedStreamFinished = async (onFinished, stream, { signal }) => {
  try {
    await onFinished;
    if (!signal.aborted) {
      abortStream(stream);
    }
  } catch (error) {
    if (!signal.aborted) {
      errorOrAbortStream(stream, error);
    }
  }
};
var onInputStreamEnd = async ({ passThroughStream, stream, streams, ended, aborted, controller: { signal } }) => {
  try {
    await finished2(stream, {
      signal,
      cleanup: true,
      readable: true,
      writable: false
    });
    if (streams.has(stream)) {
      ended.add(stream);
    }
  } catch (error) {
    if (signal.aborted || !streams.has(stream)) {
      return;
    }
    if (isAbortError(error)) {
      aborted.add(stream);
    } else {
      errorStream(passThroughStream, error);
    }
  }
};
var onInputStreamUnpipe = async ({ stream, streams, ended, aborted, unpipeEvent, controller: { signal } }) => {
  await once7(stream, unpipeEvent, { signal });
  if (!stream.readable) {
    return once7(signal, "abort", { signal });
  }
  streams.delete(stream);
  ended.delete(stream);
  aborted.delete(stream);
};
var endStream = (stream) => {
  if (stream.writable) {
    stream.end();
  }
};
var errorOrAbortStream = (stream, error) => {
  if (isAbortError(error)) {
    abortStream(stream);
  } else {
    errorStream(stream, error);
  }
};
var isAbortError = (error) => error?.code === "ERR_STREAM_PREMATURE_CLOSE";
var abortStream = (stream) => {
  if (stream.readable || stream.writable) {
    stream.destroy();
  }
};
var errorStream = (stream, error) => {
  if (!stream.destroyed) {
    stream.once("error", noop2);
    stream.destroy(error);
  }
};
var noop2 = () => {
};
var updateMaxListeners = (passThroughStream, increment2) => {
  const maxListeners = passThroughStream.getMaxListeners();
  if (maxListeners !== 0 && maxListeners !== Number.POSITIVE_INFINITY) {
    passThroughStream.setMaxListeners(maxListeners + increment2);
  }
};
var PASSTHROUGH_LISTENERS_COUNT = 2;
var PASSTHROUGH_LISTENERS_PER_STREAM = 1;

// node_modules/execa/lib/io/pipeline.js
import { finished as finished3 } from "node:stream/promises";
var pipeStreams = (source, destination) => {
  source.pipe(destination);
  onSourceFinish(source, destination);
  onDestinationFinish(source, destination);
};
var onSourceFinish = async (source, destination) => {
  if (isStandardStream(source) || isStandardStream(destination)) {
    return;
  }
  try {
    await finished3(source, { cleanup: true, readable: true, writable: false });
  } catch {
  }
  endDestinationStream(destination);
};
var endDestinationStream = (destination) => {
  if (destination.writable) {
    destination.end();
  }
};
var onDestinationFinish = async (source, destination) => {
  if (isStandardStream(source) || isStandardStream(destination)) {
    return;
  }
  try {
    await finished3(destination, { cleanup: true, readable: false, writable: true });
  } catch {
  }
  abortSourceStream(source);
};
var abortSourceStream = (source) => {
  if (source.readable) {
    source.destroy();
  }
};

// node_modules/execa/lib/io/output-async.js
var pipeOutputAsync = (subprocess, fileDescriptors, controller) => {
  const pipeGroups = new Map;
  for (const [fdNumber, { stdioItems, direction }] of Object.entries(fileDescriptors)) {
    for (const { stream } of stdioItems.filter(({ type }) => TRANSFORM_TYPES.has(type))) {
      pipeTransform(subprocess, stream, direction, fdNumber);
    }
    for (const { stream } of stdioItems.filter(({ type }) => !TRANSFORM_TYPES.has(type))) {
      pipeStdioItem({
        subprocess,
        stream,
        direction,
        fdNumber,
        pipeGroups,
        controller
      });
    }
  }
  for (const [outputStream, inputStreams] of pipeGroups.entries()) {
    const inputStream = inputStreams.length === 1 ? inputStreams[0] : mergeStreams(inputStreams);
    pipeStreams(inputStream, outputStream);
  }
};
var pipeTransform = (subprocess, stream, direction, fdNumber) => {
  if (direction === "output") {
    pipeStreams(subprocess.stdio[fdNumber], stream);
  } else {
    pipeStreams(stream, subprocess.stdio[fdNumber]);
  }
  const streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];
  if (streamProperty !== undefined) {
    subprocess[streamProperty] = stream;
  }
  subprocess.stdio[fdNumber] = stream;
};
var SUBPROCESS_STREAM_PROPERTIES = ["stdin", "stdout", "stderr"];
var pipeStdioItem = ({ subprocess, stream, direction, fdNumber, pipeGroups, controller }) => {
  if (stream === undefined) {
    return;
  }
  setStandardStreamMaxListeners(stream, controller);
  const [inputStream, outputStream] = direction === "output" ? [stream, subprocess.stdio[fdNumber]] : [subprocess.stdio[fdNumber], stream];
  const outputStreams = pipeGroups.get(inputStream) ?? [];
  pipeGroups.set(inputStream, [...outputStreams, outputStream]);
};
var setStandardStreamMaxListeners = (stream, { signal }) => {
  if (isStandardStream(stream)) {
    incrementMaxListeners(stream, MAX_LISTENERS_INCREMENT, signal);
  }
};
var MAX_LISTENERS_INCREMENT = 2;

// node_modules/execa/lib/terminate/cleanup.js
init_mjs();
import { addAbortListener as addAbortListener2 } from "node:events";
var cleanupOnExit = (subprocess, { cleanup, detached }, { signal }) => {
  if (!cleanup || detached) {
    return;
  }
  const removeExitHandler = onExit(() => {
    subprocess.kill();
  });
  addAbortListener2(signal, () => {
    removeExitHandler();
  });
};

// node_modules/execa/lib/pipe/pipe-arguments.js
var normalizePipeArguments = ({ source, sourcePromise, boundOptions, createNested }, ...pipeArguments) => {
  const startTime = getStartTime();
  const {
    destination,
    destinationStream,
    destinationError,
    from: from2,
    unpipeSignal
  } = getDestinationStream(boundOptions, createNested, pipeArguments);
  const { sourceStream, sourceError } = getSourceStream(source, from2);
  const { options: sourceOptions, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
  return {
    sourcePromise,
    sourceStream,
    sourceOptions,
    sourceError,
    destination,
    destinationStream,
    destinationError,
    unpipeSignal,
    fileDescriptors,
    startTime
  };
};
var getDestinationStream = (boundOptions, createNested, pipeArguments) => {
  try {
    const {
      destination,
      pipeOptions: { from: from2, to, unpipeSignal } = {}
    } = getDestination(boundOptions, createNested, ...pipeArguments);
    const destinationStream = getToStream(destination, to);
    return {
      destination,
      destinationStream,
      from: from2,
      unpipeSignal
    };
  } catch (error) {
    return { destinationError: error };
  }
};
var getDestination = (boundOptions, createNested, firstArgument, ...pipeArguments) => {
  if (Array.isArray(firstArgument)) {
    const destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);
    return { destination, pipeOptions: boundOptions };
  }
  if (typeof firstArgument === "string" || firstArgument instanceof URL || isDenoExecPath(firstArgument)) {
    if (Object.keys(boundOptions).length > 0) {
      throw new TypeError('Please use .pipe("file", ..., options) or .pipe(execa("file", ..., options)) instead of .pipe(options)("file", ...).');
    }
    const [rawFile, rawArguments, rawOptions] = normalizeParameters(firstArgument, ...pipeArguments);
    const destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);
    return { destination, pipeOptions: rawOptions };
  }
  if (SUBPROCESS_OPTIONS.has(firstArgument)) {
    if (Object.keys(boundOptions).length > 0) {
      throw new TypeError("Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).");
    }
    return { destination: firstArgument, pipeOptions: pipeArguments[0] };
  }
  throw new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${firstArgument}`);
};
var mapDestinationArguments = ({ options }) => ({ options: { ...options, stdin: "pipe", piped: true } });
var getSourceStream = (source, from2) => {
  try {
    const sourceStream = getFromStream(source, from2);
    return { sourceStream };
  } catch (error) {
    return { sourceError: error };
  }
};

// node_modules/execa/lib/pipe/throw.js
var handlePipeArgumentsError = ({
  sourceStream,
  sourceError,
  destinationStream,
  destinationError,
  fileDescriptors,
  sourceOptions,
  startTime
}) => {
  const error = getPipeArgumentsError({
    sourceStream,
    sourceError,
    destinationStream,
    destinationError
  });
  if (error !== undefined) {
    throw createNonCommandError({
      error,
      fileDescriptors,
      sourceOptions,
      startTime
    });
  }
};
var getPipeArgumentsError = ({ sourceStream, sourceError, destinationStream, destinationError }) => {
  if (sourceError !== undefined && destinationError !== undefined) {
    return destinationError;
  }
  if (destinationError !== undefined) {
    abortSourceStream(sourceStream);
    return destinationError;
  }
  if (sourceError !== undefined) {
    endDestinationStream(destinationStream);
    return sourceError;
  }
};
var createNonCommandError = ({ error, fileDescriptors, sourceOptions, startTime }) => makeEarlyError({
  error,
  command: PIPE_COMMAND_MESSAGE,
  escapedCommand: PIPE_COMMAND_MESSAGE,
  fileDescriptors,
  options: sourceOptions,
  startTime,
  isSync: false
});
var PIPE_COMMAND_MESSAGE = "source.pipe(destination)";

// node_modules/execa/lib/pipe/sequence.js
var waitForBothSubprocesses = async (subprocessPromises) => {
  const [
    { status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason },
    { status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason }
  ] = await subprocessPromises;
  if (!destinationResult.pipedFrom.includes(sourceResult)) {
    destinationResult.pipedFrom.push(sourceResult);
  }
  if (destinationStatus === "rejected") {
    throw destinationResult;
  }
  if (sourceStatus === "rejected") {
    throw sourceResult;
  }
  return destinationResult;
};

// node_modules/execa/lib/pipe/streaming.js
import { finished as finished4 } from "node:stream/promises";
var pipeSubprocessStream = (sourceStream, destinationStream, maxListenersController) => {
  const mergedStream = MERGED_STREAMS.has(destinationStream) ? pipeMoreSubprocessStream(sourceStream, destinationStream) : pipeFirstSubprocessStream(sourceStream, destinationStream);
  incrementMaxListeners(sourceStream, SOURCE_LISTENERS_PER_PIPE, maxListenersController.signal);
  incrementMaxListeners(destinationStream, DESTINATION_LISTENERS_PER_PIPE, maxListenersController.signal);
  cleanupMergedStreamsMap(destinationStream);
  return mergedStream;
};
var pipeFirstSubprocessStream = (sourceStream, destinationStream) => {
  const mergedStream = mergeStreams([sourceStream]);
  pipeStreams(mergedStream, destinationStream);
  MERGED_STREAMS.set(destinationStream, mergedStream);
  return mergedStream;
};
var pipeMoreSubprocessStream = (sourceStream, destinationStream) => {
  const mergedStream = MERGED_STREAMS.get(destinationStream);
  mergedStream.add(sourceStream);
  return mergedStream;
};
var cleanupMergedStreamsMap = async (destinationStream) => {
  try {
    await finished4(destinationStream, { cleanup: true, readable: false, writable: true });
  } catch {
  }
  MERGED_STREAMS.delete(destinationStream);
};
var MERGED_STREAMS = new WeakMap;
var SOURCE_LISTENERS_PER_PIPE = 2;
var DESTINATION_LISTENERS_PER_PIPE = 1;

// node_modules/execa/lib/pipe/abort.js
import { aborted } from "node:util";
var unpipeOnAbort = (unpipeSignal, unpipeContext) => unpipeSignal === undefined ? [] : [unpipeOnSignalAbort(unpipeSignal, unpipeContext)];
var unpipeOnSignalAbort = async (unpipeSignal, { sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime }) => {
  await aborted(unpipeSignal, sourceStream);
  await mergedStream.remove(sourceStream);
  const error = new Error("Pipe canceled by `unpipeSignal` option.");
  throw createNonCommandError({
    error,
    fileDescriptors,
    sourceOptions,
    startTime
  });
};

// node_modules/execa/lib/pipe/setup.js
var pipeToSubprocess = (sourceInfo, ...pipeArguments) => {
  if (isPlainObject11(pipeArguments[0])) {
    return pipeToSubprocess.bind(undefined, {
      ...sourceInfo,
      boundOptions: { ...sourceInfo.boundOptions, ...pipeArguments[0] }
    });
  }
  const { destination, ...normalizedInfo } = normalizePipeArguments(sourceInfo, ...pipeArguments);
  const promise = handlePipePromise({ ...normalizedInfo, destination });
  promise.pipe = pipeToSubprocess.bind(undefined, {
    ...sourceInfo,
    source: destination,
    sourcePromise: promise,
    boundOptions: {}
  });
  return promise;
};
var handlePipePromise = async ({
  sourcePromise,
  sourceStream,
  sourceOptions,
  sourceError,
  destination,
  destinationStream,
  destinationError,
  unpipeSignal,
  fileDescriptors,
  startTime
}) => {
  const subprocessPromises = getSubprocessPromises(sourcePromise, destination);
  handlePipeArgumentsError({
    sourceStream,
    sourceError,
    destinationStream,
    destinationError,
    fileDescriptors,
    sourceOptions,
    startTime
  });
  const maxListenersController = new AbortController;
  try {
    const mergedStream = pipeSubprocessStream(sourceStream, destinationStream, maxListenersController);
    return await Promise.race([
      waitForBothSubprocesses(subprocessPromises),
      ...unpipeOnAbort(unpipeSignal, {
        sourceStream,
        mergedStream,
        sourceOptions,
        fileDescriptors,
        startTime
      })
    ]);
  } finally {
    maxListenersController.abort();
  }
};
var getSubprocessPromises = (sourcePromise, destination) => Promise.allSettled([sourcePromise, destination]);

// node_modules/execa/lib/io/contents.js
import { setImmediate as setImmediate2 } from "node:timers/promises";

// node_modules/execa/lib/io/iterate.js
import { on as on5 } from "node:events";
import { getDefaultHighWaterMark as getDefaultHighWaterMark3 } from "node:stream";
var iterateOnSubprocessStream = ({ subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines }) => {
  const controller = new AbortController;
  stopReadingOnExit(subprocess, controller);
  return iterateOnStream({
    stream: subprocessStdout,
    controller,
    binary,
    shouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,
    encoding,
    shouldSplit: !subprocessStdout.readableObjectMode,
    preserveNewlines
  });
};
var stopReadingOnExit = async (subprocess, controller) => {
  try {
    await subprocess;
  } catch {
  } finally {
    controller.abort();
  }
};
var iterateForResult = ({ stream, onStreamEnd, lines: lines4, encoding, stripFinalNewline: stripFinalNewline2, allMixed }) => {
  const controller = new AbortController;
  stopReadingOnStreamEnd(onStreamEnd, controller, stream);
  const objectMode = stream.readableObjectMode && !allMixed;
  return iterateOnStream({
    stream,
    controller,
    binary: encoding === "buffer",
    shouldEncode: !objectMode,
    encoding,
    shouldSplit: !objectMode && lines4,
    preserveNewlines: !stripFinalNewline2
  });
};
var stopReadingOnStreamEnd = async (onStreamEnd, controller, stream) => {
  try {
    await onStreamEnd;
  } catch {
    stream.destroy();
  } finally {
    controller.abort();
  }
};
var iterateOnStream = ({ stream, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) => {
  const onStdoutChunk = on5(stream, "data", {
    signal: controller.signal,
    highWaterMark: HIGH_WATER_MARK,
    highWatermark: HIGH_WATER_MARK
  });
  return iterateOnData({
    onStdoutChunk,
    controller,
    binary,
    shouldEncode,
    encoding,
    shouldSplit,
    preserveNewlines
  });
};
var DEFAULT_OBJECT_HIGH_WATER_MARK = getDefaultHighWaterMark3(true);
var HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;
var iterateOnData = async function* ({ onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) {
  const generators = getGenerators({
    binary,
    shouldEncode,
    encoding,
    shouldSplit,
    preserveNewlines
  });
  try {
    for await (const [chunk] of onStdoutChunk) {
      yield* transformChunkSync(chunk, generators, 0);
    }
  } catch (error) {
    if (!controller.signal.aborted) {
      throw error;
    }
  } finally {
    yield* finalChunksSync(generators);
  }
};
var getGenerators = ({ binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) => [
  getEncodingTransformGenerator(binary, encoding, !shouldEncode),
  getSplitLinesGenerator(binary, preserveNewlines, !shouldSplit, {})
].filter(Boolean);

// node_modules/execa/lib/io/contents.js
var getStreamOutput = async ({ stream, onStreamEnd, fdNumber, encoding, buffer, maxBuffer, lines: lines4, allMixed, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => {
  const logPromise = logOutputAsync({
    stream,
    onStreamEnd,
    fdNumber,
    encoding,
    allMixed,
    verboseInfo,
    streamInfo
  });
  if (!buffer) {
    await Promise.all([resumeStream(stream), logPromise]);
    return;
  }
  const stripFinalNewlineValue = getStripFinalNewline(stripFinalNewline2, fdNumber);
  const iterable = iterateForResult({
    stream,
    onStreamEnd,
    lines: lines4,
    encoding,
    stripFinalNewline: stripFinalNewlineValue,
    allMixed
  });
  const [output] = await Promise.all([
    getStreamContents2({
      stream,
      iterable,
      fdNumber,
      encoding,
      maxBuffer,
      lines: lines4
    }),
    logPromise
  ]);
  return output;
};
var logOutputAsync = async ({ stream, onStreamEnd, fdNumber, encoding, allMixed, verboseInfo, streamInfo: { fileDescriptors } }) => {
  if (!shouldLogOutput({
    stdioItems: fileDescriptors[fdNumber]?.stdioItems,
    encoding,
    verboseInfo,
    fdNumber
  })) {
    return;
  }
  const linesIterable = iterateForResult({
    stream,
    onStreamEnd,
    lines: true,
    encoding,
    stripFinalNewline: true,
    allMixed
  });
  await logLines(linesIterable, stream, fdNumber, verboseInfo);
};
var resumeStream = async (stream) => {
  await setImmediate2();
  if (stream.readableFlowing === null) {
    stream.resume();
  }
};
var getStreamContents2 = async ({ stream, stream: { readableObjectMode }, iterable, fdNumber, encoding, maxBuffer, lines: lines4 }) => {
  try {
    if (readableObjectMode || lines4) {
      return await getStreamAsArray(iterable, { maxBuffer });
    }
    if (encoding === "buffer") {
      return new Uint8Array(await getStreamAsArrayBuffer(iterable, { maxBuffer }));
    }
    return await getStreamAsString(iterable, { maxBuffer });
  } catch (error) {
    return handleBufferedData(handleMaxBuffer({
      error,
      stream,
      readableObjectMode,
      lines: lines4,
      encoding,
      fdNumber
    }));
  }
};
var getBufferedData = async (streamPromise) => {
  try {
    return await streamPromise;
  } catch (error) {
    return handleBufferedData(error);
  }
};
var handleBufferedData = ({ bufferedData }) => isArrayBuffer(bufferedData) ? new Uint8Array(bufferedData) : bufferedData;

// node_modules/execa/lib/resolve/wait-stream.js
import { finished as finished5 } from "node:stream/promises";
var waitForStream = async (stream, fdNumber, streamInfo, { isSameDirection, stopOnExit = false } = {}) => {
  const state = handleStdinDestroy(stream, streamInfo);
  const abortController = new AbortController;
  try {
    await Promise.race([
      ...stopOnExit ? [streamInfo.exitPromise] : [],
      finished5(stream, { cleanup: true, signal: abortController.signal })
    ]);
  } catch (error) {
    if (!state.stdinCleanedUp) {
      handleStreamError(error, fdNumber, streamInfo, isSameDirection);
    }
  } finally {
    abortController.abort();
  }
};
var handleStdinDestroy = (stream, { originalStreams: [originalStdin], subprocess }) => {
  const state = { stdinCleanedUp: false };
  if (stream === originalStdin) {
    spyOnStdinDestroy(stream, subprocess, state);
  }
  return state;
};
var spyOnStdinDestroy = (subprocessStdin, subprocess, state) => {
  const { _destroy } = subprocessStdin;
  subprocessStdin._destroy = (...destroyArguments) => {
    setStdinCleanedUp(subprocess, state);
    _destroy.call(subprocessStdin, ...destroyArguments);
  };
};
var setStdinCleanedUp = ({ exitCode, signalCode }, state) => {
  if (exitCode !== null || signalCode !== null) {
    state.stdinCleanedUp = true;
  }
};
var handleStreamError = (error, fdNumber, streamInfo, isSameDirection) => {
  if (!shouldIgnoreStreamError(error, fdNumber, streamInfo, isSameDirection)) {
    throw error;
  }
};
var shouldIgnoreStreamError = (error, fdNumber, streamInfo, isSameDirection = true) => {
  if (streamInfo.propagating) {
    return isStreamEpipe(error) || isStreamAbort(error);
  }
  streamInfo.propagating = true;
  return isInputFileDescriptor(streamInfo, fdNumber) === isSameDirection ? isStreamEpipe(error) : isStreamAbort(error);
};
var isInputFileDescriptor = ({ fileDescriptors }, fdNumber) => fdNumber !== "all" && fileDescriptors[fdNumber].direction === "input";
var isStreamAbort = (error) => error?.code === "ERR_STREAM_PREMATURE_CLOSE";
var isStreamEpipe = (error) => error?.code === "EPIPE";

// node_modules/execa/lib/resolve/stdio.js
var waitForStdioStreams = ({ subprocess, encoding, buffer, maxBuffer, lines: lines4, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => subprocess.stdio.map((stream, fdNumber) => waitForSubprocessStream({
  stream,
  fdNumber,
  encoding,
  buffer: buffer[fdNumber],
  maxBuffer: maxBuffer[fdNumber],
  lines: lines4[fdNumber],
  allMixed: false,
  stripFinalNewline: stripFinalNewline2,
  verboseInfo,
  streamInfo
}));
var waitForSubprocessStream = async ({ stream, fdNumber, encoding, buffer, maxBuffer, lines: lines4, allMixed, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => {
  if (!stream) {
    return;
  }
  const onStreamEnd = waitForStream(stream, fdNumber, streamInfo);
  if (isInputFileDescriptor(streamInfo, fdNumber)) {
    await onStreamEnd;
    return;
  }
  const [output] = await Promise.all([
    getStreamOutput({
      stream,
      onStreamEnd,
      fdNumber,
      encoding,
      buffer,
      maxBuffer,
      lines: lines4,
      allMixed,
      stripFinalNewline: stripFinalNewline2,
      verboseInfo,
      streamInfo
    }),
    onStreamEnd
  ]);
  return output;
};

// node_modules/execa/lib/resolve/all-async.js
var makeAllStream = ({ stdout, stderr }, { all }) => all && (stdout || stderr) ? mergeStreams([stdout, stderr].filter(Boolean)) : undefined;
var waitForAllStream = ({ subprocess, encoding, buffer, maxBuffer, lines: lines4, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => waitForSubprocessStream({
  ...getAllStream(subprocess, buffer),
  fdNumber: "all",
  encoding,
  maxBuffer: maxBuffer[1] + maxBuffer[2],
  lines: lines4[1] || lines4[2],
  allMixed: getAllMixed(subprocess),
  stripFinalNewline: stripFinalNewline2,
  verboseInfo,
  streamInfo
});
var getAllStream = ({ stdout, stderr, all }, [, bufferStdout, bufferStderr]) => {
  const buffer = bufferStdout || bufferStderr;
  if (!buffer) {
    return { stream: all, buffer };
  }
  if (!bufferStdout) {
    return { stream: stderr, buffer };
  }
  if (!bufferStderr) {
    return { stream: stdout, buffer };
  }
  return { stream: all, buffer };
};
var getAllMixed = ({ all, stdout, stderr }) => all && stdout && stderr && stdout.readableObjectMode !== stderr.readableObjectMode;

// node_modules/execa/lib/resolve/wait-subprocess.js
import { once as once8 } from "node:events";

// node_modules/execa/lib/verbose/ipc.js
var shouldLogIpc = (verboseInfo) => isFullVerbose(verboseInfo, "ipc");
var logIpcOutput = (message, verboseInfo) => {
  const verboseMessage = serializeVerboseMessage(message);
  verboseLog({
    type: "ipc",
    verboseMessage,
    fdNumber: "ipc",
    verboseInfo
  });
};

// node_modules/execa/lib/ipc/buffer-messages.js
var waitForIpcOutput = async ({
  subprocess,
  buffer: bufferArray,
  maxBuffer: maxBufferArray,
  ipc,
  ipcOutput,
  verboseInfo
}) => {
  if (!ipc) {
    return ipcOutput;
  }
  const isVerbose2 = shouldLogIpc(verboseInfo);
  const buffer = getFdSpecificValue(bufferArray, "ipc");
  const maxBuffer = getFdSpecificValue(maxBufferArray, "ipc");
  for await (const message of loopOnMessages({
    anyProcess: subprocess,
    channel: subprocess.channel,
    isSubprocess: false,
    ipc,
    shouldAwait: false,
    reference: true
  })) {
    if (buffer) {
      checkIpcMaxBuffer(subprocess, ipcOutput, maxBuffer);
      ipcOutput.push(message);
    }
    if (isVerbose2) {
      logIpcOutput(message, verboseInfo);
    }
  }
  return ipcOutput;
};
var getBufferedIpcOutput = async (ipcOutputPromise, ipcOutput) => {
  await Promise.allSettled([ipcOutputPromise]);
  return ipcOutput;
};

// node_modules/execa/lib/resolve/wait-subprocess.js
var waitForSubprocessResult = async ({
  subprocess,
  options: {
    encoding,
    buffer,
    maxBuffer,
    lines: lines4,
    timeoutDuration: timeout,
    cancelSignal,
    gracefulCancel,
    forceKillAfterDelay,
    stripFinalNewline: stripFinalNewline2,
    ipc,
    ipcInput
  },
  context,
  verboseInfo,
  fileDescriptors,
  originalStreams,
  onInternalError,
  controller
}) => {
  const exitPromise = waitForExit(subprocess, context);
  const streamInfo = {
    originalStreams,
    fileDescriptors,
    subprocess,
    exitPromise,
    propagating: false
  };
  const stdioPromises = waitForStdioStreams({
    subprocess,
    encoding,
    buffer,
    maxBuffer,
    lines: lines4,
    stripFinalNewline: stripFinalNewline2,
    verboseInfo,
    streamInfo
  });
  const allPromise = waitForAllStream({
    subprocess,
    encoding,
    buffer,
    maxBuffer,
    lines: lines4,
    stripFinalNewline: stripFinalNewline2,
    verboseInfo,
    streamInfo
  });
  const ipcOutput = [];
  const ipcOutputPromise = waitForIpcOutput({
    subprocess,
    buffer,
    maxBuffer,
    ipc,
    ipcOutput,
    verboseInfo
  });
  const originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);
  const customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);
  try {
    return await Promise.race([
      Promise.all([
        {},
        waitForSuccessfulExit(exitPromise),
        Promise.all(stdioPromises),
        allPromise,
        ipcOutputPromise,
        sendIpcInput(subprocess, ipcInput),
        ...originalPromises,
        ...customStreamsEndPromises
      ]),
      onInternalError,
      throwOnSubprocessError(subprocess, controller),
      ...throwOnTimeout(subprocess, timeout, context, controller),
      ...throwOnCancel({
        subprocess,
        cancelSignal,
        gracefulCancel,
        context,
        controller
      }),
      ...throwOnGracefulCancel({
        subprocess,
        cancelSignal,
        gracefulCancel,
        forceKillAfterDelay,
        context,
        controller
      })
    ]);
  } catch (error) {
    context.terminationReason ??= "other";
    return Promise.all([
      { error },
      exitPromise,
      Promise.all(stdioPromises.map((stdioPromise) => getBufferedData(stdioPromise))),
      getBufferedData(allPromise),
      getBufferedIpcOutput(ipcOutputPromise, ipcOutput),
      Promise.allSettled(originalPromises),
      Promise.allSettled(customStreamsEndPromises)
    ]);
  }
};
var waitForOriginalStreams = (originalStreams, subprocess, streamInfo) => originalStreams.map((stream, fdNumber) => stream === subprocess.stdio[fdNumber] ? undefined : waitForStream(stream, fdNumber, streamInfo));
var waitForCustomStreamsEnd = (fileDescriptors, streamInfo) => fileDescriptors.flatMap(({ stdioItems }, fdNumber) => stdioItems.filter(({ value, stream = value }) => isStream(stream, { checkOpen: false }) && !isStandardStream(stream)).map(({ type, value, stream = value }) => waitForStream(stream, fdNumber, streamInfo, {
  isSameDirection: TRANSFORM_TYPES.has(type),
  stopOnExit: type === "native"
})));
var throwOnSubprocessError = async (subprocess, { signal }) => {
  const [error] = await once8(subprocess, "error", { signal });
  throw error;
};

// node_modules/execa/lib/convert/concurrent.js
var initializeConcurrentStreams = () => ({
  readableDestroy: new WeakMap,
  writableFinal: new WeakMap,
  writableDestroy: new WeakMap
});
var addConcurrentStream = (concurrentStreams, stream, waitName) => {
  const weakMap = concurrentStreams[waitName];
  if (!weakMap.has(stream)) {
    weakMap.set(stream, []);
  }
  const promises = weakMap.get(stream);
  const promise = createDeferred();
  promises.push(promise);
  const resolve = promise.resolve.bind(promise);
  return { resolve, promises };
};
var waitForConcurrentStreams = async ({ resolve, promises }, subprocess) => {
  resolve();
  const [isSubprocessExit] = await Promise.race([
    Promise.allSettled([true, subprocess]),
    Promise.all([false, ...promises])
  ]);
  return !isSubprocessExit;
};

// node_modules/execa/lib/convert/readable.js
import { Readable as Readable3 } from "node:stream";
import { callbackify as callbackify2 } from "node:util";

// node_modules/execa/lib/convert/shared.js
import { finished as finished6 } from "node:stream/promises";
var safeWaitForSubprocessStdin = async (subprocessStdin) => {
  if (subprocessStdin === undefined) {
    return;
  }
  try {
    await waitForSubprocessStdin(subprocessStdin);
  } catch {
  }
};
var safeWaitForSubprocessStdout = async (subprocessStdout) => {
  if (subprocessStdout === undefined) {
    return;
  }
  try {
    await waitForSubprocessStdout(subprocessStdout);
  } catch {
  }
};
var waitForSubprocessStdin = async (subprocessStdin) => {
  await finished6(subprocessStdin, { cleanup: true, readable: false, writable: true });
};
var waitForSubprocessStdout = async (subprocessStdout) => {
  await finished6(subprocessStdout, { cleanup: true, readable: true, writable: false });
};
var waitForSubprocess = async (subprocess, error) => {
  await subprocess;
  if (error) {
    throw error;
  }
};
var destroyOtherStream = (stream, isOpen, error) => {
  if (error && !isStreamAbort(error)) {
    stream.destroy(error);
  } else if (isOpen) {
    stream.destroy();
  }
};

// node_modules/execa/lib/convert/readable.js
var createReadable = ({ subprocess, concurrentStreams, encoding }, { from: from2, binary: binaryOption = true, preserveNewlines = true } = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from2, concurrentStreams);
  const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
  const { read, onStdoutDataDone } = getReadableMethods({
    subprocessStdout,
    subprocess,
    binary,
    encoding,
    preserveNewlines
  });
  const readable2 = new Readable3({
    read,
    destroy: callbackify2(onReadableDestroy.bind(undefined, { subprocessStdout, subprocess, waitReadableDestroy })),
    highWaterMark: readableHighWaterMark,
    objectMode: readableObjectMode,
    encoding: readableEncoding
  });
  onStdoutFinished({
    subprocessStdout,
    onStdoutDataDone,
    readable: readable2,
    subprocess
  });
  return readable2;
};
var getSubprocessStdout = (subprocess, from2, concurrentStreams) => {
  const subprocessStdout = getFromStream(subprocess, from2);
  const waitReadableDestroy = addConcurrentStream(concurrentStreams, subprocessStdout, "readableDestroy");
  return { subprocessStdout, waitReadableDestroy };
};
var getReadableOptions = ({ readableEncoding, readableObjectMode, readableHighWaterMark }, binary) => binary ? { readableEncoding, readableObjectMode, readableHighWaterMark } : { readableEncoding, readableObjectMode: true, readableHighWaterMark: DEFAULT_OBJECT_HIGH_WATER_MARK };
var getReadableMethods = ({ subprocessStdout, subprocess, binary, encoding, preserveNewlines }) => {
  const onStdoutDataDone = createDeferred();
  const onStdoutData = iterateOnSubprocessStream({
    subprocessStdout,
    subprocess,
    binary,
    shouldEncode: !binary,
    encoding,
    preserveNewlines
  });
  return {
    read() {
      onRead(this, onStdoutData, onStdoutDataDone);
    },
    onStdoutDataDone
  };
};
var onRead = async (readable2, onStdoutData, onStdoutDataDone) => {
  try {
    const { value, done } = await onStdoutData.next();
    if (done) {
      onStdoutDataDone.resolve();
    } else {
      readable2.push(value);
    }
  } catch {
  }
};
var onStdoutFinished = async ({ subprocessStdout, onStdoutDataDone, readable: readable2, subprocess, subprocessStdin }) => {
  try {
    await waitForSubprocessStdout(subprocessStdout);
    await subprocess;
    await safeWaitForSubprocessStdin(subprocessStdin);
    await onStdoutDataDone;
    if (readable2.readable) {
      readable2.push(null);
    }
  } catch (error) {
    await safeWaitForSubprocessStdin(subprocessStdin);
    destroyOtherReadable(readable2, error);
  }
};
var onReadableDestroy = async ({ subprocessStdout, subprocess, waitReadableDestroy }, error) => {
  if (await waitForConcurrentStreams(waitReadableDestroy, subprocess)) {
    destroyOtherReadable(subprocessStdout, error);
    await waitForSubprocess(subprocess, error);
  }
};
var destroyOtherReadable = (stream, error) => {
  destroyOtherStream(stream, stream.readable, error);
};

// node_modules/execa/lib/convert/writable.js
import { Writable as Writable3 } from "node:stream";
import { callbackify as callbackify3 } from "node:util";
var createWritable = ({ subprocess, concurrentStreams }, { to } = {}) => {
  const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
  const writable2 = new Writable3({
    ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
    destroy: callbackify3(onWritableDestroy.bind(undefined, {
      subprocessStdin,
      subprocess,
      waitWritableFinal,
      waitWritableDestroy
    })),
    highWaterMark: subprocessStdin.writableHighWaterMark,
    objectMode: subprocessStdin.writableObjectMode
  });
  onStdinFinished(subprocessStdin, writable2);
  return writable2;
};
var getSubprocessStdin = (subprocess, to, concurrentStreams) => {
  const subprocessStdin = getToStream(subprocess, to);
  const waitWritableFinal = addConcurrentStream(concurrentStreams, subprocessStdin, "writableFinal");
  const waitWritableDestroy = addConcurrentStream(concurrentStreams, subprocessStdin, "writableDestroy");
  return { subprocessStdin, waitWritableFinal, waitWritableDestroy };
};
var getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal) => ({
  write: onWrite.bind(undefined, subprocessStdin),
  final: callbackify3(onWritableFinal.bind(undefined, subprocessStdin, subprocess, waitWritableFinal))
});
var onWrite = (subprocessStdin, chunk, encoding, done) => {
  if (subprocessStdin.write(chunk, encoding)) {
    done();
  } else {
    subprocessStdin.once("drain", done);
  }
};
var onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal) => {
  if (await waitForConcurrentStreams(waitWritableFinal, subprocess)) {
    if (subprocessStdin.writable) {
      subprocessStdin.end();
    }
    await subprocess;
  }
};
var onStdinFinished = async (subprocessStdin, writable2, subprocessStdout) => {
  try {
    await waitForSubprocessStdin(subprocessStdin);
    if (writable2.writable) {
      writable2.end();
    }
  } catch (error) {
    await safeWaitForSubprocessStdout(subprocessStdout);
    destroyOtherWritable(writable2, error);
  }
};
var onWritableDestroy = async ({ subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy }, error) => {
  await waitForConcurrentStreams(waitWritableFinal, subprocess);
  if (await waitForConcurrentStreams(waitWritableDestroy, subprocess)) {
    destroyOtherWritable(subprocessStdin, error);
    await waitForSubprocess(subprocess, error);
  }
};
var destroyOtherWritable = (stream, error) => {
  destroyOtherStream(stream, stream.writable, error);
};

// node_modules/execa/lib/convert/duplex.js
import { Duplex as Duplex3 } from "node:stream";
import { callbackify as callbackify4 } from "node:util";
var createDuplex = ({ subprocess, concurrentStreams, encoding }, { from: from2, to, binary: binaryOption = true, preserveNewlines = true } = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from2, concurrentStreams);
  const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
  const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
  const { read, onStdoutDataDone } = getReadableMethods({
    subprocessStdout,
    subprocess,
    binary,
    encoding,
    preserveNewlines
  });
  const duplex2 = new Duplex3({
    read,
    ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
    destroy: callbackify4(onDuplexDestroy.bind(undefined, {
      subprocessStdout,
      subprocessStdin,
      subprocess,
      waitReadableDestroy,
      waitWritableFinal,
      waitWritableDestroy
    })),
    readableHighWaterMark,
    writableHighWaterMark: subprocessStdin.writableHighWaterMark,
    readableObjectMode,
    writableObjectMode: subprocessStdin.writableObjectMode,
    encoding: readableEncoding
  });
  onStdoutFinished({
    subprocessStdout,
    onStdoutDataDone,
    readable: duplex2,
    subprocess,
    subprocessStdin
  });
  onStdinFinished(subprocessStdin, duplex2, subprocessStdout);
  return duplex2;
};
var onDuplexDestroy = async ({ subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy }, error) => {
  await Promise.all([
    onReadableDestroy({ subprocessStdout, subprocess, waitReadableDestroy }, error),
    onWritableDestroy({
      subprocessStdin,
      subprocess,
      waitWritableFinal,
      waitWritableDestroy
    }, error)
  ]);
};

// node_modules/execa/lib/convert/iterable.js
var createIterable = (subprocess, encoding, {
  from: from2,
  binary: binaryOption = false,
  preserveNewlines = false
} = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const subprocessStdout = getFromStream(subprocess, from2);
  const onStdoutData = iterateOnSubprocessStream({
    subprocessStdout,
    subprocess,
    binary,
    shouldEncode: true,
    encoding,
    preserveNewlines
  });
  return iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);
};
var iterateOnStdoutData = async function* (onStdoutData, subprocessStdout, subprocess) {
  try {
    yield* onStdoutData;
  } finally {
    if (subprocessStdout.readable) {
      subprocessStdout.destroy();
    }
    await subprocess;
  }
};

// node_modules/execa/lib/convert/add.js
var addConvertedStreams = (subprocess, { encoding }) => {
  const concurrentStreams = initializeConcurrentStreams();
  subprocess.readable = createReadable.bind(undefined, { subprocess, concurrentStreams, encoding });
  subprocess.writable = createWritable.bind(undefined, { subprocess, concurrentStreams });
  subprocess.duplex = createDuplex.bind(undefined, { subprocess, concurrentStreams, encoding });
  subprocess.iterable = createIterable.bind(undefined, subprocess, encoding);
  subprocess[Symbol.asyncIterator] = createIterable.bind(undefined, subprocess, encoding, {});
};

// node_modules/execa/lib/methods/promise.js
var mergePromise = (subprocess, promise) => {
  for (const [property, descriptor] of descriptors) {
    const value = descriptor.value.bind(promise);
    Reflect.defineProperty(subprocess, property, { ...descriptor, value });
  }
};
var nativePromisePrototype = (async () => {
})().constructor.prototype;
var descriptors = ["then", "catch", "finally"].map((property) => [
  property,
  Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
]);

// node_modules/execa/lib/methods/main-async.js
var execaCoreAsync = (rawFile, rawArguments, rawOptions, createNested) => {
  const { file, commandArguments, command: command2, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleAsyncArguments(rawFile, rawArguments, rawOptions);
  const { subprocess, promise } = spawnSubprocessAsync({
    file,
    commandArguments,
    options,
    startTime,
    verboseInfo,
    command: command2,
    escapedCommand,
    fileDescriptors
  });
  subprocess.pipe = pipeToSubprocess.bind(undefined, {
    source: subprocess,
    sourcePromise: promise,
    boundOptions: {},
    createNested
  });
  mergePromise(subprocess, promise);
  SUBPROCESS_OPTIONS.set(subprocess, { options, fileDescriptors });
  return subprocess;
};
var handleAsyncArguments = (rawFile, rawArguments, rawOptions) => {
  const { command: command2, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
  const { file, commandArguments, options: normalizedOptions } = normalizeOptions(rawFile, rawArguments, rawOptions);
  const options = handleAsyncOptions(normalizedOptions);
  const fileDescriptors = handleStdioAsync(options, verboseInfo);
  return {
    file,
    commandArguments,
    command: command2,
    escapedCommand,
    startTime,
    verboseInfo,
    options,
    fileDescriptors
  };
};
var handleAsyncOptions = ({ timeout, signal, ...options }) => {
  if (signal !== undefined) {
    throw new TypeError('The "signal" option has been renamed to "cancelSignal" instead.');
  }
  return { ...options, timeoutDuration: timeout };
};
var spawnSubprocessAsync = ({ file, commandArguments, options, startTime, verboseInfo, command: command2, escapedCommand, fileDescriptors }) => {
  let subprocess;
  try {
    subprocess = spawn(file, commandArguments, options);
  } catch (error) {
    return handleEarlyError({
      error,
      command: command2,
      escapedCommand,
      fileDescriptors,
      options,
      startTime,
      verboseInfo
    });
  }
  const controller = new AbortController;
  setMaxListeners(Number.POSITIVE_INFINITY, controller.signal);
  const originalStreams = [...subprocess.stdio];
  pipeOutputAsync(subprocess, fileDescriptors, controller);
  cleanupOnExit(subprocess, options, controller);
  const context = {};
  const onInternalError = createDeferred();
  subprocess.kill = subprocessKill.bind(undefined, {
    kill: subprocess.kill.bind(subprocess),
    options,
    onInternalError,
    context,
    controller
  });
  subprocess.all = makeAllStream(subprocess, options);
  addConvertedStreams(subprocess, options);
  addIpcMethods(subprocess, options);
  const promise = handlePromise({
    subprocess,
    options,
    startTime,
    verboseInfo,
    fileDescriptors,
    originalStreams,
    command: command2,
    escapedCommand,
    context,
    onInternalError,
    controller
  });
  return { subprocess, promise };
};
var handlePromise = async ({ subprocess, options, startTime, verboseInfo, fileDescriptors, originalStreams, command: command2, escapedCommand, context, onInternalError, controller }) => {
  const [
    errorInfo,
    [exitCode, signal],
    stdioResults,
    allResult,
    ipcOutput
  ] = await waitForSubprocessResult({
    subprocess,
    options,
    context,
    verboseInfo,
    fileDescriptors,
    originalStreams,
    onInternalError,
    controller
  });
  controller.abort();
  onInternalError.resolve();
  const stdio = stdioResults.map((stdioResult, fdNumber) => stripNewline(stdioResult, options, fdNumber));
  const all = stripNewline(allResult, options, "all");
  const result = getAsyncResult({
    errorInfo,
    exitCode,
    signal,
    stdio,
    all,
    ipcOutput,
    context,
    options,
    command: command2,
    escapedCommand,
    startTime
  });
  return handleResult2(result, verboseInfo, options);
};
var getAsyncResult = ({ errorInfo, exitCode, signal, stdio, all, ipcOutput, context, options, command: command2, escapedCommand, startTime }) => ("error" in errorInfo) ? makeError({
  error: errorInfo.error,
  command: command2,
  escapedCommand,
  timedOut: context.terminationReason === "timeout",
  isCanceled: context.terminationReason === "cancel" || context.terminationReason === "gracefulCancel",
  isGracefullyCanceled: context.terminationReason === "gracefulCancel",
  isMaxBuffer: errorInfo.error instanceof MaxBufferError,
  isForcefullyTerminated: context.isForcefullyTerminated,
  exitCode,
  signal,
  stdio,
  all,
  ipcOutput,
  options,
  startTime,
  isSync: false
}) : makeSuccessResult({
  command: command2,
  escapedCommand,
  stdio,
  all,
  ipcOutput,
  options,
  startTime
});

// node_modules/execa/lib/methods/bind.js
var mergeOptions = (boundOptions, options) => {
  const newOptions = Object.fromEntries(Object.entries(options).map(([optionName, optionValue]) => [
    optionName,
    mergeOption(optionName, boundOptions[optionName], optionValue)
  ]));
  return { ...boundOptions, ...newOptions };
};
var mergeOption = (optionName, boundOptionValue, optionValue) => {
  if (DEEP_OPTIONS.has(optionName) && isPlainObject11(boundOptionValue) && isPlainObject11(optionValue)) {
    return { ...boundOptionValue, ...optionValue };
  }
  return optionValue;
};
var DEEP_OPTIONS = new Set(["env", ...FD_SPECIFIC_OPTIONS]);

// node_modules/execa/lib/methods/create.js
var createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca) => {
  const createNested = (mapArguments2, boundOptions2, setBoundExeca2) => createExeca(mapArguments2, boundOptions2, deepOptions, setBoundExeca2);
  const boundExeca = (...execaArguments) => callBoundExeca({
    mapArguments,
    deepOptions,
    boundOptions,
    setBoundExeca,
    createNested
  }, ...execaArguments);
  if (setBoundExeca !== undefined) {
    setBoundExeca(boundExeca, createNested, boundOptions);
  }
  return boundExeca;
};
var callBoundExeca = ({ mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested }, firstArgument, ...nextArguments) => {
  if (isPlainObject11(firstArgument)) {
    return createNested(mapArguments, mergeOptions(boundOptions, firstArgument), setBoundExeca);
  }
  const { file, commandArguments, options, isSync } = parseArguments({
    mapArguments,
    firstArgument,
    nextArguments,
    deepOptions,
    boundOptions
  });
  return isSync ? execaCoreSync(file, commandArguments, options) : execaCoreAsync(file, commandArguments, options, createNested);
};
var parseArguments = ({ mapArguments, firstArgument, nextArguments, deepOptions, boundOptions }) => {
  const callArguments = isTemplateString(firstArgument) ? parseTemplates(firstArgument, nextArguments) : [firstArgument, ...nextArguments];
  const [initialFile, initialArguments, initialOptions] = normalizeParameters(...callArguments);
  const mergedOptions = mergeOptions(mergeOptions(deepOptions, boundOptions), initialOptions);
  const {
    file = initialFile,
    commandArguments = initialArguments,
    options = mergedOptions,
    isSync = false
  } = mapArguments({ file: initialFile, commandArguments: initialArguments, options: mergedOptions });
  return {
    file,
    commandArguments,
    options,
    isSync
  };
};

// node_modules/execa/lib/methods/command.js
var mapCommandAsync = ({ file, commandArguments }) => parseCommand(file, commandArguments);
var mapCommandSync = ({ file, commandArguments }) => ({ ...parseCommand(file, commandArguments), isSync: true });
var parseCommand = (command2, unusedArguments) => {
  if (unusedArguments.length > 0) {
    throw new TypeError(`The command and its arguments must be passed as a single string: ${command2} ${unusedArguments}.`);
  }
  const [file, ...commandArguments] = parseCommandString(command2);
  return { file, commandArguments };
};
var parseCommandString = (command2) => {
  if (typeof command2 !== "string") {
    throw new TypeError(`The command must be a string: ${String(command2)}.`);
  }
  const trimmedCommand = command2.trim();
  if (trimmedCommand === "") {
    return [];
  }
  const tokens = [];
  for (const token of trimmedCommand.split(SPACES_REGEXP)) {
    const previousToken = tokens.at(-1);
    if (previousToken && previousToken.endsWith("\\")) {
      tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
    } else {
      tokens.push(token);
    }
  }
  return tokens;
};
var SPACES_REGEXP = / +/g;

// node_modules/execa/lib/methods/script.js
var setScriptSync = (boundExeca, createNested, boundOptions) => {
  boundExeca.sync = createNested(mapScriptSync, boundOptions);
  boundExeca.s = boundExeca.sync;
};
var mapScriptAsync = ({ options }) => getScriptOptions(options);
var mapScriptSync = ({ options }) => ({ ...getScriptOptions(options), isSync: true });
var getScriptOptions = (options) => ({ options: { ...getScriptStdinOption(options), ...options } });
var getScriptStdinOption = ({ input, inputFile, stdio }) => input === undefined && inputFile === undefined && stdio === undefined ? { stdin: "inherit" } : {};
var deepScriptOptions = { preferLocal: true };

// node_modules/execa/index.js
var execa = createExeca(() => ({}));
var execaSync = createExeca(() => ({ isSync: true }));
var execaCommand = createExeca(mapCommandAsync);
var execaCommandSync = createExeca(mapCommandSync);
var execaNode = createExeca(mapNode);
var $2 = createExeca(mapScriptAsync, {}, deepScriptOptions, setScriptSync);
var {
  sendMessage: sendMessage2,
  getOneMessage: getOneMessage2,
  getEachMessage: getEachMessage2,
  getCancelSignal: getCancelSignal2
} = getIpcExport();

// src/commands/components/commands/add/utils/updaters/update-dependencies.ts
async function updateDependencies(dependencies, cwd, options) {
  dependencies = Array.from(new Set(dependencies));
  if (!dependencies?.length) {
    return;
  }
  options = {
    silent: false,
    ...options
  };
  const dependenciesSpinner = spinner(`Installing dependencies.`, {
    silent: options.silent
  })?.start();
  dependenciesSpinner?.start();
  await execa("bun", [
    "add",
    ...dependencies,
    ...options.devDependency ? [`--dev`] : []
  ], {
    cwd
  });
  dependenciesSpinner?.succeed();
}

// src/commands/components/commands/add/utils/updaters/update-files.ts
var import_fs_extra3 = __toESM(require_lib(), 1);
import path10 from "path";
var import_prompts4 = __toESM(require_prompts3(), 1);
import { existsSync } from "fs";

// src/commands/components/commands/add/utils/download-file-from-github.ts
var import_fs_extra2 = __toESM(require_lib(), 1);
async function fetchFileFromGitHubAPI(apiUrl, outputPath) {
  try {
    const response = await fetch(apiUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch file info from GitHub API. HTTP Status: ${response.status}`);
    }
    const data = await response.json();
    const fileContent = Buffer.from(data.content, "base64").toString("utf-8");
    import_fs_extra2.default.writeFileSync(outputPath, fileContent);
  } catch (err) {
    handleError(`Error: ${err.message}`);
  }
}

// src/commands/components/commands/add/utils/updaters/update-files.ts
async function updateFiles(componentLocations, options) {
  if (!componentLocations?.length) {
    return {
      filesCreated: [],
      filesUpdated: [],
      filesSkipped: []
    };
  }
  options = {
    overwrite: false,
    silent: false,
    ...options
  };
  const filesCreatedSpinner = spinner(`Updating files.`, {
    silent: options.silent
  })?.start();
  const filesCreated = [];
  const filesUpdated = [];
  const filesSkipped = [];
  for (const location of componentLocations) {
    const targetDir = path10.dirname(location.target);
    const existingFile = existsSync(location.target);
    if (existingFile && !options.overwrite) {
      filesCreatedSpinner.stop();
      const { overwrite } = await import_prompts4.default({
        type: "confirm",
        name: "overwrite",
        message: `The file ${highlighter.info(location.target)} already exists. Would you like to overwrite?`,
        initial: false
      });
      if (!overwrite) {
        filesSkipped.push(path10.relative(options.cwd, location.target));
        continue;
      }
      filesCreatedSpinner?.start();
      if (!existsSync(targetDir)) {
        await import_fs_extra3.default.mkdir(targetDir, { recursive: true });
      }
    }
    if (!existsSync(targetDir)) {
      await import_fs_extra3.default.mkdir(targetDir, { recursive: true });
    }
    await fetchFileFromGitHubAPI(location.src, location.target);
    existingFile ? filesUpdated.push(path10.relative(options.cwd, location.target)) : filesCreated.push(path10.relative(options.cwd, location.target));
  }
  const hasUpdatedFiles = filesCreated.length || filesUpdated.length;
  if (!hasUpdatedFiles && !filesSkipped.length) {
    filesCreatedSpinner?.info("No files updated.");
  }
  if (filesCreated.length) {
    filesCreatedSpinner?.succeed(`Created ${filesCreated.length} ${filesCreated.length === 1 ? "file" : "files"}:`);
    if (!options.silent) {
      for (const file of filesCreated) {
        logger.log(`  - ${file}`);
      }
    }
  } else {
    filesCreatedSpinner?.stop();
  }
  if (filesUpdated.length) {
    spinner(`Updated ${filesUpdated.length} ${filesUpdated.length === 1 ? "file" : "files"}:`, {
      silent: options.silent
    })?.info();
    if (!options.silent) {
      for (const file of filesUpdated) {
        logger.log(`  - ${file}`);
      }
    }
  }
  if (filesSkipped.length) {
    spinner(`Skipped ${filesSkipped.length} ${filesUpdated.length === 1 ? "file" : "files"}: (use --overwrite to overwrite)`, {
      silent: options.silent
    })?.info();
    if (!options.silent) {
      for (const file of filesSkipped) {
        logger.log(`  - ${file}`);
      }
    }
  }
  if (!options.silent) {
    logger.break();
  }
  return {
    filesCreated,
    filesUpdated,
    filesSkipped
  };
}

// src/commands/components/commands/add/utils/add-components.ts
async function addComponents(components, options) {
  const registrySpinner = spinner(`Checking registry.`, {
    silent: options.silent
  })?.start();
  const tree = await registryResolveItemsTree(components);
  if (!tree) {
    registrySpinner?.fail();
    return handleError(new Error("Failed to fetch components from registry."));
  }
  registrySpinner?.succeed();
  await updateDependencies(tree.dependencies, options.cwd, {
    silent: options.silent
  });
  await updateDependencies(tree.devDependencies, options.cwd, {
    silent: options.silent,
    devDependency: true
  });
  await updateFiles(tree.files, {
    cwd: options.cwd,
    overwrite: options.overwrite,
    silent: options.silent
  });
}

// src/commands/components/commands/add/add.ts
var addComponentCommand = command({
  name: "add",
  desc: "add components and dependencies to your pipe",
  options: {
    components: string().desc("name of the pipe"),
    path: string().desc("the path to add the component to."),
    silent: boolean().desc("mute output.").default(false),
    overwrite: boolean().desc("overwrite existing files.").default(false),
    cwd: string().desc("the working directory. defaults to the current directory.").default(process.cwd())
  },
  handler: async (opts) => {
    try {
      let components;
      if (!opts?.components?.length) {
        components = await promptForRegistryComponents();
      } else {
        components = [opts.components];
      }
      const result = await preFlightAdd(opts.cwd);
      if (result?.errors[ERRORS.MISSING_DIR_OR_EMPTY_PIPE]) {
        logger.warn("you need to create a pipe first. run bunx @screenpipe/create-pipe@latest or visit https://docs.screenpi.pe/docs/plugins for more information.");
        process.exit(1);
      }
      await addComponents(components, { silent: opts.silent, cwd: opts.cwd, overwrite: opts.overwrite });
    } catch (error) {
      logger.break();
      handleError(error);
    }
  }
});

// src/commands/components/commands/register.ts
var import_prompts5 = __toESM(require_prompts3(), 1);
var import_fs_extra4 = __toESM(require_lib(), 1);
async function writeJsonToFile(filePath, data) {
  try {
    await import_fs_extra4.default.promises.writeFile(filePath, JSON.stringify(data, null, 2), "utf8");
    logger.success(`component registry successfully updated.`);
  } catch (error) {
    if (error) {
      if (error instanceof Error) {
        if (error.message === "No such file or directory") {
          logger.break();
          logger.warn("this command can only be called from within the screenpipe-js/cli of screenpipe's repository");
          process.exit(1);
        }
      }
    }
    logger.break();
    handleError("critical: could not save information to registry");
    process.exit(1);
  }
}
var registerComponentCommand = command({
  name: "register",
  desc: "register a new component in screenpipe's component registry",
  options: {
    name: string().desc("name of the component"),
    src: string().desc("github url for the component."),
    target: string().desc("path where file should be created.")
  },
  handler: async (opts) => {
    try {
      if (!opts.name) {
        const { name } = await import_prompts5.default({
          type: "text",
          name: "name",
          message: "what's your component's name?",
          instructions: false
        });
        opts.name = name;
      }
      if (!opts.src) {
        const { src } = await import_prompts5.default({
          type: "text",
          name: "src",
          message: "where should we download the component from?",
          hint: "url with the following pattern: https://api.github.com/repos/{owner}/{repo}/contents/{path}. see README for more info."
        });
        opts.src = src;
      }
      if (!opts.target) {
        const { target } = await import_prompts5.default({
          type: "text",
          name: "target",
          message: "where should the component be created?"
        });
        opts.target = target;
      }
      if (!opts.name?.length || !opts.src?.length || !opts.target?.length) {
        logger.break();
        handleError("invalid component");
        process.exit(1);
      }
      const { deps } = await import_prompts5.default({
        type: "list",
        name: "deps",
        message: "type all of the component's runtime dependencies by name, separated by a comma",
        separator: ","
      });
      const { devDeps } = await import_prompts5.default({
        type: "list",
        name: "devDeps",
        message: "type all of the component's dev dependencies by name, separated by a comma",
        separator: ","
      });
      const { registryDeps } = await import_prompts5.default({
        type: "list",
        name: "registryDeps",
        message: "type all of the component's registry dependencies by name, separated by a comma",
        separator: ","
      });
      const componentObject = {
        name: opts.name,
        src: opts.src,
        target: opts.target,
        dependencies: deps.length ? deps : undefined,
        devDependencies: devDeps.length ? devDeps : undefined,
        registryDependencies: registryDeps.length ? registryDeps : undefined
      };
      const currentRegistry = await getRegistry();
      if (!currentRegistry) {
        logger.break();
        handleError("critical: build is missing registry file.");
        process.exit(1);
      }
      currentRegistry[opts.name] = componentObject;
      await writeJsonToFile("./src/commands/components/commands/add/registry/registry.json", currentRegistry);
      logger.log("run `bun run build` and open a PR at https://github.com/mediar-ai/screenpipe to update registry.");
    } catch (error) {
      logger.break();
      handleError(error);
    }
  }
});

// src/commands/components/index.ts
var componentsCommands = command({
  name: "components",
  desc: "commands to interact with screenpipe's components",
  subcommands: [
    addComponentCommand,
    registerComponentCommand
  ]
});
// src/index.ts
run([
  loginCommand,
  logoutCommand,
  createCommand,
  componentsCommands,
  registerCommand,
  publishCommand,
  listVersionsCommand
], {
  name: "screenpipe-dev",
  description: "screenpipe development CLI tool"
});
