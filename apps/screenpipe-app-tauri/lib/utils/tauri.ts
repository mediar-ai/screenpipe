
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async openPermissionSettings(permission: OSPermission) : Promise<void> {
    await TAURI_INVOKE("open_permission_settings", { permission });
},
async requestPermission(permission: OSPermission) : Promise<void> {
    await TAURI_INVOKE("request_permission", { permission });
},
/**
 * Reset a permission using tccutil and re-request it
 * This removes the app from the TCC database and triggers a fresh permission request
 */
async resetAndRequestPermission(permission: OSPermission) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_and_request_permission", { permission }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async doPermissionsCheck(initialCheck: boolean) : Promise<OSPermissionsCheck> {
    return await TAURI_INVOKE("do_permissions_check", { initialCheck });
},
/**
 * Check only microphone permission (no screen recording check)
 * Use this for polling to avoid triggering macOS screen capture permission dialogs
 */
async checkMicrophonePermission() : Promise<OSPermissionStatus> {
    return await TAURI_INVOKE("check_microphone_permission");
},
/**
 * Check only accessibility permission
 * Use this for polling to check if user has granted accessibility permission
 */
async checkAccessibilityPermissionCmd() : Promise<OSPermissionStatus> {
    return await TAURI_INVOKE("check_accessibility_permission_cmd");
},
async getEnv(name: string) : Promise<string> {
    return await TAURI_INVOKE("get_env", { name });
},
async getLogFiles() : Promise<Result<LogFile[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_log_files") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getMediaFile(filePath: string) : Promise<Result<JsonValue, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_media_file", { filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async uploadFileToS3(filePath: string, signedUrl: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("upload_file_to_s3", { filePath, signedUrl }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateGlobalShortcuts(showShortcut: string, startShortcut: string, stopShortcut: string, startAudioShortcut: string, stopAudioShortcut: string, profileShortcuts: { [key in string]: string }) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_global_shortcuts", { showShortcut, startShortcut, stopShortcut, startAudioShortcut, stopAudioShortcut, profileShortcuts }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async spawnScreenpipe(overrideArgs: string[] | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("spawn_screenpipe", { overrideArgs }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async stopScreenpipe() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_screenpipe") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getMonitors() : Promise<Result<MonitorDevice[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_monitors") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAudioDevices() : Promise<Result<AudioDeviceInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_audio_devices") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDiskUsage(forceRefresh: boolean | null) : Promise<Result<JsonValue, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_disk_usage", { forceRefresh }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openPipeWindow(port: number, title: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_pipe_window", { port, title }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateShowScreenpipeShortcut(newShortcut: string, enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_show_screenpipe_shortcut", { newShortcut, enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async showWindow(window: ShowRewindWindow) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("show_window", { window }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async closeWindow(window: ShowRewindWindow) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("close_window", { window }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Hide the Main panel so the next shortcut press reconfigures it for the new mode.
 */
async resetMainWindow() : Promise<void> {
    await TAURI_INVOKE("reset_main_window");
},
async setWindowSize(window: ShowRewindWindow, width: number, height: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_window_size", { window, width, height }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getOnboardingStatus() : Promise<Result<OnboardingStore, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_onboarding_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async completeOnboarding() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("complete_onboarding") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetOnboarding() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_onboarding") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setOnboardingStep(step: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_onboarding_step", { step }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async showOnboardingWindow() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("show_onboarding_window") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openSearchWindow(query: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_search_window", { query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async showShortcutReminder(shortcut: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("show_shortcut_reminder", { shortcut }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hideShortcutReminder() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("hide_shortcut_reminder") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Register window-specific shortcuts (Escape, search shortcut) when main window is visible
 * These should only be active when the overlay is open to avoid blocking other apps
 */
async registerWindowShortcuts() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("register_window_shortcuts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unregister window-specific shortcuts when main window is hidden.
 * Only unregisters Escape and arrow keys. Global shortcuts (search, show, chat)
 * are NOT touched here â€” they must persist across window show/hide cycles.
 */
async unregisterWindowShortcuts() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unregister_window_shortcuts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Suspend arrow shortcuts (called from JS when search/chat modal opens)
 */
async suspendArrowShortcuts() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("suspend_arrow_shortcuts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Resume arrow shortcuts (called from JS when search/chat modal closes)
 */
async resumeArrowShortcuts() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resume_arrow_shortcuts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the version of the backed-up app (if any), so the UI can show a rollback button
 */
async getRollbackVersion() : Promise<string | null> {
    return await TAURI_INVOKE("get_rollback_version");
},
/**
 * Roll back to the previous version. Spawns a helper script, then the app must quit.
 */
async rollbackToPreviousVersion() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("rollback_to_previous_version") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Back up the current app bundle (called from frontend before JS-driven updates)
 */
async backupCurrentApp() : Promise<void> {
    await TAURI_INVOKE("backup_current_app");
},
async setTrayUnhealthIcon() : Promise<void> {
    await TAURI_INVOKE("set_tray_unhealth_icon");
},
async setTrayHealthIcon() : Promise<void> {
    await TAURI_INVOKE("set_tray_health_icon");
},
async writeBrowserLog(level: string, message: string) : Promise<void> {
    await TAURI_INVOKE("write_browser_log", { level, message });
},
/**
 * Get current sync status.
 */
async getSyncStatus() : Promise<Result<SyncStatusResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_sync_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Enable or disable sync.
 */
async setSyncEnabled(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_sync_enabled", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Trigger an immediate sync via the screenpipe server.
 */
async triggerSync() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("trigger_sync") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get sync configuration.
 */
async getSyncConfig() : Promise<Result<SyncConfig, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_sync_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update sync configuration.
 */
async updateSyncConfig(config: SyncConfig) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_sync_config", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get list of registered devices.
 */
async getSyncDevices() : Promise<Result<SyncDeviceInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_sync_devices") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Remove a device from sync.
 */
async removeSyncDevice(deviceId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_sync_device", { deviceId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Initialize sync with password.
 * This initializes both the local SyncManager (for device queries) and
 * the server's SyncService (for actual data sync).
 */
async initSync(password: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("init_sync", { password }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Lock sync (clear keys from memory and stop server sync service).
 */
async lockSync() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("lock_sync") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete all cloud data.
 */
async deleteCloudData() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_cloud_data") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get Pi info
 */
async piInfo() : Promise<Result<PiInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_info") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start the Pi sidecar in RPC mode
 */
async piStart(projectDir: string, userToken: string | null) : Promise<Result<PiInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_start", { projectDir, userToken }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop the Pi sidecar
 */
async piStop() : Promise<Result<PiInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_stop") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if pi is available
 */
async piCheck() : Promise<Result<PiCheckResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_check") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Install pi via bun
 */
async piInstall() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_install") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Send a prompt to Pi, optionally with images
 */
async piPrompt(message: string, images: PiImageContent[] | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_prompt", { message, images }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Abort current Pi operation
 */
async piAbort() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_abort") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start a new Pi session (clears conversation history)
 */
async piNewSession() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pi_new_session") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save obsidian settings to persistent store (called when settings change)
 */
async obsidianSaveSettings(settings: ObsidianSyncSettings) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("obsidian_save_settings", { settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Validate that a path is a valid Obsidian vault (has .obsidian folder)
 */
async obsidianValidateVault(path: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("obsidian_validate_vault", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get suggested Obsidian vault paths by scanning common locations
 */
async obsidianGetVaultPaths() : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("obsidian_get_vault_paths") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get current sync status
 */
async obsidianGetSyncStatus() : Promise<Result<ObsidianSyncStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("obsidian_get_sync_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Run a sync operation (manual trigger or from scheduler)
 */
async obsidianRunSync(settings: ObsidianSyncSettings, userToken: string | null) : Promise<Result<ObsidianSyncStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("obsidian_run_sync", { settings, userToken }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start the background scheduler for periodic syncs
 */
async obsidianStartScheduler(settings: ObsidianSyncSettings, userToken: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("obsidian_start_scheduler", { settings, userToken }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop the background scheduler
 */
async obsidianStopScheduler() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("obsidian_stop_scheduler") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Cancel the currently running sync
 */
async obsidianCancelSync() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("obsidian_cancel_sync") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check Reminders authorization + scheduler status (no popup).
 */
async remindersStatus() : Promise<Result<RemindersStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Request Reminders permission (shows one-time macOS popup).
 * Returns "granted", "denied", or an error message.
 */
async remindersAuthorize() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_authorize") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List existing reminders in the "Screenpipe" list.
 */
async remindersList() : Promise<Result<ReminderItem[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_list") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a single reminder.
 */
async remindersCreate(title: string, notes: string | null, due: string | null) : Promise<Result<ReminderItem, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_create", { title, notes, due }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Scan recent activity and create reminders from action items.
 * Optional custom_prompt appended to the AI instructions.
 */
async remindersScan(customPrompt: string | null) : Promise<Result<ScanResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_scan", { customPrompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start the background scheduler (30-min interval). Persists across page navigation.
 * Saves enabled=true to persistent store so it auto-starts on app relaunch.
 */
async remindersStartScheduler() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_start_scheduler") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stop the background scheduler. Saves enabled=false to persistent store.
 */
async remindersStopScheduler() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_stop_scheduler") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the saved custom prompt.
 */
async remindersGetCustomPrompt() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_get_custom_prompt") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save a custom prompt.
 */
async remindersSetCustomPrompt(prompt: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reminders_set_custom_prompt", { prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AIPreset = { id: string; prompt: string; provider: AIProviderType; url?: string; model?: string; defaultPreset: boolean; apiKey: string | null; maxContextChars: number }
export type AIProviderType = "openai" | "native-ollama" | "custom" | "screenpipe-cloud" | "pi"
export type AudioDeviceInfo = { name: string; isDefault: boolean }
export type Credits = { amount: number }
export type EmbeddedLLM = { enabled: boolean; model: string; port: number }
export type JsonValue = null | boolean | number | string | JsonValue[] | { [key in string]: JsonValue }
export type LogFile = { name: string; path: string; modified_at: bigint }
export type MonitorDevice = { id: number; name: string; isDefault: boolean; width: number; height: number }
export type OSPermission = "screenRecording" | "microphone" | "accessibility"
export type OSPermissionStatus = "notNeeded" | "empty" | "granted" | "denied"
export type OSPermissionsCheck = { screenRecording: OSPermissionStatus; microphone: OSPermissionStatus; accessibility: OSPermissionStatus }
/**
 * Obsidian sync settings stored in the app store
 */
export type ObsidianSyncSettings = { 
/**
 * Whether sync is enabled
 */
enabled: boolean; 
/**
 * Path to the Obsidian vault
 */
vaultPath: string; 
/**
 * Subfolder within vault for notes (e.g., "screenpipe/logs" or "daily/activity")
 */
notesPath?: string; 
/**
 * Sync interval in minutes (0 = manual only)
 */
syncIntervalMinutes: number; 
/**
 * Custom user prompt to append to system prompt
 */
customPrompt: string; 
/**
 * Last successful sync timestamp (ISO 8601)
 */
lastSyncTime: string | null; 
/**
 * Number of hours to sync (how far back to look)
 */
syncHours: number }
/**
 * Status of an ongoing or completed sync
 */
export type ObsidianSyncStatus = { isSyncing: boolean; lastSyncTime: string | null; lastError: string | null; notesCreatedToday: number; 
/**
 * Next scheduled run time (ISO 8601) - for UI display
 */
nextScheduledRun: string | null }
export type OnboardingStore = { isCompleted: boolean; completedAt: string | null; 
/**
 * Current step in onboarding flow (login, intro, usecases, status)
 * Used to resume after app restart (e.g., after granting permissions)
 */
currentStep?: string | null }
export type PiCheckResult = { available: boolean; path: string | null }
/**
 * Image content for Pi RPC protocol
 */
export type PiImageContent = { type: string; source: PiImageSource }
export type PiImageSource = { type: string; mediaType: string; data: string }
export type PiInfo = { running: boolean; projectDir: string | null; pid: number | null; sessionId: string | null }
export type ReminderItem = { identifier: string; title: string; notes: string | null; completed: boolean }
export type RemindersStatus = { available: boolean; authorized: boolean; authorizationStatus: string; schedulerRunning: boolean; reminderCount: number }
export type ScanResult = { remindersCreated: bigint; items: ReminderItem[]; contextChars: bigint; error: string | null }
export type SettingsStore = 
/**
 * Catch-all for fields added by the frontend (e.g. chatHistory, deviceId)
 * that the Rust struct doesn't know about. Without this, `save()` would
 * serialize only known fields and silently wipe frontend-only data.
 */
({ [key in string]: null | boolean | number | string | JsonValue[] | { [key in string]: JsonValue } }) & { aiPresets: AIPreset[]; deepgramApiKey: string; isLoading: boolean; userId: string; 
/**
 * Persistent analytics ID used for PostHog tracking (both frontend and backend)
 */
analyticsId: string; devMode: boolean; audioTranscriptionEngine: string; ocrEngine: string; monitorIds: string[]; audioDevices: string[]; 
/**
 * When true, automatically follow system default audio devices
 */
useSystemDefaultAudio?: boolean; usePiiRemoval: boolean; restartInterval: number; port: number; dataDir: string; disableAudio: boolean; ignoredWindows: string[]; includedWindows: string[]; ignoredUrls?: string[]; fps: number; vadSensitivity: string; analyticsEnabled: boolean; audioChunkDuration: number; useChineseMirror: boolean; languages: string[]; embeddedLLM: EmbeddedLLM; enableBeta: boolean; isFirstTimeUser: boolean; autoStartEnabled: boolean; enableFrameCache: boolean; platform: string; disabledShortcuts: string[]; user: User; showScreenpipeShortcut: string; startRecordingShortcut: string; stopRecordingShortcut: string; startAudioShortcut: string; stopAudioShortcut: string; showChatShortcut: string; searchShortcut: string; enableRealtimeAudioTranscription: boolean; realtimeAudioTranscriptionEngine: string; disableVision: boolean; useAllMonitors: boolean; adaptiveFps?: boolean; enableRealtimeVision: boolean; showShortcutOverlay?: boolean; 
/**
 * Unique device ID for AI usage tracking (generated on first launch)
 */
deviceId?: string; 
/**
 * Enable UI event capture (keyboard, mouse, clipboard).
 * Requires accessibility and input monitoring permissions on macOS.
 */
enableUiEvents?: boolean; 
/**
 * Auto-install updates and restart when a new version is available.
 * When disabled, users must click "update now" in the tray menu.
 */
autoUpdate?: boolean; 
/**
 * Timeline overlay mode: "fullscreen" (floating panel above everything) or
 * "window" (normal resizable window with title bar).
 */
overlayMode?: string; 
/**
 * Allow screen recording apps to capture the overlay.
 * Disabled by default so the overlay doesn't appear in screenpipe's own recordings.
 */
showOverlayInScreenRecording?: boolean; 
/**
 * Video quality preset controlling storage vs quality tradeoff.
 * Affects H.265 CRF during recording and JPEG quality during frame extraction.
 * Values: "low", "balanced", "high", "max". Default: "balanced".
 */
videoQuality?: string }
export type ShowRewindWindow = "Main" | { Settings: { page: string | null } } | { Search: { query: string | null } } | "Onboarding" | "Chat" | "PermissionRecovery"
/**
 * Sync configuration.
 */
export type SyncConfig = { enabled: boolean; syncIntervalMinutes: number; syncTranscripts: boolean; syncOcr: boolean; syncAudio: boolean; syncFrames: boolean }
/**
 * Device information.
 */
export type SyncDeviceInfo = { id: string; deviceId: string; deviceName: string | null; deviceOs: string; lastSyncAt: string | null; createdAt: string; isCurrent: boolean }
/**
 * Sync status response.
 */
export type SyncStatusResponse = { enabled: boolean; isSyncing: boolean; lastSync: string | null; lastError: string | null; storageUsed: bigint | null; storageLimit: bigint | null; deviceCount: number | null; deviceLimit: number | null; syncTier: string | null; machineId: string }
export type User = { id: string | null; name: string | null; email: string | null; image: string | null; token: string | null; clerk_id: string | null; api_key: string | null; credits: Credits | null; stripe_connected: boolean | null; stripe_account_status: string | null; github_username: string | null; bio: string | null; website: string | null; contact: string | null; cloud_subscribed: boolean | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
