
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async openPermissionSettings(permission: OSPermission) : Promise<void> {
    await TAURI_INVOKE("open_permission_settings", { permission });
},
async requestPermission(permission: OSPermission) : Promise<void> {
    await TAURI_INVOKE("request_permission", { permission });
},
async doPermissionsCheck(initialCheck: boolean) : Promise<OSPermissionsCheck> {
    return await TAURI_INVOKE("do_permissions_check", { initialCheck });
},
/**
 * Check only microphone permission (no screen recording check)
 * Use this for polling to avoid triggering macOS screen capture permission dialogs
 */
async checkMicrophonePermission() : Promise<OSPermissionStatus> {
    return await TAURI_INVOKE("check_microphone_permission");
},
/**
 * Check only accessibility permission
 * Use this for polling to check if user has granted accessibility permission
 */
async checkAccessibilityPermissionCmd() : Promise<OSPermissionStatus> {
    return await TAURI_INVOKE("check_accessibility_permission_cmd");
},
/**
 * Reset a permission using tccutil and re-request it
 * This removes the app from the TCC database and triggers a fresh permission request
 */
async resetAndRequestPermission(permission: OSPermission) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_and_request_permission", { permission }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get list of missing permissions
 */
async getMissingPermissions() : Promise<OSPermission[]> {
    return await TAURI_INVOKE("get_missing_permissions");
},
/**
 * Show the permission recovery window
 */
async showPermissionRecoveryWindow() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("show_permission_recovery_window") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getEnv(name: string) : Promise<string> {
    return await TAURI_INVOKE("get_env", { name });
},
async getLogFiles() : Promise<Result<LogFile[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_log_files") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getMediaFile(filePath: string) : Promise<Result<JsonValue, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_media_file", { filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async uploadFileToS3(filePath: string, signedUrl: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("upload_file_to_s3", { filePath, signedUrl }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateGlobalShortcuts(showShortcut: string, startShortcut: string, stopShortcut: string, startAudioShortcut: string, stopAudioShortcut: string, profileShortcuts: { [key in string]: string }) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_global_shortcuts", { showShortcut, startShortcut, stopShortcut, startAudioShortcut, stopAudioShortcut, profileShortcuts }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async spawnScreenpipe(overrideArgs: string[] | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("spawn_screenpipe", { overrideArgs }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async stopScreenpipe() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_screenpipe") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDiskUsage() : Promise<Result<JsonValue, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_disk_usage") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openPipeWindow(port: number, title: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_pipe_window", { port, title }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateShowScreenpipeShortcut(newShortcut: string, enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_show_screenpipe_shortcut", { newShortcut, enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async showWindow(window: ShowRewindWindow) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("show_window", { window }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async closeWindow(window: ShowRewindWindow) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("close_window", { window }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setWindowSize(window: ShowRewindWindow, width: number, height: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_window_size", { window, width, height }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getOnboardingStatus() : Promise<Result<OnboardingStore, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_onboarding_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async completeOnboarding() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("complete_onboarding") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetOnboarding() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_onboarding") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setOnboardingStep(step: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_onboarding_step", { step }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async showOnboardingWindow() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("show_onboarding_window") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openSearchWindow(query: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_search_window", { query }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async showShortcutReminder(shortcut: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("show_shortcut_reminder", { shortcut }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hideShortcutReminder() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("hide_shortcut_reminder") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Register window-specific shortcuts (Escape, Ctrl+Cmd+K) when main window is visible
 * These should only be active when the overlay is open to avoid blocking other apps
 */
async registerWindowShortcuts() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("register_window_shortcuts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Unregister window-specific shortcuts when main window is hidden
 * This allows Escape, Ctrl+Cmd+K to work normally in other apps
 */
async unregisterWindowShortcuts() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unregister_window_shortcuts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setTrayUnhealthIcon() : Promise<void> {
    await TAURI_INVOKE("set_tray_unhealth_icon");
},
async setTrayHealthIcon() : Promise<void> {
    await TAURI_INVOKE("set_tray_health_icon");
},
/**
 * Suspend all global shortcuts (for shortcut recording mode)
 * Call this before entering shortcut recording to prevent existing shortcuts from triggering
 */
async suspendGlobalShortcuts() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("suspend_global_shortcuts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Resume all global shortcuts (after shortcut recording mode)
 * Call this after exiting shortcut recording to re-register all shortcuts
 */
async resumeGlobalShortcuts() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resume_global_shortcuts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AIPreset = { id: string; prompt: string; provider: AIProviderType; url?: string; model?: string; defaultPreset: boolean; apiKey: string | null; maxContextChars: number }
export type AIProviderType = "openai" | "native-ollama" | "custom" | "screenpipe-cloud"
export type Credits = { amount: number }
export type EmbeddedLLM = { enabled: boolean; model: string; port: number }
export type JsonValue = null | boolean | number | string | JsonValue[] | { [key in string]: JsonValue }
export type LogFile = { name: string; path: string; modified_at: bigint }
export type OSPermission = "screenRecording" | "microphone" | "accessibility"
export type OSPermissionStatus = "notNeeded" | "empty" | "granted" | "denied"
export type OSPermissionsCheck = { screenRecording: OSPermissionStatus; microphone: OSPermissionStatus; accessibility: OSPermissionStatus }
export type OnboardingStore = { isCompleted: boolean; completedAt: string | null; 
/**
 * Current step in onboarding flow (login, intro, usecases, status)
 * Used to resume after app restart (e.g., after granting permissions)
 */
currentStep?: string | null }
export type SettingsStore = { aiPresets: AIPreset[]; deepgramApiKey: string; isLoading: boolean; userId: string; 
/**
 * Persistent analytics ID used for PostHog tracking (both frontend and backend)
 */
analyticsId: string; devMode: boolean; audioTranscriptionEngine: string; ocrEngine: string; monitorIds: string[]; audioDevices: string[]; usePiiRemoval: boolean; restartInterval: number; port: number; dataDir: string; disableAudio: boolean; ignoredWindows: string[]; includedWindows: string[]; fps: number; vadSensitivity: string; analyticsEnabled: boolean; audioChunkDuration: number; useChineseMirror: boolean; languages: string[]; embeddedLLM: EmbeddedLLM; enableBeta: boolean; isFirstTimeUser: boolean; autoStartEnabled: boolean; enableFrameCache: boolean; platform: string; disabledShortcuts: string[]; user: User; showScreenpipeShortcut: string; startRecordingShortcut: string; stopRecordingShortcut: string; startAudioShortcut: string; stopAudioShortcut: string; showChatShortcut: string; enableRealtimeAudioTranscription: boolean; realtimeAudioTranscriptionEngine: string; disableVision: boolean; useAllMonitors: boolean; enableRealtimeVision: boolean; showShortcutOverlay?: boolean; 
/**
 * Unique device ID for AI usage tracking (generated on first launch)
 */
deviceId?: string }
export type ShowRewindWindow = "Main" | { Settings: { page: string | null } } | { Search: { query: string | null } } | "Onboarding" | "Chat" | "PermissionRecovery"
export type User = { id: string | null; name: string | null; email: string | null; image: string | null; token: string | null; clerk_id: string | null; api_key: string | null; credits: Credits | null; stripe_connected: boolean | null; stripe_account_status: string | null; github_username: string | null; bio: string | null; website: string | null; contact: string | null; cloud_subscribed: boolean | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
