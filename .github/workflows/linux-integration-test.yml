- name: Set up Rust
  uses: actions-rust-lang/setup-rust-toolchain@v1
  with:
    toolchain: stable
    cache: true

- name: Install Critical Dependencies
  run: |
    sudo apt-get update
    # Install Xvfb, window manager, x11 utils, fonts, audio utilities, and OCR
    sudo apt-get install -y xvfb fluxbox x11-utils xdotool xterm locales \
      xfonts-base xfonts-100dpi xfonts-75dpi xfonts-cyrillic \
      libasound2-dev pkg-config imagemagick pulseaudio pulseaudio-utils \
      tesseract-ocr tesseract-ocr-eng
    sudo locale-gen en_US.UTF-8

    # Make CI scripts executable (if present)
    if git ls-files --error-unmatch .github/scripts/*.sh >/dev/null 2>&1; then
      git ls-files .github/scripts/*.sh | xargs -r chmod +x
    fi

    # Optional project-specific installs
    if [ -f ".github/scripts/install_dependencies.sh" ]; then
      .github/scripts/install_dependencies.sh
    fi

- name: Build CLI
  run: cargo build --release

- name: Start Virtual Environment and Create Content
  run: |
    set -euo pipefail
    export DISPLAY=:99
    export LANG=en_US.UTF-8
    export LC_ALL=en_US.UTF-8

    # Start Xvfb and record PID
    Xvfb :99 -screen 0 1280x1024x24 -nolisten tcp &
    echo $! > /tmp/xvfb.pid

    # Wait for X server to be responsive
    until xset -display "$DISPLAY" q >/dev/null 2>&1; do sleep 0.5; done

    # Start a lightweight window manager and store PID
    fluxbox &
    echo $! > /tmp/fluxbox.pid
    sleep 2

    # Ensure scripts are executable (redundant safe step)
    if git ls-files --error-unmatch .github/scripts/*.sh >/dev/null 2>&1; then
      git ls-files .github/scripts/*.sh | xargs -r chmod +x
    fi

    # Initialize audio mocking to reduce ALSA/JACK errors
    if [ -f ".github/scripts/setup_audio.sh" ]; then
      .github/scripts/setup_audio.sh || true
    else
      # fallback: start pulseaudio in user mode
      pulseaudio --start || true
      if command -v pactl >/dev/null 2>&1; then
        pactl load-module module-null-sink sink_name=ci_null_sink >/dev/null 2>&1 || true
        pactl set-default-sink ci_null_sink >/dev/null 2>&1 || true
      fi
    fi

    # Spawn a deterministic xterm with known content for OCR and store PID
    xterm -T "TestWindow" -geometry 80x24+0+0 -e "printf 'Screenpipe Integration Test Content\n'; sleep 120" &
    echo $! > /tmp/xterm.pid

    # Wait for TestWindow to appear using a robust search loop
    for i in {1..20}; do
      if xdotool search --name "TestWindow" >/dev/null 2>&1; then
        echo "SUCCESS: Test window detected"
        break
      fi
      echo "Waiting for TestWindow (attempt $i)..."
      sleep 1
    done

    # Final check: Ensure the window is active for the vision engine
    if ! xdotool search --name "TestWindow" windowactivate >/dev/null 2>&1; then
      echo "Error: Test window not found or could not be activated" >&2
      cat /proc/1/status || true
      exit 1
    fi

- name: Run Integration Tests
  env:
    DISPLAY: :99
    LANG: en_US.UTF-8
    LC_ALL: en_US.UTF-8
    RUST_LOG: debug
    SCREENPIPE_CAPTURE_FULLSCREEN: "true"
  run: |
    set -euo pipefail
    # Tee all output to the artifact log for easier debugging
    exec > >(tee -a screenpipe_output.log) 2>&1

    # Ensure scripts are executable
    if git ls-files --error-unmatch .github/scripts/*.sh >/dev/null 2>&1; then
      git ls-files .github/scripts/*.sh | xargs -r chmod +x
    fi

    # Setup audio again (idempotent)
    if [ -f ".github/scripts/setup_audio.sh" ]; then
      .github/scripts/setup_audio.sh
    fi

    # Start the screenpipe binary/service and capture its PID (script should background it or this will block)
    if [ -f ".github/scripts/run_screenpipe.sh" ]; then
      .github/scripts/run_screenpipe.sh & SCREENPIPE_PID=$!
    else
      # fallback: run the built binary directly (adjust path as needed)
      ./target/release/screenpipe --disable-telemetry --debug & SCREENPIPE_PID=$!
    fi

    echo "Started screenpipe with PID=${SCREENPIPE_PID}"
    # Wait for the binary to be alive a short while
    for i in {1..30}; do
      if ps -p "${SCREENPIPE_PID}" >/dev/null 2>&1; then break; fi
      sleep 1
    done

    # Run OCR and audio tests. Let scripts return non-zero on failure to fail the step.
    if [ -f ".github/scripts/test_ocr.sh" ]; then
      .github/scripts/test_ocr.sh
    else
      echo "Warning: .github/scripts/test_ocr.sh not present; skipping OCR checks"
    fi

    if [ -f ".github/scripts/test_audio_capture.sh" ]; then
      .github/scripts/test_audio_capture.sh
    else
      echo "Warning: .github/scripts/test_audio_capture.sh not present; skipping audio checks"
    fi

    # Stop screenpipe (script should cleanly stop the background server)
    if [ -f ".github/scripts/stop_screenpipe.sh" ]; then
      .github/scripts/stop_screenpipe.sh || true
    else
      kill "${SCREENPIPE_PID}" || true
    fi

- name: Check for crashes
  run: |
    set -euo pipefail
    # make sure check_logs script exists and is executable
    if [ -f ".github/scripts/check_logs.sh" ]; then
      chmod +x .github/scripts/check_logs.sh
      .github/scripts/check_logs.sh || true
    else
      echo "No check_logs.sh present; skipping explicit crash checks"
    fi

- name: Stop background X processes (cleanup)
  if: always()
  run: |
    set -euo pipefail
    for pidfile in /tmp/xterm.pid /tmp/fluxbox.pid /tmp/xvfb.pid; do
      if [ -f "$pidfile" ]; then
        pid="$(cat "$pidfile" 2>/dev/null || true)"
        if [ -n "$pid" ]; then
          echo "Killing PID $pid from $pidfile"
          kill "$pid" >/dev/null 2>&1 || true
        fi
        rm -f "$pidfile"
      fi
    done
    # also try to remove null sink if created
    if command -v pactl >/dev/null 2>&1; then
      # best-effort: unload module named ci_null_sink if present
      pactl list short modules | grep module-null-sink | awk '{print $1}' | xargs -r -n1 pactl unload-module || true
    fi

- name: Upload Logs
  uses: actions/upload-artifact@v4
  if: always()
  with:
    name: screenpipe-linux-logs
    path: screenpipe_output.log